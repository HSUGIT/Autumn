
1. 排序的方式：冒泡、希尔
1）选择排序：
for(i=0; i<n-1; i++)	//循环n-1次；
{
	min = i;
	for(j=i+1; j<n; j++)	//每次找出未排序部分的最小数，和未排序的第一个交换；
	{
		if(a[j] < a[i])
			min = j;
}
if(min != i)	//如找到最小的则交换
{
	temp = a[i];
	a[i] = a[j];
	a[j] = a[temp];
}
}

2）插入排序：
void insert_sort(char *x, int n)
{
	int i, j;
char t;
	for(i=1; i<n; i++)	//当前排序的数；
	{
		t = x[i];	//暂存要排序的数；
for(j=i-1; j>=0 && t<x[j]; j--)	//要排序的数比排序好的数末尾还要小，j~i-1的数依次往后挪；
x[j+1] = x[j];
}
x[j] = t;
}

3）冒泡排序：
for(i=j-1; i>0; i--)
{
	for(j=0; j<i; j++)
{
	if(a[j] > a[j+1])
	{
		temp = a[j];
		a[j] = a[j+1];
		a[j+1] = temp;
}
}
}

4）快速排序：
void quick_sort(int *x, int low, int high)
{
	int i, j, t;
	if (low < high)
	{
		i = low;
		j = high;
		t = x[low];	//存基准点的数；
		while (i<j)
		{
			while (i<j && x[j]>t)		//保证右边放大的，左边放小的；
				j--;	//如果右边本来就为大，则继续往前走；
			if (i<j)	//找到右边小的则跳出，进行处理；
			{
				x[i] = x[j];	//将原基准点的数当成左边，放找到的数，将原基准点右边的数重新做基准点；
				i++;
}

while (i<j && x[i]<=t)	//保证左边是小的；
	i++;
if (i<j)
{
	x[j] = x[i];	//找到大的数放在原来大端移出的位置，每次填补一个空位；
	j--;
}
}
x[i] = t;	//全排完了之后将比较的数放在中间；
quick_sort(x,low,i-1);  /*对基准点左边的数再执行快速排序*/  
quick_sort(x,i+1,high);  /*对基准点右边的数再执行快速排序*/ 
}
}

一、 判断题（4分每题，共20分）
1、 在同一个.c文件中，局部变量可以和全局变量重名。（对）
2、 在数组定义int a[2][2]={{3},{2,3}}；则a[0][1]的值为0。（对）
3、 int (*ptr)()，则ptr是一维数组的名字。（错）
4、 指针在任何情况下都可进行>,<,>=,<=,==运算。（对，如果不谈比较的意义）
5、 Switch(c)语句中c可以是int,long,char,float,unsigned int类型。（错）

二、 填空/找错题目(30分)
1、 在windows下，写出运行结果，每空2.5，共10分。
char str[]=”Hello “;
char *p = str;
int n = 10;
sizeof(str)=();	//5
sizeof(p)=();	//4, 假设32位
sizeof(n)=();	//4

void func(char str[100])
{
sizeof(str)=();	4
}
2、 请找出下面代码中的所有错误（10分）
说明：以下代码是把一个字符串倒序，如“abcd”倒序后变成“dcba”
main()
{
char *src=”hello,world”;
char *dest=NULL;

int len=strlen(src);
dest = (char *)malloc(len);	//len+1
						//应判断返回是否是空
char *d=dest ;
char *s=src[len] ;			//len-1
while(len-- != 0 )
d++ = s--;					//d=’\0’;
printf(“%s”,dest);
return 0;
}

3、 填空，10分
设int arr[] = {6,7,8,9,10};
int *prtr = arr;
*(ptr++) += 123;
printf(” %d,%d “,*ptr,*(++ptr));
输出结果为（  ）	//130, 8

三、 编程题（第一小题15，第二小题20分、第三小题15分）
1、 不使用库函数，编写函数int strcmp(char *source, char *dest)相等返回0，不等返回-1;
#include <assert.h>
int strcmp(const char *s1, const char *s2)
{
	int ret;
	assert(s1!=NULL || s2!=NULL)
	while(((ret=(unsigned char)*s1-(unsigned char)*s2) == 0) && *s1)
	{
		s1++;
		s2++;
}
if (ret > 0)
	ret = 1;
elseif (ret < 0)
	ret = -1;
return ret;
}

2、 写一函数void fun(char *s)实现如下单词倒序功能：如s为字符串“ast FVs ULLY”，经过此函数后，s的内容将变为:“tsa sVF YLLU”
#include <assert.h>
#include <stdio.h>

/*判断字母函数*/
int isAlphabet(char letter)	
{
	if(‘a’<=letter<=’z || ‘A’<=letter<=’Z’)
		return 0;
	else
		return -1;
}
void wordInverse(char *s, int num)
{
	int i, j;
	char temp;
	assert(str != NULL);

	i = 0;
j = num - 1;
	for (; i<j; i++,j--)		/*对单词前后字母换序*/
	{
		temp = s[i];
		s[j] = s[i];
		s[i] = temp;
}
}
/*字符串处理函数, 输入字符串指针, 返回处理后的指针*/
char * strHandle(char *str)
{
	char last = ‘1’, now;
	char strInverse = NULL;
	int i = 0;
	assert(str != NULL);
	for(; (now=*str) != ’\0’; str++)
	{
		if (!isAlphabet(now))	/*判断是字母*/
		{
			if (isAlphabet(last))	/*如果前一个字符不是字母，则这是一个单词的开始*/
				strInverse = str;
			i++;
}
else	/*单词判断结束，开始单词反序*/
{
	if(!isAlphabet(last))	/*如果前一个字符是字母，则单词获取结束，开始处理*/
{
wordInverse(strInverse, i);	/*将单词反序*/
strInverse = NULL;			/*还原要处理的指针和数目*/
		i = 0;
}
}
	
}
if (strInverse)	/*如果指针不为空则有最后一个单词还未处理*/
{
wordInverse(strInverse, i);	/*将单词反序*/
strInverse = NULL;			/*还原要处理的指针和数目*/
		i = 0;
}

return str;
}

void main(void)
{
	char *s = {“ast FVs ULLY”};
	strHandle(s);
	printf(“%s\n”, s);
}

3、 写一函数int count(char c)返回字符c的二进制数所含1的个数，例如c=3，其二进制数为00000011,那么此函数返回2。
for (j=0; i; i&i-1)
	j++;
return j;

1:设float a=2, b=4, c=3；，以下C语言表达式与代数式 (a+b)c/2计算结果不一致的是（b）
A.(a+b)*c/2	//9
B.(1/2)*(a+b)*c	//0 改为1uL/2
C.(a+b)*c*1/2		//9
D.c/2*(a+b)		//9

2:为了向二进制文件尾部增加数据，打开文件的方式应采用（a）
A.″ab″
B.″rb+″
C.″wb″
D.″wb+″

3:下述程序执行后的输出结果是（a）
＃include
main()
{
int x=’f';
printf(“%c\n”,’a'+(x-’a'+1));
}
A.G
B.H
C.I
D.J

4:C语言中，下列运算符优先级最高的是(a)
A.！		//1
B.％		//2
C.>>		//3
D.＝ ＝	//4

5:数组定义为“ int a [ 4 ] ; ”，表达式 ( ) 是错误的。(d)
A.*a
B.a [ 0 ]
C.a
D.a++

6:执行语句“ k=7>>1; ”后，变量 k 的当前值是(c)
A.15
B.31
C.3
D.1

7:定义函数时，缺省函数的类型声明，则函数类型取缺省类型(d)
A.void
B.char
C.float
D.int

8:若main（）函数带参数，参数个数最多是(c)
A.0
B.1
C.2	//int main(int argc, char *argv[])
D.3

9:若有宏定义：#define MOD(x，y) x％y
则执行以下语句后的输出结果是(b)
int a=13，b=94；
printf(″％d\n″，MOD(b，a+4))；	//94%13+4
A.5
B.7
C.9
D.11

10:下列各个错误中，哪一个不属于编译错误(a)
A.改变 x 原值 3 为 5 ，写作“ x==5 ;”
B.花括号不配对
C.复合语句中的最后一条语句后未加分号
D.变量有引用、无定义

11:下列程序段运行后， x 的值是( a)

a=1;b=2;x=0;
if(!( — a))x — ;		//a=0,x=-1
if(!b)x=7;else ++x;	//a=0,b=2,x=0
A.0
B.3
C.6
D.7

12:设
#define N 3
#define Y(n) ((N+1)*n)	//((3+1)*n)
则表达式2*(N+Y(5+1))的值是	2*(3+(3+1)*5+1))  (b)
A.42
B.48
C.54
D.出错

13:若定义了char ch[]={″abc\0def″｝，*p=ch;则执行printf(″%c″,*p+4);语句的输出结果是(c)
A.def
B.d
C.e
D.0

14:下列转义字符中错误的是(c)
A.′\000′
B.′\14′
C.′\x111′
D.′\2′

15:算术运算符，赋值运算符和关系运算符的运算优先级按从高到低依次为(b)
A.算术运算、赋值运算、关系运算
B.算术运算、关系运算、赋值运算
C.关系运算、赋值运算、算术运算
D.关系运算、算术运算、赋值运算

17:表达式 strcmp( “ 3.14 ”，“ 3.278 ” ) 的值是一个(a)
A.非零整数
B.浮点数
C.0
D.字符

18:设struct
{ short a;
char b;
float c;
}cs;
则sizeof(cs)的值是(d)
A.4
B.5
C.6
D.7

19:若变量已正确定义，表达式( j=3 ， j++ )的值是(b)
A.3
B.4
C.5
D.0

20:C 语言中运算对象必须是整型的运算符是(a)
A.%
B./
C.!
D.**

简答题

21:打印一个N*N的方阵，N为每边字符的个数（ 3〈N〈20 ），要求最外层为“X”，第二层为“Y”，从第三层起每层依次打印数字0，1，2，3，…
例子：当N =5，打印出下面的图形：
X X X X X
X Y Y Y X
X Y 0 Y X
X Y Y Y X
X X X X X

#define N 5
char a[20][20];
void square_array(char *a, int n)
{
	int i, j, st;
	for (i=0; i<n; a[0][i]=a[n-1][i]=a[i][0]=a[i][n-1]=’X’,i++);	/*写最外层X*/
	for (i=1; i<n-1; a[1][i]=a[n-2][i]=a[i][1]=a[i][n-2]=’Y’,i++);	/*写第二层Y*/
	for (st =2,j=0; st<n; st++,j++)
for (i=st; i<n-1-st; a[st][ i]=a[n-1-st][i]=a[i][st]=a[i][n-1-st]=j,i++);	/*写数字层*/

	for (i=0; i<n-1; i++)	/*打印阵列*/
	{
		for(j=0; j<n-1; j++)
			printf(“%c”, a[i][j]);
		printf(“\n”);
	}
}
void main(void)
{
	square_array(a, N);
}
s
24:#include

　　void main()	//2473

　　{ int c;

　　while ((c=getchar())!= ′\ n ′ )

　　switch(c – ′ 2 ′ )

　　{ case 0:

　　case 1:putchar(c+4);break;	6897

　　case 2:putchar(c+4);break;

　　case 3:putchar(c+3);break;

　　default:putchar(c+2);break;

　　}

　　printf( ″\ n ″ );

　　}

　　运行时输入： 2473 ，输出结果：(6897)

25:用两个栈实现一个队列的功能？
入队:   将新元素push入栈A;   
出队:  
(1)判断栈B是否为空；  
 (2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；  
 (3)将栈B的栈顶元素POP出


26:写一语句实现x是否为2的若干次幂的判断。
(x&x-1)? 0, 1;

27:解二次方程:a*x*x+b*x+c
int Quadratic( double a,double b,double c,double& x1,double& x2);
返回值：解的个数
根号b^2-4ac, <0无解，=0一个解，>0两个解，解为2a分之-b正负根号b^2-4ac。
#include <math.h>
sqrt();

28:如何判别一个整形数是unsigned。
if (x>=0 && -x>=0);

29:执行下述程序的输出结果是______ABCDEF  CDEF  EF____________。
#include
char b[]=”ABCDEF”;
main()
{
char *bp;
for (bp=b;*bp;bp+=2)
printf(“%s”,bp);
printf(“\n”);
}

30:已知一个数组table，用一个宏定义，求出数据的元素个数。
#define NUM_TABLE (sizeof(table)/sizeof(table[0]))

参考答案：1. B
2. D
3. A
4. A

5. D
6. C
7. D
8. C
9. B
10. A
11. A
12. B
13. C
14. C
15. B
16. B
17. A
18. D
19. A
20. A


　　13. 评价下面的代码片断：
unsigned int zero = 0;
则反码是：
　　unsigned int compzero = 0xFFFF;
　　/*1's complement of zero */
　　对吗？
　　对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下
　　unsigned int compzero = ~0;

　　动态内存分配（Dynamic memory allocation）
14. 结果？
　　char *ptr;
　　if ((ptr = (char *)malloc(0)) == NULL)
　　puts("Got a null pointer");
　　else
　　puts("Got a valid pointer");
　　
该代码的输出是“Got a valid pointer”。

Typedef
　　15. Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
　　#define dPS struct s *
　　typedef struct s * tPS;
以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？

　　typedef更好，有指针会出错，
　　dPS p1,p2;
　　tPS p3,p4;
　　
　　第一个扩展为
　　struct s * p1, p2;
　　
　　上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。
　　
　　晦涩的语法
　　
　　16. C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
　　int a = 5, b = 7, c;
　　c = a+++b;

编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：
　　c = a++ + b;
　　因此, 这段代码持行后a = 6, b = 7, c = 12。
但你应指出最好不这么做，代码要规范易读

嵌入式系统求职回忆录

一、引言
   一年前的这个时候，我开始了人生的真正求职历程在这个过程中，有幸参加过广嵌、迈瑞、华为、智光、周立功、理邦等几个比较大笔试和面试虽然大部分都失败了，但是我觉得正是这一次次的失败认我真正认识自己的不足，积累经验，成长进步，为最后的成功打下坚实的基础求职是一个展现个人综合实力的过程，除了需要专业技能之外，还需要有一定的策略同时这也是一个逐步提高和适应的过程就像一支球队参加真正比赛之前都要经过系列的热身赛，熟悉对手的同时也在发现自己的不足那时候我经看看别人的面经，现在我觉得把自己的体会跟大家分享也是一件很愉快的事情特别在这个找工作的高潮时刻，也希望我以前总结的求职经历能给大家一点借鉴和帮助哦……
 
二、广嵌面试
    这是我人生的第一次正式面试，挺紧张的广嵌在广州科学城那边，有点偏了，人比较少首先是做题，没有什么时间限制，做完就交题目不多，8道好像，全是问答和编程题，没得蒙主要考了C语音、数据结构、操作系统、编译原理、内存分配和链表的一些东西虽然是很基础的东西，但是平时不注意不一定做得出来题目做完了，HR拿去给技术总监看，过了一会来告诉我，技术总监对我的答题较满意，叫我去会议室进行面试技术总监来是一个比较年轻的工程师，谈吐之间感觉巨牛我首先介绍了项目的情况，可能是第一次吧，讲的比较细，他听了一会感觉出我实际做了点东西，懒得听我说，直接叫我停止，开始问了我几个问题看起来不是什么技术难题，但却不好答我印象比较深刻的是下面三个题目： 
1、在学校实验室中编程做项目和实际编程做项目有什么不同，需要注意什么？ 
2、如果在公司中碰到了行政问题和技术难题应该怎么样处理？ 
3、你的职业规划或者是你未来几年打算怎么样？ 
    这些的回答见仁见智我没想到他会问这些问题，开始愣了几秒中，脑子一下转不过来不过我对自己的回答比较满意，可能技术总监也认同我的回答接着他问我做TCP/IP方面的东西怎么样我说没有怎么样做过网络底层的东西，主要做的应用层上面的套接字编程然后他问我在windows和linux的驱动层和应用层做过什么东西，我就讲相关的项目和工作稍稍说了一说然后他给我介绍了进来公司要做的一些工作，主要是做TCP/IP应用层的测试验证工作后面也没什么问了他出去后，HR进来和我谈了谈公司的具体情况和福利方面的东西大概三个小时，我的第一次面试就这样结束了
 
三、迈瑞笔试
收到迈瑞的笔试其实不是很意外，但是比较突然，没有想到当天宣讲完第二天下午就开始笔试，一点准备的机会都没有，去开开眼界吧迈瑞通知我去考软件工程师，但我C++其实不怎么懂，肯定得交白卷还好可以和来霸王面的人一起进了硬件工程师的考场进去后我又要了系统研究工程师的题目，觉得系统的东西具体不是很清楚，思路说说还是可以的然而，这次考试实在对自己的打击太大了，总算看清楚自己的真是水平了 
    在硬件的题目中，考试范围很广，模电，数电，CPLD，操作系统，算法，智力，设计等都涉及到对打击自己的是，明明看着知道怎么做，但是忘记相关的公式概念，没法下笔，更伤心的是会做的粗心做错了，唉...无药可救了 
    第1题是单位的换算，我居然把1Gbyte=1000Mbyte,出来想想才知道错了，应该是1024 第2题是一个模电的题目，考查共射三极管的电容对上限截止频率和下限截止频率影响，包括耦合电容，极间电容和布线电容第3题是问什么是摩尔定律，摩尔定律对硬件开发有什么影响？我一个字也写不下来第4题又是一道伤心的题目，这是我唯一一道有点把握的题目，给了两个运放，要求写出名称和表达式，一个是差动比例放大器，一个积分电路，但是由于粗心，将差动比例放大器推导推错了接下来的题目是什么呢......第5题做不出来，题目是说电容在高频的时候可以等效成一个电感、一个电容和一个电阻的串连，问实际中在什么频率时候使用做合适第6题是数电的题目，什么是冒险与竞争，怎么样去消除冒险与竞争数电的最基本题目，我又空白，你说这样的题目我都做不出来，在简历上吹你熟悉模电和数电还有人会相信吗？下面一题是英语翻译题目，给一个PCI的读时序，让你翻译将上面的英文翻译成中文接着是一个智力题目：一个人从A城市下班后乘火车到火车站，他的妻子从家里骑车刚好到车站接他回家，一天，他坐了早班火车，5：30就到了火车站，然后走路回家，他的妻子在半路上接了他，回到家里发现比平时早了10分钟，问他坐了多少时间的路？这题我又挂了后面是选做题，3选1一道模电，给了运放、二极管，一个AD前端信号调理电路，要找出其中的错误唉，又没头绪，估计是二极管钳位，写了几个字另外一个是要用CPLD语言描述出JK触发器，再用JK触发器和与、非门搭出D触发器这题我又放弃了最后一个是操作系统的题目，关于PCI总线的三个读取方式的，只能放弃了后面还有哦，一个二叉树遍历的程序补充，呵呵，这是数据结构最基本最简单的题目，我又缴械了应该是最后一题了，说说你的一个成功的项目或者课程设计，画出结构框图，说出工作原理，碰到了什么难题怎么样解决这个当然谁到会写拉，不就吹牛嘛 
    再看看系统工程师的题目，分三个部分第一部分有四个可选题目，和公司的四条产品线密切相关，第一个是描述心电信号的特点和测量方法第二个是描述人体生理信号的特点与测量方法第三个是说说数字滤波器的特征和实现，最后一个是说说光谱吸收装置的原理好像本来觉得第三个很眼熟，但是又不知道怎么下笔，算了，反正都不会，选了第一到吹了一通第二题是编程题，一个是补充汉诺塔的程序，还有一部分是计算冒泡法的比较次数和用顺序法找一个最大值的平均次数下面一道题目是设计题目，设计一个数码相机，从市场需求、功能设计、质量方面、可行性和市场风险去设计还好这个可以写点东西，不然正的是交白卷了最后是一个4选1的题目，考查的是精度方面的东西第一个是说说游标卡尺的精度影响因素，第二个是分析数控机床的精度影响因素，第三个是分析光强测量装置的精度影响因素第四个忘记了我选了数控机床那个东西写了几个字 
    虽然是深深收到了打击，但是也真正的看到了自己的水平 学了那么多年，最基本的东西都没有掌握，正是惭愧啊看来是时候开始好好找找自己的方向了，明确一个目标就去复习复习吧软件东西我懂的都是皮毛，看来和它有缘无分拉，和硬件看来还有点尘缘未了啊 
11月1号补充：虽然没有面试的机会，但是还是关注了迈瑞的面试情况，顺便记录了些在浙大BBS上看到的浙大牛人的面经：
面试官是那天监考的工作人员，考卷也是他看的好像他是根据考试情况来定面试内容的从来开始讲一下他的问题吧：
1.你选择深圳工作，有考虑过深圳离你家近？
2.如果老板给你一个很急的任务，按理来讲要7天完成，但是却要你5天之内完成，你会怎么办？
3.你的身边有这么一个老工程师，他可能不如你厉害，但是他脾气还很不好，你会怎么和他相处？
4.你的老板有一套方案已经确定了，而且马上要实施，而你认为自己的方案也不错，并且在某点还很有创新，你会怎么办？
5.你对选择做硬件有什么特别的想法？
6.我看你最后一道题答的很详细也很工整，是我想要的结果，但我还是想让你给我解释一下关键问题的解决思路他会给我一张纸，在我画框图的过程中打断我，顺便问几个技术问题，比如运放做比较器和专门的比较器会有什么不同点等等
最后他说可能不一定会有二面，但是11月1号上午会确定是否给offer
我的感觉是：在答最后一道自由发挥的题时，大家最好把自己最熟悉的项目写上，并且写清楚，这样会给人家留下非常好的印象另外项目如果不是自己做的，或者解释不清楚的，简历上最好不要提，被他们盯上就不好说了但是他们还是很Nice的
 
四、华为笔试
人家说得不错，要做好一些事情，不但要有目标还需要有充分的准备虽然我没有什么明确的目标，但是这次我有了稍稍的准备自从被迈瑞打击了一下，我重新认识了自己回来正经地复习了一下功课
    虽然华为的硬件笔试题目出得很基础，但我也有不少做不好但总算可以从迈瑞的失败中稍稍恢复了一点点信心，不管结果怎么样，我终于可以从头到尾做完，还提前了半个小时交卷下面稍稍总结一下吧
    对于华为，我感觉浙大的牛人很不屑一顾BBS上面关注的人不多，有也是华为负面的消息迈瑞笔试那天有四个教室人，华为今天也就一个阶梯教室人在笔试之前，华为都给参加笔试的人打了电话，问问情况我也收了两个，不过没带手机，没接上接到电话的人有两个被调整到技术服务类了不过听说技术服务类比研发的待遇要好哦在考场上，什么也不用检查，去了就考，没有通知到的也可以考，总之是来者不拒
    试卷有10道填空题，12道单选，12道多选和一道分析题其中分析题就叫写出2－4译码器的真值表，是不是比期末考试还简单呢，20分哦填空题第一道就是一道运放题目，给一些已知条件求运放的输出电阻，出来听大家讨论，好像我作错了第二道又不会，问2DPSK是什么键控，是通信方面的内容，在百度搜了一下，原来二相差分移相键控下面有什么是误码率啊，什么PCM一次群，8086的寄存器是几位，给你一个128K的静态RAM和起始地址，问你最后一个字节的地址，还有VHDL和数字逻辑等等有一道题我真写不下东西，问组合逻辑输出用做时钟容易产生什么在单选题目考还是那些基础的东西，有问IBM-PC和兼容机的I/O端口空间，PCM32一次群一个复帧的时间，还有是问码元长0.1us，2.5秒产生一个误码，其误码率是多少，不会就蒙吧还问到RAM和ROM的区别，静态RAM和动态RAM的存储单元结构等等多选比较变态点第一题问下面的逻辑门必须上来电阻的是：OC门、OE门、OD门、以上都要第二题是问你下面是可编程逻辑器的是：ASIC、PAL、GAL、FPGA、CPLD第三题是RISC和CSIC的区别第四题是总线的功能，我不知道驱动是不是总线的功能，所以没选第五题有点难，问下面避免竞争冒险的是：采用同步时序电路，采用异步时序电路，修改状态转移表，增加延时逻辑第六是ROM和RAM的区别，下面是8051的P3脚复用功能，接着是检波器的组成，还有常见的滤波器第10题不会：问8KHz和10KHz的正弦波经过混频器之后，能产生下面那些频率的信号：－2K、2K、18K、1K11题考8051的中断，最后一道不容易，问下面对负反馈那里两个是对的
    从题目的难度和广度上看，比迈瑞的简单，但是没有准备过的人也很难做出来的哦，范围广，重基础，关键还有可恶的多选选择总的来说，我对自己的表现比较满意没有迈瑞的那么狼狈但是，估计没有下文了我想这份题目做得好的人大大的是啊听上午接到电话的人说，华为搞硬件的主要是3个方面：DSP和算法、逻辑电路、ASIC唉，这三个我没有一个会，更不用说懂就算有幸进到一面，也会被刷的，我想主要还是专业不太对有点影响未来的事情就等它发生了再说吧好好准备眼前的事情才是正道
 
五、华为一面
华为的硬件笔试考完之后感觉不错，果然得到了一面的机会不过我们学校去参加笔试的都可以去参加面试不过听说华为这次做硬件的只招收DSP和逻辑两个方面，我一听就觉得自己就此终止华为的征程了，看看大公司的面试也是长长经验吧我的面试时间被安排在6号的9点，搞到那天6点45就得起来从下沙赶到黄龙那边的一个酒店，极度的痛苦 
    不知道怎么搞的，和我一起来的几个9点20的都面试完了还没有轮到我们后来问问才知道我被安排到DSP组里面去了，后来赶紧叫他们改为逻辑大概等到11点，终于到我了不过当我走到面世官的前面，他却说要上洗手间，叫我等几分中，看来真是出师不利啊 
    面试官很和蔼客气，大家say hello之后，我紧张的心情松了不少然后他开始瞄我的简历，我估算了一下，不超过3秒钟还好我做的是一页简历他看到我后面有两个项目的实物图，就指着我在04年机械设计大赛的获奖作品问：“这个好像是什么车？”我说这个是我在省里面竞赛的一个作品，主要用一个多单片机系统控制直流电机和舵机完成相应的功能不过他好像不感兴趣，然后就问：“我看你的简历好像做DSP和逻辑的比较少嘛”（其实我根本就没有做过）我赶紧说：“是的，我们研究生虽然有相关的课程，但是我们学到只要是一些入门的基础，离实际的应用还很远，我在本科的时候主要是一些基础知识的系统学习，在研究生阶段主要是跟老师做做项目，其实我现在的技能主要和我做的项目相关，在以前的基础上的其中一两个方面进行比较深入的研究”面试官看了看的简历说：“我看你做单片机的项目比较多嘛，我们也有做单板机软件，也有用一些小型的CPU和AD转换、DA转换的一些东西，你愿不愿意做呢？”我想DSP和逻辑肯定挂了，这个还有一线生机，赶紧说：“OK，没有问题，其实我的毕业设计就说一个单片机的数据采集和处理系统，我把实物带来了，你要不要看一下？”他点头示意可以我心里一阵高兴，终于可以使出我的武器了 
    下面的面试内容的完全按照我事先预料的方向进行了首先我详细的介绍我带来的系统，从原理到框图，从性能到关键点说了一通他听完，问我：“这个系统是你设计的吗？”对于这个问题我觉得还是老实做答好，不然会死得很惨的我说不是，我参加这个项目的时候，这个系统已经设计好了，我做的工作就是对老的版本进行测试，改善，从硬件和软件两个角度去进行性能和稳定性的提高他说：“那好，我就问你几个问题吧？”首先问我上面一个三极管是干什么用的，我说那其实不是三极管，是一个稳压器79L05，产生一个－5V的电压给AD然后他问我上面两个二极管是干什么用的，我说那是起保护作用，主要是限制电流反流他一听很奇怪，他说二极管好像没有限流作用吧，我觉得他可能听错了，就补充了二极管的单向导通性，圆了一下场接着他叫我将系统上面的有源滤波画出来，完了，这个系统我就那个地方没有弄懂怎么办呢？只有画吧，凭着记忆画了一个二阶的有源滤波电路，跟他说我其实忘记了，大概说这样吧他说那你讲讲这个滤波器的工作原理吧，我连画都画不出来，原理更讲不清了我就跟他说：“其实二阶的滤波器和一阶滤波器的推导大致原理一样的，我画个一阶的来解析一下吧”然后就画画讲讲，其实我还讲的比较清楚的拉他问了最后一个问题，如果你的那个传感器的线比较长，会对你的系统有什么影响，其实我也是按照大致的方向去答的拉，我说这样就会导致信号的衰减和干扰的增大他稍稍停了一下，问我喜欢做偏硬一点的还是偏软一点的我说相对来说，我平时对偏软一点的做的事情比较多他说：“那我就给你定底软的岗位吧，我现在要考考你；两道C语言的题目”然后取了一叠试卷，边找边说给我找两个简单点的题目 
    第一个：写一个宏名为MIN的宏，输入两个参数，求最小的那个？晕倒！我见了很多次，但是为什么偏偏在那个时候忘记呢？但是总不能说不会吧，人家都说给我找简单的了只有硬着头皮写拉我的答案是： 
＃define  MIN (A,B)  ？（A>=B）B:A 
他看了我的答案，马上指出我的几个错误，应该是： 
＃define  MIN (A,B)  （A>=B）？（B）:（A） 
    第二个是读程序写结果，在一个mian()函数里面循环3次调用一个有静态变量的函数，输出一个和的结果这个我最熟悉的了，三两下就把结果和过程都写出来了 
    这时，面试也差不多要结束了面试官问我工作地点的问题我说我是广东人，希望在深圳，他说这个没有问题然后我再一个确认我的工作内容，他说主要是底软吧，到时候部门之间再调配一下，他看了看我的简历，发现我有ARM和LINUX的经验，他说其实他们也会做相关的东西，例如VxWorks等 
    这时，面试官对我说，他对我的能力比较满意，我心里一阵狂喜，不知道是骄傲还是高兴他主动站起来和我握手，说叫我等秘书的通知，下一轮面试通知会在这两天发出这时我都不知道自己在做什么了，收拾了下我的东西，临走前我主动和面试官再次握了握手，感谢他的面试与指导 
 
六、华为二面
没想到华为的工作效率那么快，本来还以为要到8号才有二面的通知，所以6号晚上玩了一把，到1点才睡觉当我睡得正香的时候，来了两个短信，心里一阵狂怒，凌晨两点半什么人那么无聊发短信啊不过一看原来是华为通知7好早上9点半面试，果然和大家说的一样，集体群殴PK，不管它了，继续睡觉本来想睡到7点起来的，不过6点20分左右，又来了短信，还是华为通知面试的，他们不会加班到通宵吧
    我们学校去参加研发一面的有4个人，其中有3个都进了二面到了指定的酒店后，先是填表，还真是详细，什么都得填本来安排是9点30的面试，后来拖到了10点20左右之前，我们组的12个人都到得差不多了，大家赶紧先认识一下，到时候PK的时候也比较熟悉嘛
    时间到了，我们在一个MM的带领下进了房间，三个桌子排成三角型，中间一牌是面试官4男1女两外两个是AB两组，反正大家随便坐，12个人分成两组PK首先是每个人用一张纸折一个铭牌，将自己的姓名和应聘岗位写在上面然后面试官开始叫我们自我介绍，要说得让面试官和大家对你留下深刻的影响，说说你的特点和以后的职业规划我发现浙大的人理想很大哦，职业规划都是要做什么技术管理结合的职业经理人我都忘记了我是怎么样介绍我的，好像说了说我一些竞赛获奖，说了说我的业余爱好，喜欢踢足球拉，还有就是我觉得我的硬件基础比较扎实，在华为里面能发挥所长，体现价值，华为是一个大企业，我在里面也能得到锻炼和成长不知道这样说有没有问题？
    接着开始一个活动，在10分钟里面，每组按照发的题目将里面属于白领最忧虑的事情进行排序，然后由组里面的一个人进行陈述理由，然后其他人可以进行补充活动刚开始我提了一个意见，但是有一个人的意见比我的更好，那就按照他的意见去做吧，我顺势将他推举为我们组的leader在10分钟里面，HR们过来看大家的表现，然后打分，反正我是没有怎么去排列，我只是协调一下大家的动作啊，看看时间啊很快时间到了，他们组先进行了陈述，在陈述的过程中，面试官会打断陈述，叫另外有个人补充表述我们这组也是在这个表述中，我基本上没有什么话，算是话最少的了
    两个组的排列顺序很不一样，这时候面试官说，你们两个组分别陈述理由，让对方同意你的观点然后，两个组的人就纷纷展现自己，在这个过程中，我几乎一言不发，看来犯了群殴的大忌了最后，面试官叫没有发过言的同学起来说两句，我是最后一个起来发言的，我就总结性的说了两点，然后就休息5分钟
   其实休息5分钟是让我们两个组在外面交流一下，统一一下观点我知道他的意思，出来后我问两个组是不是应该统一一下观点啊，好像他们也没有退步的感觉，那就算了吧
   很快有进去了，首先面试官叫对方组的一个人起来，说说他的看法，他说同意了我们组的一个观点但是也有不同的地方他说完之后，面试官看着我说，你们好像在外面统一了一下观点，你说说将B组的12点排在前面，你认不认同我突然晕了，这怎么回答呢，答认同嘛，不知道会不会被我们组认说，说不认同嘛，那面试官明说说我们统一观点，而且B组的人也妥协了那我只有用了找迂回战术，顺着B组刚刚的内容说了些总结性的东西，既不认同也不否认认同面试官看我答非所问，又将问题问了一遍，我又将刚才的话说了一边晕倒，这时那面官来了句其实我只是问你认不认同，这时候我发现我们组的leader在我的纸上写了认同两个字，我赶紧说认同认同，这才能坐下啊
    接着就是PK时段，想不到我是我们组唯一参与的B组也有一个人，面试官说，给你一个机会你把你的特点和长处说出来，让我们觉得你应该加入华为对方那人说啊说，面试官还让他举了一个案例真想不到会轮到我要参与PK，是不是因为我话太少，不够积极呢，还是什么......面试官看我有点紧张，就对我说，你看我现在给了你这么好的一个机会，你要把你的特点和长处说出来，其他人我都没有给机会啊不知道是不是安慰我的话然后我就慢条斯理的说，我自己性格比较随和，喜欢跟别人交流，我觉得在交流的过程中会得到很大的提高，我的基础知识比较扎实，在项目的实践过程中，发现基础技能很重要，很多高端的问题都可以用基础的知识来解决说我本科是学硬件的，研究生学的是软件，在实践的过程中发现现在不管是硬件开始还是软件开始都是一个协同的过程，不能机械的拆分两者，说我考虑问题会从系统的角度去分析，个体不一定是最好的，但是可能对系统的贡献是最大的最后我总结说，我的优点是我为人随和，有独立分析问题和解决问题的能力，自我适应能力和学习能力比较强，在知识结构上面，软硬件结合，实际项目经验较多面试官接着问我平时爱好干什么啊，我就说我喜欢体育运功，特别喜欢踢足球他居然问我踢那个位置，不知道他是不是也踢足球的，我是中场他又问我平时都和什么人踢啊，是不是和同学踢，我说不一定，有时候和同学踢，有时候到了球场上，碰到谁就和谁踢，还说我参加过一个大型的足球比赛
    就这样传说中的华为群殴结束了，虽然没有网上说得那么恐怖，但是也领我感到有点不爽，不知道是不是我被问的缘故后面还有10分钟的提问时间，有人问了华为集体辞职和加班的问题，还有下面的一些安排这时我才知道下面还有一个单对单的综合面试和综合素质测试、性格测试和英语测试
    长路漫漫啊......不知道还能不能收到三面的通知呢？等等吧......
 
七、智光面试
非常感谢智光电气给我面试的机会拉由于18号中午学校要进行毕业生的图像数据采集，我没有办法参加智光电气的笔试，虽然在宣讲会那天和相关的人员打了招呼，但是那天一直到下午三点多还没有收到任何通知，在浙大88上看到已经有人开始面试了，感觉这次是不是又没戏了呢？干脆回去寝室睡觉算了这时居然接到了智光电气的电话，说明天什么时候来杭州百脑汇8楼面试...... 
    没有参加笔试和一面，直接参加19号的面试，这样的待遇我还是头一次，很有受尊重的感觉有机会就不能错过，剩下的时间我就开始临时抱佛脚，听说很有用，不过面试的时候我都没有用上，因为我的面试估计也就10几分钟吧之前我等了大概半个小时 
    面试我的是一个博士，还有另外三个人主要就是根据简历上的东西随便问问你，但是每个技术都问得很到点子上，但是我也答得很到点上，而且还很老实，很多东西都直接说不是我设计或者不是我一个人做的，或许这样他们就不再往下问了现在的硕士大家都知道什么水平的拉......总不能说自己是什么大牛，估计我是说了肯定逃不过他们的法眼这次我仍然带了我的毕业课题做的板子过去，不过他们就随便看了看，也没说什么，我一点发挥的机会都没有......是不是他们看不上呢？他们问为什么用华邦的单片机做呢？我说便宜啊就这样另外还问我有没有做过电机方面的东西，那我就把以前机械设计竞赛和指导电子设计竞赛的一些东西说了说，大概就五六句话吧后来有个人问我做的一个数据汇集机用什么进行电话网通信的，我说是MODEM，本来以为可以大说一顿的拉，那个工程师说可以了，知道了那我也没什么说的了基本上聊了一些基本问题面试也就结束 
    接下来就谈待遇了，那个主面的博士问我期望多少钱，经过多次的打击，我也不好意思说了，就说我没有很高的要求，中等就可以了他叫我尽管说我说5K到6K吧他说5K应该没什么问题的估计也就这个身价了后来聊了一些工作内容和时间的问题，基本都比较合意吧然后就叫我准备三方了我说两天内答复找工作实在太累太耗时间和精力了，其实也没有什么可以选择的了，就这样......回去再想想，卖了吧
 
八、理邦面试
自从上次在智光面试完之后，也没有什么合适的单位到来在智光面试完，我正准备签三方的时候，他们的HR告诉我，要等广州总部的总工电话面试，但是快两个礼拜了都没有音讯，估计我是被他们放弃了正好1号深圳理邦来浙大宣讲，就去碰碰运气吧
    那天宣讲完马上开始笔试，还好之前抱了下佛脚原本我应聘的是嵌入式软件工程师职位，需要考一份软件题，不过一想到软件的算法，心里有点慌慌，要了份硬件的题目来做题目不多，八九道简答题，主要涉及晶体管、运放、滤波、触发器、AD、通信、单片机等一些很基础的东西我已经是身经百考的人了，每个公司的硬件题目都差不多的，大部分做起来没有什么问题，除了一个压控电流源和一道场效应管的题目没做，其他的问题不是很大，估计有下文，果然晚上接到了面试的电话
    理邦公司给你第一感觉很实在，很规范化，而且很守时面试安排在9点20，我怕迟到早点到了，说20就是20，我在面试的时候发现他们原来是有表的，难怪时间那么准，一次面试，经历了三个面试官的车轮战，对于我来说，还是头一次
第一战：技术面试
    我原来是他们通知的第二个来面试的人面试的时候，和他有好几米的距离，感觉有点紧张上来第一个问题是你喜欢做什么样的工作，然后开始按照你的简历上面的所做的项目来问，我都忘了我怎么回答的了，总之就是不停的说我第一次感觉到我的简历没有被浪费，他们用黄色的荧光笔在上面画了不少东西，看来我还是有一点东西能让他们感兴趣的它对我应聘嵌入式软件工程师去考硬件题目有点奇怪，那也没什么好解释的，就觉得自己对硬件更有把握一点这时又问了一些linux和ucos方面的东西等等，最后问我技术上面有什么问题需要问的这个我还真的没有怎么备，不问感觉好像对公司和个人不关心的，我问他们像我这种非生物医疗专业的人进去做会不会很困难他说没关系，我看你的计算机学得很不错，呵呵….这句话我搞得我很不好意思也就是十几分钟，就结束了，要走的时候，他说我考的是硬件题，技术总监要面试我硬件方面，面就面罗
第二战：技术总监
    技术总监给你感觉和蔼而威严他看了看我的成绩单，好像更关心的是我本科的成绩，他说你本科是机械自动化的，那你觉得你和电子、计算机专业的学生竞争有什么优势吗？说真的，在专业技术上面没有任何的优势，我主要围绕着软硬件结合和项目经验比较丰富这两方面来讲，好像说得过去了接着他问了我单片机方面的一些东西，好像他们对UCOS这个东西比较感兴趣，问我UCOS移植到MSP430上面行不行，我说没什么大的问题，然后说了说这个移植的过程这个过程中，我感觉我一直在不停的说，嘴都干了，都不知道我那来那么东西说在他问我为什么要在6月份毕业的时候，一个女的HR进来了，正好，技术总监叫我跟她出去了
第三战：面对女HR
    也许这次是我第一次真正的面对HR，感觉很不自然，而且问题回答的很糟糕在整个过程中都非常的严肃，我不知道其他公司的HR面试是不是也这样
    在面试的时候，我看到她在一张写着资格审查的表上写了我回答的问题，她问的问题我基本上都没有什么准备过，总之，问什么就答什么，但是我犯了个错误，有些问题不需要答得太多，说多了就会有问题…
    首先问我的职业规划是什么样的，我还真没有考虑过，经过上次华为二面的教训，我大概把3－5年的打算说了说，就一句话，我这段时间想在一个行业里面做研发，在技术上面多点积累，五年后可能做做技术管理方面的东西然后问你要找什么样的公司？工作地点在那里？有没有女朋友？平时喜欢干什么？性格是偏内向还是偏外向？其实这个我自己都不是很清楚，应该是有点内向吧问我身边都是些什么朋友？这个问题我答得比较糟糕，我也不想多说拉接着问你父母对你的最大影响是什么啊？对加班的看法？你最艰难的时候是什么时候，这个地方我又说多了，唉…..还问了毕业时间和实习的一些情况，最后问我有没有offer，我还真的是没有啊，问我以前有没有offer，我说智光电气给我了口头的offer，她好像很关心，把这个公司和我应聘的岗位都写下了，问我他们的待遇是多少，她顺便问我期望薪资多少，我想他们也不会给太多，说了个5K到6K，估计最后成的话也就5K吧最后她例行的问我有没有什么问题要问的，我之前还真没有考虑过哦，问了她在公司里面三年这个发展过程怎么样
1号上午理邦一面回来感觉不是很好，但是晚上还是收到了二面的通知在宣讲会的时候，他们说是要小组面试，我心里想一面的时候，技术专家面了，技术总监也见了，HR也谈了，二面面什么呢，小组面试会不会是跟华为他们一样的呢？心里没有什么底，也不知道怎么准备，干脆就不准备了
冬天早起的确是一件很艰难的事情，好不容易才爬起来，九点钟面试，我八点五十五才感到面试地点当我进去面试的房间才知道他们的小组面试是什么回事，原来所谓的小组，是他们小组，面试我一个人，昨天面试的3个人一起来面试我，大概30分钟吧原来还是问技术方面的问题，但是问的很深入，有很多问题我知道也做过，但是答的不完整，有些问题他们继续深入问，我只能说不知道他们完全按照我简历上面写的项目和技能来进行考查，所以说没有做过，甚至没有什么把握的东西，最好少出现在简历上面，一旦有严格考查的公司面试，一下就暴露出来了，而且还觉得你有吹嘘的嫌疑
面试一开始，公司技术总监就拿着我的本科成绩单和笔试题目说，我是机电毕业的学生，但是从笔试来看，我的基础不是很好，这个怎么办好呢？问我准备以后怎么样去补救其实我觉得这份题目做的还不错的拉，我看他在那道压控二极点高通滤波器上面打了一个大叉叉，我本来还觉得这道题目会做对的呢？然后他问我一些做“月球车”比赛的事情，我回答得应该不错，他说我是这个团队的军师了，这我科万万不能接受啊，赶紧把队友的贡献说了一通，强调他们的重要作用，这个团队里面少了谁也不行接着问我一些单片机相关的项目，这个我都答得没有什么问题然后是一个应该是偏软件一点的技术专家问我首先就我用VC做的一个项目问我windows消息的机制是怎么样实现，这个问题其实我答得不是很好，我就项目上面基于消息机制的异步网络传输说了一些windows消息机制的一些东西，他接着我说的问我知不知道将关联消息和消息响应函数的那个宏是怎么样实现的，有没有看过代码，我只能说没有看过，但是我说我知道它的原理，是用一个静态的函数表将消息和消息响应函数关联在一起的，他又顺着问题往下问我知不知道这个函数表叫什么，我又只能说不知道了下面他看我上面写着有linux下C/C++开发的经验，就开始从这里问我了看我上面写着做过字符设备的驱动，其实我只是做做实验看看代码而已，我就把字符设备驱动的框架说了一说，他又接着我的回答，问我知不知道操作系统怎么样找到设备相应的处理函数的，我也没怎么样想，就直接说不知道了，但是我说我觉得他们应该是怎么样的，我想应该回答得到点上面了接着他问我有没有做过linux上面的应用开发，我还是老老实实的告诉他吧，没有做过他好像对我在简历上面的不老实有点不满然后他继续问我相关于嵌入式和linux方面的东西，比如说移植啊，bootloader啊，会不会做randisk啊等等，大部分我只能say no了，但是我也不是完全举手投降，把相关的知识点答了一些，可能这也为我前面的不足做了一下弥补吧最后是HR发问，还是一些常规但是不好答的问题：你觉得什么是成功？你觉得人生的意义是什么？你觉得自己有什么缺点？你为什么要选择理邦？你觉得到了理邦公司你能做些什么样的贡献？如果现在给你offer你会不会签？等等…我觉得这些问题的回答非常关键，可能前面你都答的不错，但是这问题回答不好，也会被out的我觉得今天我这些问题答的还是可以的，虽然不是很好，总之这些问题怎么回答还是见仁见智的了最后一个环节是例行的问我有没有什么要问的，我其实也没什么问的了，但是不问不是很好，就问了一些关于实习的事情面试结果要到下午才能知道
想不到他们效率那么的快，在中午我正在食堂打饭的时候，他们的电话来了虽然有点吵，但是还要赶紧接拉HR先把面试结论告诉我，没怎么听清，大概是说我知识面比较宽，但是深度不够，基础不是很扎实等等等等，但是作为一个嵌入式软件工程师来说，还是可以培养的，下午可以来签约了，然后是待遇的情况，说了一通时候，告诉我要带什么什么
还考虑什么呢，下午赶紧把需要的东西带齐，奔赴浙大签约了签约只是一个5分钟的过程，他们把资料收好，给我出了张公司的接收函，再给我一张联系方式，整个签约就结束了，巨快我就这样卖出去了，尽管有很大的遗憾，但是最后我选择了一个高校，跟理邦办了违约手续
 
九、经验总结
    1、要有备而来，尽量将面试官引导到你最擅长的地方其实他们也希望这样的吧，否则他很难发现你的能力和特长，而他不知道你的长处，就只有按照他的思路来考你，对你乱开枪，这样大家都没有得到想要的结果 
    2、诚实最重要，懂就懂，不会就不会，东西不是你做就不要乱认面试你的都是这一行的资深工程师，要忽悠他们可没那么容易 
   3、对于不会回答的题目，不一定要给出准确的答案，只要往正确地将大致的思路说清楚就可以了，关键是你把你思考的过程告诉面试官 
   4、要有自信心，当被问到确实不会的问题是，可以问问面试官，他们会给你一些提示或者思路，你或许能做出来呢？ 
    5、平时要主要积累和准备，不然当面试机会来临的时候就手忙脚乱的拉，不过有时候临时抱佛脚也挺有用的，总之，没有准备很难有好发挥
6、投简历要有目的性，瞄准一家之后，做好各方面的情报工作，在网上收集试题、面经等等再投一些同类的公司，他们只是您的热身对手，重在参与，发现不足，锻炼心理，演练战术
7、笔试不可怕，笔过两会就经验丰富了，考什么你心里很自然会清楚的硬件的当然是数模电基础、单片机接口和C语言拉嵌入式方面少不了操作系统、网络原理、驱动等一些内容，但都是基础，比期末考试还要容易呢
8、求职是一个复杂的过程，职场如战场您完全可以把它看作一场战斗，优胜劣汰，除了有足够的枪支弹药，还需要有战略战术的指导
祝大家求职顺利，个个早日找到理想的工作岗位


嵌入式软件工程师笔试题(含答案).txt∞-一人行,必会发情	二人行,必会激情	三人行,必有奸情	就不会被珍惜。真实的女孩不完美，完美的女孩不真实。得之坦然，失之淡然，顺其自然，争其必然。选择题

1:设float a=2, b=4, c=3；，以下C语言表达式与代数式 (a+b)+c计算结果不一致的是
A.(a+b)*c/2
B.(1/2)*(a+b)*c
C.(a+b)*c*1/2
D.c/2*(a+b)
参考答案：B，因为a,b,c三个变量都是浮点数，所以在B答案中其结果是0，因为在计算1/2是就是0，如果改成1/2.0就正确了。

2:为了向二进制文件尾部增加数据，打开文件的方式应采用
A.″ab″
B.″rb+″
C.″wb″
D.″wb+″
参考答案：D

3:下述程序执行后的输出结果是
＃include
main()
{
int x='f';
printf("%c\n",'a'+(x-'a'+1));
}
A.g
B.h
C.i
D.j
参考答案：A

4:C语言中，下列运算符优先级最高的是
A.！
B.％
C.>>
D.＝ ＝
参考答案：A

5:数组定义为“ int a [ 4 ] ; ”，表达式 ( ) 是错误的。
A.*a
B.a [ 0 ]
C.a
D.a++
参考答案：D

6:执行语句“ k=7>>1; ”后，变量 k 的当前值是
A.15
B.31
C.3
D.1
参考答案：C

7:定义函数时，缺省函数的类型声明，则函数类型取缺省类型
A.void
B.char
C.float
D.int
参考答案：D

8:若main（）函数带参数，参数个数最多是
A.0
B.1
C.2
D.3
参考答案：C 只知道有定义形式main(int argc,char* argv[])）

9:若有宏定义：#define MOD(x，y) x％y
则执行以下语句后的输出结果是
int a=13，b=94；
printf(″％d\n″，MOD(b，a+4))；
A.5
B.7
C.9
D.11
参考答案：B

10:下列各个错误中，哪一个不属于编译错误
A.改变 x 原值 3 为 5 ，写作“ x==5 ;”
B.花括号不配对
C.复合语句中的最后一条语句后未加分号
D.变量有引用、无定义
参考答案：A

11:下列程序段运行后， x 的值是( )

a=1;b=2;x=0;
if(!( -- a))x -- ;
if(!b)x=7;else ++x;
A.0
B.3
C.6
D.7
参考答案：A

12:设
#define N 3
#define Y(n) ((N+1)*n)
则表达式2*(N+Y(5+1))的值是
A.42
B.48
C.54
D.出错
参考答案：B Y(5+1) 传递过去的应该是6，而不是简单的把5+1给替换掉

13:若定义了char ch[]={″abc\0def″｝，*p=ch;则执行printf(″%c″,*p+4);语句的输出结果是
A.def
B.d
C.e
D.0
参考答案：C

14:下列转义字符中错误的是
A.′\000′
B.′\14′
C.′\x111′
D.′\2′
参考答案：C error C2022: '273' : too big for character

15:算术运算符，赋值运算符和关系运算符的运算优先级按从高到低依次为
A.算术运算、赋值运算、关系运算
B.算术运算、关系运算、赋值运算
C.关系运算、赋值运算、算术运算
D.关系运算、算术运算、赋值运算
参考答案：B

16:设#define N 3
#define Y(n) ((N+1)*n)
则表达式2*(N+Y(5+1))的值是
A.42
B.48
C.54
D.出错
参考答案：B

17:表达式 strcmp( “ 3.14 ”，“ 3.278 ” ) 的值是一个
A.非零整数
B.浮点数
C.0
D.字符
参考答案： A

18:设struct
{ short a;
char b;
float c;
}cs;
则sizeof(cs)的值是
A.4
B.5
C.6
D.7
参考答案： D 字节对齐的话应该是8

19:若变量已正确定义，表达式( j=3 ， j++ )的值是
A.3
B.4
C.5
D.0
参考答案：A

20:C 语言中运算对象必须是整型的运算符是
A.%
B./
C.!
D.**
参考答案：A
简答题

21:打印一个N*N的方阵，N为每边字符的个数（ 3〈N〈20 ），要求最外层为“X”，第二层为“Y”，从第三层起每层依次打印数字0，1，2，3，...
例子：当N =5，打印出下面的图形：
X X X X X
X Y Y Y X
X Y 0 Y X
X Y Y Y X
X X X X X

22:谈谈COM的线程模型。然后讨论进程内/外组件的差别。

23:多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?
参考答案：
虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.
而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的,这是实现多态的关键.

24:#include

　　void main()

　　{ int c;

　　while ((c=getchar())!= ′\ n ′ )

　　switch(c - ′ 2 ′ )

　　{ case 0:

　　case 1:putchar(c+4);break;

　　case 2:putchar(c+4);break;

　　case 3:putchar(c+3);break;

　　default:putchar(c+2);break;

　　}

　　printf( ″\ n ″ );

　　}

　　运行时输入： 2473 ，输出结果：
参考答案：6897 VC++6.0测试过
25:用两个栈实现一个队列的功能？
参考答案：
设2个栈为A,B, 一开始均为空.入队:
将新元素push入栈A;出队:
(1)判断栈B是否为空；
(2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；
(3)将栈B的栈顶元素pop出；这样实现的队列入队和出队的平摊复杂度都还是O(1),
26:写一语句实现x是否为2的若干次幂的判断。
参考答案：!(X)&(X-1)

27:解二次方程:a*x*x+b*x+c
int Quadratic( double a,double b,double c,double& x1,double& x2);
返回值：解的个数

28:如何判别一个数是unsigned。
参考答案;
#define issignal(x) ((x>=0 && ~x>=0) ? 1:0) //为1是无符号 为0有符号
29:执行下述程序的输出结果是  ABCDEFCDEFEF  。
#include
char b[]="ABCDEF";
main()
{
char *bp;
for (bp=b;*bp;bp+=2)
printf("%s",bp);
printf("\n");
}

30:已知一个数组table，用一个宏定义，求出数据的元素个数。
参考答案：#define NTBL
#define NTBL (sizeof(table)/sizeof(table[0]))


分享到
QQ空间
新浪微博
百度搜藏
人人网
腾讯微博
开心网
腾讯朋友
百度空间
豆瓣网
搜狐微博
MSN
QQ收藏
淘江湖
百度贴吧
谷歌Buzz
更多...
 
应届生求职全攻略 
应届生求职网首页| 全职推荐| 实习推荐| 宣讲会| 招聘会| 行业招聘| 公务员事业单位| 分类求职| 网申截止| 求职旅社| 更多 
切换到窄版 
帖子
好友
道具
勋章
收藏
任务


wwaannggqqii 在线我的帖子|任务 | |设置 |消息 |提醒 |退出 
积分: 26 |用户组: 职员 
快捷导航 
我的
微博
论坛BBS
职业规划
综合
简历
网申
笔试
面试
签约
薪资
户口
公务员
大礼包
工具
下载规则
我的简历
我的网申@应届生
我的论坛帖子
我的开心应届生
我的应届生微博
短信订阅名企招聘
GPA在线计算器
工资计算器
Offer比较分析器
求职许愿墙
Offer发送机
手机上应届生
金庸趣味职业测试
更多求职小工具
本版
用户
应届生求职招聘论坛 › 论坛 › 求职综合区 › 面试技巧、面经大全 › 面试技巧及面经精华 › 嵌入式面试资料（嵌入式程序员面试须知） 
Email订阅本站每日最新校园招聘信息推荐
应届生求职全攻略(简历、笔试、面试、银行)
关注应届生  
12345678910... 14下一页
返回列表 
查看: 14807|回复: 269 

[技术类面试] 嵌入式面试资料（嵌入式程序员面试须知） [复制链接] 




powerlang 
powerlang 当前离线 
最后登录
2008-11-3
在线时间
3 小时
注册时间
2008-9-25
阅读权限
5
精华
0
帖子
3
狗仔卡 

求职中

求职中, 积分 4, 距离下一级还需 16 积分
在线时间
3 小时
应届生币
4 枚
最后登录
2008-11-3
阅读权限
5
精华
0
帖子
3
串个门
加好友
打招呼
发消息
电梯直达 
1楼 
发表于 2008-9-27 10:16:54 |只看该作者 |倒序浏览 
分享到: 新浪微博 qq空间 百度搜藏 人人网 
嵌入式面试资料
 
        C语言测试是招聘嵌入式系统程序员过程中必须而且有效的方法。这些年，我既参加也组织了许多这种测试，在这过程中我意识到这些测试能为面试者和被面试者提供许多有用信息，此外，撇开面试的压力不谈，这种测试也是相当有趣的。
        从被面试者的角度来讲，你能了解许多关于出题者或监考者的情况。这个测试只是出题者为显示其对ANSI标准细节的知识而不是技术技巧而设计吗？这是个愚蠢的问题吗？如要你答出某个字符的ASCII值。这些问题着重考察你的系统调用和内存分配策略方面的能力吗？这标志着出题者也许花时间在微机上而不是在嵌入式系统上。如果上述任何问题的答案是"是"的话，那么我知道我得认真考虑我是否应该去做这份工作。
        从面试者的角度来讲，一个测试也许能从多方面揭示应试者的素质：最基本的，你能了解应试者C语言的水平。不管怎么样，看一下这人如何回答他不会的问题也是满有趣。应试者是以好的直觉做出明智的选择，还是只是瞎蒙呢？当应试者在某个问题上卡住时是找借口呢，还是表现出对问题的真正的好奇心，把这看成学习的机会呢？我发现这些信息与他们的测试成绩一样有用。
        有了这些想法，我决定出一些真正针对嵌入式系统的考题，希望这些令人头痛的考题能给正在找工作的人一点帮助。这些问题都是我这些年实际碰到的。其中有些题很难，但它们应该都能给你一点启迪。
        这个测试适于不同水平的应试者，大多数初级水平的应试者的成绩会很差，经验丰富的程序员应该有很好的成绩。为了让你能自己决定某些问题的偏好，每个问题没有分配分数，如果选择这些考题为你所用，请自行按你的意思分配分数。

预处理器（Preprocessor）

1 . 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
         #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情：
1) #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
2)懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
3) 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
4) 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。

2 . 写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。
        #define MIN(A,B) （（A） <= (B) ? (A) : (B)) 
这个测试是为下面的目的而设的：
1) 标识#define在宏中应用的基本知识。这是很重要的。因为在  嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
2)三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
3) 懂得在宏中小心地把参数用括号括起来
4) 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
        least = MIN(*p++, b);

3. 预处理器标识#error的目的是什么？
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。


死循环（Infinite loops）

4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
这个问题用几个解决方案。我首选的方案是：

while(1)
{

}

一些程序员更喜欢如下方案：

for(;;)
{

}

这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是："我被教着这样做，但从没有想到过为什么。"这会给我留下一个坏印象。

第三个方案是用 goto
Loop:
...
goto Loop;
应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。


数据声明（Data declarations） 

5. 用变量a给出下面的定义
a) 一个整型数（An integer） 
b)一个指向整型数的指针（ A pointer to an integer） 
c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r 
d)一个有10个整型数的数组（ An array of 10 integers） 
e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） 
f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） 
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） 
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）

答案是： 
a) int a; // An integer 
b) int *a; // A pointer to an integer 
c) int **a; // A pointer to a pointer to an integer 
d) int a[10]; // An array of 10 integers 
e) int *a[10]; // An array of 10 pointers to integers 
f) int (*a)[10]; // A pointer to an array of 10 integers 
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer 
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer 

人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？

Static 

6. 关键字static的作用是什么？
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。

大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。


Const 

7．关键字const有什么含意？
我只要一听到被面试者说："const意味着常数"，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着"只读"就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）
如果应试者能正确回答这个问题，我将问他一个附加的问题：
下面的声明都是什么意思？

const int a;
int const a;
const int *a;
int * const a;
int const * a const;

/******/
前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
1) 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
2) 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
3) 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。


Volatile 

8. 关键字volatile有什么含意?并给出三个不同的例子。
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
1) 并行设备的硬件寄存器（如：状态寄存器）
2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3) 多线程应用中被几个任务共享的变量

回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。
假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
1)一个参数既可以是const还可以是volatile吗？解释为什么。
2); 一个指针可以是volatile 吗？解释为什么。
3); 下面的函数有什么错误：

int square(volatile int *ptr)
{
        return *ptr * *ptr;
}

下面是答案：
1)是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
2); 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
3) 这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：

int square(volatile int *ptr) 
{
    int a,b;
    a = *ptr;
    b = *ptr;
    return a * b;
}

由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：

long square(volatile int *ptr) 
{
    int a;
    a = *ptr;
    return a * a;
}

位操作（Bit manipulation） 

9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
对这个问题有三种基本的反应
1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
2) 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：

#define BIT3 (0x1 << 3)
static int a;

void set_bit3(void) 
{
    a |= BIT3;
}
void clear_bit3(void) 
{
    a &= ~BIT3;
}

一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。


访问固定的内存位置（Accessing fixed memory locations） 

10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
    int *ptr;
    ptr = (int *)0x67a9;
    *ptr = 0xaa55;

 A more obscure approach is: 
一个较晦涩的方法是：

    *(int * const)(0x67a9) = 0xaa55;

即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。

中断（Interrupts） 

11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。

__interrupt double compute_area (double radius) 
{
    double area = PI * radius * radius;
    printf("\nArea = %f", area);
    return area;
}

这个函数有太多的错误了，以至让人不知从何说起了：
1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。


代码例子（Code examples）

12 . 下面的代码输出是什么，为什么？

void foo(void)
{
    unsigned int a = 6;
    int b = -20;
    (a+b > 6) ? puts("> 6") : puts("<= 6");
}
这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 ">6"。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。

13. 评价下面的代码片断：

unsigned int zero = 0;
unsigned int compzero = 0xFFFF; 
/*1's complement of zero */

对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：

unsigned int compzero = ~0;

这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧...


动态内存分配（Dynamic memory allocation） 

14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：
下面的代码片段的输出是什么，为什么？

char *ptr;
if ((ptr = (char *)malloc(0)) == NULL) 
    puts("Got a null pointer");
else
    puts("Got a valid pointer");

这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是"Got a valid pointer"。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。

Typedef 
 
15 Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：

#define dPS struct s *
typedef struct s * tPS;

以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：

dPS p1,p2;
tPS p3,p4;

第一个扩展为

struct s * p1, p2;
.
上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。



晦涩的语法

16 . C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？

int a = 5, b = 7, c;
c = a+++b;

这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：

c = a++ + b;

因此, 这段代码持行后a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。


好了，伙计们，你现在已经做完所有的测试了。这就是我出的C语言测试题，我怀着愉快的心情写完它，希望你以同样的心情读完它。如果是认为这是一个好的测试，那么尽量都用到你的找工作的过程中去吧。天知道也许过个一两年，我就不做现在的工作，也需要找一个。


分享到: QQ空间 腾讯微博 腾讯朋友 
分享0 收藏0 评分 

使用道具 举报 
提升卡
置顶卡
沉默卡
喧嚣卡
变色卡
显身卡 




1:设float a=2, b=4, c=3；，以下C语言表达式与代数式 (a+b)+c计算结果不一致的是
A.(a+b)*c/2
B.(1/2)*(a+b)*c
C.(a+b)*c*1/2
D.c/2*(a+b)
参考答案：B，因为a,b,c三个变量都是浮点数，所以在B答案中其结果是0，因为在计算1/2是就是0，如果改成1/2.0就正确了。

2:为了向二进制文件尾部增加数据，打开文件的方式应采用
A.″ab″
B.″rb+″
C.″wb″
D.″wb+″
参考答案：D

3:下述程序执行后的输出结果是
＃include
main()
{
int x='f';
printf("%c\n",'a'+(x-'a'+1));
}
A.g
B.h
C.i
D.j
参考答案：A

4:C语言中，下列运算符优先级最高的是
A.！
B.％
C.>>
D.＝ ＝
参考答案：A

5:数组定义为“ int a [ 4 ] ; ”，表达式 ( ) 是错误的。
A.*a
B.a [ 0 ]
C.a
D.a++
参考答案：D

6:执行语句“ k=7>>1; ”后，变量 k 的当前值是
A.15
B.31
C.3
D.1
参考答案：C

7:定义函数时，缺省函数的类型声明，则函数类型取缺省类型
A.void
B.char
C.float
D.int
参考答案：D

8:若main（）函数带参数，参数个数最多是
A.0
B.1
C.2
D.3
参考答案：C 只知道有定义形式main(int argc,char* argv[])）

9:若有宏定义：#define MOD(x，y) x％y
则执行以下语句后的输出结果是
int a=13，b=94；
printf(″％d\n″，MOD(b，a+4))；
A.5
B.7
C.9
D.11
参考答案：B

10:下列各个错误中，哪一个不属于编译错误
A.改变 x 原值 3 为 5 ，写作“ x==5 ;”
B.花括号不配对
C.复合语句中的最后一条语句后未加分号
D.变量有引用、无定义
参考答案：A

11:下列程序段运行后， x 的值是( )

a=1;b=2;x=0;
if(!( -- a))x -- ;
if(!b)x=7;else ++x;
A.0
B.3
C.6
D.7
参考答案：A

12:设
#define N 3
#define Y(n) ((N+1)*n)
则表达式2*(N+Y(5+1))的值是
A.42
B.48
C.54
D.出错
参考答案：B Y(5+1) 传递过去的应该是6，而不是简单的把5+1给替换掉

13:若定义了char ch[]={″abc\0def″｝，*p=ch;则执行printf(″%c″,*p+4);语句的输出结果是
A.def
B.d
C.e
D.0
参考答案：C

14:下列转义字符中错误的是
A.′\000′
B.′\14′
C.′\x111′
D.′\2′
参考答案：C error C2022: '273' : too big for character

15:算术运算符，赋值运算符和关系运算符的运算优先级按从高到低依次为
A.算术运算、赋值运算、关系运算
B.算术运算、关系运算、赋值运算
C.关系运算、赋值运算、算术运算
D.关系运算、算术运算、赋值运算
参考答案：B

16:设#define N 3
#define Y(n) ((N+1)*n)
则表达式2*(N+Y(5+1))的值是
A.42
B.48
C.54
D.出错
参考答案：B

17:表达式 strcmp( “ 3.14 ”，“ 3.278 ” ) 的值是一个
A.非零整数
B.浮点数
C.0
D.字符
参考答案： A

18:设struct
{ short a;
char b;
float c;
}cs;
则sizeof(cs)的值是
A.4
B.5
C.6
D.7
参考答案： D 字节对齐的话应该是8

19:若变量已正确定义，表达式( j=3 ， j++ )的值是
A.3
B.4
C.5
D.0
参考答案：A

20:C 语言中运算对象必须是整型的运算符是
A.%
B./
C.!
D.**
参考答案：A
简答题

21:打印一个N*N的方阵，N为每边字符的个数（ 3〈N〈20 ），要求最外层为“X”，第二层为“Y”，从第三层起每层依次打印数字0，1，2，3，...
例子：当N =5，打印出下面的图形：
X X X X X
X Y Y Y X
X Y 0 Y X
X Y Y Y X
X X X X X

22:谈谈COM的线程模型。然后讨论进程内/外组件的差别。

23:多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?
参考答案：
虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.
而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的,这是实现多态的关键.

24:#include

　　void main()

　　{ int c;

　　while ((c=getchar())!= ′\ n ′ )

　　switch(c - ′ 2 ′ )

　　{ case 0:

　　case 1:putchar(c+4);break;

　　case 2:putchar(c+4);break;

　　case 3:putchar(c+3);break;

　　default:putchar(c+2);break;

　　}

　　printf( ″\ n ″ );

　　}

　　运行时输入： 2473 ，输出结果：
参考答案：6897 VC++6.0测试过
25:用两个栈实现一个队列的功能？
参考答案：
设2个栈为A,B, 一开始均为空.入队:
将新元素push入栈A;出队:
(1)判断栈B是否为空；
(2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；
(3)将栈B的栈顶元素pop出；这样实现的队列入队和出队的平摊复杂度都还是O(1),
26:写一语句实现x是否为2的若干次幂的判断。
参考答案：!(X)&(X-1)

27:解二次方程:a*x*x+b*x+c
int Quadratic( double a,double b,double c,double& x1,double& x2);
返回值：解的个数

28:如何判别一个数是unsigned。
参考答案;
#define issignal(x) ((x>=0 && ~x>=0) ? 1:0) //为1是无符号 为0有符号
29:执行下述程序的输出结果是  ABCDEFCDEFEF  。
#include
char b[]="ABCDEF";
main()
{
char *bp;
for (bp=b;*bp;bp+=2)
printf("%s",bp);
printf("\n");
}

30:已知一个数组table，用一个宏定义，求出数据的元素个数。
参考答案：#define NTBL
#define NTBL (sizeof(table)/sizeof(table[0]))


嵌入式开发—C语言面试题（笔试部分）
预处理器（Preprocessor） 
1. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题） 
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL 
我在这想看到几件事情： 
1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等） 
2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。 
3). 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。 
4). 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。 
2. 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。 
#define MIN(A,B) ((A) <= (B) (A) : )) 
这个测试是为下面的目的而设的： 
1). 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。 
2). 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。 
3). 懂得在宏中小心地把参数用括号括起来 
4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？ 
least = MIN(*p++, b); 
3. 预处理器标识#error的目的是什么？ 
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种 
问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。 
死循环（Infinite loops） 
4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？ 
这个问题用几个解决方案。我首选的方案是： 
while(1) { } 
一些程序员更喜欢如下方案： 
for(;;) { } 
这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的 
基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。 
第三个方案是用 goto 
Loop: 
... 
goto Loop; 
应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。 
数据声明（Data declarations） 
5. 用变量a给出下面的定义 
a) 一个整型数（An integer） 
b) 一个指向整型数的指针（A pointer to an integer） 
c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer） 
d) 一个有10个整型数的数组（An array of 10 integers） 
e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers） 
f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers） 
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） 
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ） 
答案是： 
a) int a; // An integer 
b) int *a; // A pointer to an integer 
c) int **a; // A pointer to a pointer to an integer 
d) int a[10]; // An array of 10 integers 
e) int *a[10]; // An array of 10 pointers to integers 
f) int (*a)[10]; // A pointer to an array of 10 integers 
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer 
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer 
人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。 
但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道 
所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？ 
Static 
6. 关键字static的作用是什么？ 
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用： 
1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。 
2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。 
3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。 
大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。 
Const 
7．关键字const是什么含意？ 
我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么. 
如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？ 
const int a; 
int const a; 
const int *a; 
int * const a; 
int const * a const; 
前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由： 
1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。） 
2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。 
3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。 
Volatile 
8. 关键字volatile有什么含意 并给出三个不同的例子。 
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子： 
1). 并行设备的硬件寄存器（如：状态寄存器） 
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 
3). 多线程应用中被几个任务共享的变量 
回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。 
假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。 
1). 一个参数既可以是const还可以是volatile吗？解释为什么。 
2). 一个指针可以是volatile 吗？解释为什么。 
3). 下面的函数有什么错误： 
int square(volatile int *ptr) 
{ return *ptr * *ptr; 
} 下面是答案： 
1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。 
2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。 
3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码： 
int square(volatile int *ptr) 
{ int a,b; 
a = *ptr; 
b = *ptr; 
return a * b; 
} 由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下： 
long square(volatile int *ptr) 
{ int a; 
a = *ptr; 
return a * a; 
} 
位操作（Bit manipulation） 
9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。 
对这个问题有三种基本的反应 
1). 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。 
2). 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。 
3). 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下： 
#define BIT3 (0x1<<3) 
static int a; 
void set_bit3(void) 
{ a |= BIT3; 
} void clear_bit3(void) 
{ a &= ~BIT3; 
} 一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。 
10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。 
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下： 
int *ptr; 
ptr = (int *)0x67a9; 
*ptr = 0xaa55; 
一个较晦涩的方法是： 
*(int * const)(0x67a9) = 0xaa55; 
即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。 
中断（Interrupts） 
11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。 
__interrupt double compute_area (double radius) 
{ double area = PI * radius * radius; 
printf(" Area = %f", area); 
return area; 
} 
这个函数有太多的错误了，以至让人不知从何说起了： 
1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。 
2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。 
3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。 
4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。 
代码例子（Code examples） 
12 . 下面的代码输出是什么，为什么？ 
void foo(void) 
{ unsigned int a = 6; 
int b = -20; 
(a+b > 6) puts("> 6") : puts("<= 6"); 
} 
这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“>6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。 
13. 评价下面的代码片断： 
unsigned int zero = 0; 
unsigned int compzero = 0xFFFF; 
/*1's complement of zero */ 
对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下： 
unsigned int compzero = ~0; 
这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。 
到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧… 
动态内存分配（Dynamic memory allocation） 
14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？ 
这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？ 
char *ptr; 
if ((ptr = (char *)malloc(0)) == NULL) 
puts("Got a null pointer"); 
else 
puts("Got a valid pointer"); 
这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是“Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。 
Typedef 
15. Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子： 
#define dPS struct s * 
typedef struct s * tPS; 
以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？ 
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子： 
dPS p1,p2; 
tPS p3,p4; 
第一个扩展为 
struct s * p1, p2; 
上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。
晦涩的语法 
16. C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？ 
int a = 5, b = 7, c; 
c = a+++b; 
这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成： 
c = a++ + b; 
因此, 这段代码持行后a = 6, b = 7, c = 12。 
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是:这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题 
What will print out? 
main() 
{ char *p1=“name”; 
char *p2; 
p2=(char*)malloc(20); 
memset (p2, 0, 20); 
while(*p2++ = *p1++); 
printf(“%sn”,p2); 
} 
Answer:empty string. 
What will be printed as the result of the operation below: 
main() 
{ int x=20,y=35; 
x=y++ + x++; 
y= ++y + ++x; 
printf(“%d%dn”,x,y); 
} 
Answer : 5794 
What will be printed as the result of the operation below: 
main() 
{ int x=5; 
printf(“%d,%d,%dn”,x,x< <2,x>>2); 
} 
Answer: 5,20,1 
What will be printed as the result of the operation below: 
#define swap(a,b) a=a+b;b=a-b;a=a-b; 
void main() 
{ int x=5, y=10; 
swap (x,y); 
printf(“%d %dn”,x,y); 
swap2(x,y); 
printf(“%d %dn”,x,y); 
} 
int swap2(int a, int b) 
{ int temp; 
temp=a; 
b=a; 
a=temp; 
return 0; 
} 
Answer: 10, 5 
10, 5 
What will be printed as the result of the operation below: 
main() 
{ char *ptr = ” Cisco Systems”; 
*ptr++; printf(“%sn”,ptr); 
ptr++; 
printf(“%sn”,ptr); 
} 
Answer:Cisco Systems 
isco systems 
What will be printed as the result of the operation below: 
main() 
{ char s1[]=“Cisco”; 
char s2[]= “systems”; 
printf(“%s”,s1); 
} Answer: Cisco 
What will be printed as the result of the operation below: 
main() 
{ char *p1; 
char *p2; 
p1=(char *)malloc(25); 
p2=(char *)malloc(25); 
strcpy(p1,”Cisco”); 
strcpy(p2,“systems”); 
strcat(p1,p2); 
printf(“%s”,p1); 
} 
Answer: Ciscosystems 
The following variable is available in file1.c, who can access it?: 
static int average; 
Answer: all the functions in the file1.c can access the variable. 
WHat will be the result of the following code? 
#define TRUE 0 // some code 
while(TRUE) 
{ 
// some code 
} 
Answer: This will not go into the loop as TRUE is defined as 0. 
What will be printed as the result of the operation below: 
int x; 
int modifyvalue() 
{ return(x+=10); 
} int changevalue(int x) 
{ return(x+=1); 
} 
void main() 
{ int x=10; 
x++; 
changevalue(x); 
x++; 
modifyvalue(); 
printf("First output:%dn",x); 
x++; 
changevalue(x); 
printf("Second output:%dn",x); 
modifyvalue(); 
printf("Third output:%dn",x); 
} 
Answer: 12 , 13 , 13 
What will be printed as the result of the operation below: 
main() 
{ int x=10, y=15; 
x = x++; 
y = ++y; 
printf(“%d %dn”,x,y); 
} 
Answer: 11, 16 
What will be printed as the result of the operation below: 
main() 
{ int a=0; 
if(a==0) 
printf(“Cisco Systemsn”); 
printf(“Cisco Systemsn”); 
} 
Answer: Two lines with “Cisco Systems” will be printed. 
再次更新C++相关题集 
1. 以下三条输出语句分别输出什么？[C易] 
char str1[] = "abc"; 
char str2[] = "abc"; 
const char str3[] = "abc"; 
const char str4[] = "abc"; 
const char* str5 = "abc"; 
const char* str6 = "abc"; 
cout << boolalpha << ( str1==str2 ) << endl; // 输出什么？ 
cout << boolalpha << ( str3==str4 ) << endl; // 输出什么？ 
cout << boolalpha << ( str5==str6 ) << endl; // 输出什么？ 
13. 非C++内建型别 A 和 B，在哪几种情况下B能隐式转化为A？[C++中等] 
答： 
a. class B : public A { ……} // B公有继承自A，可以是间接继承的 
b. class B { operator A( ); } // B实现了隐式转化为A的转化 
c. class A { A( const B& ); } // A实现了non-explicit的参数为B（可以有其他带默认值的参数）构造函数 
d. A& operator= ( const A& ); // 赋值操作，虽不是正宗的隐式类型转换，但也可以勉强算一个 
12. 以下代码中的两个sizeof用法有问题吗？[C易] 
void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母 
{ for( size_t i=0; i<sizeof(str)/sizeof(str[0]); ++i ) 
if( 'a'<=str[i] && str[i]<='z' ) 
str[i] -= ('a'-'A' ); 
} char str[] = "aBcDe"; 
cout << "str字符长度为: " << sizeof(str)/sizeof(str[0]) << endl; 
UpperCase( str ); 
cout << str << endl; 
7. 以下代码有什么问题？[C难] 
void char2Hex( char c ) // 将字符以16进制表示 
{ char ch = c/0x10 + '0'; if( ch > '9' ) ch += ('A'-'9'-1); 
char cl = c%0x10 + '0'; if( cl > '9' ) cl += ('A'-'9'-1); 
cout << ch << cl << ' '; 
} char str[] = "I love 中国"; 
for( size_t i=0; i<strlen(str); ++i ) 
char2Hex( str[i] ); 
cout << endl; 
4. 以下代码有什么问题？[C++易] 
struct Test 
{ Test( int ) {} 
Test() {} 
void fun() {} 
}; 
void main( void ) 
{ Test a(1); 
a.fun(); 
Test b(); 
b.fun(); 
} 
5. 以下代码有什么问题？[C++易] 
cout << (true?1:"1") << endl; 
8. 以下代码能够编译通过吗，为什么？[C++易] 
unsigned int const size1 = 2; 
char str1[ size1 ]; 
unsigned int temp = 0; 
cin >> temp; 
unsigned int const size2 = temp; 
char str2[ size2 ]; 
9. 以下代码中的输出语句输出0吗，为什么？[C++易] 
struct CLS 
{ int m_i; 
CLS( int i ) : m_i(i) {} 
CLS() 
{ CLS(0); 
} }; 
CLS obj; 
cout << obj.m_i << endl; 
10. C++中的空类，默认产生哪些类成员函数？[C++易] 
答： 
class Empty 
{ public: 
Empty(); // 缺省构造函数 
Empty( const Empty& ); // 拷贝构造函数 
~Empty(); // 析构函数 
Empty& operator=( const Empty& ); // 赋值运算符 
Empty* operator&(); // 取址运算符 
const Empty* operator&() const; // 取址运算符 const 
}; 
3. 以下两条输出语句分别输出什么？[C++难] 
float a = 1.0f; 
cout << (int)a << endl; 
cout << (int&)a << endl; 
cout << boolalpha << ( (int)a == (int&)a ) << endl; // 输出什么？ 
float b = 0.0f; 
cout << (int)b << endl; 
cout << (int&)b << endl; 
cout << boolalpha << ( (int)b == (int&)b ) << endl; // 输出什么？ 
2. 以下反向遍历array数组的方法有什么错误？[STL易] 
vector array; 
array.push_back( 1 ); 
array.push_back( 2 ); 
array.push_back( 3 ); 
for( vector::size_type i=array.size()-1; i>=0; --i ) // 反向遍历array数组 
{ cout << array[i] << endl; 
} 
6. 以下代码有什么问题？[STL易] 
typedef vector IntArray; 
IntArray array; 
array.push_back( 1 ); 
array.push_back( 2 ); 
array.push_back( 2 ); 
array.push_back( 3 ); 
// 删除array数组中所有的2 
for( IntArray::iterator itor=array.begin(); itor!=array.end(); ++itor ) 
{ if( 2 == *itor ) array.erase( itor ); 
} 
11. 写一个函数，完成内存之间的拷贝。[考虑问题是否全面] 
答： 
void* mymemcpy( void *dest, const void *src, size_t count )   
{   
char* pdest = static_cast<char*>( dest );   
const char* psrc = static_cast<const char*>( src );   
if( pdest>psrc && pdest<psrc+cout ) 能考虑到这种情况就行了   
{   
for( size_t i=count-1; i!=-1; --i )   
pdest[i] = psrc[i];   
}   
else  
{   
for( size_t i=0; i<count; ++i )   
pdest[i] = psrc[i];   
}   
return dest;   
}   
int main( void )   
{   
char str[] = "0123456789";   
mymemcpy( str+1, str+0, 9 );   
cout << str << endl;   
  
system( "Pause" );   
return 0;   
}
 
分享到： 
  上一篇：C/C++ 面试 
  下一篇：C语言面试题总汇 
查看评论 
1楼 匿名用户 2010-03-30 09:31发表 [回复] [引用] [举报]


嵌入式软件工程师笔试题(含答案).txt26选择自信，就是选择豁达坦然，就是选择在名利面前岿然不动，就是选择在势力面前昂首挺胸，撑开自信的帆破流向前，展示搏击的风采。选择题

1:设float a=2, b=4, c=3；，以下C语言表达式与代数式 (a+b)+c计算结果不一致的是
A.(a+b)*c/2
B.(1/2)*(a+b)*c
C.(a+b)*c*1/2
D.c/2*(a+b)
参考答案：B，因为a,b,c三个变量都是浮点数，所以在B答案中其结果是0，因为在计算1/2是就是0，如果改成1/2.0就正确了。

2:为了向二进制文件尾部增加数据，打开文件的方式应采用
A.″ab″
B.″rb+″
C.″wb″
D.″wb+″
参考答案：D

3:下述程序执行后的输出结果是
＃include
main()
{
int x='f';
printf("%c\n",'a'+(x-'a'+1));
}
A.g
B.h
C.i
D.j
参考答案：A

4:C语言中，下列运算符优先级最高的是
A.！
B.％
C.>>
D.＝ ＝
参考答案：A

5:数组定义为“ int a [ 4 ] ; ”，表达式 ( ) 是错误的。
A.*a
B.a [ 0 ]
C.a
D.a++
参考答案：D

6:执行语句“ k=7>>1; ”后，变量 k 的当前值是
A.15
B.31
C.3
D.1
参考答案：C

7:定义函数时，缺省函数的类型声明，则函数类型取缺省类型
A.void
B.char
C.float
D.int
参考答案：D

8:若main（）函数带参数，参数个数最多是
A.0
B.1
C.2
D.3
参考答案：C 只知道有定义形式main(int argc,char* argv[])）

9:若有宏定义：#define MOD(x，y) x％y
则执行以下语句后的输出结果是
int a=13，b=94；
printf(″％d\n″，MOD(b，a+4))；
A.5
B.7
C.9
D.11
参考答案：B

10:下列各个错误中，哪一个不属于编译错误
A.改变 x 原值 3 为 5 ，写作“ x==5 ;”
B.花括号不配对
C.复合语句中的最后一条语句后未加分号
D.变量有引用、无定义
参考答案：A

11:下列程序段运行后， x 的值是( )

a=1;b=2;x=0;
if(!( -- a))x -- ;
if(!b)x=7;else ++x;
A.0
B.3
C.6
D.7
参考答案：A

12:设
#define N 3
#define Y(n) ((N+1)*n)
则表达式2*(N+Y(5+1))的值是
A.42
B.48
C.54
D.出错
参考答案：B Y(5+1) 传递过去的应该是6，而不是简单的把5+1给替换掉

13:若定义了char ch[]={″abc\0def″｝，*p=ch;则执行printf(″%c″,*p+4);语句的输出结果是
A.def
B.d
C.e
D.0
参考答案：C

14:下列转义字符中错误的是
A.′\000′
B.′\14′
C.′\x111′
D.′\2′
参考答案：C error C2022: '273' : too big for character

15:算术运算符，赋值运算符和关系运算符的运算优先级按从高到低依次为
A.算术运算、赋值运算、关系运算
B.算术运算、关系运算、赋值运算
C.关系运算、赋值运算、算术运算
D.关系运算、算术运算、赋值运算
参考答案：B

16:设#define N 3
#define Y(n) ((N+1)*n)
则表达式2*(N+Y(5+1))的值是
A.42
B.48
C.54
D.出错
参考答案：B

17:表达式 strcmp( “ 3.14 ”，“ 3.278 ” ) 的值是一个
A.非零整数
B.浮点数
C.0
D.字符
参考答案： A

18:设struct
{ short a;
char b;
float c;
}cs;
则sizeof(cs)的值是
A.4
B.5
C.6
D.7
参考答案： D 字节对齐的话应该是8

19:若变量已正确定义，表达式( j=3 ， j++ )的值是
A.3
B.4
C.5
D.0
参考答案：A

20:C 语言中运算对象必须是整型的运算符是
A.%
B./
C.!
D.**
参考答案：A
简答题

21:打印一个N*N的方阵，N为每边字符的个数（ 3〈N〈20 ），要求最外层为“X”，第二层为“Y”，从第三层起每层依次打印数字0，1，2，3，...
例子：当N =5，打印出下面的图形：
X X X X X
X Y Y Y X
X Y 0 Y X
X Y Y Y X
X X X X X

22:谈谈COM的线程模型。然后讨论进程内/外组件的差别。

23:多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?
参考答案：
虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.
而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的,这是实现多态的关键.

24:#include

　　void main()

　　{ int c;

　　while ((c=getchar())!= ′\ n ′ )

　　switch(c - ′ 2 ′ )

　　{ case 0:

　　case 1:putchar(c+4);break;

　　case 2:putchar(c+4);break;

　　case 3:putchar(c+3);break;

　　default:putchar(c+2);break;

　　}

　　printf( ″\ n ″ );

　　}

　　运行时输入： 2473 ，输出结果：
参考答案：6897 VC++6.0测试过
25:用两个栈实现一个队列的功能？
参考答案：
设2个栈为A,B, 一开始均为空.入队:
将新元素push入栈A;出队:
(1)判断栈B是否为空；
(2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；
(3)将栈B的栈顶元素pop出；这样实现的队列入队和出队的平摊复杂度都还是O(1),
26:写一语句实现x是否为2的若干次幂的判断。
参考答案：!(X)&(X-1)

27:解二次方程:a*x*x+b*x+c
int Quadratic( double a,double b,double c,double& x1,double& x2);
返回值：解的个数

28:如何判别一个数是unsigned。
参考答案;
#define issignal(x) ((x>=0 && ~x>=0) ? 1:0) //为1是无符号 为0有符号
29:执行下述程序的输出结果是  ABCDEFCDEFEF  。
#include
char b[]="ABCDEF";
main()
{
char *bp;
for (bp=b;*bp;bp+=2)
printf("%s",bp);
printf("\n");
}

30:已知一个数组table，用一个宏定义，求出数据的元素个数。
参考答案：#define NTBL
#define NTBL (sizeof(table)/sizeof(table[0]))

嵌入式工程师面试基础知识问答
   C语言测试是招聘嵌入式系统程序员过程中必须而且有效的方法。这些年，我既参加也组织了许多这种测试，在这过程中我意识到这些测试能为面试者和被面试者提供许多有用信息，此外，撇开面试的压力不谈，这种测试是相当有趣的。
      从被面试者的角度来讲，你能了解许多关于出题者或监考者的情况。这个测试只是出题者为显示其对ANSI标准细节的知识而不是技术技巧而设计吗？这是个愚蠢的问题吗？如要你答出某个字符的ASCII值。这些问题着重考察你的系统调用和内存分配策略方面的能力吗？这标志着出题者也许花时间在微机上而不是在嵌入式系统上。如果上述任何问题的答案是"是"的话，那么我知道我得认真考虑我是否应该去做这份工作。
       从面试者的角度来讲，一个测试也许能从多方面揭示应试者的素质：最基本的，你能了解应试者C语言的水平。不管怎么样，看一下这人如何回答他不会的问题也是满有趣。应试者是以好的直觉做出明智的选择，还是只是瞎蒙呢？当应试者在某个问题上卡住时是找借口呢，还是表现出对问题的真正的好奇心，把这看成学习的机会呢？我发现这些信息与他们的测试成绩一样有用。
       有了这些想法，我决定出一些真正针对嵌入式系统的考题，希望这些令人头痛的考题能给正在找工作的人一点帮助。这些问题都是我这些年实际碰到的。其中有些题很难，但它们应该都能给你一点启迪。
       这个测试适于不同水平的应试者，大多数初级水平的应试者的成绩会很差，经验丰富的程序员应该有很好的成绩。为了让你能自己决定某些问题的偏好，每个问题没有分配分数，如果选择这些考题为你所用，请自行按你的意思分配分数。
  
  预处理器（PREPROCESSOR）
  
  1 . 用预处理指令#DEFINE 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
           #DEFINE SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
  我在这想看到几件事情：
  1) #DEFINE 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
  2)懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
  3) 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
  4) 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。
  
  2 . 写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。
          #DEFINE MIN(A,B) （（A） <= (B) ? (A) : (B)) 
  这个测试是为下面的目的而设的：
  1) 标识#DEFINE在宏中应用的基本知识。这是很重要的。因为在  嵌入(INLINE)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
  2)三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比IF-THEN-ELSE更优化的代码，了解这个用法是很重要的。
  3) 懂得在宏中小心地把参数用括号括起来
  4) 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
          LEAST = MIN(*P++, B);
  
  3. 预处理器标识#ERROR的目的是什么？
  如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。
  
  
  死循环（INFINITE LOOPS）
  
  4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
  这个问题用几个解决方案。我首选的方案是：
  
  WHILE(1)
  {
  
  }
  
  一些程序员更喜欢如下方案：
  
  FOR(;;)
  {
  
  }
  
  这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是："我被教着这样做，但从没有想到过为什么。"这会给我留下一个坏印象。
  
  第三个方案是用 GOTO
  LOOP:
  ...
  GOTO LOOP;
  应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。
  
  
  数据声明（DATA DECLARATIONS） 
  
  5. 用变量A给出下面的定义
  A) 一个整型数（AN INTEGER） 
  B)一个指向整型数的指针（ A POINTER TO AN INTEGER） 
  C)一个指向指针的的指针，它指向的指针是指向一个整型数（ A POINTER TO A POINTER TO AN INTEGE）R 
  D)一个有10个整型数的数组（ AN ARRAY OF 10 INTEGERS） 
  E) 一个有10个指针的数组，该指针是指向一个整型数的。（AN ARRAY OF 10 POINTERS TO INTEGERS） 
  F) 一个指向有10个整型数数组的指针（ A POINTER TO AN ARRAY OF 10 INTEGERS） 
  G) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A POINTER TO A FUNCTION THAT TAKES AN INTEGER AS AN ARGUMENT AND RETURNS AN INTEGER） 
  H) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ AN ARRAY OF TEN POINTERS TO FUNCTIONS THAT TAKE AN INTEGER ARGUMENT AND RETURN AN INTEGER ）
  
  答案是： 
  A) INT A; // AN INTEGER 
  B) INT *A; // A POINTER TO AN INTEGER 
  C) INT **A; // A POINTER TO A POINTER TO AN INTEGER 
  D) INT A[10]; // AN ARRAY OF 10 INTEGERS 
  E) INT *A[10]; // AN ARRAY OF 10 POINTERS TO INTEGERS 
  F) INT (*A)[10]; // A POINTER TO AN ARRAY OF 10 INTEGERS 
  G) INT (*A)(INT); // A POINTER TO A FUNCTION A THAT TAKES AN INTEGER ARGUMENT AND RETURNS AN INTEGER 
  H) INT (*A[10])(INT); // AN ARRAY OF 10 POINTERS TO FUNCTIONS THAT TAKE AN INTEGER ARGUMENT AND RETURN AN INTEGER 
  
  人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？
  
  STATIC 
  
  6. 关键字STATIC的作用是什么？
  这个简单的问题很少有人能回答完全。在C语言中，关键字STATIC有三个明显的作用：
  1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
  2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
  3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
  
  大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。
  
  
  CONST 
  
  7．关键字CONST有什么含意？
  我只要一听到被面试者说："CONST意味着常数"，我就知道我正在和一个业余者打交道。去年DAN SAKS已经在他的文章里完全概括了CONST的所有用法，因此ESP(译者：EMBEDDED SYSTEMS PROGRAMMING)的每一位读者应该非常熟悉CONST能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出CONST意味着"只读"就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下SAKS的文章吧。）
  如果应试者能正确回答这个问题，我将问他一个附加的问题：
  下面的声明都是什么意思？
  
  CONST INT A;
  INT CONST A;
  CONST INT *A;
  INT * CONST A;
  INT CONST * A CONST;
  
  /******/
  前两个的作用是一样，A是一个常整型数。第三个意味着A是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思A是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着A是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 CONST，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字CONST呢？我也如下的几下理由：
  1) 关键字CONST的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用CONST的程序员很少会留下的垃圾让别人来清理的。）
  2) 通过给优化器一些附加的信息，使用关键字CONST也许能产生更紧凑的代码。
  3) 合理地使用关键字CONST可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少BUG的出现。
  
  
  VOLATILE 
  
  8. 关键字VOLATILE有什么含意?并给出三个不同的例子。
  一个定义为VOLATILE的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是VOLATILE变量的几个例子：
  1) 并行设备的硬件寄存器（如：状态寄存器）
  2) 一个中断服务子程序中会访问到的非自动变量(NON-AUTOMATIC VARIABLES)
  3) 多线程应用中被几个任务共享的变量
  
  回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到VOLATILE变量。不懂得VOLATILE的内容将会带来灾难。
  假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得VOLATILE完全的重要性。
  1)一个参数既可以是CONST还可以是VOLATILE吗？解释为什么。
  2); 一个指针可以是VOLATILE 吗？解释为什么。
  3); 下面的函数有什么错误：
  
  INT SQUARE(VOLATILE INT *PTR)
  {
          RETURN *PTR * *PTR;
  }
  
  下面是答案：
  1)是的。一个例子是只读的状态寄存器。它是VOLATILE因为它可能被意想不到地改变。它是CONST因为程序不应该试图去修改它。
  2); 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个BUFFER的指针时。
  3) 这段代码有点变态。这段代码的目的是用来返指针*PTR指向值的平方，但是，由于*PTR指向一个VOLATILE型参数，编译器将产生类似下面的代码：
  
  INT SQUARE(VOLATILE INT *PTR) 
  {
      INT A,B;
      A = *PTR;
      B = *PTR;
      RETURN A * B;
  }
  
  由于*PTR的值可能被意想不到地该变，因此A和B可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
  
  LONG SQUARE(VOLATILE INT *PTR) 
  {
      INT A;
      A = *PTR;
      RETURN A * A;
  }
  
  位操作（BIT MANIPULATION） 
  
  9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量A，写两段代码，第一个设置A的BIT 3，第二个清除A 的BIT 3。在以上两个操作中，要保持其它位不变。
  对这个问题有三种基本的反应
  1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
  2) 用BIT FIELDS。BIT FIELDS是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 INFINEON为其较复杂的通信芯片写的驱动程序，它用到了BIT FIELDS因此完全对我无用，因为我的编译器用其它的方式来实现BIT FIELDS的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
  3) 用 #DEFINES 和 BIT MASKS 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
  
  #DEFINE BIT3 (0X1 << 3)
  STATIC INT A;
  
  VOID SET_BIT3(VOID) 
  {
      A |= BIT3;
  }
  VOID CLEAR_BIT3(VOID) 
  {
      A &= ~BIT3;
  }
  
  一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。
  
  
  访问固定的内存位置（ACCESSING FIXED MEMORY LOCATIONS） 
  
  10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0X67A9的整型变量的值为0XAA66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
  这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（TYPECAST）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
      INT *PTR;
      PTR = (INT *)0X67A9;
      *PTR = 0XAA55;
  
   A MORE OBSCURE APPROACH IS: 
  一个较晦涩的方法是：
  
      *(INT * CONST)(0X67A9) = 0XAA55;
  
  即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。
  
  中断（INTERRUPTS） 
  
  11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __INTERRUPT。下面的代码就使用了__INTERRUPT关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
  
  __INTERRUPT DOUBLE COMPUTE_AREA (DOUBLE RADIUS) 
  {
      DOUBLE AREA = PI * RADIUS * RADIUS;
      PRINTF("\NAREA = %F", AREA);
      RETURN AREA;
  }
  
  这个函数有太多的错误了，以至让人不知从何说起了：
  1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
  2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
  3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
  4) 与第三点一脉相承，PRINTF()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。
  
  
  代码例子（CODE EXAMPLES）
  
  12 . 下面的代码输出是什么，为什么？
  
  VOID FOO(VOID)
  {
      UNSIGNED INT A = 6;
      INT B = -20;
      (A+B > 6) ? PUTS("> 6") : PUTS("<= 6");
  }
  这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 ">6"。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。
  
  13. 评价下面的代码片断：
  
  UNSIGNED INT ZERO = 0;
  UNSIGNED INT COMPZERO = 0XFFFF; 
  /*1'S COMPLEMENT OF ZERO */
  
  对于一个INT型不是16位的处理器为说，上面的代码是不正确的。应编写如下：
  
  UNSIGNED INT COMPZERO = ~0;
  
  这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
  到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个*吧...
  
  
  动态内存分配（DYNAMIC MEMORY ALLOCATION） 
  
  14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（HEAP）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
  这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. PLAUGER, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：
  下面的代码片段的输出是什么，为什么？
  
  CHAR *PTR;
  IF ((PTR = (CHAR *)MALLOC(0)) == NULL) 
      PUTS("GOT A NULL POINTER");
  ELSE
      PUTS("GOT A VALID POINTER");
  
  这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数MALLOC，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是"GOT A VALID POINTER"。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。
  
  TYPEDEF 
   
  15 TYPEDEF 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
  
  #DEFINE DPS STRUCT S *
  TYPEDEF STRUCT S * TPS;
  
  以上两种情况的意图都是要定义DPS 和 TPS 作为一个指向结构S指针。哪种方法更好呢？（如果有的话）为什么？
  这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：TYPEDEF更好。思考下面的例子：
  
  DPS P1,P2;
  TPS P3,P4;
  
  第一个扩展为
  
  STRUCT S * P1, P2;
  .
  上面的代码定义P1为一个指向结构的指针，P2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了P3 和P4 两个指针。
  
  
  
  晦涩的语法
  
  16 . C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
  
  INT A = 5, B = 7, C;
  C = A+++B;
  
  这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：
  
  C = A++ + B;
  
  因此, 这段代码持行后A = 6, B = 7, C = 12。
  如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。




1 . 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
         #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情：
1) #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
2)懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
3) 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
4) 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。

2 . 写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。
        #define MIN(A,B) （（A） <= (B) ? (A) : (B)) 
这个测试是为下面的目的而设的：
1) 标识#define在宏中应用的基本知识。这是很重要的。因为在  嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
2)三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
3) 懂得在宏中小心地把参数用括号括起来
4) 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
        least = MIN(*p++, b);

3. 预处理器标识#error的目的是什么？
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。


死循环（Infinite loops）

4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
这个问题用几个解决方案。我首选的方案是：

while(1)
{

}

一些程序员更喜欢如下方案：

for(;;)
{

}

这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是："我被教着这样做，但从没有想到过为什么。"这会给我留下一个坏印象。

第三个方案是用 goto
Loop:
...
goto Loop;
应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。


数据声明（Data declarations） 

5. 用变量a给出下面的定义
a) 一个整型数（An integer） 
b)一个指向整型数的指针（ A pointer to an integer） 
c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r 
d)一个有10个整型数的数组（ An array of 10 integers） 
e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） 
f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） 
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） 
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）

答案是： 
a) int a; // An integer 
b) int *a; // A pointer to an integer 
c) int **a; // A pointer to a pointer to an integer 
d) int a[10]; // An array of 10 integers 
e) int *a[10]; // An array of 10 pointers to integers 
f) int (*a)[10]; // A pointer to an array of 10 integers 
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer 
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer 

人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？

Static 

6. 关键字static的作用是什么？
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。

大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。


Const 

7．关键字const有什么含意？
我只要一听到被面试者说："const意味着常数"，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着"只读"就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）
如果应试者能正确回答这个问题，我将问他一个附加的问题：
下面的声明都是什么意思？

const int a;
int const a;
const int *a;
int * const a;
int const * a const;

/******/
前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
1) 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
2) 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
3) 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。


Volatile 

8. 关键字volatile有什么含意?并给出三个不同的例子。
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
1) 并行设备的硬件寄存器（如：状态寄存器）
2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3) 多线程应用中被几个任务共享的变量

回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。
假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
1)一个参数既可以是const还可以是volatile吗？解释为什么。
2); 一个指针可以是volatile 吗？解释为什么。
3); 下面的函数有什么错误：

int square(volatile int *ptr)
{
        return *ptr * *ptr;
}

下面是答案：
1)是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
2); 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
3) 这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：

int square(volatile int *ptr) 
{
    int a,b;
    a = *ptr;
    b = *ptr;
    return a * b;
}

由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：

long square(volatile int *ptr) 
{
    int a;
    a = *ptr;
    return a * a;
}

位操作（Bit manipulation） 

9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
对这个问题有三种基本的反应
1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
2) 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：

#define BIT3 (0x1 << 3)
static int a;

void set_bit3(void) 
{
    a |= BIT3;
}
void clear_bit3(void) 
{
    a &= ~BIT3;
}

一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。


访问固定的内存位置（Accessing fixed memory locations） 

10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
    int *ptr;
    ptr = (int *)0x67a9;
    *ptr = 0xaa55;

 A more obscure approach is: 
一个较晦涩的方法是：

    *(int * const)(0x67a9) = 0xaa55;

即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。

中断（Interrupts） 

11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。

__interrupt double compute_area (double radius) 
{
    double area = PI * radius * radius;
    printf("\nArea = %f", area);
    return area;
}

这个函数有太多的错误了，以至让人不知从何说起了：
1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。


代码例子（Code examples）

12 . 下面的代码输出是什么，为什么？

void foo(void)
{
    unsigned int a = 6;
    int b = -20;
    (a+b > 6) ? puts("> 6") : puts("<= 6");
}
这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 ">6"。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。

13. 评价下面的代码片断：

unsigned int zero = 0;
unsigned int compzero = 0xFFFF; 
/*1's complement of zero */

对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：

unsigned int compzero = ~0;

这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧...


动态内存分配（Dynamic memory allocation） 

14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：
下面的代码片段的输出是什么，为什么？

char *ptr;
if ((ptr = (char *)malloc(0)) == NULL) 
    puts("Got a null pointer");
else
    puts("Got a valid pointer");

这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是"Got a valid pointer"。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。

Typedef 
 
15 Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：

#define dPS struct s *
typedef struct s * tPS;

以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：

dPS p1,p2;
tPS p3,p4;

第一个扩展为

struct s * p1, p2;
.
上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。



晦涩的语法

16 . C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？

int a = 5, b = 7, c;
c = a+++b;

这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：

c = a++ + b;

因此, 这段代码持行后a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。


初入职场嵌入式工程师面试宝典
随着物联网发展的推进，嵌入式技术越来越成为一名高新技术行业，目前市场对此方面的人才需求也相对较大，各大高校也先后开设了此类课程。但是此专业的学生如何找到一份嵌入式工作？
	第一：技术为王，作为技术类工作，技术肯定是至关重要的。如何在短暂的时间向面试官展示你的技术能力？
	实物展示项目开发经验是最具说服力的，嵌入式技术作为软硬件相结合的技术，简历上写的天花乱坠也比不上一个实物的展示，通过自己制作一个实物，实现一定的智能控制功能，能够清晰的阐述出你设计的原理以及思路，能够分析自己的代码。不管你展示的项目难易程度高低，至少通过此方法可以让面试官明白第一你是做了精心准备的，是一个负责的人，为了自己的这份工作是用心去准备了的。态度上能给面试官一个好感。第二面试官通过你的讲解也能了解到你的大概水平，就算现在技术不到位，至少也知道你是个可造之材，或者知道如何培养你。
	所以技术类工作首先得保证手头有货，而刚好相反目前大多数同学都是表现在口头有货。说到什么技术都知道，ARM11都过时了、A8才是主流，元计算、内核裁剪、系统架构等等。说起来天花乱坠，但是实际落实到真正动手能力上…
东方智达科技致力于单片机、嵌入式培训。培养模式也是项目实战为主，所以想提高项目实战的同学欢迎来东方智达学习。
	第二：态度诚恳，不卑不亢。
面对面试官不需要表现的过分的谦虚谨慎，个人感觉这种人没活力，没底气，就像一个永远不会犯错的小羔羊。当然本着天下老子第一的态度更不用谈了，毕竟人家现在可以应聘你肯定比你牛X。话说回来“不气盛，那叫年轻人。”我就看好有个性的年轻人，充满着自信，这事我能搞定，这种人也许是企业更希望得到的。
	第三：面试服饰礼仪。
本文主要针对嵌入式工程师面试，作为技术工种所以建议不要西装革履了，刚毕业的同学花大几千买套西装真不划算，花几百买套劣质西装倒不如好好买套休闲装，看着精神干净。服饰方面一直提出休闲简约，不要搞的花里胡哨的。自己穿着舒服，别人看着干净刚好。
第四：回答面试官问题。
	有几个问题时面试官经常问到的，你未来几年的职业规划，你的理想薪资，你的自我评价。
针对这个几个问题第一你未来几年的职业规划，这个问题也许答案很范，但是个人建议在同学们踏入职场前最好真心把这个问题思考清楚，自己将何去何从，未来的方向在哪里，未来的目标在哪里，有人云：“没有方向的船、任何风都不是顺风”。如果你自己没有清晰的目标不知道自己将去哪里，在你的职业生涯中基本上就是一个工作机器，为了养家糊口的赚钱机器，因为你没有职业上的规划，你只有为了获取生理上的满足，同时面对面试官的这个问题你也应该谨慎回答，不可信口开河说的牛x哄哄，也不和含糊其辞。总之最好的回答是建立在你应聘公司发展的角度。
理想薪资：叫太高怕丢了这个offer，叫太低怕亏了自己，这个问题还是看自己的手头上的能力吧，自己几斤几两自己清楚，叫个合理的价格，是金子总会发光，进来工资低有能力涨的也快，进来工资高结果做不了事、后果可能更惨烈。
自我评价：这个建议实事求是，人无完人，优缺点说清楚，必将将来都是一起工作的人，心照不宣还是要好很多。啥优缺点也是包不住的。，
综上所述，面试就要是做到技术牛逼、态度诚恳、天高地阔任我闯的坦荡。
	

在嵌入式软件开发过程中，一般来说，花在测试和花在编码的时间比为3:1(实际上可能更 多)。这个比例随着你的编程和测试水平的提高而不断下降，但不论怎样，软件测试对一般人来讲很重要。很多年前，一位开发人员为了对嵌入式有更深层次的理 解，向Oracle询问了这样的一个问题:我怎么才能知道并懂得我的系统到底在干些什么呢?　Oracle 面对这个问题有些吃惊，因为在当时没有人这么问过，而同时代的嵌入式开发人员问的最多的大都围绕“我怎么才能使程序跑的更快”、“什么编译器最好”等肤浅 的问题。所以，面对这个不同寻常却异乎成熟的问题，Oracle感到欣喜并认真回复了他:你的问题很有深度很成熟，因为只有不断地去深入理解才有可能不断 地提高水平。并且Oracle为了鼓励这位执着的程序员，把10条关于嵌入式软件开发测试的秘诀告诉了他:
　　1.懂得使用工具
　　2.尽早发现内存问题
　　3.深入理解代码优化
　　4.不要让自己大海捞针
　　5.重现并隔离问题
　　6.以退为进
　　7.确定测试的完整性
　　8.提高代码质量意味着节省时间
　　9.发现它，分析它，解决它
　　10.利用初学者的思维
　　这十条秘诀在业界广为流传，使很多人受益。本文围绕这十条秘诀展开论述。
　　1.懂得使用工具
　　通常嵌入式系统对可靠性的要求比较高。嵌入式系统安全性的失效可能会导致灾难性的后果，即使是非安全性系统，由于大批量生产也会导致严重的经济 损失。这就要求对嵌入式系统，包括嵌入式软件进行严格的测试、确认和验证。随着越来越多的领域使用软件和微处理器控制各种嵌入式设备，对门益复杂的嵌入式 软件进行快速有效的测试愈加显得重要。
　　就象修车需要工具一样，好的程序员应该能够熟练运用各种软件工具。不同的工具，有不同的使用范围，有不同的功能。使用这些工具，你可以看到你的 系统在干些什么，它又占用什么资源，它到底和哪些外界的东西打交道。让你郁闷好几天的问题可能通过某个工具就能轻松搞定，可惜你就是不知道。那么为什么那 么多的人总是在折腾个半死之后才想到要用测试工具呢?原因很多，主要有两个。一个是害怕，另一个是惰性。害怕是因为加入测试用具或测试模块到代码需要技巧 同时有可能引入新的错误，所以他们总喜欢寄希望于通过不断地修改重编译代码来消除bug,结果却无济于事。懒惰是因为他们习惯了使用printf之类的简 单测试手段。下面来介绍一些嵌入式常用的测试工具。
　　.源码级调试器[Source-level Debugger]
　　这种调试器一般提供单步或多步调试、断点设置、内存检测、变量查看等功能，是嵌入式调试最根本有效的调试方法。比如VxWorks TornadoII提供的gdb就属于这一种。
　　.简单实用的打印显示工具[printf]
　　printf或其它类似的打印显示工具估计是最灵活最简单的调试工具。打印代码执行过程中的各种变量可以让你知道代码执行的情况。但是， printf 对正常的代码执行干扰比较大(一般printf占用CPU比较长的时间)，需要慎重使用，最好设置打印开关来控制打印。
　　.ICE或JTAG调试器[In-circuit Emulator]
　　ICE是用来仿真CPU核心的设备，它可以在不干扰运算器的正常运行情况下，实时的检测CPU的内部工作情况。像桌面调试软件所提供的:复杂的 条件断点、先进的实时跟踪、性能分析和端口分析这些功能，它也都能提供。ICE一般都有一个比较特殊的CPU，称为外合(bond-out)CPU。这是 一种被打开了封装的CPU，并且通过特殊的连接，可以访问到CPU的内部信号，而这些信号，在CPU被封装时，是没法“看到”的。当和工作站上强大的调试 软件联合使用时，ICE就能提供你所能找到的最全面的调试功能。但ICE同样有一些缺点:昂贵;不能全速工作;同样，并不是所有的CPU都可以作为外合 CPU 的，从另一个角度说，这些外合CPU也不大可能及时的被新出的CPU所更换。JTAG(Joint Test Action Group)虽然它最初开发 出来是为了监测IC和电路连接，但是这种串行接口扩展了用途，包括对调试的支持。AD公司为Blackfin设计的Visual Dsp++就支持高速的 JTAG调试。
　　.ROM监视器[ROM Monitor]
　　ROM监控器是一小程序，驻留在嵌入系统ROM中，通过串行的或网络的连接和运行在工作站上的调试软件通信。这是一种便宜的方式，当然也是最低 端的技术。它除了要求一个通信端口和少量的内存空间外，不需要其它任何专门的硬件。并提供了如下功能:下载代码、运行控制、断点、单步步进、以及观察、修 改寄存器和内存。因为ROM监控器是操作软件的一部分，只有当你的应用程序运行时，它才会工作。如果你想检查CPU和应用程序的状态，你就必须停下应用程 序，再次进入ROM监控器。
　　.Data监视器[Data Monitor]
　　这种监视器在不停止CPU运行的情况下不仅可以显示指定变量内容，还可以收集并以图形形式显示各个变量的变化过程。
　　.OS监视器[Operating System Monitor]
　　操作系统监视器可以显示诸如任务切换、信号量收发、中断等事件。一方面，这些监视器能够为你呈现事件之间的关系和时间联系;另一方面，还可以提供对信号量优先级反转、死锁和中断延时等问题的诊断。
　　.性能分析工具[Profiler]
　　可以用来测试CPU到底耗在那里。profiler工具可以让你知道系统的瓶颈在那里、CPU的使用率以及需要优化的地方。
　　.内存测试工具[Memory Teseter]
　　可以找到内存使用的问题所在，比如内存泄露、内存碎片、内存崩溃等问题。如果发现系统出现一些不可预知的或间歇性的问题，就应该使用内存测试工具测测看。
　　.运行跟踪器[Execution Tracer]
　　可以显示CPU执行了哪些函数、谁在调用、参数是什么、何时调用等情况。这种工具主要用于测试代码逻辑，可以在大量的事件中发现异常的那些。
　　.覆盖工具[Coverage Tester]
　　主要显示CPU具体执行了那些代码，并让你知道那些代码分支没有被执行到。这样有助于提高代码质量并消除无用代码。
　　.GUI测试工具[GUI Tester]
　　很多嵌入式应用带有某种形式的图形用户界面进行交互，有些系统性能测试足根掘用户输入响应时间进行的。GUI测试工具可以作为脚本工具有开发环 境中运行测试用例，其功能包括对操作的记录和回放、抓取屏幕显示供以后分析和比较、设置和管理测试过程(Rational公司的robot和 Mercury的 Loadrunner工具是杰出的代表)。很多嵌入式设备没有GUI，但常常可以对嵌入式设备进行插装来运行GUI测试脚本，虽然这种方式可能要求对被测 代码进行更改，但是节省了功能测试和回归测试的时间。
　　.自制工具[Home-made tester]
　　在嵌入式应用中，有时候为了特定的目的，需要自行编写一些工具来达到某种测试目的。本人曾经编写的视频流录显工具在测试视频会议数据流向和变化上帮了大忙,帮公司找到了几个隐藏很深的bug。
　　2.尽早发现内存问题
　　内存问题危害很大，不容易排查，主要有三种类型:内存泄露、内存碎片和内存崩溃。对于内存问题态度必须要明确，那就是早发现早“治疗”。在软件 设计中，内存泄露的“名气”最大，主要由于不断分配的内存无法及时地被释放，久而久之，系统的内存耗尽。即使细心的编程老手有时后也会遭遇内存泄露问题。 有测试过内存泄露的朋友估计都有深刻地体验，那就是内存泄露问题一般隐藏很深，很难通过代码阅读来发现。有些内存泄露甚至可能出现在库当中。有可能这本身 是库中的bug，也有可能是因为程序员没有正确理解它们的接口说明文档造成错用。
　　在很多时候，大多数的内存泄露问题无法探测，但可能表现为随机的故障。程序员们往往会把这种现象怪罪于硬件问题。如果用户对系统稳定性不是很 高，那么重启系统问题也不大;但，如果用户对系统稳定很高，那么这种故障就有可能使用户对产品失去信心，同时也意味着你的项目是个失败的项目。由于内存泄 露危害巨大，现在已经有许多工具来解决这个问题。这些工具通过查找没有引用或重复使用的代码块、垃圾内存收集、库跟踪等技术来发现内存泄露的问题。每个工 具都有利有弊，不过总的来说，用要比不用好。总之，负责的开发人员应该去测试内存泄露的问题，做到防患于未然。
　　内存碎片比内存泄露隐藏还要深。随着内存的不断分配并释放，大块内存不断分解为小块内存，从而形成碎片，久而久之，当需要申请大块内存是，有可 能就会失败。如果系统内存够大，那么坚持的时间会长一些，但最终还是逃不出分配失败的厄运。在使用动态分配的系统中，内存碎片经常发生。目前，解决这个问 题最效的方法就是使用工具通过显示系统中内存的使用情况来发现谁是导致内存碎片的罪魁祸首，然后改进相应的部分。
　　由于动态内存管理的种种问题，在嵌入式应用中，很多公司干脆就禁用malloc/free的以绝后患。
　　内存崩溃是内存使用最严重的结果，主要原因有数组访问越界、写已经释放的内存、指针计算错误、访问堆栈地址越界等等。这种内存崩溃造成系统故障是随机的，而且很难查找，目前提供用于排查的工具也很少。
　　总之，如果要使用内存管理单元的话，必须要小心，并严格遵守它们的使用规则，比如谁分配谁释放。
　　3.深入理解代码优化
　　讲到系统稳定性，人们更多地会想到实时性和速度，因为代码效率对嵌入式系统来说太重要了。知道怎么优化代码是每个嵌入式软件开发人员必须具备的 技能。就象女孩子减肥一样，起码知道她哪个地方最需要减，才能去购买减肥药或器材来减掉它。可见，代码优化的前提是找到真正需要优化的地方，然后对症下 药，优化相应部分的代码。前面提到的profile(性能分析工具，一些功能齐全IDE都提供这种内置的工具)能够记录各种情况比如各个任务的CPU占用 率、各个任务的优先级是否分配妥当、某个数据被拷贝了多少次、访问磁盘多少次、是否调用了网络收发的程序、测试代码是否已经关闭等等。
　　但是，profile工具在分析实时系统性能方面还是有不够的地方。一方面，人们使用profile工具往往是在系统出现问题即CPU耗尽之 后，而 profile工具本身对CPU占用较大，所以profile对这种情况很可能不起作用。根据Heisenberg效应，任何测试手段或多或少都会改变系 统运行，这个对profiler同样适用!
　　总之，提高运行效率的前提是你必须要知道CPU到底干了些什么干的怎么样。
　　4.不要让自己大海捞针
　　大海捞针只是对调试的一种生动比喻。
　　经常听到组里有人对自己正在调试的代码说****!可以理解，因为代码不是他写的，他有足够的理由去**** bug百出的代码，只要他自己不 要写出这种代码，否则有一天同组的其它人可能同样会****他写的代码。为何会有大海捞针呢?肯定是有人把针掉到海里咯;那针为何会掉在海里呢?肯定是有 人不小心或草率呗。所以当你在抱怨针那么难找的时候，你是否想过是你自己草率地丢掉的。同样，当你调试个半死的时候，你是否想过你要好好反省一下当初为了 寻求捷径可能没有严格地遵守好的编码设计规范、没有检测一些假设条件或算法的正确性、没有将一些可能存在问题的代码打上记号呢?关于如何写高质量请参考林 锐的《高质量c++/c编程指南》或《关于C的0×8本“经书”》。
　　如果你确实已经把针掉在海里是，为了防止在找到之前刺到自己，你必须要做一些防范工作，比如戴上安全手套。同样，为了尽能地暴露和捕捉问题根 源，我们可以设计比较全面的错误跟踪代码。怎么来做呢?尽可能对每个函数调用失败作出处理，尽可能检测每个参数输入输出的有效性包括指针以及检测是否过多 或过少地调用某个过程。错误跟踪能够让你知道你大概把针掉在哪个位置。
　　5.重现并隔离问题
　　如果你不是把针掉在大海了，而是掉在草堆里，那要好办写。因为至少我们可以把草堆分成很多块，一块一块的找。对于模块独立的大型项目，使用隔离 方法往往是对付那些隐藏极深bug的最后方法。如果问题的出现是间歇性的,我们有必要设法去重现它并记录使其重现的整个过程以备在下一次可以利用这些条件 去重现问题。如果你确信可以使用记录的那些条件去重现问题，那么我们就可以着手去隔离问题。怎么隔离呢?我们可以用#ifdef把一些可能和问题无关的代 码关闭，把系统最小化到仍能够重现问题的地步。如果还是无法定位问题所在，那么有必要打开“工具箱”了。可以试着用ICE或数据监视器去查看某个可疑变量 的变化;可以使用跟踪工具获得函数调用的情况包括参数的传递;检查内存是否崩溃以及堆栈溢出的问题。
　　6.以退为进
　　猎人为了不使自己在森林里迷路，他常常会在树木上流下一些标记，以备自己将来有一天迷路时可以根据这些标记找到出路。对过去代码的修改进行跟踪 记录对将来出现问题之后的调试很有帮助。假如有一天，你最近一次修改的程序跑了很久之后忽然死掉了，那么你这时的第一反映就是我到底改动了些什么呢，因为 上次修改之前是好的。那么如何检测这次相对于上次的修改呢?没错，代码控制系统SCS或称版本控制系统VCS (Concurrent Version Control,CVS是VCS的演化版本)。将上个版本check in下来后和当前测试版本比较。比较的工 具可以是SCS/VCS/CVS自带的diff工具或其它功能更强的比较工具，比如BeyondCompare和ExamDiff。通过比较，记录所有改 动的代码，分析所有可能导致问题的可疑代码。
　　7.确定测试的完整性
　　你怎么知道你的测试有多全面呢?覆盖测试(coverage testing)可以回答这个问题。覆盖测试工具可以告诉你CPU到底执行了那些 代码。好的覆盖工具通常可以告诉你大概20%到40%代码没有问题，而其余的可能存在bug。覆盖工具有不同的测试级别，用户可以根据自己的需要选择某个 级别。即使你很确信你的单元测试已经很全面并且没有dead code,覆盖工具还是可以为你指出一些潜在的问题，看下面的代码:
　　if (i >= 0 && (almostAlwaysZero == 0 || (last = i)))
　　如果almostAlwaysZero为非0,那么last=i赋值语句就被跳过，这可能不是你所期望的。这种问题通过覆盖工具的条件测试功能可以轻松的被发现。
　　总之，覆盖测试对于提高代码质量很有帮助。
　　8.提高代码质量意味着节省时间
　　有研究表明软件开发的时间超过80%被用在下面几个方面:
　　.调试自己的代码(单元测试)
　　.调试自己和其他相关的代码(模块间测试)
　　.调试整个系统(系统测试)
　　更糟糕的是你可能需要花费10-200倍的时间来找一个bug,而这个bug在开始的时候可能很容易就能找到。一个小bug可能让你付出巨大的 代价，即使这个bug对整个系统的性能没有太大的影响，但很可能会影响让那些你可以看得到的部分。所以我们必须要养成良好的编码和测试手段以求更高的代码 质量，以便缩短调试的代码。
　　9.发现它，分析它，解决它
　　这世界没有万能的膏药。profile再强大也有力不从心的时候;内存监视器再好，也有无法发现的时候;覆盖工具再好用，也有不能覆盖的地方。 一些隐藏很深的问题即使用尽所有工具也有可能无法查到其根源，这时我们能做的就是通过这些问题所表现出来的外在现象或一些数据输出来发现其中的规律或异 常。一旦发现任何异常，一定要深入地理解并回溯其根源，直到解决为止。
　　10.利用初学者的思维
　　有人这样说过:“有些事情在初学者的脑子里可能有各种各样的情况，可在专家的头脑里可能就很单一”。有时候，有些简单的问题会被想的很复杂，有 些简单的系统别设计的很复杂，就是由于你的“专家思维”。当你被问题难住时，关掉电脑，出去走走，把你的问题和你的朋友甚至你的小狗说说，或许他们可以给 你意想不到的启发。
　　总结:嵌入式调试也是一门艺术。就想其它的艺术一样，如果你想取得成功，你必须具备智慧、经验并懂得使用工具。只要我们能够很好地领悟Oracle这十条秘诀，我相信我们在嵌入式测试方面就能够取得成功。









1、将一个字符串逆序
2、将一个链表逆序
3、计算一个字节里（byte）里面有多少bit被置1
4、搜索给定的字节(byte)
5、在一个字符串中找到可能的最长的子字符串
6、字符串转换为整数
7、整数转换为字符串 

威盛
1.什么是平衡二叉树？编写一个删除平衡二叉树的程序？
2.写一个程序，求有向有权图两点之间的最小权？
3.根据你的理解，写出Cstring类的构造函数和析构函数？
4.使用C语言实现对ini文件的访问，使程序可以对int，double，字符串类进行读写。
5.n×n个方格（n为任意整数），定义若两个格有公共边则称两个格相邻。现将 个格中的N个格子图黑，使每个格子都与黑格子相邻。试编程，使N最小。
1.static变量和static 函数各有什么特点？
3.描述一下嵌入式基于ROM的运行方式基于ram的运行方式有什么区别。
4.task 有几种状态？
5.task 有几种通讯方式？
6.C函数允许重入吗？
7.嵌入式操作系统和通用操作系统有什么差别？










嵌入式求职笔试面试题目汇总
人的气质与性格的不同，关系到工作效率的不同，甚至影响个人成才。在某些职业中，如飞 行员、运动员、教师等对气质和
性格提出了更严格的要求。合适的个性特征往往决定了一个人是否适宜从事该类职业。瑞士 心理家荣格首先提出内向型和外向型的人格。当前，许多人格心理学家都把内向和外向看做 是人格的重要特质或维度。实践证明，荣格的内向/外向人格测验能够比较准确地测定人员 的基本性格。本公司为加强员工性格测评的力度，决定实施该项人格测验。下面是问题举例 ：
1.能花功夫做较为麻烦的事吗? . . . . . . . . . . . . .. . . . .是?(否)
2.经常留心注意细微小事吗? . . . . . . . . . . . . . . . .. . .是?(否)
3.能立刻下决心吗? . . . . . . . . . . . . . . . . . . . .. . .是?(否)
4.遇事经常认为：与其反复思考还不如赶快行动吗? . . . . . . . . 是?(否)
5.经常下了决心以后再加以改变吗? . . . . . . . . . . . . . . . .是?(否)
6.经常在遭到失败以后就不再尝试了吗? . . . . . . . . . . . . . .是?(否)
7.常常感到心情忧郁吗? . . . . . . . . . . . . . . . . . . . . .是?(否)
8.不爱多说话吗? . . . . . . . . . . . . . . . . . . . . . . . .是?(否)
9.经常将感情流于言表吗? . . . . . . . . . . . . . . . . . . . .是?(否)
10.埋头于工作吗?. . . . . . . . . . . . . . . . . . . . . . . .是?(否)
11.喜欢空想和幻想吗?. . . . . . . . . . . . . . . . . . . . . .是?(否)
12.过于爱清洁吗?. . . . . . . . . . . . . . . . . . . . . . . .是?(否)
13.丢三落四吗? . . . . . . . . . . . . . . . . . . . . . . . .是?(否)
14.别人都不大愿意和你交往吗?. . . . . . . . . . . . . . . . . .是?(否)
15.固执吗?. . . . . . . . . . . . . . . . . . . . . . . . . . .是?(否)
16.容易受人煽动吗?. . . . . . . . . . . . . . . . . . . . . . .是?(否)

杨帅岭 20:34:42

杨帅岭 20:34:59
问题一：“请你自我介绍一下”
思路：
1、这是面试的必考题目。
2、介绍内容要与个人简历相一致。
3、表述方式上尽量口语化。
4、要切中要害，不谈无关、无用的内容。
5、条理要清晰，层次要分明。
6、事先最好以文字的形式写好背熟。 

问题二：“谈谈你的家庭情况”
思路：
1、 情况对于了解应聘者的性格、观念、心态等有一定的作用，这是招聘单位问该问题的主要原因。
2、 简单地罗列家庭人口。
3、 宜强调温馨和睦的家庭氛围。
4、 宜强调父母对自己教育的重视。
5、 宜强调各位家庭成员的良好状况。
6、 宜强调家庭成员对自己工作的支持。
7、 宜强调自己对家庭的责任感。 

问题三：“你有什么业余爱好？”
思路：
1、 业余爱好能在一定程度上反映应聘者的性格、观念、心态，这是招聘单位问该问题的主要原因。 

杨帅岭 20:35:08
这个好像 校内上有
杨帅岭 20:35:19
2、 最好不要说自己没有业余爱好。
3、 不要说自己有那些庸俗的、令人感觉不好的爱好。
4、 最好不要说自己仅限于读书、听音乐、上网，否则可能令面试官怀疑应聘者性格孤僻。
5、 最好能有一些户外的业余爱好来“点缀”你的形象。 

问题四：“你最崇拜谁？”
思路：
1、 最崇拜的人能在一定程度上反映应聘者的性格、观念、心态，这是面试官问该问题的主要原因。
2、 不宜说自己谁都不崇拜。
3、 不宜说崇拜自己。
4、 不宜说崇拜一个虚幻的、或是不知名的人。
5、 不宜说崇拜一个明显具有负面形象的人。
6、 所崇拜的人人最好与自己所应聘的工作能“搭”上关系。
7、 最好说出自己所崇拜的人的哪些品质、哪些思想感染着自己、鼓舞着自己。

问题五：“你的座右铭是什么？”
思路：
1、座右铭能在一定程度上反映应聘者的性格、观念、心态，这是面试官问这个问题的主要原因。
2、不宜说那些易引起不好联想的座右铭。
3、不宜说那些太抽象的座右铭。
4、不宜说太长的座右铭。
5、座右铭最好能反映出自己某种优秀品质。

杨帅岭 20:35:29
6、 参考答案——“只为成功找方法，不为失败找借口” 

问题六：“谈谈你的缺点”
思路：
1、 不宜说自己没缺点。
2、 不宜把那些明显的优点说成缺点。
3、 不宜说出严重影响所应聘工作的缺点。
4、 不宜说出令人不放心、不舒服的缺点。
5、 可以说出一些对于所应聘工作“无关紧要”的缺点，甚至是一些表面上看是缺点，从工作的角度看却是优点的缺点. 

问题七：“谈一谈你的一次失败经历”
思路：
1、 不宜说自己没有失败的经历。
2、 不宜把那些明显的成功说成是失败。
3、 不宜说出严重影响所应聘工作的失败经历，
4、 所谈经历的结果应是失败的。
5、 宜说明失败之前自己曾信心白倍、尽心尽力。
6、 说明仅仅是由于外在客观原因导致失败。
7、 失败后自己很快振作起来，以更加饱满的热情面对以后的工作。 

问题八：“你为什么选择我们公司？”
思路：
1、 面试官试图从中了解你求职的动机、愿望以及对此项工作的态度。 

杨帅岭 20:35:38
2、 建议从行业、企业和岗位这三个角度来回答。
3、 参考答案——“我十分看好贵公司所在的行业，我认为贵公司十分重视人才，而且这项工作很适合我，相信自己一定能做好。” 

问题九：“对这项工作，你有哪些可预见的困难？”
思路：
1、 不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。
2、 可以尝试迂回战术，说出应聘者对困难所持有的态度——“工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服的。” 

问题十：“如果我录用你，你将怎样开展工作”
思路：
1、 如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法，
2、 可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。” 

问题十一：“与上级意见不一是，你将怎么办？”
思路：
1、 一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”
2、 如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。” 

问题十二：“我们为什么要录用你？” 

杨帅岭 20:35:46
思路：
1、 应聘者最好站在招聘单位的角度来回答。
2、 招聘单位一般会录用这样的应聘者：基本符合条件、对这份工作感兴趣、有足够的信心。
3、 如“我符合贵公司的招聘条件，凭我目前掌握的技能、高度的责任感和良好的适应能力及学习能力 ，完全能胜任这份工作。我十分希望能为贵公司服务，如果贵公司给我这个机会，我一定能成为贵公司的栋梁！” 

问题十三：“你能为我们做什么？”
思路：
1、 基本原则上“投其所好”。
2、 回答这个问题前应聘者最好能“先发制人”，了解招聘单位期待这个职位所能发挥的作用。
3、 应聘者可以根据自己的了解，结合自己在专业领域的优势来回答这个问题。 

问题十四：“你是应届毕业生，缺乏经验，如何能胜任这项工作？”
思路：
1、 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘单位并不真正在乎“经验”，关键看应聘者怎样回答。
2、 对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。
3、 如“作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。” 

问题十五：“你希望与什么样的上级共事？” 

杨帅岭 20:35:54
思路：
1、 通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又上一次机会。
2、 最好回避对上级具体的希望，多谈对自己的要求。
3、 如“做为刚步入社会新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。” 

问题十六：“您在前一家公司的离职原因是什么？”
思路：
1、 最重要的是：应聘者要使招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在。
2、 避免把“离职原因”说得太详细、太具体。
3、 不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等。
4、 但也不能躲闪、回避，如“想换换环境”、“个人原因”等。
5、 不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等。
6、 尽量使解释的理由为应聘者个人形象添彩。
7、 如“我离职是因为这家公司倒闭。我在公司工作了三年多，有较深的感情。从去年始，由于市场形势突变，公司的局面急转直下。到眼下这一步我觉得很遗憾，但还要面对现实，重新寻找能发挥我能力的舞台。” 同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在于应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景












1.用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
　　
　　#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
　　我在这想看到几件事情：
　　1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
　　2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
　　3). 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
　　4). 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。
　　
　　
　　2. 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。
　　
　　
　　#define MIN(A,B) ((A) <= (B) (A) : (B))
　　这个测试是为下面的目的而设的：
　　1). 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
　　2). 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
　　3). 懂得在宏中小心地把参数用括号括起来
　　4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
　　least = MIN(*p++, b);
　　
　　3. 预处理器标识#error的目的是什么？
　　
　　如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种
　　问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。
　　
　　死循环（Infinite loops）
　　
　　4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
　　
　　这个问题用几个解决方案。我首选的方案是：
　　while(1) { }
　　一些程序员更喜欢如下方案：
　　for(;;) { }
　　这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的
　　基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。
　　第三个方案是用 goto
　　Loop:
　　...
　　goto Loop;
　　应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。
　　
　　数据声明（Data declarations）
　　
　　5. 用变量a给出下面的定义
　　a) 一个整型数（An integer）
　　b) 一个指向整型数的指针（A pointer to an integer）
　　c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）
　　d) 一个有10个整型数的数组（An array of 10 integers）
　　e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）
　　f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）
　　g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）
　　h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）
　　
　　答案是：
　　a) int a; // An integer
　　b) int *a; // A pointer to an integer
　　c) int **a; // A pointer to a pointer to an integer
　　d) int a[10]; // An array of 10 integers
　　e) int *a[10]; // An array of 10 pointers to integers
　　f) int (*a)[10]; // A pointer to an array of 10 integers
　　g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer
　　h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer
　　
　　
　　人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。
　　但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道
　　所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？
　　
　　
　　Static
　　
　　6. 关键字static的作用是什么？
　　
　　这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
　　1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
　　2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
　　3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
　　大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。
　　
　　
　　Const
　　
　　7．关键字const是什么含意？
　　我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？
　　
　　const int a;
　　int const a;
　　const int *a;
　　int * const a;
　　int const * a const;
　　
　　前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
　　1). 关键字const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
　　2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
　　3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。
　　
　　Volatile
　　
　　8. 关键字volatile有什么含意 并给出三个不同的例子。
　　
　　一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
　　1). 并行设备的硬件寄存器（如：状态寄存器）
　　2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
　　3). 多线程应用中被几个任务共享的变量
　　回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。
　　假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
　　1). 一个参数既可以是const还可以是volatile吗？解释为什么。
　　2). 一个指针可以是volatile 吗？解释为什么。
　　3). 下面的函数有什么错误：
　　int square(volatile int *ptr)
　　{
　　return *ptr * *ptr;
　　}
　　下面是答案：
　　1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
　　2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
　　3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
　　int square(volatile int *ptr)
　　{
　　int a,b;
　　a = *ptr;
　　b = *ptr;
　　return a * b;
　　}
　　由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
　　long square(volatile int *ptr)
　　{
　　int a;
　　a = *ptr;
　　return a * a;
　　}
　　
　　位操作（Bit manipulation）
　　
　　9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
　　
　　对这个问题有三种基本的反应
　　1). 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
　　2). 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式 来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
　　3). 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
　　#define BIT3 (0x1<<3)
　　static int a;
　　void set_bit3(void)
　　{
　　a |= BIT3;
　　}
　　void clear_bit3(void)
　　{
　　a &= ~BIT3;
　　}
　　一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。
　　
　　访问固定的内存位置（Accessing fixed memory locations）
　　
　　10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
　　
　　这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
　　int *ptr;
　　ptr = (int *)0x67a9;
　　*ptr = 0xaa55;
　　
　　一个较晦涩的方法是：
　　*(int * const)(0x67a9) = 0xaa55;
　　
　　即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。
　　
　　中断（Interrupts）
　　
　　11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
　　
　　__interrupt double compute_area (double radius)
　　{
　　 double area = PI * radius * radius;
　　 printf(" Area = %f", area);
　　 return area;
　　}
　　
　　这个函数有太多的错误了，以至让人不知从何说起了：
　　1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
　　2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
　　3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
　　4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。
　　
　　代码例子（Code examples）
　　12 . 下面的代码输出是什么，为什么？
　　
　　void foo(void)
　　{
　　 unsigned int a = 6;
　　 int b = -20;
　　 (a+b > 6) puts("> 6") : puts("<= 6");
　　}
　　
　　这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“>6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于 6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。
　　
　　13. 评价下面的代码片断：
　　
　　unsigned int zero = 0;
　　unsigned int compzero = 0xFFFF;
　　/*1's complement of zero */
　　
　　对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：
　　
　　unsigned int compzero = ~0;
　　
　　这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
　　到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧…
　　
　　
　　
　　动态内存分配（Dynamic memory allocation）
　　
　　
　　
　　14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
　　
　　这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？
　　
　　char *ptr;
　　if ((ptr = (char *)malloc(0)) == NULL)
　　puts("Got a null pointer");
　　else
　　puts("Got a valid pointer");
　　
　　这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是“Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。
　　
　　Typedef
　　
　　15. Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
　　#define dPS struct s *
　　typedef struct s * tPS;
　　
　　以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
　　这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：
　　dPS p1,p2;
　　tPS p3,p4;
　　
　　第一个扩展为
　　struct s * p1, p2;
　　
　　上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。
　　
　　晦涩的语法
　　
　　16. C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
　　int a = 5, b = 7, c;
　　c = a+++b;
　　
　　这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：
　　c = a++ + b;
　　因此, 这段代码持行后a = 6, b = 7, c = 12。
　　如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是:这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题
补充：
编译程序时，只要遇到 #error 就会跳出一个编译错误，既然是编译错误，要它干嘛呢？其目的就是保证程序是按照你所设想的那样进行编译的。

下面举个例子：
程序中往往有很多的预处理指令
#ifdef XXX
...
#else
#endif

当程序比较大时，往往有些宏定义是在外部指定的（如makefile），或是在系统头文件中指定的，当你不太确定当前是否定义了 XXX 时，就可以改成如下这样进行编译：

#ifdef XXX
...
#error "XXX has been defined"
#else
#endif

这样,如果编译时出现错误,输出了XXX has been defined,表明宏XXX已经被定义了












预处理器（Preprocessor）
1. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情：
1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
3). 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
4). 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。
2. 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。
#define MIN(A,B) ((A) <= (B) (A) : ))
这个测试是为下面的目的而设的：
1). 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
2). 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
3). 懂得在宏中小心地把参数用括号括起来
4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
least = MIN(*p++, b);
3. 预处理器标识#error的目的是什么？
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种
问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。
死循环（Infinite loops）
4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
这个问题用几个解决方案。我首选的方案是：
while(1) { }
一些程序员更喜欢如下方案：
for(;;) { }
这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的
基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。
第三个方案是用 goto
Loop:
...
goto Loop;
应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。
数据声明（Data declarations）
5. 用变量a给出下面的定义
a) 一个整型数（An integer）
b) 一个指向整型数的指针（A pointer to an integer）
c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）
d) 一个有10个整型数的数组（An array of 10 integers）
e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）
f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）
答案是：
a) int a; // An integer
b) int *a; // A pointer to an integer
c) int **a; // A pointer to a pointer to an integer
d) int a[10]; // An array of 10 integers
e) int *a[10]; // An array of 10 pointers to integers
f) int (*a)[10]; // A pointer to an array of 10 integers
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer
人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。
但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道
所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？
Static
6. 关键字static的作用是什么？
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。
Const
7．关键字const是什么含意？
我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.
如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？
const int a;
int const a;
const int *a;
int * const a;
int const * a const;
前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。
Volatile
8. 关键字volatile有什么含意 并给出三个不同的例子。
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。
假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
1). 一个参数既可以是const还可以是volatile吗？解释为什么。
2). 一个指针可以是volatile 吗？解释为什么。
3). 下面的函数有什么错误：
int square(volatile int *ptr)
{ return *ptr * *ptr;
} 下面是答案：
1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
int square(volatile int *ptr)
{ int a,b;
a = *ptr;
b = *ptr;
return a * b;
} 由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
long square(volatile int *ptr)
{ int a;
a = *ptr;
return a * a;
}
位操作（Bit manipulation）
9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
对这个问题有三种基本的反应
1). 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
2). 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
3). 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
#define BIT3 (0x1<<3)
static int a;
void set_bit3(void)
{ a |= BIT3;
} void clear_bit3(void)
{ a &= ~BIT3;
} 一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。
10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
int *ptr;
ptr = (int *)0x67a9;
*ptr = 0xaa55;
一个较晦涩的方法是：
*(int * const)(0x67a9) = 0xaa55;
即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。
中断（Interrupts）
11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
__interrupt double compute_area (double radius)
{ double area = PI * radius * radius;
printf(" Area = %f", area);
return area;
}
这个函数有太多的错误了，以至让人不知从何说起了：
1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。
代码例子（Code examples）
12 . 下面的代码输出是什么，为什么？
void foo(void)
{ unsigned int a = 6;
int b = -20;
(a+b > 6) puts(“> 6″) : puts(“<= 6");
}
这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“>6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。
13. 评价下面的代码片断：
unsigned int zero = 0;
unsigned int compzero = 0xFFFF;
/*1′s complement of zero */
对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：
unsigned int compzero = ~0;
这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧…
动态内存分配（Dynamic memory allocation）
14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？
char *ptr;
if ((ptr = (char *)malloc(0)) == NULL)
puts(“Got a null pointer”);
else
puts(“Got a valid pointer”);
这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是“Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。
Typedef
15. Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
#define dPS struct s *
typedef struct s * tPS;
以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：
dPS p1,p2;
tPS p3,p4;
第一个扩展为
struct s * p1, p2;
上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。
晦涩的语法
16. C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
int a = 5, b = 7, c;
c = a+++b;
这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：
c = a++ + b;
因此, 这段代码持行后a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是:这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题
What will print out?
main()
{ char *p1=“name”;
char *p2;
p2=(char*)malloc(20);
memset (p2, 0, 20);
while(*p2++ = *p1++);
printf(“%sn”,p2);
}
Answer:empty string.
What will be printed as the result of the operation below:
main()
{ int x=20,y=35;
x=y++ + x++;
y= ++y + ++x;
printf(“%d%dn”,x,y);
}
Answer : 5794
What will be printed as the result of the operation below:
main()
{ int x=5;
printf(“%d,%d,%dn”,x,x< <2,x>>2);
}
Answer: 5,20,1
What will be printed as the result of the operation below:
#define swap(a,b) a=a+b;b=a-b;a=a-b;
void main()
{ int x=5, y=10;
swap (x,y);
printf(“%d %dn”,x,y);
swap2(x,y);
printf(“%d %dn”,x,y);
}
int swap2(int a, int b)
{ int temp;
temp=a;
b=a;
a=temp;
return 0;
}
Answer: 10, 5
10, 5
What will be printed as the result of the operation below:
main()
{ char *ptr = ” Cisco Systems”;
*ptr++; printf(“%sn”,ptr);
ptr++;
printf(“%sn”,ptr);
}
Answer:Cisco Systems
isco systems
What will be printed as the result of the operation below:
main()
{ char s1[]=“Cisco”;
char s2[]= “systems”;
printf(“%s”,s1);
} Answer: Cisco
What will be printed as the result of the operation below:
main()
{ char *p1;
char *p2;
p1=(char *)malloc(25);
p2=(char *)malloc(25);
strcpy(p1,”Cisco”);
strcpy(p2,“systems”);
strcat(p1,p2);
printf(“%s”,p1);
}
Answer: Ciscosystems
The following variable is available in file1.c, who can access it?:
static int average;
Answer: all the functions in the file1.c can access the variable.
WHat will be the result of the following code?
#define TRUE 0 // some code
while(TRUE)
{
// some code
}
Answer: This will not go into the loop as TRUE is defined as 0.
What will be printed as the result of the operation below:
int x;
int modifyvalue()
{ return(x+=10);
} int changevalue(int x)
{ return(x+=1);
}
void main()
{ int x=10;
x++;
changevalue(x);
x++;
modifyvalue();
printf(“First output:%dn”,x);
x++;
changevalue(x);
printf(“Second output:%dn”,x);
modifyvalue();
printf(“Third output:%dn”,x);
}
Answer: 12 , 13 , 13
What will be printed as the result of the operation below:
main()
{ int x=10, y=15;
x = x++;
y = ++y;
printf(“%d %dn”,x,y);
}
Answer: 11, 16
What will be printed as the result of the operation below:
main()
{ int a=0;
if(a==0)
printf(“Cisco Systemsn”);
printf(“Cisco Systemsn”);
}
Answer: Two lines with “Cisco Systems” will be printed.
再次更新C++相关题集
1. 以下三条输出语句分别输出什么？[C易]
char str1[] = “abc”;
char str2[] = “abc”;
const char str3[] = “abc”;
const char str4[] = “abc”;
const char* str5 = “abc”;
const char* str6 = “abc”;
cout << boolalpha << ( str1==str2 ) << endl; // 输出什么？
cout << boolalpha << ( str3==str4 ) << endl; // 输出什么？
cout << boolalpha << ( str5==str6 ) << endl; // 输出什么？
13. 非C++内建型别 A 和 B，在哪几种情况下B能隐式转化为A？[C++中等]
答：
a. class B : public A { ……} // B公有继承自A，可以是间接继承的
b. class B { operator A( ); } // B实现了隐式转化为A的转化
c. class A { A( const B& ); } // A实现了non-explicit的参数为B（可以有其他带默认值的参数）构造函数
d. A& operator= ( const A& ); // 赋值操作，虽不是正宗的隐式类型转换，但也可以勉强算一个
12. 以下代码中的两个sizeof用法有问题吗？[C易]
void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母
{ for( size_t i=0; i if( 'a'<=str[i] && str[i]<='z' )
str[i] -= ('a'-'A' );
} char str[] = "aBcDe";
cout << "str字符长度为: " << sizeof(str)/sizeof(str[0]) << endl;
UpperCase( str );
cout << str << endl;
7. 以下代码有什么问题？[C难]
void char2Hex( char c ) // 将字符以16进制表示
{ char ch = c/0x10 + '0'; if( ch > ’9′ ) ch += (‘A’-’9′-1);
char cl = c%0×10 + ’0′; if( cl > ’9′ ) cl += (‘A’-’9′-1);
cout << ch << cl << ' ';
} char str[] = "I love 中国";
for( size_t i=0; i char2Hex( str[i] );
cout << endl;
4. 以下代码有什么问题？[C++易]
struct Test
{ Test( int ) {}
Test() {}
void fun() {}
};
void main( void )
{ Test a(1);
a.fun();
Test b();
b.fun();
}
5. 以下代码有什么问题？[C++易]
cout << (true?1:"1") << endl;
8. 以下代码能够编译通过吗，为什么？[C++易]
unsigned int const size1 = 2;
char str1[ size1 ];
unsigned int temp = 0;
cin >> temp;
unsigned int const size2 = temp;
char str2[ size2 ];
9. 以下代码中的输出语句输出0吗，为什么？[C++易]
struct CLS
{ int m_i;
CLS( int i ) : m_i(i) {}
CLS()
{ CLS(0);
} };
CLS obj;
cout << obj.m_i << endl;
10. C++中的空类，默认产生哪些类成员函数？[C++易]
答：
class Empty
{ public:
Empty(); // 缺省构造函数
Empty( const Empty& ); // 拷贝构造函数
~Empty(); // 析构函数
Empty& operator=( const Empty& ); // 赋值运算符
Empty* operator&(); // 取址运算符
const Empty* operator&() const; // 取址运算符 const
};
3. 以下两条输出语句分别输出什么？[C++难]
float a = 1.0f;
cout << (int)a << endl;
cout << (int&)a << endl;
cout << boolalpha << ( (int)a == (int&)a ) << endl; // 输出什么？
float b = 0.0f;
cout << (int)b << endl;
cout << (int&)b << endl;
cout << boolalpha << ( (int)b == (int&)b ) << endl; // 输出什么？
2. 以下反向遍历array数组的方法有什么错误？[STL易]
vector array;
array.push_back( 1 );
array.push_back( 2 );
array.push_back( 3 );
for( vector::size_type i=array.size()-1; i>=0; –i ) // 反向遍历array数组
{ cout << array[i] << endl;
}
6. 以下代码有什么问题？[STL易]
typedef vector IntArray;
IntArray array;
array.push_back( 1 );
array.push_back( 2 );
array.push_back( 2 );
array.push_back( 3 );
// 删除array数组中所有的2
for( IntArray::iterator itor=array.begin(); itor!=array.end(); ++itor )
{ if( 2 == *itor ) array.erase( itor );
}
11. 写一个函数，完成内存之间的拷贝。[考虑问题是否全面]
答：
void* mymemcpy( void *dest, const void *src, size_t count )
{
char* pdest = static_cast( dest );
const char* psrc = static_cast( src );
if( pdest>psrc && pdest {
for( size_t i=count-1; i!=-1; –i )
pdest[i] = psrc[i];
}
else
{
for( size_t i=0; i pdest[i] = psrc[i];
}
return dest;
}
int main( void )
{
char str[] = “0123456789″;
mymemcpy( str+1, str+0, 9 );
cout << str << endl; 

system( “Pause” );
return 0;
}












一.选择题（共15题，每题3分）
（1）下面关于算法说法错误的是_______。
a. 算法最终必须由计算机程序实现
b. 为解决某问题的算法同为该问题编写的程序含义是相同的
c. 算法的可行性是指指令不能有二义性
d. 以上几个都是错误的
（2）下面说法错误的是______.
a. 算法原地工作的含义是指不需要任何额外的辅助空间
b. 在相同的规模n下，复杂度O(n)的算法在时间上总是优于复杂度O(2n)的算法
c. 所谓时间复杂度是指最坏情况下，估算算法执行时间的一个上界
d. 同一个算法，实现语言的级别越高，执行效率就越低
（3）在下面的程序段中，对x的赋值语句的频度为_____。
for (int i; i<n; i++)
{ for (int j=o; j<n; j++)
{ x:=x+1;
} }
a. 0(2n)            b. 0(n)        c. 0(n2)     d. O(log2n)
（4）下面说法正确的是______。
a. 数据元素是数据的最小单位；
b. 数据元素是数据的最小单位；
c. 数据的物理结构是指数据在计算机内的实际存储形式
d. 数据结构的抽象操作的定义与具体实现有关
（5）下面说法正确的是_______。
a. 在顺序存储结构中，有时也存储数据结构中元素之间的关系
b. 顺序存储方式的优点是存储密度大，且插入、删除运算效率高
c. 数据结构的基本操作的设置的最重要的准则是，实现应用程序与存储结构的独立
d. 数据的逻辑结构说明数据元素之间的顺序关系,它依赖于计算机的储存结构
（6） 下述_____是顺序存储结构的优点。
a. 存储密度大
b. 插入运算方便
c. 删除运算方便
d. 可方便地用于各种逻辑结构的存储表示
（7）下面关于线性表的叙述中，错误的是_____。
a. 线性表采用顺序存储，必须占用一片连续的存储单元
b. 线性表采用顺序存储，便于进行插入和删除操作
c. 线性表采用链接存储，不必占用一片连续的存储单元
d. 线性表采用链接存储，便于插入和删除操作
（8） 某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用_______存储方式最节省时间。
a. 顺序表      b. 双链表        c. 带头结点的双循环链表     d. 单循环链表
（9）静态链表中指针表示的是______。
a. 内存地址     b. 数组下标     c. 下一元素地址     d. 左、右孩子地址
（10）下面的叙述不正确的是_______。
a. 线性表在链式存储时，查找第i个元素的时间同i的值成正比
b. 线性表在链式存储时，查找第i个元素的时间同i的值无关
c. 线性表在顺序存储时，查找第i个元素的时间同i 的值成正比
d. 线性表在顺序存储时，查找第i个元素的时间同i的值无关
（11）下面说法错误的是_____。
a. 静态链表既有顺序存储的优点，又有动态链表的优点。所以，它存取表中第i个元素的时间与i无关。
b. 静态链表中能容纳的元素个数的最大数在表定义时就确定了，以后不能增加。
c. 静态链表与动态链表在元素的插入、删除上类似，不需做元素的移动。
d. 静态链表就是一直不发生变化的链表。
（12）在双向链表指针p的结点前插入一个指针q的结点操作是______。
a. p->Llink=q; q->Rlink=p; p->Llink->Rlink=q; q->Llink=q；
b. p->Llink=q; p->Llink->Rlink=q; q->Rlink=p; q->Llink=p->Llink;
c. q->Rlink=p; q->Llink=p->Llink; p->Llink->Rlink=q; p->Llink=q;
d. q->Llink=p->Llink; q->Rlink=q; p->Llink=q; p->Llink=q;
（13）下面说法正确的是______。
a. 顺序存储结构的主要缺点是不利于插入或删除操作；
b. 线性表采用链表存储时，结点和结点内部的存储空间可以是不连续的；
c. 顺序存储方式插入和删除时效率太低，因此它不如链式存储方式好；
d. 顺序存储方式只能用于存储线性结构。
（14）下面说法正确的是______。
a. 线性表只能用顺序存储结构实现。
b. 为了很方便的插入和删除数据，可以使用双向链表存放数据。
c. 顺序存储方式的优点是存储密度大，且插入、删除运算效率高。
d. 链表是采用链式存储结构的线性表,进行插入、删除操作时，在链表中比在顺序存储结构中效率高。
（15）下面说法正确的是_________。
a. 数据元素是数据的最小单位。
b. 队列逻辑上是一个下端口和上端能增加又能减少的线性表。
c. 任何一个递归过程都可以转换成非递归过程。
d. 只有那种使用了局部变量的递归过程在转换成非递归过程时才必须使用栈。

二.  填空题(共5题，每题5分)
（1）    下列程序的功能是创建单向链表，请补充完整。
#include <stdio.h>
#include <alloc.h>
struct link
{ char  name[10];
int    mark;
struct link  * next;
};
void insert(char * name,  int mark);
struct link * head = NULL;
main()
{ char  name[10];
int    mark;
struct  link *t;
while (1)
{  scanf(“%s %d”,  name,  &mark);
if (strcmp(name, “#”) == 0 )
{ break; }
______(1)_______;
}
for (t=head; ______(2)_______)
{
printf(“<%s>: %d\n”,  t->name,  t->mark);
}
}
void insert(char * name,  int mark)
{
struct link * p;
p = ______(3)_______ ;
strcpy(p->name,  name);
p->mark = mark;
______(4)_______;
if ( head != NULL )
{
______(5)_______;
}
head = p;
}
（2）    用循环链表表示的队列长度为n， 若只设头指针,则出队和入队的时间复杂度分别是______和_____； 若只设尾指针,则出队和入队的时间复杂度分别是_____和_____。
（3）    在n个记录的有序顺序表中进行折半查找,最大的比较次数是______。
（4）    仔细阅读下列程序，在空白处填入适当的语句。
函数match(s,t)完成在字符串s中寻找与t匹配的字符，若存在一个匹配，则返回t在字符串s中的下标；否则，返回-1。其中，字符指针*b始终指向s的第一元素。
Match(s,t)
Char s,t;
｛ char *b=s;
char *p, *r;
for _________________________________
｛
for (p=s, r=t; *r!=`\0` && *p= =*r; p++, r++);
if__________________________________
return(s-b);
｝
return(-1);
｝
（5）    补充下列程序：设一棵二叉序列树b，下列算法函数是实现在b中插入一个结点s。
函数：
void insert（btree *b，btree *s）
{ if（b == NULL） b = s；
else
if（s->data == b->data） return();
else
if(s->data < b->data)
；
else
；  }
三.简答题（共3题，每题10分）
（1）    在一个包含 n 个元素的数组 M 中查找一个元素 x。 算法假设 M 已经按升序排列了，请写出二分搜索算法的步骤。

（2）    试将一个无序的线性表A=(11,16,8,5,14,10,38,23)转换成一个按升序排列的有序线性表（用链表实现）。

（3）    何为栈和队列？简述两者的区别和联系。









一. 选择题（共15题，每题3分。）
（1）设有以下语句:
char a=3, b=6, c;
c = a^b<<2;
则c的二进制值是_____。
a. 00011011
b. 00010100
c. 00011100
d. 00011000

（2）表达式0×13&0×17的值是___。
a. 0×17
b. 0×13
c. 0xf8
d. 0xec

（3）表达式0xl3|0xl7的值是____。
a. 0×13
b. 0×17
c. 0xE8
d. 0xc8

（4） 以下叙述中正确的是_____。
a. 表达式a&＝b等价于a＝a&b
b. 表达式a|＝b等价于a＝a|b
c. 表达式a!＝b等价于a＝a!b
d. 表达式a^＝b等价于a＝a^b

（5） 运作对象必须是整型数的运算符是_____。
a. %    b. .    c. /    d. **

（6） 根据以下定义，错误的表达式是_____。
struct
{
int a;
char b;
} Q, *p = &Q;

a. Q.a
b. (*p).b
c. p->a
d. *p.b

（7） 若x是单精度实型变量，表达式 x = 10/4 的值是_____ 。
a. 2.5         b. 2.0        c. 3         d. 2

（8） 表达式 !x 等价于_____。
a. x == 0        b. x == 1       c. x != 0     d. x != 1

（9） ______是合法的用户自定义标识符。
a. b-b        b. float         c. <fr>          d. _isw

（10） 若变量已正确定义并赋值，表达式______不符合C语言语法。
a. a*b/c;     b. 3.14%2       c. 2, b         d. a/b/c

（11） _____是不正确的字符常量。
a. ‘\n’        b. ’1′           c. “a”          d. ‘\101′

（12） 在 C 程序中，用_____表示逻辑值”真”。
a. 1           b. 非 0 的数      c. 非 1 的数     d. 大于 0 的数

（13） ______把x、y定义成float类型变量，并赋同一初值3.14。
a. float x, y=3.14;              b. float x, y=2*3.14;
c. float x=3.14, y=x=3.14;     d. float x=y=3.14;

（14） 假设变量已正确定义，表达式______的值不是2。
a. 2&3       b. 1<<1         c. a==2         d. 1^3

（15） 若变量已正确定义，语句if(a>b) k=0; else k=1;和______等价。
a. k=(a>b)?1:0;              b. k=a>b;
c. k=a<=b;                    d. a<=b ? 0 : 1;

二．填空题（每题5分）。

（1） &运算符作为单目运算符时表示的是____运算；作为双目运算符时表示的是_____运算。
（2） 请计算sizeof的值：
char str[] = “Hello” ;
char *p = str ;
int n = 10;
请计算
sizeof (str ) = ____
sizeof ( p ) = _____
sizeof ( n ) = ______

（3） 请计算sizeof的值：
void Func ( char str[100])
{
// 请计算
sizeof( str ) = _____
}

（4） 请计算sizeof的值：
void *p = malloc( 100 );
// 请计算
sizeof ( p ) = ______

（5） 下列程序段的输出是_______。
#define f(a, b, x)  a*x+b
printf(“%d, %d\n”, f(3,2,1), f(6, 5, f(3, 2, 1)));

（6） 下列程序段的输出是_____。
main()
{
int k;
for(k=1; k<5; k++)
{
if(k % 2)  printf(“*”);
else continue;
printf(“#”);
}}

三.简单题（共3题，每题10分）

（1） 指出下面程序的错误并改正：
void main(void)
{int a,b;
a = 1;
b = a/++a;
printf(“b equals %d\n”, b);}

（2） int a=391,b=1971; 写出 a^b^a的值。

（3） 语句：x++;?++x; x=x+1;?x=l+x; ，执行后都使变量x中的值增1，请写出一条同一功能的赋值语句。










预处理器（Preprocessor）

1. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）

#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL

我在这想看到几件事情：

1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）

2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。

3). 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。

4). 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。

2. 写一个”标准”宏MIN，这个宏输入两个参数并返回较小的一个。

#define MIN(A,B) ((A) <= (B) (A) : (B))

这个测试是为下面的目的而设的：

1). 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。

2). 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。

3). 懂得在宏中小心地把参数用括号括起来

4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？

least = MIN(*p++, b);

3. 预处理器标识#error的目的是什么？

如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种

问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。

死循环（Infinite loops）

4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？

这个问题用几个解决方案。我首选的方案是：

while(1) { }

一些程序员更喜欢如下方案：

for(;;) { }

这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的

基本原理。如果他们的基本答案是：”我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。

第三个方案是用 goto

Loop:

…

goto Loop;

应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。

数据声明（Data declarations）

5. 用变量a给出下面的定义

a) 一个整型数（An integer）

b) 一个指向整型数的指针（A pointer to an integer）

c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）

d) 一个有10个整型数的数组（An array of 10 integers）

e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）

f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）

g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）

h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）

答案是：

a) int a; // An integer

b) int *a; // A pointer to an integer

c) int **a; // A pointer to a pointer to an integer

d) int a[10]; // An array of 10 integers

e) int *a[10]; // An array of 10 pointers to integers

f) int (*a)[10]; // A pointer to an array of 10 integers

g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer

h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer

6. 关键字static的作用是什么？

这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：

1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。

2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。

3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。

大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。

7．关键字const是什么含意？

我只要一听到被面试者说：”const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着”只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？

const int a;

int const a;

const int *a;

int * const a;

int const * a const;

前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：

1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）

2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。

3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。

8. 关键字volatile有什么含意 并给出三个不同的例子。

一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：

1). 并行设备的硬件寄存器（如：状态寄存器）

2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)

3). 多线程应用中被几个任务共享的变量

回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。

假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。

1). 一个参数既可以是const还可以是volatile吗？解释为什么。

2). 一个指针可以是volatile 吗？解释为什么。

3). 下面的函数有什么错误：

int square(volatile int *ptr)

{

return *ptr * *ptr;

}

下面是答案：

1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。

3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：

int square(volatile int *ptr)

{

int a,b;

a = *ptr;

b = *ptr;

return a * b;

}

由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：

long square(volatile int *ptr)

{

int a;

a = *ptr;

return a * a;

}

位操作（Bit manipulation）

9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。

对这个问题有三种基本的反应

1). 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。

2). 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。

3). 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：

#define BIT3 (0×1<<3)

static int a;

void set_bit3(void)

{

a |= BIT3;

}

void clear_bit3(void)

{

a &= ~BIT3;

}

一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。

访问固定的内存位置（Accessing fixed memory locations）

10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。

这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：

int *ptr;

ptr = (int *)0x67a9;

*ptr = 0xaa55;

一个较晦涩的方法是：

*(int * const)(0x67a9) = 0xaa55;

即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。

中断（Interrupts）

11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字__interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。

__interrupt double compute_area (double radius)

{

double area = PI * radius * radius;

printf(” Area = %f”, area);

return area;

}

这个函数有太多的错误了，以至让人不知从何说起了：

1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。

2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。

3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。

4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。

代码例子（Code examples）

12 . 下面的代码输出是什么，为什么？

void foo(void)

{

unsigned int a = 6;

int b = -20;

(a+b > 6) puts(“> 6″) : puts(“<= 6″);

}

这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是”>6″。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。 因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。

13. 评价下面的代码片断：

unsigned int zero = 0;

unsigned int compzero = 0xFFFF;

/*1′s complement of zero */

对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：

unsigned int compzero = ~0;

这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。

到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧…

动态内存分配（Dynamic memory allocation）

14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？

这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？

char *ptr;

if ((ptr = (char *)malloc(0)) == NULL)

puts(“Got a null pointer”);

else

puts(“Got a valid pointer”);

这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是”Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。

Typedef

15. Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：

#define dPS struct s *

typedef struct s * tPS;

以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？

这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：

dPS p1,p2;

tPS p3,p4;

第一个扩展为

struct s * p1, p2;

上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。

16. C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？

int a = 5, b = 7, c;

c = a+++b;

这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：

c = a++ + b;

因此, 这段代码持行后a = 6, b = 7, c = 12。

什么是预编译

何时需要预编译：

１、总是使用不经常改动的大型代码体。

２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。

char * const p;

char const * p

const char *p

上述三个有什么区别？

char * const p; //常量指针，p的值不可以修改

char const * p；//指向常量的指针，指向的常量值不可以改

const char *p； //和char const *p

char str1[] = “abc”;

char str2[] = “abc”;

const char str3[] = “abc”;

const char str4[] = “abc”;

const char *str5 = “abc”;

const char *str6 = “abc”;

char *str7 = “abc”;

char *str8 = “abc”;

cout << ( str1 == str2 ) << endl;

cout << ( str3 == str4 ) << endl;

cout << ( str5 == str6 ) << endl;

cout << ( str7 == str8 ) << endl;

结果是：0 0 1 1

解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；

而str5,str6,str7,str8是指针，它们指向相同的常量区域。

3. 以下代码中的两个sizeof用法有问题吗？

void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母

{

for( size_t i=0; iif( ‘a’<=str[i] && str[i]<=’z’ )

str[i] -= (‘a’-'A’ );

}

char str[] = “aBcDe”;

cout << “str字符长度为: ” << sizeof(str)/sizeof(str[0]) << endl;

UpperCase( str );

cout << str << endl;

答：函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。

一个32位的机器,该机器的指针是多少位

指针是多少位只要看地址总线的位数就行了。80386以后的机子都是32的数据总线。所以指针的位数就是4个字节了。

main()

{

int a[5]={1,2,3,4,5};

int *ptr=(int *)(&a+1);

printf(“%d,%d”,*(a+1),*(ptr-1));

}

输出：2,5

*(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5

&a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）

int *ptr=(int *)(&a+1);

则ptr实际是&(a[5]),也就是a+5

原因如下：

&a是数组指针，其类型为 int (*)[5];

而指针加1要根据指针类型加上一定的值，

不同类型的指针+1之后增加的大小不同

a是长度为5的int数组指针，所以要加 5*sizeof(int)

所以ptr实际是a[5]

但是prt与(&a+1)类型是不一样的(这点很重要)

所以prt-1只会减去sizeof(int*)

a,&a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5].

1.请问以下代码有什么问题：

int main()

{

char a;

char *str=&a;

strcpy(str,”hello”);

printf(str);

return 0;

}

没有为str分配内存空间，将会发生异常

问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。

char* s=”AAA”;

printf(“%s”,s);

s[0]=’B';

printf(“%s”,s);

有什么错？

“AAA”是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。

cosnt char* s=”AAA”;

然后又因为是常量，所以对是s[0]的赋值操作是不合法的。

1、写一个“标准”宏，这个宏输入两个参数并返回较小的一个。

.#define Min(X, Y) ((X)>(Y)?(Y):(X))//结尾没有;

2、嵌入式系统中经常要用到无限循环，你怎么用C编写死循环。

while(1){}或者for(;;)

3、关键字static的作用是什么？

定义静态变量

4、关键字const有什么含意？

表示常量不可以修改的变量。

5、关键字volatile有什么含意？并举出三个不同的例子？

提示编译器对象的值可能在编译器未监测到的情况下改变。

int (*s[10])(int) 表示的是什么啊

int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。

1.有以下表达式：

int a=248; b=4;int const c=21;const int *d=&a;

int *const e=&b;int const *f const =&a;

请问下列表达式哪些会被编译器禁止？为什么？

*c=32;d=&b;*d=43;e=34;e=&a;f=0x321f;

*c 这是个什么东东，禁止

*d 说了是const， 禁止

e = &a 说了是const 禁止

const *f const =&a; 禁止

2.交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3;

有两种解法, 一种用算术算法, 一种用^(异或)

a = a + b;

b = a – b;

a = a – b;

or

a = a^b;// 只能对int,char..

b = a^b;

a = a^b;

or

a ^= b ^= a;

3.c和c++中的struct有什么不同？

c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private

4.#include

#include

void getmemory(char *p)

{

p=(char *) malloc(100);

strcpy(p,”hello world”);

}

int main( )

{

char *str=NULL;

getmemory(str);

printf(“%s/n”,str);

free(str);

return 0;

}

程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险

5.char szstr[10];

strcpy(szstr,”0123456789″);

产生什么结果？为什么？

长度不一样，会造成非法的OS

6.列举几种进程的同步机制，并比较其优缺点。

原子操作

信号量机制

自旋锁

管程，会合，分布式系统

7.进程之间通信的途径

共享存储系统

消息传递系统

管道：以文件系统为基础

8.类的静态成员和非静态成员有何区别？

类的静态成员每个类只有一个，非静态成员每个对象一个

9.纯虚函数如何定义？使用时应注意什么？

virtual void f()=0;

是接口，子类必须要实现

10.数组和链表的区别

数组：数据顺序存储，固定大小

连表：数据可以随机存储，大小可动态改变

11.进程死锁的原因

资源竞争及进程推进顺序非法

12.死锁的4个必要条件

互斥、请求保持、不可剥夺、环路

13.死锁的处理

鸵鸟策略、预防策略、避免策略、检测与解除死锁

14. 操作系统中进程调度策略有哪几种？

FCFS(先来先服务)，优先级，时间片轮转，多级反馈

15.ISO的七层模型是什么？tcp/udp是属于哪一层？tcp/udp有何优缺点？

应用层

表示层

会话层

运输层

网络层

物理链路层

物理层

tcp /udp属于运输层

TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。

与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。

tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好

udp: 不提供稳定的服务，包头小，开销小

1) 下面的测试题中，认为所有必须的头文件都已经正确的包含了
2)数据类型
char 一个字节 1 byte
int 两个字节 2 byte (16位系统，认为整型是2个字节)
long int 四个字节 4 byte
float   四个字节4 byet
double 八个字节 8 byte
long double 十个字节 10 byte
pointer 两个字节 2 byte(注意，16位系统,地址总线只有16位)
第1题: 考查对volatile关键字的认识
#include<setjmp.h>static jmp_buf   buf;main()     {   volatile   int b;   b =3;   if(setjmp(buf)!=0)     {     printf(“%d “, b);       exit(0);   }   b=5;   longjmp(buf , 1);}
请问，这段程序的输出是
(a) 3
(b) 5
(c) 0
(d) 以上均不是
第2题:考查类型转换
main(){    struct node     {      int a;      int b;      int c;         };    struct node   s= { 3, 5,6 };    struct node *pt = &s;    printf(“%d” ,   *(int*)pt);}
这段程序的输出是:
(a) 3
(b) 5
(c) 6
(d) 7
第3题:考查递归调用
int   foo ( int x , int   n) {   int val;   val =1;     if (n>0)    {     if (n%2 == 1)   val = val *x;         val = val * foo(x*x , n/2);   }   return val;}
这段代码对x和n完成什么样的功能(操作)?
(a) xn
(b) x*n
(c) nx
(d) 以上均不是
第4题:考查指针
main() {   int   a[5] = {1,2,3,4,5};   int *ptr =   (int*)(&a+1);   printf(“%d %d” , *(a+1), *(ptr-1) );}
这段程序的输出是:
(a) 2 2
(b) 2 1
(c) 2 5
(d) 以上均不是
第5题:考查多维数组与指针
void foo(int [][3] );      main(){   int a [3][3]= { { 1,2,3} , { 4,5,6},{7,8,9}};   foo(a);   printf(“%d” , a[2][1]);}void foo( int b[][3])    {   ++ b;   b[1][1] =9;}
这段程序的输出是:
(a) 8
(b) 9
(c) 7
(d)以上均不对

第6题目:考查逗号表达式
main(){   int a, b,c, d;   a=3;   b=5;   c=a,b;   d=(a,b);   printf(“c=%d” ,c);   printf(“d=%d” ,d);}
这段程序的输出是:
(a) c=3 d=3
(b) c=5 d=3
(c) c=3 d=5
(d) c=5 d=5
第7题:考查指针数组
main(){   int a[][3] = { 1,2,3 ,4,5,6};   int (*ptr)[3] =a;   printf(“%d %d “   ,(*ptr)[1], (*ptr)[2] );   ++ptr;   printf(“%d %d”   ,(*ptr)[1], (*ptr)[2] );}
这段程序的输出是:
(a) 2 3 5 6
(b) 2 3 4 5
(c) 4 5 0 0
(d) 以上均不对
第8题:考查函数指针
int *f1(void){   int x =10;   return(&x);}int *f2(void){   int*ptr;   *ptr =10;   return ptr;}int *f3(void){   int *ptr;   ptr=(int*) malloc(sizeof(int));   return ptr;}
上面这3个函数哪一个最可能引起指针方面的问题
(a) 只有 f3
(b) 只有f1 and f3
(c) 只有f1 and f2
(d) f1 , f2 ,f3
第9题:考查自加操作(++)
main(){   int i=3;   int j;   j = sizeof(++i+ ++i);   printf(“i=%d j=%d”, i ,j);}
这段程序的输出是:
(a) i=4 j=2
(b) i=3 j=2
(c) i=3 j=4
(d) i=3 j=6
第10题:考查形式参数，实际参数，指针和数组
void f1(int *, int); void f2(int *, int); void(*p[2]) ( int *, int);main(){   int a;   int b;   p[0] = f1;   p[1] = f2;   a=3;   b=5;   p[0](&a , b);   printf(“%d\t %d\t” , a ,b);   p[1](&a , b);   printf(“%d\t %d\t” , a ,b);}void f1( int* p , int q){   int tmp;   tmp =*p;   *p = q;   q= tmp;}void f2( int* p , int q){   int tmp;   tmp =*p;   *p = q;   q= tmp;}
这段程序的输出是:
(a) 5 5 5 5
(b) 3 5 3 5
(c) 5 3 5 3
(d) 3 3 3 3
第11题:考查自减操作(–)
void e(int );    main(){   int a;   a=3;   e(a);}void e(int n){   if(n>0)   {     e(–n);     printf(“%d” , n);     e(–n);   }}
这段程序的输出是:
(a) 0 1 2 0
(b) 0 1 2 1
(c) 1 2 0 1
(d) 0 2 1 1
第12题:考查typedef类型定义,函数指针
typedef int (*test) ( float * , float*)test tmp;
tmp 的类型是
(a) 函数的指针，该函数以 两个指向浮点数(float)的指针(pointer)作为参数(arguments)
Pointer to function of having two arguments that is pointer to float
(b) 整型
(c) 函数的指针，该函数以 两个指向浮点数(float)的指针(pointer)作为参数(arguments),并且函数的返回值类型是整型
Pointer to function having two argument that is pointer to float and return int
(d) 以上都不是

第13题:数组与指针的区别与联系
main(){   char *p;   char buf[10] ={ 1,2,3,4,5,6,9,8};   p = (buf+1)[5];   printf(“%d” , p);}
这段程序的输出是:
(a) 5
(b) 6
(c) 9
(d) 以上都不对
第14题:
Void f(char**);main(){   char * argv[] = { “ab” ,”cd” , “ef” ,”gh”, “ij” ,”kl” };   f( argv );}void f( char **p ){   char* t;   t= (p+= sizeof(int))[-1];   printf( “%s” , t);}
这段程序的输出是:
(a) ab
(b) cd
(c) ef
(d) gh
第15题:
#include<stdarg.h>int ripple ( int , …);main(){   int num;   num = ripple ( 3, 5,7);   printf( ” %d” , num);}int ripple (int n, …){   int i , j;   int k;     va_list p;   k= 0;   j = 1;   va_start( p , n);        for (; j<n;   ++j)    {     i =   va_arg( p , int);     for (; i;     i &=i-1   )       ++k;   }   return k;}
这段程序的输出是:
(a) 7
(b) 6
(c) 5
(d) 3
第16题:
int counter (int i){   static int count =0;   count = count +i;   return (count );}main(){   int i , j;   for (i=0; i <=5; i++)     j = counter(i);}
The value of j at the end of the execution of the this program is:
(a) 10
(b) 15
(c) 6
(d) 7

详细参考答案
第1题:    (b)
volatile字面意思是易于挥发的。这个关键字来描述一个变量时，意味着 给该变量赋值(写入)之后，马上再读取，写入的值与读取的值可能不一样,所以说它”容易挥发”的。
这是因为这个变量可能一个寄存器，直接与外部设备相连，你写入之后，该寄存器也有可能被外部设备的写操作所改变;或者，该变量被一个中断程序，或另一个进程
改变了.
volatile variable isn’t affected by the optimization. Its value after the longjump is the last value variable assumed.
b last value is 5 hence 5 is printed.
setjmp : Sets up for nonlocal goto /* setjmp.h*/
Stores context information such as register values so that the lomgjmp function can return control to the statement following the one calling setjmp.Returns 0 when it is initially called.
Lonjjmp: longjmp Performs nonlocal goto /* setjmp.h*/
Transfers control to the statement where the call to setjmp (which initialized buf) was made. Execution continues at this point as if longjmp cannot return the value 0.A nonvolatile automatic variable might be changed by a call to longjmp.When you use setjmp and longjmp, the only automatic variables guaranteed to remain valid are those declared volatile.
Note: Test program without volatile qualifier (result may very)

第2题:    (a)
The members of structures have address in increasing order of their declaration. If a pointer to a structure is cast to the type of a pointer to its first member, the result refers to the first member.
第3题:   (a)
Non recursive version of the program
int   what ( int x ,int n){   int val;  int product;  product =1;val =x;   while(n>0)

{   if (n%2 == 1)  product = product*val;   n = n/2;   val = val* val;   }}
/* Code raise a number (x) to a large power (n) using binary doubling strategy */
Algorithm description
(while n>0)   {   if   next most significant binary digit of   n( power)   is one   then multiply accumulated product by current val   ,    reduce n(power)   sequence by a factor of two using integer division .   get next val by multiply current value of itself                    }

第4题:   (c)
type of a is array of int
type of &a is pointer to array of int
Taking a pointer to the element one beyond the end of an array is sure to work.
第5题:   (b)

第6题:   (c)
The comma separates the elements of a function argument list. The comma is also used as an operator in comma expressions. Mixing the two uses of comma is legal, but you must use parentheses to distinguish them. the left operand E1 is evaluated as a void expression, then E2 is evaluated to give the result and type of the comma expression. By recursion, the expression
E1, E2, …, En
results in the left-to-right evaluation of each Ei, with the value and type of En giving the result of the whole expression.
c=a,b;   / *yields c=a* /d=(a,b); /* d =b   */

第7题:   (a)
/* ptr is pointer to array of 3 int */

第8题:   (c)
f1 and f2 return address of local variable ,when function exit local variable disappeared
第9题:   (b)
sizeof operator gives the number of bytes required to store an object of the type of its operand . The operands is either an expression, which is not evaluated ( (++i + ++ i ) is not evaluated so i remain 3 and j is sizeof int that is 2) or a parenthesized type name.
第10题:   (a)
void(*p[2]) ( int *, int);
define array of pointer to function accept two argument that is pointer to int and return int. p[0] = f1; p[1] = f2 contain address of function .function name without parenthesis represent address of function Value and address of variable is passed to function only argument that is effected is a (address is passed). Because of call by value f1, f2 can not effect b
第11题:   (a)
第12题:   (c)
C provide a facility called typedef for creating new data type names, for example declaration
typedef char string
Makes the name string a synonym for int .The type string can be used in declaration, cast, etc, exactly the same way that the type int can be. Notice that the type being declared in a typedef appears in the position of a variable name not after the word typedef.
第13题:   (c)
If the type of an expression is “array of T” for some type T, then the value of the expression is a pointer to the first object in the array, and the type of the expression is altered to “pointer to T”
So (buf+1)[5] is equvalent to *(buf +6) or buf[6]
第14题:   (b)
p+=sizeof(int) point to argv[2]
(p+=sizeof(int))[-1] points to argv[1]
第15题:   (c)
When we call ripple value of the first argument passed to ripple is collected in the n that is 3. va_start initialize p to point to first unnamed argument that is 5 (first argument).Each call of va_arg return an argument and step p to the next argument. va_arg uses a type name to determine what type to return and how big a step to take Consider inner loop
(; i; i&=i-1) k++ /* count number of   1 bit in i *
in five number of 1 bits is (101) 2
in seven number of 1 bits is (111) 3
hence k return 5
example
let  i=9=1001      i-1= 1000             (i-1) +1 = i                1000  +1    1 001
The right most 1 bit of i has corresponding 0 bit in i-1 this way i & i-1, in a two complement number system will delete the right most 1 bit I(repeat until I become 0 gives number of 1 bits)
第16题:   (b)
The answer is (b)
Static variable count remain in existence rather than coming and going each time function is called
so first call counter(0) count =0
second call counter(1) count = 0+1;
third call counter(2) count = 1+2; /* count = count +i */
fourth call counter(3) count = 3+3;
fifth call counter(4) count = 6+4;
sixth call counter(5) count = 10+5;





什么是平衡二叉树？编写一个删除平衡二叉树的程序？



1、  解释C语言关键字extern、static的含义。

2、  解释C语言关键字volatile、const的含义。

3、举例说明typedef和define的用法。

　 4、语句for( ；1 ；)有什么问题？它是什么意思？

　　5、do……while和while……do有什么区别？

　　6、请写出下列代码的输出内容

　　#include

　　main()

　　{

　　　int a,b,c,d;

　　　a=10;

　　　b=a++;

　　　c=++a;

　　　d=10*a++;

　　　printf(“b，c，d：%d，%d，%d”，b，c，d）;

　　　return 0;

　　}

答：

　　7、设有以下说明和定义：（32位编译器情况下）

　　typedef union {long i; int k[5]; char c;} DATE;

　　struct data { int cat; DATE cow; double dog;} too;

　　DATE max;

　　则语句 printf(“%d”,sizeof(struct date)+sizeof(max));的执行结果是：_______

8、下面是51单片机最小系统电路图，试分析该电路结构以及实现原理？

9、谈谈汇编语言、C和C++三种语言在嵌入式开发中的区别和特点？简述你对嵌入式概念的理解？

10、列举常见的嵌入式操作系统和单片机？简要介绍你以前做过的项目，在项目中用过什么处理器和操作系统，实现什么功能以及关键技术。








今天老大让我针对一个面试者出些嵌入式方面的面试题，主要是想对他的技术深度进一步了解。我就出了下面这些问题，每个问题背后都是考察一个嵌入式程序员应该具备的相关技能。当然这些只是我的个人理解，不一定正确。在此与大家分享，只是希朋友们能够得到一点点启发：如何抓住每一个契机展现你的与众不同？同样的技术问题，很多人可能都能够回答得对，但有些人只是知其然而不知所以然。其实面试官每一个问题背后通常都隐藏着一个考察点。如果我们能够透过问题看到背后的实质，在回答出答案的时候还能够借机发挥，我相信90和100分的差别就出来了。哪个面试官不喜欢招一个喜欢思考、能透过现象看本质的员工呢～


下面我们来看看嵌入式C面试题背后到底藏何玄机～。以下仅是个人的一些想法，欢迎大家讨论，拍砖的轻点～～

////////////////////////////
1、 int a=2,b=11,c=a+b++/a++; 则c值为多少？
【考点】编码规范。
表面上考察你对运算符优先级的掌握程度，但实际上优先级这些玩意很难死记硬背得住？大家的疑惑不就是运算符的结合顺序么？那么如何去避免呢？c=a+((b++)/(a++))不就行了么，其实问题背后考察的是你的编码规范，如何写清晰易懂的代码，如何在一个团队中让自己的代码狠容易毫无偏差的让新人看懂～

2、 Static用在全局变量定义和函数内部局部变量定义有何区别？
【考点】编码规范及模块化设计。
Static变量的两个属性涉及存储位置及可见域。在大型的程序设计中static全局变量可以有效的避免名字空间的重复及无意的变量引用，这样可以有效的提高程序设计的安全性，同时也利用模块化作业

3、 在程序设计中哪些地方需要使用define？如何用define来定义一年内有多少小时的常量？
【考点】可移植性。
嵌入式程序设计的特点就是软硬件平台可变性，有效利用define常量可以提高程序的可移植性，这样改动方便，不易出错

4、 Define宏语句和inline函数有什么区别？
【考点】时空效率及宏的副作用。
嵌入式系统平台通常存储资源有限，但同时又对实时性有一定的要求，二者如何权衡需要考虑。Define宏语句相对于函数调用能提高运行时间性能，但消耗了空间，并且不标准的宏语句定义在不标准的编码中更容易出现副作用，因此inline函数则是define语句的完美替代品。小资金干大事正是嵌入式的终极目标！

5、 哪些地方可以用到const？const变量和函数输入参数用const修饰有哪些作用？
【考点】程序设计可靠性。
Const只读变量可以有效克服define常量的一些弊端，如无类型安全检查。Const形参可以有效避免程序内部更改无意的更改。人非圣贤孰能无误，所以我们要将这些可能的失误统统交给智能的编译器，这样就可以将错误扼杀在摇篮中

6、 Int，short，char在32位平台下各占几个字节？一个结构体含有int、short、char变量各一个，结构体占据的总内存空间多少？
【考点】跨平台移植。
嵌入式并非x86，其硬件平台具备很大的差异性，同为int在不同的架构体系下可能占据的字节数是不一样的。不同的平台也有不同的编译器，其在变量对齐方面可能有不同的特性。因此在结构体定义时如何设计成员变量的顺序以有效减少占据的内存空间，以及如何填充特定字段保证访问对齐问题，都是嵌入式系统结构体设计时应该考虑的跨平台可移植性问题

7、 如何将unsigned int明确定义为一个32位类型？define和typedef有何区别？
【考点】跨平台移植。
define和typedef都可以实现变量类型重定义，但是typedef类型的指针变量可以有效去除变量定义的二义性。在嵌入式的工程项目中，通常为了保证数据类型的统一且便于跨平台移植时修改数据类型方便，通常都会单独定义一个数据类型的头文件，把所有用到的数据类型typedef成所熟悉的形式

8、 有没有用过volatile？有哪些典型的适用场合？
【考点】编译优化的副作用。
通常为了提高程序运行的效率，编译器会自动进行一些优化，如将变量放在寄存器中，以减少存储器访问次数，在数据长期未变时不重新读取内存等等。但是优化有时会带来问题，如硬件寄存器、多任务共享变量、中断和主程序共享变量，优化有可能带来数据访问不一致性的问题，因此对于这些个别变量，我们需要用volatile声明告诉编译器取消优化

9、 参数传递有哪些形式？寄存器和堆栈传递各有什么优缺点？
【考点】编译优化、调用性能、接口设计。
每种体系结构及对应的编译器对参数传递都有自己的规定。参数传递并非总是通过堆栈进行的，参数入栈出栈是需要耗费时间的，编译器总是尽量优化利用寄存器来传递参数，因为寄存器的访问效率要高，但当参数过多时，将放弃优化从而用栈传递参数。因此为了提高调用性能，应尽量减少参数个数，太多时可以将所有参数重新定义为一个结构体，利用结构体指针来传递参数。在函数接口设计时应考虑硬件平台和编译器的特性，以灵活定义参数形式

10、 中断服务程序设计应注意的问题？中断触发方式的选择？中断处理太长怎么办？中断处理程序如何与主应用程序交互？
【考点】中断服务程序设计。
嵌入式程序最大的特点是经常需要和硬件打交道，中断是接收外界输入的典型方式，通常都决定了系统运行流程，因此如何高效不丢失的处理中断是每个嵌入式程序员应考虑的问题

11、 TCP/IP和OSI七层模型是如何划分的？各层的功能，这么设计有什么好处？
【考点】层次化软件设计保证可移植性。
分层模型最大的好处就是某一层变化了，只要其提供上层的接口未变，那么上层就无需做任何改动。因此只需要更改本层的实现即可。嵌入式平台因为软硬件多变性，为了最大限度的利用先前的成果，软件设计一定要遵循这种层次化模型，这样才能保证其可移植性

12、 TCP和UDP的区别？各种网络互连设备都用在哪一层？如何建立链接？如何进行拥塞控制？
【考点】协议设计可靠性及缓冲区设计管理。
TCP和UDP的最大区别在于可靠性，TCP通过三次握手协议及超时机制安全可靠的建立或者释放连接。协议设计最大的问题就是如何保证效率合可靠性，TCP的设计为我们提供了一个参考。而滑动窗口机制可以有效的进行拥塞控制，但窗口大小的设计则关系到内存利用率及缓冲效率可靠性等问题。在嵌入式的驱动程序设计中，经常会开辟缓冲区来进行流量控制及防止数据覆盖，缓冲区的大小设计则需要更加具体的应用情况设计才能保证可靠性合灵活性










1.请写出下列代码的输出内容
#include<stdio.h>
main()
{
int a,b,c,d;
a=10;
b=a++;
c=++a;
d=10*a++;
printf("b，c，d：%d，%d，%d"，b，c，d）;
return 0;
}
答：10，12，120
2	程序的局部变量存在于（堆栈）中，
全局变量存在于（静态区 ）中，
动态申请数据存在于（ 堆）中。
3、队列和栈有什么区别？队列先进先出，栈后进先出
4、
unsigned char *p1;
unsigned long *p2;
p1=(unsigned char *)0x801000;
p2=(unsigned long *)0x810000;
请问
p1+5= 0x801005;
p2+5= 0x810014(加5*4=20字节，16进制为0x14);
5
以下是求一个数的平方的程序,请找出错误:
#define SQUARE(a)((a)*(a))
int a=5;
int b;
b=SQUARE(a++);
a值发生变化已经
6.交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3;
有两种解法, 一种用算术算法, 一种用^(异或)
a = a + b;
b = a - b;
a = a - b;
or
a = a^b;// 只能对int,char..
b = a^b;
a = a^b;
or
a ^= b ^= a;
7
下面这个程序执行后会有什么错误或者效果:
#define MAX 255
int main()
{
unsigned char A[MAX],i;//i被定义为unsigned char
for (i=0;i<=MAX;i++)
A[i]=i;
}
解答：死循环加数组越界访问（C/C++不进行数组越界检查）
MAX=255
数组A的下标范围为:0..MAX-1,这是其一..
其二.当i循环到255时,循环内执行:
A[255]=255;
这句本身没有问题..但是返回for (i=0;i<=MAX;i++)语句时,
由于unsigned char的取值范围在(0..255),i++以后i又为0了..无限循环下去.
8
1、找错
Void test1()
{
char string[10];
char* str1="0123456789";
strcpy(string, str1);     // 溢出，应该包括一个存放'\0'的字符string[11]
}
9 写出程序运行结果
int sum(int a)
{
auto int c=0;
static int b=3;
c+=1;
b+=2;
return(a+b+c);
}
void main()
{
int I;
int a=2;
for(I=0;I<5;I++)
{
printf("%d,", sum(a));
}
}// static会保存上次结果，记住这一点，剩下的自己写
输出：8,10,12,14,16,
10 int func(int a)
{
int b=0;
switch(a)
{
case 1: 30;
case 2: 20;
case 3: 16;
default: 0
}
return b;
}
则func(1)=0  //b定义赋值后没有改变。 
11
两个字符串，s,t;把t字符串插入到s字符串中，s字符串有足够的空间存放t字符串
void insert(char *s, char *t, int i)
{
memcpy(&s[strlen(t)+i],&s[i],strlen(s)-i);
memcpy(&s[i],t,strlen(t));
s[strlen(s)+strlen(t)]='\0';
}

12
写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。  
#define MIN(A,B) （（A） <= (B) ? (A) : (B))  

13 用变量a给出下面的定义  
a) 一个整型数（An integer）  
b)一个指向整型数的指针（ A pointer to an integer）  
c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r  
d)一个有10个整型数的数组（ An array of 10 integers）  
e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）  
f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）  
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）  
h)一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）  

a) int a; // An integer  
b) int *a; // A pointer to an integer  
c) int **a; // A pointer to a pointer to an integer  
d) int a[10]; // An array of 10 integers  
e) int *a[10]; // An array of 10 pointers to integers  
f) int (*a)[10]; // A pointer to an array of 10 integers  
g) int (*a)(int); // A pointer to a function a that  takes an integer argument and returns an integer  
h) int (*a[10])(int); // An array of 10 pointers to functions  that take an integer argument and return an integer  
14 .给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。
在以上两个操作中，要保持其它位不变。  
int a;  
void set_bit3(void) {  
a |= （1<<3）;  
}  
void clear_bit3(void) {  
a &= ~(1<<3);  
}
15. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展―让标准C支持中断。具代表事实是，产生了一个新的关键
字__interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。  
 __interrupt double compute_area (double radius)  
{  double area = PI * radius * radius;  
printf("\nArea = %f", area);  
return area;  
}  
 ISR 不能返回一个值。 
 ISR 不能传递参数。  
 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。  
 printf()经常有重入和性能上的问题。 
16 . 下面的代码输出是什么，为什么？  
 void foo(void)  
{  
unsigned int a = 6;  
int b = -20;  
(a+b > 6) ? puts("> 6") : puts("<= 6");  
}  
答案是输出是">6"。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。 因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。 


C语言测试是招聘嵌入式系统程序员过程中必须而且有效的方法。这些年，我既参加也组织了许多这种测试，在这过程中我意识到这些测试能为带面试者和被面试者提供许多有用信息，此外，撇开面试的压力不谈，这种测试也是相当有趣的。          
从被面试者的角度来讲，你能了解许多关于出题者或监考者的情况。这个测试只是出题者为显示其对ANSI标准细节的知识而不是技术技巧而设计吗？这个愚蠢的问题吗？如要你答出某个字符的ASCII值。这些问题着重考察你的系统调用和内存分配策略方面的能力吗？这标志着出题者也许花时间在微机上而不上在嵌入式系统上。如果上述任何问题的答案是"是"的话，那么我知道我得认真考虑我是否应该去做这份工作。
从面试者的角度来讲，一个测试也许能从多方面揭示应试者的素质：最基本的，你能了解应试者C语言的水平。不管怎么样，看一下这人如何回答他不会的问题也是满有趣。应试者是以好的直觉做出明智的选择，还是只是瞎蒙呢？当应试者在某个问题上卡住时是找借口呢，还是表现出对问题的真正的好奇心，把这看成学习的机会呢？我发现这些信息与他们的测试成绩一样有用。
有了这些想法，我决定出一些真正针对嵌入式系统的考题，希望这些令人头痛的考题能给正在找工作的人一点帮住。这些问题都是我这些年实际碰到的。其中有些题很难，但它们应该都能给你一点启迪。
这个测试适于不同水平的应试者，大多数初级水平的应试者的成绩会很差，经验丰富的程序员应该有很好的成绩。为了让你能自己决定某些问题的偏好，每个问题没有分配分数，如果选择这些考题为你所用，请自行按你的意思分配分数。
预处理器（Preprocessor）
1 . 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情：
?; #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
?; 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
?; 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
?; 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。

2 . 写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。
#define MIN(A,B) ( (A) <= (B) ? (A) : (B) )
这个测试是为下面的目的而设的：
?; 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
?; 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
?; 懂得在宏中小心地把参数用括号括起来
?; 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？least = MIN(*p++, b);

3. 预处理器标识#error的目的是什么？
#error 停止编译并显示错误信息 
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。
死循环（Infinite loops）

4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
这个问题用几个解决方案。我首选的方案是：
while(1)
{
;}
一些程序员更喜欢如下方案：
for(;;)
{
;}
这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是："我被教着这样做，但从没有想到过为什么。"这会给我留下一个坏印象。
第三个方案是用 goto
Loop:
...
goto Loop;
应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。
数据声明（Data declarations） 
5. 用变量a给出下面的定义
a) 一个整型数（An integer）   int a
b)一个指向整型数的指针（ A pointer to an integer）  int *a
c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r   *(int *a)   int**a
d)一个有10个整型数的数组（ An array of 10 integers）int a[10]
e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） int *a[10]
f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） *（int a[10]）  int (*a)[10]
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）   fun(*int a )  int (*max_function)(int a)
h)一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）fun(*int a[10])
int (*a[10])(int)
答案是： 
a) int a; // An integer 
b) int *a; // A pointer to an integer 
c) int **a; // A pointer to a pointer to an integer 
d) int a[10]; // An array of 10 integers
e) int *a[10]; // An array of 10 pointers to integers 
等价于int *(a[10]);
f) int (*a)[10]; // A pointer to an array of 10 integers 
g) int (*max_function)(int a); // A pointer to a function a that takes an integer argument and returns an integer
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer
人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？
6. 关键字static的作用是什么？
在C语言中，关键字static有三个明显的作用：
一旦声明为静态变量,在编译时刻开始永远存在,不受作用域范围约束,但是如果是局部静态变量,则此静态变量只能在局部作用域内使用,超出范围不能使用,但是它确实还占用内存,还存在.
?; 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
?; 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
大多数应试者能正确回答第一部分，一部分能正确回答第二部分，很少人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。
7．关键字const有什么含意？
总结：1）只读。2）使用关键字const也许能产生更紧凑的代码。3）使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。
我只要一听到被面试者说："const意味着常数"，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着"只读"就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）
如果应试者能正确回答这个问题，我将问他一个附加的问题：
下面的声明都是什么意思？
const int a;
int const a;
const int *a;
int * const a;
int const * a const;
/******/
前两个的作用是一样，a是一个常整型数。
第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。
第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。
最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。
如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
?; 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
?; 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
?; 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。

8. 关键字volatile有什么含意?并给出三个不同的例子。
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
下面是volatile变量的几个例子：
?; 并行设备的硬件寄存器（如：状态寄存器）
?; 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
?; 多线程应用中被几个任务共享的变量
回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。
假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
?; 一个参数既可以是const还可以是volatile吗？解释为什么。
?; 一个指针可以是volatile 吗？解释为什么。
?; 下面的函数有什么错误：int square(volatile int *ptr){return *ptr * *ptr;}
下面是答案：
?; 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
?; 是的。尽管这并不很常见。一个例子是当一个中断服务子程序修改一个指向一个buffer的指针时。
?; 这段代码有点变态。这段代码的目的是用来返回指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
int square(volatile int *ptr) 
{
int a,b;
a = *ptr;
b = *ptr;
return a * b;
}
由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
long square(volatile int *ptr) 
{
int a;
a = *ptr;
return a * a;
}
位操作（Bit manipulation） 
9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
对这个问题有三种基本的反应
?; 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
?; 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
?; 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
#define BIT3 (0x1 << 3)
static int a;
void set_bit3(void) {a |= BIT3;}
void clear_bit3(void) {a &= ~BIT3;}
一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。

访问固定的内存位置（Accessing fixed memory locations） 
10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa55。
编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
int *ptr;
ptr = (int *)0x67a9;
*ptr = 0xaa55;
A more obscure approach is: 
一个较晦涩的方法是：
*(int * const)(0x67a9) = 0xaa55;
即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。

中断（Interrupts） 
11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展——让标准C支持中断。具代表事实是，产生了一个新的关键字__interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
__interrupt double compute_area (double radius) 
{
double area = PI * radius * radius;
printf("\nArea = %f", area);
return area;
}
这个函数有太多的错误了，以至让人不知从何说起了：
?; ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
?; ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
?; 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
?; 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。

*****
代码例子（Code examples）
12 . 下面的代码输出是什么，为什么？
void foo(void)
{
unsigned int a = 6;
int b = -20;
(a+b > 6) ? puts("> 6") : puts("<= 6");
}
这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 ">6"。
原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。 
因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。
13. 评价下面的代码片断：
unsigned int zero = 0;
unsigned int compzero = 0xFFFF; //1's complement of zero
对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：
unsigned int compzero = ~0;
这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧...
动态内存分配（Dynamic memory allocation） 
14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：
下面的代码片段的输出是什么，为什么？
char *ptr;
if ((ptr = (char *)malloc(0)) == NULL) puts("Got a null pointer");
else puts("Got a valid pointer");
这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是"Got a valid pointer"。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。

15 Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
#define dPS struct s *
typedef struct s * tPS;
以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：
dPS p1,p2;
tPS p3,p4;
第一个扩展为struct s * p1, p2;
上面的代码定义p1为一个指向结构的指针，p2为一个实际的结构，这也许不是你想要的。

第二个例子正确地定义了p3 和p4 两个指针。

晦涩的语法
16 . C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
int a = 5, b = 7, c;
c = a+++b;
这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：c = a++ + b;
因此, 这段代码持行后a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。

好了，伙计们，你现在已经做完所有的测试了。这就是我出的C语言测试题，我怀着愉快的心情写完它，希望你以同样的心情读完它。如果是认为这是一个好的测试，那么尽量都用到你的找工作的过程中去吧。
memcmp 
Compare characters in two buffers. 
比较两块内存中的字符 
int memcmp( const void *buf1, const void *buf2, size_t count );
memset 
Sets buffers to a specified character 
将内存块设置为指定的字符
sprintf 
Write formatted data to a string 
将格式化的数据写到字符串


●8086的堆栈采取向下生长的方式，在压入时__(41)__。 

（41）    A. SP 先减，再压入数据          B. 先压入数据，SP 再减 

C. SP 先加，再压入数据          D. 先压入数据，SP 再加

<解析>：考查8086堆栈的基础知识。个人觉得，堆栈是嵌入式的基础东西，自然就是考试重点，以后或许会多考单片机ARM的结构。

8086处理器均采用满递减堆栈。入栈时，先减地址，后进数据；出栈时，先出数据，后减地址。

PUSH SRL：先将栈顶指针SP向上移两位，即SP-2，指向一个新的字存储单元，再将操作数的内容存入SP所指的字存储单元。

POP DST：将当前栈顶指针SP所指向字单元内容送向DST，然后将SP下移两位，SP-2。

参考答案：A。

 


● 若对某一寄存器某几位清零，可用一条指令__(42)__处理。 
















今天老大让我针对一个面试者出些嵌入式方面的面试题，主要是想对他的技术深度进一步了解。我就出了下面这些问题，每个问题背后都是考察一个嵌入式程序员应该具备的相关技能。当然这些只是我的个人理解，不一定正确。在此与大家分享，只是希望朋友们能够得到一点点启发：如何抓住每一个契机展现你的与众不同？ 


同样的技术问题，很多人可能都能够回答得对，但有些人只是知其然而不知所以然。其实面试官每一个问题背后通常都隐藏着一个考察点。如果我们能够透过问题看到背后的实质，在回答出答案的时候还能够借机发挥，我相信90和100分的差别就出来了。哪个面试官不喜欢招一个喜欢思考、能透过现象看本质的员工呢～ 


下面我们来看看嵌入式C面试题背后到底藏何玄机～。以下仅是个人的一些想法，欢迎大家讨论，拍砖的轻点～～ 


//////////////////////////// 

1、 int a=2,b=11,c=a+b++/a++; 则c值为多少？

【考点】编码规范。

表面上考察你对运算符优先级的掌握程度，但实际上优先级这些玩意很难死记硬背得住？大家的疑惑不就是运算符的结合顺序么？那么如何去避免呢？c=a+((b++)/(a++))不就行了么，其实问题背后考察的是你的编码规范，如何写清晰易懂的代码，如何在一个团队中让自己的代码狠容易毫无偏差的让新人看懂～


2、 Static用在全局变量定义和函数内部局部变量定义有何区别？

【考点】编码规范及模块化设计。

Static变量的两个属性涉及存储位置及可见域。在大型的程序设计中static全局变量可以有效的避免名字空间的重复及无意的变量引用，这样可以有效的提高程序设计的安全性，同时也利用模块化作业


3、 在程序设计中哪些地方需要使用define？如何用define来定义一年内有多少小时的常量？

【考点】可移植性。

嵌入式程序设计的特点就是软硬件平台可变性，有效利用define常量可以提高程序的可移植性，这样改动方便，不易出错


4、 Define宏语句和inline函数有什么区别？

【考点】时空效率及宏的副作用。

嵌入式系统平台通常存储资源有限，但同时又对实时性有一定的要求，二者如何权衡需要考虑。Define宏语句相对于函数调用能提高运行时间性能，但消耗了空间，并且不标准的宏语句定义在不标准的编码中更容易出现副作用，因此inline函数则是define语句的完美替代品。小资金干大事正是嵌入式的终极目标！


5、 哪些地方可以用到const？const变量和函数输入参数用const修饰有哪些作用？

【考点】程序设计可靠性。

Const只读变量可以有效克服define常量的一些弊端，如无类型安全检查。Const形参可以有效避免程序内部更改无意的更改。人非圣贤孰能无误，所以我们要将这些可能的失误统统交给智能的编译器，这样就可以将错误扼杀在摇篮中


6、 Int，short，char在32位平台下各占几个字节？一个结构体含有int、short、char变量各一个，结构体占据的总内存空间多少？

【考点】跨平台移植。

嵌入式并非x86，其硬件平台具备很大的差异性，同为int在不同的架构体系下可能占据的字节数是不一样的。不同的平台也有不同的编译器，其在变量对齐方面可能有不同的特性。因此在结构体定义时如何设计成员变量的顺序以有效减少占据的内存空间，以及如何填充特定字段保证访问对齐问题，都是嵌入式系统结构体设计时应该考虑的跨平台可移植性问题


7、 如何将unsigned int明确定义为一个32位类型？define和typedef有何区别？

【考点】跨平台移植。

define和typedef都可以实现变量类型重定义，但是typedef类型的指针变量可以有效去除变量定义的二义性。在嵌入式的工程项目中，通常为了保证数据类型的统一且便于跨平台移植时修改数据类型方便，通常都会单独定义一个数据类型的头文件，把所有用到的数据类型typedef成所熟悉的形式


8、 有没有用过volatile？有哪些典型的适用场合？

【考点】编译优化的副作用。

通常为了提高程序运行的效率，编译器会自动进行一些优化，如将变量放在寄存器中，以减少存储器访问次数，在数据长期未变时不重新读取内存等等。但是优化有时会带来问题，如硬件寄存器、多任务共享变量、中断和主程序共享变量，优化有可能带来数据访问不一致性的问题，因此对于这些个别变量，我们需要用volatile声明告诉编译器取消优化


9、 参数传递有哪些形式？寄存器和堆栈传递各有什么优缺点？

【考点】编译优化、调用性能、接口设计。

每种体系结构及对应的编译器对参数传递都有自己的规定。参数传递并非总是通过堆栈进行的，参数入栈出栈是需要耗费时间的，编译器总是尽量优化利用寄存器来传递参数，因为寄存器的访问效率要高，但当参数过多时，将放弃优化从而用栈传递参数。因此为了提高调用性能，应尽量减少参数个数，太多时可以将所有参数重新定义为一个结构体，利用结构体指针来传递参数。在函数接口设计时应考虑硬件平台和编译器的特性，以灵活定义参数形式


10、 中断服务程序设计应注意的问题？中断触发方式的选择？中断处理太长怎么办？中断处理程序如何与主应用程序交互？

【考点】中断服务程序设计。

嵌入式程序最大的特点是经常需要和硬件打交道，中断是接收外界输入的典型方式，通常都决定了系统运行流程，因此如何高效不丢失的处理中断是每个嵌入式程序员应考虑的问题


11、 TCP/IP和OSI七层模型是如何划分的？各层的功能，这么设计有什么好处？

【考点】层次化软件设计保证可移植性。

分层模型最大的好处就是某一层变化了，只要其提供上层的接口未变，那么上层就无需做任何改动。因此只需要更改本层的实现即可。嵌入式平台因为软硬件多变性，为了最大限度的利用先前的成果，软件设计一定要遵循这种层次化模型，这样才能保证其可移植性


12、 TCP和UDP的区别？各种网络互连设备都用在哪一层？如何建立链接？如何进行拥塞控制？

【考点】协议设计可靠性及缓冲区设计管理。

TCP和UDP的最大区别在于可靠性，TCP通过三次握手协议及超时机制安全可靠的建立或者释放连接。协议设计最大的问题就是如何保证效率合可靠性，TCP的设计为我们提供了一个参考。而滑动窗口机制可以有效的进行拥塞控制，但窗口大小的设计则关系到内存利用率及缓冲效率可靠性等问题。在嵌入式的驱动程序设计中，经常会开辟缓冲区来进行流量控制及防止数据覆盖，缓冲区的大小设计则需要更加具体的应用情况设计才能保证可靠性合灵活性

（42）A. AND        B. OR        C. NOT           D. XOR 

<解析>：考查汇编语言的基础知识，简单到极点了，这个分数拿不到，基本过不了。

AND（与）：有0为0。

OR（或）：有1为1。

NOT（非）：取反。

XOR（异或）：相同为0，不同为1。

要对寄存器的某几位清零，应用AND。

例如对11011010的中间四位清零：11011010 AND 11000011 得11000010。

个人认为：用XOR指令，一条指令是做不到的，实际中不可取。

参考答案：A。

 

● 指令周期是指__(43)__。 

（43）    A. CPU 从主存取出一条指令的时间 

B. CPU 执行一条指令的时间 

C. CPU 从主存取出一条指令加上执行该条指令的时间 

D. 时钟周期的时间 

<解析>：考嵌入式最最基本的概念了，记住就行，这个分数必拿。

指令周期：CPU从内存取出一条指令并执行这条指令的时间总和。

包括取指令，分析指令，执行指令整个过程。

       <补充>：时钟周期、机器周期、指令周期的概念辨析。

       时钟周期：时序中的最小单位，就是1/fosc。例如：晶振为12MHz，那么时钟周期为1/12us。

       机器周期：完成某一规定操作所需的时间，通常由若干时钟周期构成。例如：单片机是12周期的话，那么在12MHz晶振的情况下，其机器周期为1us。

       指令周期：完成一条指令的所有时间。例如RET是一个2周期指令，在上述的条件下，它的指令周期为2us。

参考答案：C。

 

●在汇编过程中，不产生机器码，只用来指示汇编程序如何汇编的指令是__(44)__。  

（44）A. 宏指令      B. 伪指令          C. 汇编指令      D. 机器指令 

<解析>：考查汇编语言的基础知识。

不想多说了，太简单了，自己看看概念吧。

或者这样记住：伪指令就是假的指令，假得指令是给人看的，不是给机器看的，所以机器不能产生代码。

注意一下宏指令的用法，说不好下次就考了。

参考答案：B。

 

●在8086微处理器中，若(SS) = 2000H，(SP) = 0100H，(AX) = 2107H，执行指令PUSH AX 后存放数据21H 的物理地址是__(45)__。 

（45）A. 20102H      B. 20101H          C. 200FEH      D. 200FFH 

<解析>：这道题目不容易，需要对X86汇编语言有深入的理解，拿不到分就算了。

41题是会做对这道题目的基础。由41题可知，8086的堆栈数据操作是，SP先减，再压入数据，以字为单位对堆栈操作。

因此压入数据时的起始SP应为0100H-2=00FEH。而8086中数据采用小端模式存取，即一个字数据中低字节存放低位地址。（X86越向上的地址越小）

8086逻辑地址到物理地址的形成机制为：物理地址=段地址*16+偏移地址(或物理地址=段地址左移4位+偏移地址)。压栈后，内容存储的物理地址为2000*16+00FEH=200FE，21H是AX中的高位，其存储位置为200FFH。

参考答案：D。

 

● 在串行通信中，根据数据传输方向不同，可以分成三种方式，不包括__(46)__方式。 

（46）A. 单工      B. 双工                  C. 半单工              D. 半双工 

<解析>：考查接口通信的基础知识。

没有必要多说，是我们搞嵌入式必须知道的基本常识。

什么是单工、双工、半双工得搞搞清楚。

参考答案：C。

 

● 寄存器间接寻址方式中，操作数处在__(47)__。 

（47）A. 通用寄存器      B. 主存单元          C. 程序计数器       D. 堆栈

<解析>：考查寻址方式的基础概念，需要有一点的理解，但是其选项会让很多人答对。

简单来说，寄存器间接寻址方式是说，指令的寄存器的内容不是操作数，而是操作数的偏移地址，操作数本身则在存储器中。

参考答案：B。

 

●  IEEE 1394具有__(48)__位地址空间，IEEE 1394的通信协议具有三个协议层，下面不属于这三个协议层的是__(49)__。 

（48）A. 8          B. 16         C. 32                D. 64 

（49）A. 事务层         B. 表示层       C. 链路层            D. 物理层 

<解析>：考查接口技术中1394的基本知识。

参考《教程》219-221页。

1394总线类似于PCI总线，任何设备可以在64位地址空间内进行读写操作。

一条1394总线可以接入63个设备，支持同步和异步两种串行传输方式。

1394的协议由3层组成：物理层、链路层、事务层。

参考答案：D、B。

 

● 在软件测试中，白盒测试是基于设计的和基于__(50)__测试。 

（50）A. 需求的       B. 代码的      C. 提炼的          D. 反常的或极端的

<解析>：考查软件测试的基本知识。

参考《教程》405-410页，在2007年考试中，下午考了一道这方面的题目，要注意。

机器测试分为黑盒测试和白盒测试。

黑盒测试也称为功能测试。

白盒测试也称为结构测试。

白盒测试，将软件看成透明的白盒，根据程序内部结构和逻辑来设计测试用例，对程序的路径和过程进行测试，检查是否满足设计的需要。

通过白盒测试，测试人员可以很清楚已经有多少代码被检查过了，可以准确地预测出系统中的程序设计错误的数量规模。

参考答案：B。


















下面的题目必须全部答对才给分：
1、 如何在C中初始化一个字符数组。
2、 如何在C中为一个数组分配空间。
3、 如何初始化一个指针数组。
4、如何定义一个有10个元素的整数型指针数组。
5、 s[10]的另外一种表达方式是什么。
6、 GCC3.2.2版本中支持哪几种编程语言。
7、 要使用CHAR_BIT需要包含哪个头文件。
8、 对(-1.2345)取整是多少？
9、 如何让局部变量具有全局生命期。
10、C中的常量字符串应在何时定义？
11、如何在两个.c文件中引用对方的变量。
12、使用malloc之前需要做什么准备工作。
13、realloc函数在使用上要注意什么问题。
14、strtok函数在使用上要注意什么问题。
15、gets函数在使用上要注意什么问题。
16、C语言的词法分析在长度规则方面采用的是什么策略？
17、a+++++b所表示的是什么意思？有什么问题？
18、如何定义Bool变量的TRUE和FALSE的值。
19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。

这部分是ANSI C的一些问题，题目的前提是必须都答对，看似很变态，但是细想一下，这些都是最基础的，虽然我们在使用他们的时候会犯这样那样的错误，但是最终目的是不犯错误，不是么，那么好，从最基础的开始。



1、 如何在C中初始化一个字符数组。
这个问题看似很简单，但是我们要将最简单的问题用最严谨的态度来对待。关键的地方：初始化、字符型、数组。最简单的方法是char array[];。这个问题看似解决了，但是在初始化上好像还欠缺点什么，个人认为：char array[5]={'1','2','3','4','5'};或者char array[5]={"12345"};或者char array[2][10]={"China","Beijing"};也许更符合“初始化”的意思。



2、 如何在C中为一个数组分配空间。
最简单的方法是：char array[5]；意思是分配给数组array一个5个字节的空间。但是我们要知道在C中数组其实就是一个名字，其实质含义就是指针，比如char array[]；是到底分配的多少空间？所以我们要将其分成为两种不同的形式给出答案：
一种是栈的形式：char array[5]；
一种是堆的形式：char *array; array=(char *)malloc(5);//C++: array=new char[5];
堆和栈的含义其实我也没弄太透彻，改天明白了再发一篇。
我们要明白的是，第一种形式空间分配的大小可能会受操作系统的限制,比如windows会限制在2M；第二种形式成空间分配很灵活，想分配多少分配多少，只要RAM够大。



3、 如何初始化一个指针数组。
首先明确一个概念，就是指向数组的指针，和存放指针的数组。
指向数组的指针：char (*array)[5];含义是一个指向存放5个字符的数组的指针。
存放指针的数组：char *array[5];含义是一个数组中存放了5个指向字符型数据的指针。
按照题意，我理解为初始化一个存放指针的数组，char *array[2]={"China","Beijing"}；其含义是初始化了一个有两个指向字符型数据的指针的数组，这两个指针分别指向字符串"China"和"Beijing"。



4、如何定义一个有10个元素的整数型指针数组。
既然只是定义而不是初始化，那就很简单且没有争议了：int *array[10];。



5、 s[10]的另外一种表达方式是什么。
前面说过了，数组和指针其实是数据存在形态的两种表现形式，如果说对于数组s[]，我们知道*s=s[0]，那么s[10]的另一种表达方式就是：*(s+10)。



6、 GCC3.2.2版本中支持哪几种编程语言。
这个问题实在变态，就像问你#error的作用是什么一样。不可否认，gcc是linux下一个亮点，是一个备受无数程序员推崇的编译器，其优点省略 1000字，有兴趣可以自己查，我翻了翻书，书上曰：支持C,C++,Java,Obj-C,Ada,Fortran,Pascal,Modula-3等语言，这个“等”比较要命，不过我认为已经很全了，如果认为还是不全，干脆把ASM也加上算了，不过那已经不算是编译了。



7、 要使用CHAR_BIT需要包含哪个头文件。
如果结合上面的问题，答题的人估计会认为自己撞鬼了，这个问题实在是……搜索了一下，应该是limits.h。



8、 对(-1.2345)取整是多少？
其实不同的取整函数可能有不同的结果，不过这个数没有太大的争议，答案是-1。



9、 如何让局部变量具有全局生命期。
具体的生命期的概念我觉得我还要好好深入的学习一下，但是这个题目还算比较简单，即用static修饰就可以了，但是只是生命期延长，范围并没有扩大，除非把这个变量定义在函数体外的静态区，不过那样就变成全局变量了，仿佛不符合题目要求。



10、C中的常量字符串应在何时定义？
这个问题说实话不是很理解题干的意思，据我理解，有两种情况，一种是预处理阶段，用#define定义；还有就是使用const修饰词，不过const修饰的是一个变量，其含义是“只读”，称之为常量并不准确，但是确实可以用操作变量的方法当常量用。所以还是第一种比较靠谱。



11、如何在两个.c文件中引用对方的变量。
这个问题也问的挺含糊的，怎么说呢，最简单最直接的方法是为变量添加extern修饰词，当然，这个变量必须是全局变量。还有一种就是利用函数调用来进行变量的间接引用，比如这个C文件中的一个函数引用另外一个C中的函数，将变量通过实参的形式传递过去。不过题目既然说是引用，那么还是用第一个答案好了。



12、使用malloc之前需要做什么准备工作。
其实准备工作很多啊，比如你需要一台计算机之类的。玩笑话，我们首先要知道malloc的用途，简单的说就是动态的分配一段空间，返回这段空间的头指针。实际的准备工作可以这么分：需要这段空间的指针是否存在，若不存在，则定义一个指针用来被赋值，还要清楚要返回一个什么类型的指针，分配的空间是否合理；如果指针已经存在，那么在重新将新的空间头地址赋值给这个指针之前，要先判断指针是否为NULL，如果不是要free一下，否则原来的空间就会被浪费，或者出错，free之后就按照前一种情形考虑就可以了。



13、realloc函数在使用上要注意什么问题。
这个函数我也才知道的，汗一个。据我的初步理解，这个函数的作用是重新分配空间大小，返回的头指针不变，只是改变空间大小。既然是改变，就有变大、变小和为什么改变的问题。变大，要注意不能大到内存溢出；变小，那变小的那部分空间会被征用，原有数据不再存在；为什么改变，如果是想重新挪作他用，还是先 free了吧。



14、strtok函数在使用上要注意什么问题。
这个问题我不知道能不能回答全面，因为实在是用的很少。这个函数的作用是分割字符串，但是要分割的字符串不能是常量，这是要注意的。比如先定义一个字符串：char array[]="part1,part2";，strtok的原形是char *strtok(char *string, char *delim);，我们将","作为分隔符，先用pt=strtok(array,",");，得到的结果print出来就是"part1"，那后面的呢，要写成pt=strtok(NULL,",");，注意，要用NULL，如果被分割的字符串会被分成N段，那从第二次开始就一直要用NULL。总结起来，需要注意的是：被分割的字符串和分隔符都要使用变量；除第一次使用指向字符串的指针外，之后的都要使用NULL；注意使用这个函数的时候千万别把指针跟丢了，不然就全乱了。



15、gets函数在使用上要注意什么问题。
这是一个键盘输入函数，将输入字符串的头地址返回。说到要注意的问题，我还是先查了一下网上的一些情况，需要注意的就是gets以输入回车结束，这个地球人都知道，但是很多人不知道的是，当你输入完一个字符串后，这个字符串可能依然存在于这个标准输入流之中，当再次使用gets的时候，也许会把上次输入的东西读出来，所以应该在使用之后用fflush(stdin);处理一下，将输入流清空。最后也还是要注意溢出的问题。关于这个答案我比较含糊，不知道有没有高人高见？



16、C语言的词法分析在长度规则方面采用的是什么策略？
我无语……闻所未闻啊……还是搜索了一下，有一篇文章，地址是：http://202.117.80.9/jp2005/20/kcwz/wlkc/wlkc/03/3_5_2.htm，是关于词法分析器的。其中提到了两点策略： (1) 按最长匹配原则确定被选的词型；(2) 如果一个字符串能为若干个词型匹配，则排列在最前面的词型被选中。不知道是不是题干的要求，还是其他什么。我乃一介草民，望达人指点迷津！



17、a+++++b所表示的是什么意思？有什么问题？
这个东西（称之为东西一点都不过分）其实并没有语法错误，按照C对运算符等级的划分，++的优先级大于+，那么这句话会被编译器看做：(a++)+(++ b)，这回明白了吧。有什么问题，语法上没有问题，有的是道德上的问题！作为一个优秀的程序员，我们要力求语句的合法性和可读性，如果写这句的人是在一个 team里，那么他基本会被打的半死……最后讨论一下结果：假设a之前的值是3，b是4，那么运行完这个变态语句后，a的值是4，b是5，语句的结果是 8。



18、如何定义Bool变量的TRUE和FALSE的值。
不知道这个题有什么陷阱，写到现在神经已经大了，一般来说先要把TURE和FALSE给定义了，使用#define就可以：
#define TURE 1
#define FALSE 0
如果有一个变量需要定义成bool型的，举个例子：bool a=TURE;就可以了。



19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
首先，这个题干抽了10题回答的一个大嘴巴。关于常量的概念看来我要好好看看书了……我说过了，const修饰词可以将一个变量修饰为“只读”，这个就能称为常量么？姑且认为可以。回到题目中，const是只读的意思，它限定一个变量不允许被改变，谁都不能改！既然是修饰变量，那么变量的类型就可以丰富多彩，int啊，char啊，只要C认识的都可以；但是#define就不可以了，在预处理阶段缺乏类型检测机制，有可能会出错。还有就是变量可以 extern，但是#define就不可以。貌似const还可以节省RAM，这个我倒是没有考证过。至于const的用法和作用，有很多，我会总结后发上来。



20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。
终于最后一题了，容易么……如果这个测试是一个关于嵌入式的，那么这道题非常重要！！从词面上讲，volatile的意思是易变的，也就是说，在程序运行过程中，有一些变量可能会被莫名其妙的改变，而优化器为了节约时间，有时候不会重读这个变量的真实值，而是去读在寄存器的备份，这样的话，这个变量的真实值反而被优化器给“优化”掉了，用时髦的词说就是被“和谐”了。如果使用了这个修饰词，就是通知编译器别犯懒，老老实实去重新读一遍！可能我说的太“通俗”了，那么我引用一下“大师”的标准解释：
volatile的本意是“易变的” 。
由于访问寄存器的速度要快过RAM,所以编译器一般都会作减少存取外部RAM的优化，但有可能会读脏数据。当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。

好了，答完了，也不知道标准答案是什么。如果有达人看到皱眉头的话，千万停下来，浪费您宝贵的几分钟时间指点一二，不胜感激！



（1）什么是预编译，何时需要预编译： 
答案： 
１、总是使用不经常改动的大型代码体。 
２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。 
（2）char * const p      char const * p      const char *p 上述三个有什么区别？ 
答案： 
char * const p; //常量指针，p的值不可以修改 
char const * p；//指向常量的指针，指向的常量值不可以改 const char *p； //和char const *p 
（3）char str1[] = "abc"; char str2[] = "abc"; const char str3[] = "abc"; const char str4[] = "abc"; const char *str5 = "abc"; const char *str6 = "abc"; char *str7 = "abc"; char *str8 = "abc"; cout < < ( str1 == str2 ) < < endl; cout < < ( str3 == str4 ) < < endl; cout < < ( str5 == str6 ) < < endl; cout < < ( str7 == str8 ) < < endl; 
结果是：0 0 1 1 str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。 
（4）以下代码中的两个sizeof用法有问题吗？ 
[C易] void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母 {    for( size_t i=0; i <sizeof(str)/sizeof(str[0]); ++i )        if( 'a' <=str[i] && str[i] <='z' )            str[i] -= ('a'-'A' ); } char str[] = "aBcDe"; cout < < "str字符长度为: " < < sizeof(str)/sizeof(str[0]) < < endl; UpperCase( str ); cout < < str < < endl; 答案：函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，因为还有'\0'，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。 
（5）一个32位的机器,该机器的指针是多少位答案： 
指针是多少位只要看地址总线的位数就行了。80386以后的机子都是32的数据总线。所以指针的位数就是4个字节了。 
6。main() {  int a[5]={1,2,3,4,5};    int *ptr=(int *)(&a+1);    printf("%d,%d",*(a+1),*(ptr-1)); } 答案：2。5 *(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5 &a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int） int *ptr=(int *)(&a+1); 则ptr实际是&(a[5]),也就是a+5 原因如下： &a是数组指针，其类型为 int (*)[5]; 而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同 a是长度为5的int数组指针，所以要加 5*sizeof(int) 所以ptr实际是a[5] 但是prt与(&a+1)类型是不一样的(这点很重要) 所以prt-1只会减去sizeof(int*) a,&a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5]. 
7。请问以下代码有什么问题： int  main() { char a; char *str=&a; strcpy(str,"hello"); printf(str); return 0; } 答案：没有为str分配内存空间，将会发生异常问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。 
8。char* s="AAA"; printf("%s",s); s[0]='B'; printf("%s",s); 有什么错？答案："AAA"是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。 cosnt char* s="AAA"; 然后又因为是常量，所以对是s[0]的赋值操作是不合法的。 
9。写一个“标准”宏，这个宏输入两个参数并返回较小的一个。答案：.#define Min(X, Y) ((X)>(Y)?(Y):(X))  //结尾没有‘；’ 
10。嵌入式系统中经常要用到无限循环，你怎么用C编写死循环。答案：while(1){}或者for(;;) 
11。关键字static的作用是什么？答案：定义静态变量 
12。关键字const有什么含意？答案：表示常量不可以修改的变量。 
13。关键字volatile有什么含意？并举出三个不同的例子？答案：提示编译器对象的值可能在编译器未监测到的情况下改变。 
14。int (*s[10])(int) 表示的是什么啊？答案：int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。 
15。有以下表达式： int a=248; b=4;int const c=21;const int *d=&a; int *const e=&b;int const *f const =&a; 请问下列表达式哪些会被编译器禁止？为什么？答案：*c=32;d=&b;*d=43;e=34;e=&a;f=0x321f; *c 这是个什么东东，禁止 *d 说了是const， 禁止 e = &a 说了是const 禁止 const *f const =&a; 禁止 
16交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3; 答案：有两种解法, 一种用算术算法, 一种用^(异或) a = a + b; b = a - b; a = a - b; or a = a^b;// 只能对int,char.. b = a^b; a = a^b; or a ^= b ^= a; 
17.c和c++中的struct有什么不同？答案：c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private 
18.#include <stdio.h>  #include <stdlib.h>  void getmemory(char *p)  {    p=(char *) malloc(100);    strcpy(p,"hello world");  }  int main( )  {    char *str=NULL;    getmemory(str);    printf("%s/n",str);    free(str);    return 0;    } 答案：程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险 
19.char szstr[10];  strcpy(szstr,"0123456789");  产生什么结果？为什么？答案：  长度不一样，会造成非法的OS 
20.列举几种进程的同步机制，并比较其优缺点。答案：  原子操作 信号量机制    自旋锁    管程，会合，分布式系统 
21.进程之间通信的途径答案：共享存储系统消息传递系统管道：以文件系统为基础 
22.进程死锁的原因答案：资源竞争及进程推进顺序非法 
23.死锁的4个必要条件答案：互斥、请求保持、不可剥夺、环路 
24.死锁的处理答案：鸵鸟策略、预防策略、避免策略、检测与解除死锁 
25.  操作系统中进程调度策略有哪几种？答案：FCFS(先来先服务)，优先级，时间片轮转，多级反馈 
26.类的静态成员和非静态成员有何区别？答案：类的静态成员每个类只有一个，非静态成员每个对象一个 
27.纯虚函数如何定义？使用时应注意什么？答案：virtual void f()=0; 是接口，子类必须要实现 
28.数组和链表的区别答案：数组：数据顺序存储，固定大小连表：数据可以随机存储，大小可动态改变 
29.ISO的七层模型是什么？tcp/udp是属于哪一层？tcp/udp有何优缺点？答案：应用层表示层会话层运输层网络层物理链路层物理层 tcp /udp属于运输层 TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。 tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好 udp: 不提供稳定的服务，包头小，开销小  
30：(void *)ptr 和 (*(void**))ptr的结果是否相同？其中ptr为同一个指针答案：.(void *)ptr 和 (*(void**))ptr值是相同的 
31：int main()    {    int x=3;    printf("%d",x);    return 1;      } 问函数既然不会被其它函数调用，为什么要返回1？答案：mian中，c标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息 
32，要对绝对地址0x100000赋值，我们可以用 (unsigned int*)0x100000 = 1234; 那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？答案：*((void (*)( ))0x100000 ) ( ); 首先要将0x100000强制转换成函数指针,即: (void (*)())0x100000 然后再调用它: *((void (*)())0x100000)(); 用typedef可以看得更直观些: typedef void(*)() voidFuncPtr; *((voidFuncPtr)0x100000)(); 
33，已知一个数组table，用一个宏定义，求出数据的元素个数答案：#define NTBL #define NTBL (sizeof(table)/sizeof(table[0])) 
34。线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈? 答案：进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。每个线程有自己的堆栈。 DLL中有没有独立的堆栈，这个问题不好回答，或者说这个问题本身是否有问题。因为DLL中的代码是被某些线程所执行，只有线程拥有堆栈，如果DLL中的代码是EXE中的线程所调用，那么这个时候是不是说这个DLL没有自己独立的堆栈？如果DLL中的代码是由DLL自己创建的线程所执行，那么是不是说DLL有独立的堆栈？以上讲的是堆栈，如果对于堆来说，每个DLL有自己的堆，所以如果是从DLL中动态分配的内存，最好是从DLL中删除，如果你从DLL中分配内存，然后在EXE中，或者另外一个DLL中删除，很有可能导致程序崩溃 
35。unsigned short A = 10; printf("~A = %u\n", ~A); char c=128; printf("c=%d\n",c); 输出多少？并分析过程答案：第一题，～A ＝0xfffffff5,int值 为－11，但输出的是uint。所以输出4294967285 第二题，c＝0x10,输出的是int，最高位为1，是负数，所以它的值就是0x00的补码就是128，所以输出－128。这两道题都是在考察二进制向int或uint转换时的最高位处理。  
（二） 
1. -1,2,7,28,,126请问28和126中间那个数是什么？为什么？答案：第一题的答案应该是4^3-1=63 规律是n^3-1(当n为偶数0，2，4)      n^3+1(当n为奇数1，3，5) 
2.用两个栈实现一个队列的功能？要求给出算法和思路！答案：设2个栈为A,B, 一开始均为空. 入队: 将新元素push入栈A; 出队: (1)判断栈B是否为空； (2)如果不为空，则将栈A中所有元素依次pop出并push到栈B； (3)将栈B的栈顶元素pop出；这样实现的队列入队和出队的平摊复杂度都还是O(1), 比上面的几种方法要好。 
3.在c语言库函数中将一个字符转换成整型的函数是atol()吗，这个函数的原型是什么？答案：函数名: atol 功 能: 把字符串转换成长整型数 用 法: long atol(const char *nptr); 程序例: #include <stdlib.h> #include <stdio.h> int main(void) { long l; char *str = "98765432"; l = atol(lstr); printf("string = %s integer = %ld\n", str, l); return(0); } 
4。对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现? 答案：c用宏定义，c++用inline 
5。直接链接两个信令点的一组链路称作什么? 答案：PPP点到点连接 
7。软件测试都有那些种类? 答案：黑盒：针对系统功能的测试    白合：测试函数功能，各函数接口 
8。确定模块的功能和模块的接口是在软件设计的那个队段完成的? 答案：概要设计阶段 
9。enum string    {    x1,    x2,    x3=10,    x4,    x5,    }x;    问x；答案：取值在0。1。10。11。12中的一个 
10。unsigned char *p1;    unsigned long *p2;    p1=(unsigned char *)0x801000;    p2=(unsigned long *)0x810000;    请问p1+5=  ;        p2+5=  ; 答案：801005； 810014。不要忘记了这个是16进制的数字，p2要加20变为16进制就是14 选择题:  1.Ethternet链接到Internet用到以下那个协议?  A.HDLC;B.ARP;C.UDP;D.TCP;E.ID  2.属于网络层协议的是:  A.TCP;B.IP;C.ICMP;D.X.25  3.Windows消息调度机制是:  A.指令队列;B.指令堆栈;C.消息队列;D.消息堆栈; 答案：b，a，c 
四.找错题:  
1.请问下面程序有什么错误?    int a[60][250][1000],i,j,k;    for(k=0;k <=1000;k++)    for(j=0;j <250;j++)      for(i=0;i <60;i++)      a[i][j][k]=0; 答案：把循环语句内外换一下 
2。以下是求一个数的平方的程序,请找出错误:    #define SQUARE(a)  ((a)*(a))    int a=5;    int b;    b=SQUARE(a++); 答案：这个没有问题，s（a＋＋），就是（（a＋＋）×（a＋＋））唯一要注意的就是计算后a＝7了 3。typedef unsigned char BYTE      int examply_fun(BYTE gt_len; BYTE *gt_code)      {        BYTE *gt_buf;      gt_buf=(BYTE *)MALLOC(Max_GT_Length);      ......      if(gt_len>Max_GT_Length)        {        return GT_Length_ERROR;          }        .......      } 答案：要释放内存问答题: 1.IP Phone的原理是什么? 答案：IPV6 2.TCP/IP通信建立的过程怎样，端口有什么作用？答案：三次握手，确定是哪个应用程序使用该协议 （三） 
1、局部变量能否和全局变量重名？答案：能，局部会屏蔽全局。要用全局变量，需要使用"::" 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内 
2、如何引用一个已经定义过的全局变量？答案：extern 可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错 
3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？答案：可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错 
4、语句for( ；1 ；)有什么问题？它是什么意思？答案：和while(1)相同。 
5、do……while和while……do有什么区别？答案：前一个循环一遍再判断，后一个判断以后再循环。 
6、请写出下列代码的输出内容＃include <stdio.h> main() { int a,b,c,d; a=10; b=a++; c=++a; d=10*a++; printf("b，c，d：%d，%d，%d"，b，c，d）; return 0; } 答案：10，12，120  a=10;  b=a++;//a=11 b=10  c=++a;//a=12 c=12  d=10*a++;//a=13 d=120 
高级题 
1、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
答案：全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。 static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件 static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 
2、程序的局部变量存在于（）中，全局变量存在于（）中，动态申请数据存在于（ ）中。
答案：栈；静态区；堆 3、设有以下说明和定义： typedef union {long i; int k[5]; char c;} DATE; struct data { int cat; DATE cow; double dog;} too; DATE max; 则语句 printf("%d",sizeof(too)+sizeof(max));的执行结果是：______ 答案：DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20 data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32. 所以结果是 20 + 32 = 52. 当然...在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 = 20 
4、队列和栈有什么区别？
答案：队列先进先出，栈后进先出÷ 
5、这道题目出错了，这里就不写上了。 
6、已知一个单向链表的头，请写出删除其某一个结点的算法，要求，先找到此结点，然后删除。答案：slnodetype *Delete(slnodetype *Head,int key){}中if(Head->number==key) { Head=Pointer->next; free(Pointer); break; } Back = Pointer;        Pointer=Pointer->next; if(Pointer->number==key) {            Back->next=Pointer->next; free(Pointer); break; } void delete(Node* p) {    if(Head = Node)    while(p) } 
7、请找出下面代码中的所以错误说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba” 
1、＃include"string.h" 2、main() 3、{ 4、 char*src="hello,world"; 5、 char* dest=NULL; 6、 int len=strlen(src); 7、 dest=(char*)malloc(len); 8、 char* d=dest; 9、 char* s=src[len]; 10、 while(len--!=0) 11、 d++=s--; 12、 printf("%s",dest); 13、 return 0; 14、} 答案：还要加上＃include <stdio.h> int main(){ char* src = "hello,world"; int len = strlen(src); char* dest = (char*)malloc((len+1)*sizeof(char));  //要为\0分配一个空间 char* d = dest; char* s = &src[len-1]; //指向最后一个字符 while( len-- != 0 ) *d++=*s--; *d = 0; //尾部要加\0 printf("%s\n",dest); free(dest);// 使用完，应当释放空间，以免造成内存汇泄露 return 0; }    华为笔试题（3） 2006-09-29 19:41 
一、判断题（对的写T，错的写F并说明原因，每小题4分，共20分） 
1、有数组定义int a[2][2]={{1},{2,3}};则a[0][1]的值为0。（    正确 ） 
2、int (*ptr) (),则ptr是一维数组的名字。（错误  int (*ptr) ();定义一个指向函数的指针变量    ） 
3、指针在任何情况下都可进行>, <,>=, <=,==运算。（  错误  ） 
4、switch(c) 语句中c可以是int ,long,char ,float ,unsigned int 类型。（  错，不能用实形 ） 
二、填空题（共30分） 
1、在windows下，写出运行结果，每空2分，共10分。 char str[ ]= ＂Hello＂; char *p=str; int n=10; sizeof(str)=(      ) sizeof(p)=(      ) sizeof(n)=(      ) void func(char str[100]){    } sizeof(str)=(    )  答案：6，4，4，4, 具体解释请参看我的空间里的“C/C++程序员应聘试题剖析” 
2、void getmemory(char **p, int num) { *p=(char *) malloc(num);} void test(void) {  char *str=NULL;    getmemory(&str,100);    strcpy(str,＂hello＂);    printf(str); } 运行test函数有什么结果？（                                ）10分  答案：输出hello，但是发生内存泄漏。 
3、设int arr[]={6,7,8,9,10};      int *ptr=arr;    *(ptr++)+=123;  printf(＂%d,%d＂,*ptr,*(++ptr)); (                                  ) 10分答案：8， 
8。这道题目的意义不大，因为在不同的编译器里printf的参数的方向是不一样的，在vc6.0下是从有到左，这里先*(++ptr) 后*pt，于是结果为8，8 
三、编程题（第一小题20，第二小题30分） 
1、  不使用库函数，编写函数int strcmp(char  *source, char *dest) 相等返回0，不等返回-1； 
答案：一、 int strcmp(char  *source, char *dest) {  assert((source!=NULL)&&(dest!=NULL));  int i,j;  for(i=0; source[i]==dest[i]; i++)  {  if(source[i]=='\0' && dest[i]=='\0')    return 0;  else    return -1;  } } 答案：二、 int strcmp(char *source, char *dest) {    while ( (*source != '\0') && (*source == *dest))    { source++; dest++;    }    return ( (*source) - (*dest) ) ? -1 : 0; } 
2、  写一函数int fun(char *p)判断一字符串是否为回文，是返回1，不是返回0，出错返回-1 答案：一、 int fun(char *p) {  if(p==NULL)  return -1;  else  {  int length = 0;  int i = 0;  int judge = 1;  length = strlen(p);  for(i=0; i <length/2; i++)  {    if(p[i]!=p[length-1-i])    judge = 0;    break;  }  if(judge == 0)    return 0;  else    return 1;  } } 答案：二、 int fun(char *p){ int len = strlen(p) - 1; char *q = p + len; if (!p) return -1; while (p < q) { if ((*p++) != (*q--)) return 0; } return 1;}  
华为笔试网络题（3） 2006-09-30 12:48 
1.在OSI 7 层模型中,网络层的功能有( ) A.确保数据的传送正确无误  B.确定数据包如何转发与路由 C.在信道上传送比特流    D.纠错与流控 
2.FDDI 使用的是___局域网技术。( ) A.以太网;    B.快速以太网;    C.令牌环;    D.令牌总线。 
3.下面那种LAN 是应用CSMA/CD协议的（) A.令牌环    B.FDDI    C.ETHERNET    D.NOVELL 
4.TCP 和UDP 协议的相似之处是 ( ) A.面向连接的协议    B.面向非连接的协议    C.传输层协议    D.以上均不对 5.应用程序PING 发出的是___报文.( ) A.TCP 请求报文。    B.TCP 应答报文。    C.ICMP 请求报文。  D.ICMP 应答报文。 
6.以下说法错误的是(多) ( ) A.中继器是工作在物理层的设备    B.集线器和以太网交换机工作在数据连路层 C.路由器是工作在网络层的设备    D.桥能隔离网络层广播 
7.当桥接收的分组的目的MAC地址在桥的映射表中没有对应的表项时,采取的策略是( ) A.丢掉该分组  B.将该分组分片    C.向其他端口广播该分组    D.以上答案均不对 
8.LAN Switch 在网络层次模型中的地位( ) A.物理层    B.链路层    C.网络层    D.以上都不是 
9.小于___的TCP/UDP端口号已保留与现有服务一一对应,此数字以上的端口号可自由分配。( ) A.199      B.100    C.1024      D.2048 
10.当一台主机从一个网络移到另一个网络时,以下说法正确的是 ( ) A.必须改变它的IP 地址和MAC 地址    B.必须改变它的IP 地址,但不需改动MAC 地址 C.必须改变它的MAC 地址,但不需改动IP 地址    D.MAC 地址.IP 地址都不需改动答案：1.B; 2.C; 3.C; 4.C; 5.C; 6.BD; 7.C; 8.B; 9.C; 10.B.  
华为笔试题（4） 2006-09-30 13:00 
1. 找错 void test1() {    char string[10];    char* str1="0123456789";    strcpy(string, str1); } 答：表面上并且编译都不会错误。但如果string数组原意表示的是字符串的话，那这个赋值就没有达到意图。最好定义为char string[11]，这样最后一个元素可以存储字符串结尾符'\0'; void test2() {    char string[10], str1[10];  for(int I=0; I <10;I++)  {    str1[I] ='a';  }  strcpy(string, str1); } 答：strcpy使用错误，strcpy只有遇到字符串末尾的'\0'才会结束，而str1并没有结尾标志，导致strcpy函数越界访问，不妨让str1[9]='\0'，这样就正常了。 void test3(char* str1) {    char string[10];    if(strlen(str1) <=10) {    strcpy(string, str1); } } 答：这又会出现第一道改错题的错误了。strlen(str1)算出来的值是不包含结尾符'\0'的，如果str1刚好为10个字符＋1结尾符，string就得不到结尾符了。可将strlen(str1) <=10改为strlen(str1) <10。 
2. 找错 #define MAX_SRM 256 DSN get_SRM_no() {    static int SRM_no;    int I;    for(I=0;I <MAX_SRM;I++,SRM_no++)  {    SRM_no %= MAX_SRM;    if(MY_SRM.state==IDLE)    {      break;    }  }  if(I>=MAX_SRM)    return (NULL_SRM);  else    return SRM_no; } 答：我不知道这段代码的具体功能，但明显有两个错误 1，SRM_no没有赋初值 2，由于static的声明，使该函数成为不可重入（即不可预测结果）函数，因为SRM_no变量放在程序的全局存储区中，每次调用的时候还可以保持原来的赋值。这里应该去掉static声明。 
3. 写出程序运行结果 int sum(int a) {    auto int c=0;    static int b=3;  c+=1;  b+=2;  return(a+b+c); }  void main() {    int I;  int a=2;  for(I=0;I <5;I++)  {    printf("%d,", sum(a));  } } 答：8,10,12,14,16 该题比较简单。只要注意b声明为static静态全局变量，其值在下次调用时是可以保持住原来的赋值的就可以。 
4. int func(int a) {    int b;    switch(a)    {        case 1: b=30;        case 2: b=20;        case 3: b=16;        default: b=0;    }    return b; } 则func(1)=? 答：func(1)=0，因为没有break语句，switch中会一直计算到b=0。这是提醒我们不要忘了break。呵呵。 
5:  int a[3];  a[0]=0; a[1]=1; a[2]=2;  int *p, *q;  p=a;  q=&a[2]; 则a[q-p]=? 答：a[q-p]=a[2]=2;这题是要告诉我们指针的运算特点 
6. 定义 int **a[3][4], 则变量占有的内存空间为：_____ 答：此处定义的是指向指针的指针数组，对于32位系统，指针占内存空间4字节，因此总空间为3×4×4＝48。 7. 编写一个函数，要求输入年月日时分秒，输出该年月日时分秒的下一秒。如输入2004年12月31日23时59分59秒，则输出2005年1月1日0时0分0秒。 答： /*输入年月日时分秒，输出年月日时分秒的下一秒，输出仍然在原内存空间*/ void NextMinute(int *nYear,int *nMonth,int *nDate,int *nHour,int *nMinute,int *nSecond) {  int nDays;  (*nSecond)++;  // 秒加1  if(*nSecond>=60)  // 秒满60，做出特殊处理，下面时，日，月等类同  {    *nSecond=0;    (*nMinute)++;    if(*nMinute>=60)    {      *nMinute=0;      (*nHour)++;      if(*nHour>=24)      {        *nHour=0;        (*nDate)++;        switch(*nMonth)        {          case 1:          case 3:          case 5:          case 7:          case 8:          case 10:          case 12:            nDays=31;          break;          case 2:// 判断闰年            if(*nYear%400==0 ¦ ¦*nYear%100!=0&&*nYear%4==0)            {            nDays=29;            }            else            {            nDays=28;            }          break;          default:            nDays=30;          break;        }        if(*nDate>nDays)        {          *nDate=1;          (*nMonth)++;          if(*nMonth>12)          {          *nMonth=1;          (*nYear)++;          }        }      }    }  } } /*示例可运行代码*/ void main() {  int nYear=2004,nMonth=12,nDate=31,nHour=59,nMinute=59,nSecond=59;  NextMinute(&nYear,&nMonth,&nDate,&nHour,&nMinute,&nSecond);  printf("The result:%d-%d-%d %d:%d:%d",nYear,nMonth,nDate,nHour,nMinute,nSecond); }    




嵌入式开发面试题2.txt﹃根网线''尽赚了多少人的青春い有时候感动的就是身边微不足道的小事。﹎破碎不是最残酷的	最残酷的是踩着这些碎片却假装不疼痛	固执的寻找﹎将来就算我遇见再怎么完美的人,都有一个缺点,他不是你,_____下辈子要做男生，娶一个像我这样的女生。●8086的堆栈采取向下生长的方式，在压入时__(41)__。 

（41）    A. SP 先减，再压入数据          B. 先压入数据，SP 再减 

C. SP 先加，再压入数据          D. 先压入数据，SP 再加

<解析>：考查8086堆栈的基础知识。个人觉得，堆栈是嵌入式的基础东西，自然就是考试重点，以后或许会多考单片机ARM的结构。

8086处理器均采用满递减堆栈。入栈时，先减地址，后进数据；出栈时，先出数据，后减地址。

PUSH SRL：先将栈顶指针SP向上移两位，即SP-2，指向一个新的字存储单元，再将操作数的内容存入SP所指的字存储单元。

POP DST：将当前栈顶指针SP所指向字单元内容送向DST，然后将SP下移两位，SP-2。

参考答案：A。

 


● 若对某一寄存器某几位清零，可用一条指令__(42)__处理。 
















今天老大让我针对一个面试者出些嵌入式方面的面试题，主要是想对他的技术深度进一步了解。我就出了下面这些问题，每个问题背后都是考察一个嵌入式程序员应该具备的相关技能。当然这些只是我的个人理解，不一定正确。在此与大家分享，只是希望朋友们能够得到一点点启发：如何抓住每一个契机展现你的与众不同？ 


同样的技术问题，很多人可能都能够回答得对，但有些人只是知其然而不知所以然。其实面试官每一个问题背后通常都隐藏着一个考察点。如果我们能够透过问题看到背后的实质，在回答出答案的时候还能够借机发挥，我相信90和100分的差别就出来了。哪个面试官不喜欢招一个喜欢思考、能透过现象看本质的员工呢～ 


下面我们来看看嵌入式C面试题背后到底藏何玄机～。以下仅是个人的一些想法，欢迎大家讨论，拍砖的轻点～～ 


//////////////////////////// 

1、 int a=2,b=11,c=a+b++/a++; 则c值为多少？

【考点】编码规范。

表面上考察你对运算符优先级的掌握程度，但实际上优先级这些玩意很难死记硬背得住？大家的疑惑不就是运算符的结合顺序么？那么如何去避免呢？c=a+((b++)/(a++))不就行了么，其实问题背后考察的是你的编码规范，如何写清晰易懂的代码，如何在一个团队中让自己的代码狠容易毫无偏差的让新人看懂～


2、 Static用在全局变量定义和函数内部局部变量定义有何区别？

【考点】编码规范及模块化设计。

Static变量的两个属性涉及存储位置及可见域。在大型的程序设计中static全局变量可以有效的避免名字空间的重复及无意的变量引用，这样可以有效的提高程序设计的安全性，同时也利用模块化作业


3、 在程序设计中哪些地方需要使用define？如何用define来定义一年内有多少小时的常量？

【考点】可移植性。

嵌入式程序设计的特点就是软硬件平台可变性，有效利用define常量可以提高程序的可移植性，这样改动方便，不易出错


4、 Define宏语句和inline函数有什么区别？

【考点】时空效率及宏的副作用。

嵌入式系统平台通常存储资源有限，但同时又对实时性有一定的要求，二者如何权衡需要考虑。Define宏语句相对于函数调用能提高运行时间性能，但消耗了空间，并且不标准的宏语句定义在不标准的编码中更容易出现副作用，因此inline函数则是define语句的完美替代品。小资金干大事正是嵌入式的终极目标！


5、 哪些地方可以用到const？const变量和函数输入参数用const修饰有哪些作用？

【考点】程序设计可靠性。

Const只读变量可以有效克服define常量的一些弊端，如无类型安全检查。Const形参可以有效避免程序内部更改无意的更改。人非圣贤孰能无误，所以我们要将这些可能的失误统统交给智能的编译器，这样就可以将错误扼杀在摇篮中


6、 Int，short，char在32位平台下各占几个字节？一个结构体含有int、short、char变量各一个，结构体占据的总内存空间多少？

【考点】跨平台移植。

嵌入式并非x86，其硬件平台具备很大的差异性，同为int在不同的架构体系下可能占据的字节数是不一样的。不同的平台也有不同的编译器，其在变量对齐方面可能有不同的特性。因此在结构体定义时如何设计成员变量的顺序以有效减少占据的内存空间，以及如何填充特定字段保证访问对齐问题，都是嵌入式系统结构体设计时应该考虑的跨平台可移植性问题


7、 如何将unsigned int明确定义为一个32位类型？define和typedef有何区别？

【考点】跨平台移植。

define和typedef都可以实现变量类型重定义，但是typedef类型的指针变量可以有效去除变量定义的二义性。在嵌入式的工程项目中，通常为了保证数据类型的统一且便于跨平台移植时修改数据类型方便，通常都会单独定义一个数据类型的头文件，把所有用到的数据类型typedef成所熟悉的形式


8、 有没有用过volatile？有哪些典型的适用场合？

【考点】编译优化的副作用。

通常为了提高程序运行的效率，编译器会自动进行一些优化，如将变量放在寄存器中，以减少存储器访问次数，在数据长期未变时不重新读取内存等等。但是优化有时会带来问题，如硬件寄存器、多任务共享变量、中断和主程序共享变量，优化有可能带来数据访问不一致性的问题，因此对于这些个别变量，我们需要用volatile声明告诉编译器取消优化


9、 参数传递有哪些形式？寄存器和堆栈传递各有什么优缺点？

【考点】编译优化、调用性能、接口设计。

每种体系结构及对应的编译器对参数传递都有自己的规定。参数传递并非总是通过堆栈进行的，参数入栈出栈是需要耗费时间的，编译器总是尽量优化利用寄存器来传递参数，因为寄存器的访问效率要高，但当参数过多时，将放弃优化从而用栈传递参数。因此为了提高调用性能，应尽量减少参数个数，太多时可以将所有参数重新定义为一个结构体，利用结构体指针来传递参数。在函数接口设计时应考虑硬件平台和编译器的特性，以灵活定义参数形式


10、 中断服务程序设计应注意的问题？中断触发方式的选择？中断处理太长怎么办？中断处理程序如何与主应用程序交互？

【考点】中断服务程序设计。

嵌入式程序最大的特点是经常需要和硬件打交道，中断是接收外界输入的典型方式，通常都决定了系统运行流程，因此如何高效不丢失的处理中断是每个嵌入式程序员应考虑的问题


11、 TCP/IP和OSI七层模型是如何划分的？各层的功能，这么设计有什么好处？

【考点】层次化软件设计保证可移植性。

分层模型最大的好处就是某一层变化了，只要其提供上层的接口未变，那么上层就无需做任何改动。因此只需要更改本层的实现即可。嵌入式平台因为软硬件多变性，为了最大限度的利用先前的成果，软件设计一定要遵循这种层次化模型，这样才能保证其可移植性


12、 TCP和UDP的区别？各种网络互连设备都用在哪一层？如何建立链接？如何进行拥塞控制？

【考点】协议设计可靠性及缓冲区设计管理。

TCP和UDP的最大区别在于可靠性，TCP通过三次握手协议及超时机制安全可靠的建立或者释放连接。协议设计最大的问题就是如何保证效率合可靠性，TCP的设计为我们提供了一个参考。而滑动窗口机制可以有效的进行拥塞控制，但窗口大小的设计则关系到内存利用率及缓冲效率可靠性等问题。在嵌入式的驱动程序设计中，经常会开辟缓冲区来进行流量控制及防止数据覆盖，缓冲区的大小设计则需要更加具体的应用情况设计才能保证可靠性合灵活性

（42）A. AND        B. OR        C. NOT           D. XOR 

<解析>：考查汇编语言的基础知识，简单到极点了，这个分数拿不到，基本过不了。

AND（与）：有0为0。

OR（或）：有1为1。

NOT（非）：取反。

XOR（异或）：相同为0，不同为1。

要对寄存器的某几位清零，应用AND。

例如对11011010的中间四位清零：11011010 AND 11000011 得11000010。

个人认为：用XOR指令，一条指令是做不到的，实际中不可取。

参考答案：A。

 

● 指令周期是指__(43)__。 

（43）    A. CPU 从主存取出一条指令的时间 

B. CPU 执行一条指令的时间 

C. CPU 从主存取出一条指令加上执行该条指令的时间 

D. 时钟周期的时间 

<解析>：考嵌入式最最基本的概念了，记住就行，这个分数必拿。

指令周期：CPU从内存取出一条指令并执行这条指令的时间总和。

包括取指令，分析指令，执行指令整个过程。

       <补充>：时钟周期、机器周期、指令周期的概念辨析。

       时钟周期：时序中的最小单位，就是1/fosc。例如：晶振为12MHz，那么时钟周期为1/12us。

       机器周期：完成某一规定操作所需的时间，通常由若干时钟周期构成。例如：单片机是12周期的话，那么在12MHz晶振的情况下，其机器周期为1us。

       指令周期：完成一条指令的所有时间。例如RET是一个2周期指令，在上述的条件下，它的指令周期为2us。

参考答案：C。

 

●在汇编过程中，不产生机器码，只用来指示汇编程序如何汇编的指令是__(44)__。  

（44）A. 宏指令      B. 伪指令          C. 汇编指令      D. 机器指令 

<解析>：考查汇编语言的基础知识。

不想多说了，太简单了，自己看看概念吧。

或者这样记住：伪指令就是假的指令，假得指令是给人看的，不是给机器看的，所以机器不能产生代码。

注意一下宏指令的用法，说不好下次就考了。

参考答案：B。

 

●在8086微处理器中，若(SS) = 2000H，(SP) = 0100H，(AX) = 2107H，执行指令PUSH AX 后存放数据21H 的物理地址是__(45)__。 

（45）A. 20102H      B. 20101H          C. 200FEH      D. 200FFH 

<解析>：这道题目不容易，需要对X86汇编语言有深入的理解，拿不到分就算了。

41题是会做对这道题目的基础。由41题可知，8086的堆栈数据操作是，SP先减，再压入数据，以字为单位对堆栈操作。

因此压入数据时的起始SP应为0100H-2=00FEH。而8086中数据采用小端模式存取，即一个字数据中低字节存放低位地址。（X86越向上的地址越小）

8086逻辑地址到物理地址的形成机制为：物理地址=段地址*16+偏移地址(或物理地址=段地址左移4位+偏移地址)。压栈后，内容存储的物理地址为2000*16+00FEH=200FE，21H是AX中的高位，其存储位置为200FFH。

参考答案：D。

 

● 在串行通信中，根据数据传输方向不同，可以分成三种方式，不包括__(46)__方式。 

（46）A. 单工      B. 双工                  C. 半单工              D. 半双工 

<解析>：考查接口通信的基础知识。

没有必要多说，是我们搞嵌入式必须知道的基本常识。

什么是单工、双工、半双工得搞搞清楚。

参考答案：C。

 

● 寄存器间接寻址方式中，操作数处在__(47)__。 

（47）A. 通用寄存器      B. 主存单元          C. 程序计数器       D. 堆栈

<解析>：考查寻址方式的基础概念，需要有一点的理解，但是其选项会让很多人答对。

简单来说，寄存器间接寻址方式是说，指令的寄存器的内容不是操作数，而是操作数的偏移地址，操作数本身则在存储器中。

参考答案：B。

 

●  IEEE 1394具有__(48)__位地址空间，IEEE 1394的通信协议具有三个协议层，下面不属于这三个协议层的是__(49)__。 

（48）A. 8          B. 16         C. 32                D. 64 

（49）A. 事务层         B. 表示层       C. 链路层            D. 物理层 

<解析>：考查接口技术中1394的基本知识。

参考《教程》219-221页。

1394总线类似于PCI总线，任何设备可以在64位地址空间内进行读写操作。

一条1394总线可以接入63个设备，支持同步和异步两种串行传输方式。

1394的协议由3层组成：物理层、链路层、事务层。

参考答案：D、B。

 

● 在软件测试中，白盒测试是基于设计的和基于__(50)__测试。 

（50）A. 需求的       B. 代码的      C. 提炼的          D. 反常的或极端的

<解析>：考查软件测试的基本知识。

参考《教程》405-410页，在2007年考试中，下午考了一道这方面的题目，要注意。

机器测试分为黑盒测试和白盒测试。

黑盒测试也称为功能测试。

白盒测试也称为结构测试。

白盒测试，将软件看成透明的白盒，根据程序内部结构和逻辑来设计测试用例，对程序的路径和过程进行测试，检查是否满足设计的需要。

通过白盒测试，测试人员可以很清楚已经有多少代码被检查过了，可以准确地预测出系统中的程序设计错误的数量规模。

参考答案：B。


















下面的题目必须全部答对才给分：
1、 如何在C中初始化一个字符数组。
2、 如何在C中为一个数组分配空间。
3、 如何初始化一个指针数组。
4、如何定义一个有10个元素的整数型指针数组。
5、 s[10]的另外一种表达方式是什么。
6、 GCC3.2.2版本中支持哪几种编程语言。
7、 要使用CHAR_BIT需要包含哪个头文件。
8、 对(-1.2345)取整是多少？
9、 如何让局部变量具有全局生命期。
10、C中的常量字符串应在何时定义？
11、如何在两个.c文件中引用对方的变量。
12、使用malloc之前需要做什么准备工作。
13、realloc函数在使用上要注意什么问题。
14、strtok函数在使用上要注意什么问题。
15、gets函数在使用上要注意什么问题。
16、C语言的词法分析在长度规则方面采用的是什么策略？
17、a+++++b所表示的是什么意思？有什么问题？
18、如何定义Bool变量的TRUE和FALSE的值。
19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。

这部分是ANSI C的一些问题，题目的前提是必须都答对，看似很变态，但是细想一下，这些都是最基础的，虽然我们在使用他们的时候会犯这样那样的错误，但是最终目的是不犯错误，不是么，那么好，从最基础的开始。



1、 如何在C中初始化一个字符数组。
这个问题看似很简单，但是我们要将最简单的问题用最严谨的态度来对待。关键的地方：初始化、字符型、数组。最简单的方法是char array[];。这个问题看似解决了，但是在初始化上好像还欠缺点什么，个人认为：char array[5]={'1','2','3','4','5'};或者char array[5]={"12345"};或者char array[2][10]={"China","Beijing"};也许更符合“初始化”的意思。



2、 如何在C中为一个数组分配空间。
最简单的方法是：char array[5]；意思是分配给数组array一个5个字节的空间。但是我们要知道在C中数组其实就是一个名字，其实质含义就是指针，比如char array[]；是到底分配的多少空间？所以我们要将其分成为两种不同的形式给出答案：
一种是栈的形式：char array[5]；
一种是堆的形式：char *array; array=(char *)malloc(5);//C++: array=new char[5];
堆和栈的含义其实我也没弄太透彻，改天明白了再发一篇。
我们要明白的是，第一种形式空间分配的大小可能会受操作系统的限制,比如windows会限制在2M；第二种形式成空间分配很灵活，想分配多少分配多少，只要RAM够大。



3、 如何初始化一个指针数组。
首先明确一个概念，就是指向数组的指针，和存放指针的数组。
指向数组的指针：char (*array)[5];含义是一个指向存放5个字符的数组的指针。
存放指针的数组：char *array[5];含义是一个数组中存放了5个指向字符型数据的指针。
按照题意，我理解为初始化一个存放指针的数组，char *array[2]={"China","Beijing"}；其含义是初始化了一个有两个指向字符型数据的指针的数组，这两个指针分别指向字符串"China"和"Beijing"。



4、如何定义一个有10个元素的整数型指针数组。
既然只是定义而不是初始化，那就很简单且没有争议了：int *array[10];。



5、 s[10]的另外一种表达方式是什么。
前面说过了，数组和指针其实是数据存在形态的两种表现形式，如果说对于数组s[]，我们知道*s=s[0]，那么s[10]的另一种表达方式就是：*(s+10)。



6、 GCC3.2.2版本中支持哪几种编程语言。
这个问题实在变态，就像问你#error的作用是什么一样。不可否认，gcc是linux下一个亮点，是一个备受无数程序员推崇的编译器，其优点省略 1000字，有兴趣可以自己查，我翻了翻书，书上曰：支持C,C++,Java,Obj-C,Ada,Fortran,Pascal,Modula-3等语言，这个“等”比较要命，不过我认为已经很全了，如果认为还是不全，干脆把ASM也加上算了，不过那已经不算是编译了。



7、 要使用CHAR_BIT需要包含哪个头文件。
如果结合上面的问题，答题的人估计会认为自己撞鬼了，这个问题实在是……搜索了一下，应该是limits.h。



8、 对(-1.2345)取整是多少？
其实不同的取整函数可能有不同的结果，不过这个数没有太大的争议，答案是-1。



9、 如何让局部变量具有全局生命期。
具体的生命期的概念我觉得我还要好好深入的学习一下，但是这个题目还算比较简单，即用static修饰就可以了，但是只是生命期延长，范围并没有扩大，除非把这个变量定义在函数体外的静态区，不过那样就变成全局变量了，仿佛不符合题目要求。



10、C中的常量字符串应在何时定义？
这个问题说实话不是很理解题干的意思，据我理解，有两种情况，一种是预处理阶段，用#define定义；还有就是使用const修饰词，不过const修饰的是一个变量，其含义是“只读”，称之为常量并不准确，但是确实可以用操作变量的方法当常量用。所以还是第一种比较靠谱。



11、如何在两个.c文件中引用对方的变量。
这个问题也问的挺含糊的，怎么说呢，最简单最直接的方法是为变量添加extern修饰词，当然，这个变量必须是全局变量。还有一种就是利用函数调用来进行变量的间接引用，比如这个C文件中的一个函数引用另外一个C中的函数，将变量通过实参的形式传递过去。不过题目既然说是引用，那么还是用第一个答案好了。



12、使用malloc之前需要做什么准备工作。
其实准备工作很多啊，比如你需要一台计算机之类的。玩笑话，我们首先要知道malloc的用途，简单的说就是动态的分配一段空间，返回这段空间的头指针。实际的准备工作可以这么分：需要这段空间的指针是否存在，若不存在，则定义一个指针用来被赋值，还要清楚要返回一个什么类型的指针，分配的空间是否合理；如果指针已经存在，那么在重新将新的空间头地址赋值给这个指针之前，要先判断指针是否为NULL，如果不是要free一下，否则原来的空间就会被浪费，或者出错，free之后就按照前一种情形考虑就可以了。



13、realloc函数在使用上要注意什么问题。
这个函数我也才知道的，汗一个。据我的初步理解，这个函数的作用是重新分配空间大小，返回的头指针不变，只是改变空间大小。既然是改变，就有变大、变小和为什么改变的问题。变大，要注意不能大到内存溢出；变小，那变小的那部分空间会被征用，原有数据不再存在；为什么改变，如果是想重新挪作他用，还是先 free了吧。



14、strtok函数在使用上要注意什么问题。
这个问题我不知道能不能回答全面，因为实在是用的很少。这个函数的作用是分割字符串，但是要分割的字符串不能是常量，这是要注意的。比如先定义一个字符串：char array[]="part1,part2";，strtok的原形是char *strtok(char *string, char *delim);，我们将","作为分隔符，先用pt=strtok(array,",");，得到的结果print出来就是"part1"，那后面的呢，要写成pt=strtok(NULL,",");，注意，要用NULL，如果被分割的字符串会被分成N段，那从第二次开始就一直要用NULL。总结起来，需要注意的是：被分割的字符串和分隔符都要使用变量；除第一次使用指向字符串的指针外，之后的都要使用NULL；注意使用这个函数的时候千万别把指针跟丢了，不然就全乱了。



15、gets函数在使用上要注意什么问题。
这是一个键盘输入函数，将输入字符串的头地址返回。说到要注意的问题，我还是先查了一下网上的一些情况，需要注意的就是gets以输入回车结束，这个地球人都知道，但是很多人不知道的是，当你输入完一个字符串后，这个字符串可能依然存在于这个标准输入流之中，当再次使用gets的时候，也许会把上次输入的东西读出来，所以应该在使用之后用fflush(stdin);处理一下，将输入流清空。最后也还是要注意溢出的问题。关于这个答案我比较含糊，不知道有没有高人高见？



16、C语言的词法分析在长度规则方面采用的是什么策略？
我无语……闻所未闻啊……还是搜索了一下，有一篇文章，地址是：http://202.117.80.9/jp2005/20/kcwz/wlkc/wlkc/03/3_5_2.htm，是关于词法分析器的。其中提到了两点策略： (1) 按最长匹配原则确定被选的词型；(2) 如果一个字符串能为若干个词型匹配，则排列在最前面的词型被选中。不知道是不是题干的要求，还是其他什么。我乃一介草民，望达人指点迷津！



17、a+++++b所表示的是什么意思？有什么问题？
这个东西（称之为东西一点都不过分）其实并没有语法错误，按照C对运算符等级的划分，++的优先级大于+，那么这句话会被编译器看做：(a++)+(++ b)，这回明白了吧。有什么问题，语法上没有问题，有的是道德上的问题！作为一个优秀的程序员，我们要力求语句的合法性和可读性，如果写这句的人是在一个 team里，那么他基本会被打的半死……最后讨论一下结果：假设a之前的值是3，b是4，那么运行完这个变态语句后，a的值是4，b是5，语句的结果是 8。



18、如何定义Bool变量的TRUE和FALSE的值。
不知道这个题有什么陷阱，写到现在神经已经大了，一般来说先要把TURE和FALSE给定义了，使用#define就可以：
#define TURE 1
#define FALSE 0
如果有一个变量需要定义成bool型的，举个例子：bool a=TURE;就可以了。



19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
首先，这个题干抽了10题回答的一个大嘴巴。关于常量的概念看来我要好好看看书了……我说过了，const修饰词可以将一个变量修饰为“只读”，这个就能称为常量么？姑且认为可以。回到题目中，const是只读的意思，它限定一个变量不允许被改变，谁都不能改！既然是修饰变量，那么变量的类型就可以丰富多彩，int啊，char啊，只要C认识的都可以；但是#define就不可以了，在预处理阶段缺乏类型检测机制，有可能会出错。还有就是变量可以 extern，但是#define就不可以。貌似const还可以节省RAM，这个我倒是没有考证过。至于const的用法和作用，有很多，我会总结后发上来。



20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。
终于最后一题了，容易么……如果这个测试是一个关于嵌入式的，那么这道题非常重要！！从词面上讲，volatile的意思是易变的，也就是说，在程序运行过程中，有一些变量可能会被莫名其妙的改变，而优化器为了节约时间，有时候不会重读这个变量的真实值，而是去读在寄存器的备份，这样的话，这个变量的真实值反而被优化器给“优化”掉了，用时髦的词说就是被“和谐”了。如果使用了这个修饰词，就是通知编译器别犯懒，老老实实去重新读一遍！可能我说的太“通俗”了，那么我引用一下“大师”的标准解释：
volatile的本意是“易变的” 。
由于访问寄存器的速度要快过RAM,所以编译器一般都会作减少存取外部RAM的优化，但有可能会读脏数据。当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。

好了，答完了，也不知道标准答案是什么。如果有达人看到皱眉头的话，千万停下来，浪费您宝贵的几分钟时间指点一二，不胜感激！



在网上看到了一篇嵌入式的面试题，忽然觉得自己很渺小……在未来一段时间内我会陆续贴上我的答案，当然可能有些我做不出来，做出来的也不一定准确，在检验和提高自己的同时，希望有走过路过高人指点一二。

下面的题目必须全部答对才给分：
1、 如何在C中初始化一个字符数组。
2、 如何在C中为一个数组分配空间。
3、 如何初始化一个指针数组。
4、如何定义一个有10个元素的整数型指针数组。
5、 s[10]的另外一种表达方式是什么。
6、 GCC3.2.2版本中支持哪几种编程语言。
7、 要使用CHAR_BIT需要包含哪个头文件。
8、 对(-1.2345)取整是多少？
9、 如何让局部变量具有全局生命期。
10、C中的常量字符串应在何时定义？
11、如何在两个.c文件中引用对方的变量。
12、使用malloc之前需要做什么准备工作。
13、realloc函数在使用上要注意什么问题。
14、strtok函数在使用上要注意什么问题。
15、gets函数在使用上要注意什么问题。
16、C语言的词法分析在长度规则方面采用的是什么策略？
17、a+++++b所表示的是什么意思？有什么问题？
18、如何定义Bool变量的TRUE和FALSE的值。
19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。

这部分是ANSI C的一些问题，题目的前提是必须都答对，看似很变态，但是细想一下，这些都是最基础的，虽然我们在使用他们的时候会犯这样那样的错误，但是最终目的是不犯错误，不是么，那么好，从最基础的开始。



1、 如何在C中初始化一个字符数组。
这个问题看似很简单，但是我们要将最简单的问题用最严谨的态度来对待。关键的地方：初始化、字符型、数组。最简单的方法是char array[];。这个问题看似解决了，但是在初始化上好像还欠缺点什么，个人认为：char array[5]={'1','2','3','4','5'};或者char array[5]={"12345"};或者char array[2][10]={"China","Beijing"};也许更符合“初始化”的意思。



2、 如何在C中为一个数组分配空间。
最简单的方法是：char array[5]；意思是分配给数组array一个5个字节的空间。但是我们要知道在C中数组其实就是一个名字，其实质含义就是指针，比如char array[]；是到底分配的多少空间？所以我们要将其分成为两种不同的形式给出答案：
一种是栈的形式：char array[5]；
一种是堆的形式：char *array; array=(char *)malloc(5);//C++: array=new char[5];
堆和栈的含义其实我也没弄太透彻，改天明白了再发一篇。
我们要明白的是，第一种形式空间分配的大小可能会受操作系统的限制,比如windows会限制在2M；第二种形式成空间分配很灵活，想分配多少分配多少，只要RAM够大。



3、 如何初始化一个指针数组。
首先明确一个概念，就是指向数组的指针，和存放指针的数组。
指向数组的指针：char (*array)[5];含义是一个指向存放5个字符的数组的指针。
存放指针的数组：char *array[5];含义是一个数组中存放了5个指向字符型数据的指针。
按照题意，我理解为初始化一个存放指针的数组，char *array[2]={"China","Beijing"}；其含义是初始化了一个有两个指向字符型数据的指针的数组，这两个指针分别指向字符串"China"和"Beijing"。



4、如何定义一个有10个元素的整数型指针数组。
既然只是定义而不是初始化，那就很简单且没有争议了：int *array[10];。



5、 s[10]的另外一种表达方式是什么。
前面说过了，数组和指针其实是数据存在形态的两种表现形式，如果说对于数组s[]，我们知道*s=s[0]，那么s[10]的另一种表达方式就是：*(s+10)。



6、 GCC3.2.2版本中支持哪几种编程语言。
这个问题实在变态，就像问你#error的作用是什么一样。不可否认，gcc是linux下一个亮点，


1、将一个字符串逆序 
2、将一个链表逆序 
3、计算一个字节里（byte）里面有多少bit被置1 
4、搜索给定的字节(byte) 
5、在一个字符串中找到可能的最长的子字符串 
6、字符串转换为整数 
7、整数转换为字符串
/*
* 题目：将一个字符串逆序
* 完成时间：2006.9.30深圳极讯网吧
* 版权归刘志强所有
* 描述：写本程序的目的是希望练一下手，希望下午去面试能成功，不希望国庆节之后再去找工作拉！
*/
#include <iostream>
using namespace std;
//#define NULL ((void *)0)
char * mystrrev(char * const dest,const char * const src)
{
if (dest==NULL && src==NULL)
   return NULL;
char *addr = dest;
int val_len = strlen(src);
dest[val_len] = '\0';
int i;
for (i=0; i<val_len; i++)
{
   *(dest+i) = *(src+val_len-i-1);  
}

return addr;


}
main()
{
char *str="asdfa";
char *str1=NULL;
str1 = (char *)malloc(20);
if (str1 == NULL)
   cout<<"malloc failed";

cout<<mystrrev(str1,str);
free(str1);
str1=NULL;//杜绝野指针
}
p=head; 
q=p->next; 
while(q!=NULL) 
{ 
temp=q->next; 
q->next=p; 
p=q; 
q=temp; 
} 
这样增加个辅助的指针就行乐。
ok 通过编译的代码： 
#include <stdio.h> 
#include <ctype.h> 
#include <stdlib.h> 

typedef struct List{ 
int data; 
struct List *next; 
}List; 

List *list_create(void) 
{ 
struct List *head,*tail,*p; 
int e; 
head=(List *)malloc(sizeof(List)); 
tail=head; 
printf("\nList Create,input numbers(end of 0):"); 
scanf("%d",&e); 
while(e){ 
p=(List *)malloc(sizeof(List)); 
p->data=e; 
tail->next=p; 
tail=p; 
scanf("%d",&e);} 

tail->next=NULL; 
return head; 
} 

List *list_reverse(List *head) 
{ 
List *p,*q,*r; 
p=head; 
q=p->next; 
while(q!=NULL) 
{ 
r=q->next; 
q->next=p; 
p=q; 
q=r; 
} 

head->next=NULL; 
head=p; 
return head; 
} 

void main(void) 
{ 
struct List *head,*p; 
int d; 
head=list_create(); 
printf("\n"); 
for(p=head->next;p;p=p->next) 
printf("--%d--",p->data); 

head=list_reverse(head); 
printf("\n"); 
for(p=head;p->next;p=p->next) 
printf("--%d--",p->data); 
}
       编写函数数N个BYTE的数据中有多少位是1。
解：此题按步骤解：先定位到某一个BYTE数据；再计算其中有多少个1。叠加得解。

#incluede<iostream>
#define N 10
//定义BYTE类型别名
#ifndef BYTE
typedef unsigned char BYTE;
#endif

int comb(BYTE b[],int n)
{
int count=0;
int bi,bj;
BYTE cc=1,tt;

//历遍到第bi个BYTE数据
for(bi=0;bi<n;bi++)
{
//计算该BYTE的8个bit中有多少个1
tt=b[bi];
       for(bj=0;bj<8;bj++)
{
         //与1相与或模2结果是否是1？测试当前bit是否为1
         //if(tt%2==1)
       if((tt&cc)==1)
{
            count++;
         }
         //右移一位或除以2，效果相同
//tt=tt>>1;
tt=tt/2;
}
}
return count;
}

//测试
int main()
{
BYTE b[10]={3,3,3,11,1,1,1,1,1,1};
cout<<comb(b,N)<<endl;
return 0;
}
1。编写一个 C 函数，该函数在一个字符串中找到可能的最长的子字符串，且该字符串是由同一字符组成的。
char * search(char *cpSource, char ch)
{
char *cpTemp=NULL, *cpDest=NULL;
int iTemp, iCount=0;
while(*cpSource)
{
if(*cpSource == ch)
{
iTemp = 0;
cpTemp = cpSource;
while(*cpSource == ch) 
++iTemp, ++cpSource;
if(iTemp > iCount) 
iCount = iTemp, cpDest = cpTemp;
if(!*cpSource) 
break;
}
++cpSource;
}
return cpDest;
}
#include <stdio.h>
#include <string.h>
//
// 自定义函数MyAtoI
// 实现整数字符串转换为证书输出
// 程序不检查字符串的正确性,请用户在调用前检查
//
int MyAtoI(char str[])
{
int i;
int weight = 1; // 权重
int rtn = 0; // 用作返回
for(i = strlen(str) - 1; i >= 0; i--)
{
   rtn += (str[i] - '0')* weight; // 
   weight *= 10; // 增重
}
return rtn;
}
void main()
{
char str[32];
printf("Input a string :");
gets(str);
printf("%d\n", MyAtoI(str));
}
#include<stdio.h>
#include<string.h>
void reverse(char s[]) 
{   //字符串反转 
    int c, i=0, j; 
    for(j=strlen(s)-1;i<j;j--) 
    {    c=s[i]; 
        s[i]=s[j]; 
        s[j]=c; 
        i++; 
    } 
}
void IntegerToString(char s[],int n) 
{    int i=0,sign; 
    if((sign=n)<0)//如果是负数，先转成正数   
        n=-n; 
    do //从个位开始变成字符,直到最高位,最后应该反转 
    {    s[i++]=n%10+'0'; 
    }while((n=n/10)>0); 
    //如果是负数，补上负号 
    if(sign<0) 
        s[i++]='-'; 
    s[i]='\0';//字符串结束 
    reverse(s); 
} 
void main()
{    int m;
    char c[100];
    printf("请输入整数m: ");
    scanf("%d",&m);
    IntegerToString(c,m);
    printf("integer = %d string = %s\n", m, c);
}


2、将一个链表逆序 
3、计算一个字节里（byte）里面有多少bit被置1 
4、搜索给定的字节(byte) 
5、在一个字符串中找到可能的最长的子字符串 
6、字符串转换为整数 
7、整数转换为字符串
/*
* 题目：将一个字符串逆序
* 完成时间：2006.9.30深圳极讯网吧
* 版权归刘志强所有
* 描述：写本程序的目的是希望练一下手，希望下午去面试能成功，不希望国庆节之后再去找工作拉！
*/
#include <iostream>
using namespace std;
//#define NULL ((void *)0)
char * mystrrev(char * const dest,const char * const src)
{
if (dest==NULL && src==NULL)
   return NULL;
char *addr = dest;
int val_len = strlen(src);
dest[val_len] = '\0';
int i;
for (i=0; i<val_len; i++)
{
   *(dest+i) = *(src+val_len-i-1);  
}

return addr;


}
main()
{
char *str="asdfa";
char *str1=NULL;
str1 = (char *)malloc(20);
if (str1 == NULL)
   cout<<"malloc failed";

cout<<mystrrev(str1,str);
free(str1);
str1=NULL;//杜绝野指针
}
p=head; 
q=p->next; 
while(q!=NULL) 
{ 
temp=q->next; 
q->next=p; 
p=q; 
q=temp; 
} 
这样增加个辅助的指针就行乐。
ok 通过编译的代码： 
#include <stdio.h> 
#include <ctype.h> 
#include <stdlib.h> 

typedef struct List{ 
int data; 
struct List *next; 
}List; 

List *list_create(void) 
{ 
struct List *head,*tail,*p; 
int e; 
head=(List *)malloc(sizeof(List)); 
tail=head; 
printf("\nList Create,input numbers(end of 0):"); 
scanf("%d",&e); 
while(e){ 
p=(List *)malloc(sizeof(List)); 
p->data=e; 
tail->next=p; 
tail=p; 
scanf("%d",&e);} 

tail->next=NULL; 
return head; 
} 

List *list_reverse(List *head) 
{ 
List *p,*q,*r; 
p=head; 
q=p->next; 
while(q!=NULL) 
{ 
r=q->next; 
q->next=p; 
p=q; 
q=r; 
} 

head->next=NULL; 
head=p; 
return head; 
} 

void main(void) 
{ 
struct List *head,*p; 
int d; 
head=list_create(); 
printf("\n"); 
for(p=head->next;p;p=p->next) 
printf("--%d--",p->data); 

head=list_reverse(head); 
printf("\n"); 
for(p=head;p->next;p=p->next) 
printf("--%d--",p->data); 
}
       编写函数数N个BYTE的数据中有多少位是1。
解：此题按步骤解：先定位到某一个BYTE数据；再计算其中有多少个1。叠加得解。

#incluede<iostream>
#define N 10
//定义BYTE类型别名
#ifndef BYTE
typedef unsigned char BYTE;
#endif

int comb(BYTE b[],int n)
{
int count=0;
int bi,bj;
BYTE cc=1,tt;

//历遍到第bi个BYTE数据
for(bi=0;bi<n;bi++)
{
//计算该BYTE的8个bit中有多少个1
tt=b[bi];
       for(bj=0;bj<8;bj++)
{
         //与1相与或模2结果是否是1？测试当前bit是否为1
         //if(tt%2==1)
       if((tt&cc)==1)
{
            count++;
         }
         //右移一位或除以2，效果相同
//tt=tt>>1;
tt=tt/2;
}
}
return count;
}

//测试
int main()
{
BYTE b[10]={3,3,3,11,1,1,1,1,1,1};
cout<<comb(b,N)<<endl;
return 0;
}
1。编写一个 C 函数，该函数在一个字符串中找到可能的最长的子字符串，且该字符串是由同一字符组成的。
char * search(char *cpSource, char ch)
{
char *cpTemp=NULL, *cpDest=NULL;
int iTemp, iCount=0;
while(*cpSource)
{
if(*cpSource == ch)
{
iTemp = 0;
cpTemp = cpSource;
while(*cpSource == ch) 
++iTemp, ++cpSource;
if(iTemp > iCount) 
iCount = iTemp, cpDest = cpTemp;
if(!*cpSource) 
break;
}
++cpSource;
}
return cpDest;
}
#include <stdio.h>
#include <string.h>
//
// 自定义函数MyAtoI
// 实现整数字符串转换为证书输出
// 程序不检查字符串的正确性,请用户在调用前检查
//
int MyAtoI(char str[])
{
int i;
int weight = 1; // 权重
int rtn = 0; // 用作返回
for(i = strlen(str) - 1; i >= 0; i--)
{
   rtn += (str[i] - '0')* weight; // 
   weight *= 10; // 增重
}
return rtn;
}
void main()
{
char str[32];
printf("Input a string :");
gets(str);
printf("%d\n", MyAtoI(str));
}
#include<stdio.h>
#include<string.h>
void reverse(char s[]) 
{   //字符串反转 
    int c, i=0, j; 
    for(j=strlen(s)-1;i<j;j--) 
    {    c=s[i]; 
        s[i]=s[j]; 
        s[j]=c; 
        i++; 
    } 
}
void IntegerToString(char s[],int n) 
{    int i=0,sign; 
    if((sign=n)<0)//如果是负数，先转成正数   
        n=-n; 
    do //从个位开始变成字符,直到最高位,最后应该反转 
    {    s[i++]=n%10+'0'; 
    }while((n=n/10)>0); 
    //如果是负数，补上负号 
    if(sign<0) 
        s[i++]='-'; 
    s[i]='\0';//字符串结束 
    reverse(s); 
} 
void main()
{    int m;
    char c[100];
    printf("请输入整数m: ");
    scanf("%d",&m);
    IntegerToString(c,m);
    printf("integer = %d string = %s\n", m, c);
}


嵌入式笔试题.txt30生命的美丽，永远展现在她的进取之中；就像大树的美丽，是展现在它负势向上高耸入云的蓬勃生机中；像雄鹰的美丽，是展现在它搏风击雨如苍天之魂的翱翔中；像江河的美丽，是展现在它波涛汹涌一泻千里的奔流中。1、将一个字符串逆序 
2、将一个链表逆序 
3、计算一个字节里（byte）里面有多少bit被置1 
4、搜索给定的字节(byte) 
5、在一个字符串中找到可能的最长的子字符串 
6、字符串转换为整数 
7、整数转换为字符串
/*
* 题目：将一个字符串逆序
* 完成时间：2006.9.30深圳极讯网吧
* 版权归刘志强所有
* 描述：写本程序的目的是希望练一下手，希望下午去面试能成功，不希望国庆节之后再去找工作拉！
*/
#include <iostream>
using namespace std;
//#define NULL ((void *)0)
char * mystrrev(char * const dest,const char * const src)
{
if (dest==NULL && src==NULL)
   return NULL;
char *addr = dest;
int val_len = strlen(src);
dest[val_len] = '\0';
int i;
for (i=0; i<val_len; i++)
{
   *(dest+i) = *(src+val_len-i-1);  
}

return addr;


}
main()
{
char *str="asdfa";
char *str1=NULL;
str1 = (char *)malloc(20);
if (str1 == NULL)
   cout<<"malloc failed";

cout<<mystrrev(str1,str);
free(str1);
str1=NULL;//杜绝野指针
}
p=head; 
q=p->next; 
while(q!=NULL) 
{ 
temp=q->next; 
q->next=p; 
p=q; 
q=temp; 
} 
这样增加个辅助的指针就行乐。
ok 通过编译的代码： 
#include <stdio.h> 
#include <ctype.h> 
#include <stdlib.h> 

typedef struct List{ 
int data; 
struct List *next; 
}List; 

List *list_create(void) 
{ 
struct List *head,*tail,*p; 
int e; 
head=(List *)malloc(sizeof(List)); 
tail=head; 
printf("\nList Create,input numbers(end of 0):"); 
scanf("%d",&e); 
while(e){ 
p=(List *)malloc(sizeof(List)); 
p->data=e; 
tail->next=p; 
tail=p; 
scanf("%d",&e);} 

tail->next=NULL; 
return head; 
} 

List *list_reverse(List *head) 
{ 
List *p,*q,*r; 
p=head; 
q=p->next; 
while(q!=NULL) 
{ 
r=q->next; 
q->next=p; 
p=q; 
q=r; 
} 

head->next=NULL; 
head=p; 
return head; 
} 

void main(void) 
{ 
struct List *head,*p; 
int d; 
head=list_create(); 
printf("\n"); 
for(p=head->next;p;p=p->next) 
printf("--%d--",p->data); 

head=list_reverse(head); 
printf("\n"); 
for(p=head;p->next;p=p->next) 
printf("--%d--",p->data); 
}
       编写函数数N个BYTE的数据中有多少位是1。
解：此题按步骤解：先定位到某一个BYTE数据；再计算其中有多少个1。叠加得解。

#incluede<iostream>
#define N 10
//定义BYTE类型别名
#ifndef BYTE
typedef unsigned char BYTE;
#endif

int comb(BYTE b[],int n)
{
int count=0;
int bi,bj;
BYTE cc=1,tt;

//历遍到第bi个BYTE数据
for(bi=0;bi<n;bi++)
{
//计算该BYTE的8个bit中有多少个1
tt=b[bi];
       for(bj=0;bj<8;bj++)
{
         //与1相与或模2结果是否是1？测试当前bit是否为1
         //if(tt%2==1)
       if((tt&cc)==1)
{
            count++;
         }
         //右移一位或除以2，效果相同
//tt=tt>>1;
tt=tt/2;
}
}
return count;
}

//测试
int main()
{
BYTE b[10]={3,3,3,11,1,1,1,1,1,1};
cout<<comb(b,N)<<endl;
return 0;
}
1。编写一个 C 函数，该函数在一个字符串中找到可能的最长的子字符串，且该字符串是由同一字符组成的。
char * search(char *cpSource, char ch)
{
char *cpTemp=NULL, *cpDest=NULL;
int iTemp, iCount=0;
while(*cpSource)
{
if(*cpSource == ch)
{
iTemp = 0;
cpTemp = cpSource;
while(*cpSource == ch) 
++iTemp, ++cpSource;
if(iTemp > iCount) 
iCount = iTemp, cpDest = cpTemp;
if(!*cpSource) 
break;
}
++cpSource;
}
return cpDest;
}
#include <stdio.h>
#include <string.h>
//
// 自定义函数MyAtoI
// 实现整数字符串转换为证书输出
// 程序不检查字符串的正确性,请用户在调用前检查
//
int MyAtoI(char str[])
{
int i;
int weight = 1; // 权重
int rtn = 0; // 用作返回
for(i = strlen(str) - 1; i >= 0; i--)
{
   rtn += (str[i] - '0')* weight; // 
   weight *= 10; // 增重
}
return rtn;
}
void main()
{
char str[32];
printf("Input a string :");
gets(str);
printf("%d\n", MyAtoI(str));
}
#include<stdio.h>
#include<string.h>
void reverse(char s[]) 
{   //字符串反转 
    int c, i=0, j; 
    for(j=strlen(s)-1;i<j;j--) 
    {    c=s[i]; 
        s[i]=s[j]; 
        s[j]=c; 
        i++; 
    } 
}
void IntegerToString(char s[],int n) 
{    int i=0,sign; 
    if((sign=n)<0)//如果是负数，先转成正数   
        n=-n; 
    do //从个位开始变成字符,直到最高位,最后应该反转 
    {    s[i++]=n%10+'0'; 
    }while((n=n/10)>0); 
    //如果是负数，补上负号 
    if(sign<0) 
        s[i++]='-'; 
    s[i]='\0';//字符串结束 
    reverse(s); 
} 
void main()
{    int m;
    char c[100];
    printf("请输入整数m: ");
    scanf("%d",&m);
    IntegerToString(c,m);
    printf("integer = %d string = %s\n", m, c);
}


                               嵌入式软件笔试

/************************ 
    Chapter1  语法类   
***********************/
1 .volatile作用？应用场合举3例
  volatile修饰的变量表示这个变量可能会被意想不到的改变，对该变量的操作将不作优化，用到该变量时都从这个变量的原始地址读取，而不是用保存在寄存器里的备份。
  Volatile常用在：
    1). 硬件寄存器（如：状态寄存器）。
    2). 中断程序中会访问到的非自动变量(Non-automatic variables)。
    3). 多线程应用中几个任务共享的变量
 
2. 一个参数既可以是const还可以是volatile吗？解释为什么。
  是的。比如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

3. 一个指针可以是volatile 吗？解释为什么。
  是的。 比如一个中断服务子程序修该一个指向一个buffer的指针时。

4. 用变量a给出下面的定义
a) 一个整型数
b) 一个指向整型数的指针
c) 一个指向指针的指针，它指向的指针是指向一个整型数
d) 一个有10个整型数的数组
e) 一个有10个指针的数组，该指针是指向一个整型数的
f) 一个指向有10个整型数数组的指针
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数 

    a) int  a; // An integer
b) int  *a; // A pointer to an integer
c) int  **a; // A pointer to a pointer to an integer
d) int  a[10]; // An array of 10 integers
e) int  *(a[10]); // An array of 10 pointers to integers
f) int   (*a)[10]; // A pointer to an array of 10 integers
g) int  (*a)(int); // A pointer to a function a that takes an integer argument
and returns an integer
h) int  (*a[10]) (int);  //  An array of 10 pointers to functions that take an in
teger argument and return an integer

   



5. 什么是存储机制里的大、小端模式？试举例说明
  大端模式（big-edian）：MSB存放在最低端的地址上。举例，双字节数0x1234以big-endian的方式存在起始地址0x00002000中： 	
     | data |<-- address
        | 0x12 |<-- 0x00002000
        | 0x34 |<-- 0x00002001
在Big-Endian中，对于bit序列中的序号编排方式如下（以双字节数0x8B8A为例）：
    bit | 0 1 2 3 4 5 6 7 | 8 9 10 11 12 13 14 15
        MSB----------------------------------LSB
        val | 1 0 0 0 1 0 1 1 | 1 0 0 0 1 0 1 0 |
         = 0x8 B 8 A 
小端模式(little-endian)：LSB存放在最低端的地址上。举例，双字节数0x1234以little-endian的方式存在起始地址0x00002000中：
     | data |<-- address
        | 0x34 |<-- 0x00002000
        | 0x12 |<-- 0x00002001
　在Little-Endian中，对于bit序列中的序号编排和Big-Endian刚好相反，其方式如下（以双字节数0x8B8A为例）：
    bit | 15 14 13 12 11 10 9 8 | 7 6 5 4 3 2 1 0
       MSB-----------------------------------LSB
        val | 1 0 0 0 1 0 1 1 | 1 0 0 0 1 0 1 0 |
          = 0x8 B 8 A
6. 写一段用来判断内存存储方式是大端还是小段的代码。
联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性就可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写。代码如下：
 int checkCPUendian()
        {
                union
                {
                        unsigned int a;
                        unsigned char b;
                }c;
                c.a = 1;
                return (c.b = = 1);
        }
        /*return 1 : little-endian,  return 0:big-endian*/

7. 定义一个返回值是指向函数的指针且有一个指向函数的指针作参数的函数。
       通用形式如下：
      typedef int (*P)( );         //   定义一个函数指针P类型
    
P function( int  (*p)( ) );      //   定义一个函数返回值P类型，且定义一个指向函数的指针p作参数      

8. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
#define  SECONDS_PER_YEAR  (60 * 60 * 24 * 365) UL  // UL怎么个用法？你暂不要加

 
9 . 写一个“标准”宏MIN ，这个宏输入两个参数并返回较小的一个。
   #define  MIN(A,B)  ( (A) <= (B) ? (A ): (B) )
10. 关键字static的作用是什么？
  两个作用：
 1) 局部变量被声明为static 则这一函数调用结束后该变量值保持不变。
 2) 外部变量被声明为static表明它是一个本地全局变量。该变量只能在该文件内被访问，不能被其它文件访问。 
 11．关键字const有什么含意？
    声明一个变量为只读。
 12. 下面的声明都是什么意思？
    1）const int a; 2）int const a; 3）const int *a; 4）int * const a; 5） int const * const  a ;
     1,2一样a为只读整形变量；3 指向一个只读整形变量的指针；4 指向整形的只读指针； 5 指向只读整形的只读指针。
  13. C语言实现设置一绝对地址为0x1234的整型变量的值为0xaa55。
   int  *p; 
   p=(int *) 0x1234;  // 把整型数0x1234强制转换（typecast）为一指针
   *p=0xaa55; 
  14. 找出下面一段ISR的问题。
      __interrupt double compute_area (double radius)
  {
      double area = PI * radius * radius;
      printf("\nArea = %f", area);
      return area;
  }
 1）ISR不能传递参数。
 2）ISR不能有返回值。
 3）ISR应该短且有效率，在ISR中做浮点运算不明智。

15 .下面的代码输出是什么？为什么？
void foo(void)
{
unsigned int a = 6;
int b = -20;
(a+b > 6) ? puts("> 6") : puts("<= 6");
}
输出 > 6，原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。-20成了一个非常大的正数。  // 此题的输出确实是这样，但单纯输出a+b时结果又是-14 很怪异 迷惑~~~~~~！
  
  16. 评价下面的代码片断：
unsigned int zero = 0;
unsigned int compzero = 0xFFFF;
如果碰巧int型是16位则上述代码没有问题，否则上面的代码不正确。应写成：unsigned int compzero = ~0;
  17 .  下面代码执行后a，b，c的值各是多少？
int a = 5, b = 7, c;
c = a+++b;            // c = （a++）+b 
a = 6, b = 7, c = 12.     // 吾已试，结果确如此

18. Typedef和#define的区别 
       #define在预编译的时候处理作机械的字符替换。Typedef在编译的时候处理，并不是作简单的字符替换。而是如同定义变量一样声明一个类型。然后用它去定义这种类型的变量。比如下面的例子：

 #define dPS struct s *
 typedef struct s * tPS;
以上两句都是定义dPS 和 tPS 为一个指向结构s的指针。 typedef更好。比如： 
dPS p1,p2;
tPS p3,p4;
第一句扩展为struct s * p1, p2;
这条代码定义p1为指向结构的指针，p2为一个实际的结构体。第二句定义p3 和p4 为指向结构体s的指针。

/************************ 
      Chapter2  编程类   
***********************/
   1. 在字符串中找出所有与给定字符相同字符的位置。 
#include <stdio.h>
char s[6]="hello";
 void search_char(char given)
{
   int  i=0,j=0; 
   while(s[i]!='\0'){
    if(s[i]==given){
     printf("location = %d\n", i);
     j++;
     }
    i++;
   } 
  if(j==0) 
    printf("No %c found\n",given);
}
int main(void)
{  
   search_char('o');
   return 0; 
}

/*-----      E      ----*/
   2. 将一个字符串自身逆序. 
#include <stdio.h>
#define  LEN  12
int main(void)
{
  int  m,i;
  char temp;
  char s[LEN]="hello tiger";
  m=(LEN-1)/2;  
  printf("%s\n",s);
  for(i=0;i<m;i++){
    temp=s[i]; 
    s[i]=s[LEN-2-i]; 
    s[LEN-2-i]=temp;
  }
  printf("%s\n",s);
  return 0;
}
/*-------    E   ------*/
   3. 链表的基本操作及链表自身逆序。  
/*----  chain operate from Data Structure ---*/
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
typedef int DataType; 
typedef struct Node
{
  DataType data;
  struct   Node *next;
}SLNode;

//---- initiate 
void ListInitiate(SLNode **head)
 {
   if( (*head=(SLNode *)malloc(sizeof(SLNode)))==NULL )  exit(1);
   else printf("OK\n");
   (*head)->next=NULL;
  }

//---- length cal
int ListLength(SLNode *head)
{
  SLNode *p=head;
  int size=0;
  while(p->next!=NULL){
    p=p->next;
    size++;
   }
 return size;
}
//----insert a node 
int ListInsert(SLNode *head,int i,DataType x)
{
  SLNode *p,*q;
  int j;
  p=head;
  j=-1;
  while( (p->next!=NULL) && (j<(i-1)) ) {
   p=p->next;
   j++;
   }
  if(j!=(i-1))  {
   printf("Position error\n");
   return 0;
  }
  if((q=(SLNode *)malloc(sizeof(SLNode)))==NULL)
   exit(1);
   q->data=x;
   q->next=p->next;
   p->next=q;
   return 1;
}
//----delete a node 
int ListDelete(SLNode *head,int i,DataType *x)
{
  SLNode *p,*s;
  int j;
  p=head;
  j=-1;  
  while((p->next!=NULL) && (p->next->next!=NULL) && (j<i-1) ){
    p=p->next;
    j++;
  }
 if(j!=i-1){
    printf("Position error\n");
    return 0;
  } 
  s=p->next;
  *x=s->data;
  p->next=p->next->next;
  free(s);
  return 1; 
}
//----- data get 
int ListGet(SLNode *head,int i,DataType *x)
{
  SLNode *p;
  int j;
  p=head;
  j=-1;
  while((p->next!=NULL)&&(j<i)) {
    p=p->next;
    j++;
  }
  if(j!=i)  {
    printf("Position error\n");
    return 0;
  }
  *x=p->data; 
  return 1;
}
//----Destroy a chain
void Destroy(SLNode **head)
 {
  SLNode *p,*p1;
  p=*head;
  while(p!=NULL) {
    p1=p;
    p=p->next;
    free(p1);
  }
  *head=NULL;
 }

//-----converse a chain
void converse(SLNode *head)
{
  SLNode *p,*q;
  p=head->next;
  head->next=NULL;
  while(p!=NULL) {
   q=p;
   p=p->next;
   q->next=head->next; 
   head->next=q;
  }
}
 
//---- composite operation
int main(void)
{
  SLNode  *head;
  int     i,x;
  ListInitiate(&head);
  for(i=0;i<10;i++) {  
   if(ListInsert(head,i,i)==0){
      printf("Error\n");
      return 1;
    }
  }

    if(ListDelete(head,0,&x)==0)  // chain,position,data address
   {
      printf("Error\n");
      return 1;
    } 
   if(ListInsert(head,0,100)==0) {
      printf("Error\n");
      return 1;
    }
  converse(head);
  for(i=0;i<ListLength(head);i++)  {
   if(ListGet(head,i,&x)==0)     // chain,position,data address
   {
     printf("Error\n");
      return 1;
   } 
   else printf("%d  ",x);
  }
  printf("\n");
  Destroy(&head);
 return 0;
 }
/*------   E  -------*/

   4. 写一个二分查找算法。 
#include <stdio.h>
#define size 10
int g[size]={0,1,2,3,4,5,6,7,8,9};
int search(int x)
{
  int low=0;
  int high=size-1;
  int mid;
  while(low<=high)  {
   mid=(low+high)/2;
   if(g[mid]==x)
     return mid;
   else if(g[mid]<x)
     low=mid+1;
   else if(g[mid]>x)
     high=mid-1;
  }
  return -1; 
}
//----
int main(void)
{
  printf("%d\n",search(7));
  return 0;
}
/*---   E   ---*/

   5. 计算一个字节里（byte）里面有多少bit被置1.
#include <stdio.h>
int cal_bit(char a)
{
  int i,j=0;
  for(i=0;i<8;i++) {
   if((a&0x01)==0x01)
    j++;
   a=a>>1;
  }
 return j;
}
//--
int main(void)
{
  printf("%d\n",cal_bit(255));
  return 0;
}
/*----  E  ----*/

   6. 字符串转换为整数，比如“1234”转换成1234.
#include <stdio.h>
char str[6]="12345";
int string_to_int(char s[])
{
 int i;
 int sum=0;
 for(i=0;s[i]!='\0';i++)
  sum=sum*10+s[i]-'0';
 return sum;
}
//-----
int main(void)
{
  printf("%d\n",string_to_int(str));
  return 0;
}
/*------  E  -----*/
   7. 整数转换为字符串，比如1234转换成“1234”.
#include <stdio.h>
#include <math.h>
#define  LEN 4
char str[]=" "; 
char *int_to_string(int given)
{
   int i; 
   int temp;
  for(i=0;i<LEN;i++) {
   temp=given/pow(10,LEN-1-i);        // 从最高位开始
   given=given%((int) pow(10,LEN-1-i)); //int mustbe on both side of '%'
   str[i]=temp+'0';
 } 
 return str;
}
//-----
int main(void)
{
     printf("%s\n",int_to_string(9876));
     return 0;
}
/*------  E  -----*/
   8. C语言实现插入排序算法（从大到小，从小到大）.  
#include<stdio.h>
#define LEN 5
int a[LEN]={7,4,8,4,5};
void insertion_sort(void)
{
   int i,j,key;
   for(j=1;j<LEN;j++){
       printf("%d,%d,%d,%d,%d\n",a[0],a[1],a[2],a[3],a[4]);
       key=a[j];
       i=j-1;
       while( (i>=0) && (a[i]>key) ){                       // a[i]>key 从小到大； a[i]<key 从大到小
         a[i+1]=a[i];
         i--;
        }
       a[i+1]=key;
    }
  printf("%d,%d,%d,%d,%d\n",a[0],a[1],a[2],a[3],a[4]);
}

//-----
int main(void)
{
  insertion_sort();
   return 0;
}
/*------      E     -------*/
   9. C语言实现冒泡排序算法（从大到小，从小到大）
#include<stdio.h>
#define LEN 5
int a[LEN]={5,4,3,2,1};
void bubble_sort(void)
{
  int i,j,flag=1;
  int temp;
  for(i=1;(i<LEN)&&(flag==1);i++){
    flag=0;
    for(j=0;j<LEN-i;j++)  {
      if( a[j]>a[j+1] ){                              // a[j]>a[j+1]从小到大；a[j]<a[j+1] 从大到小
       flag=1;
       temp=a[j]; 
       a[j]=a[j+1];
       a[j+1]=temp;
       } 
    }
    printf("%d,%d,%d,%d,%d\n",a[0],a[1],a[2],a[3],a[4]);
  }
}
//--------
 int main(void)
{
  bubble_sort();
  return 0;
}
/*----   E   ----*/

 10. 在一个字符串中找一个字符串


 11. 计算一个数的阶乘
递归实现：
int factorial(int n)
{ 
   if (n == 0) 
      return 1; 
   else {
     int recurse = factorial(n-1); 
     int result = n * recurse; 
    return result; 
  }
}

循环实现：
int factorial(int n)
{
   int result = 1;
   while (n > 0) { 
 result = result * n;
 n = n - 1; 
   } 
  return result;
 }


12.用嵌套循环求1-100的素数
#include <stdio.h>
int main(void)
{
  int i, j; 
  for (i = 1; i <= 100; i++) {
for (j = 2; j < i; j++) 
 if (i % j == 0)
     break; 
   if (j == i) 
 printf("%d\n", i); 
 } 
 return 0;
}
/*------------    E   -------------*/





13. 打印菱形图案
void Damond(int L, char ch){ int n, j, k, i; for(n=1;n<=L/2+1;n++)
    
 {
        
  for(j=0;j<L/2+1-n;j++)
          
    printf(" ");
       
  for(k=1;k<=2*n-1;k++)
          
    printf("%c", ch);
      
  printf("\n");
     
  }
  
 
 for(i=L-n+1;i>=1;i--)
   
  {
      
   for(j=0;j<n-i-1;j++)
            
     printf(" ");
      
   for(k=1;k<=2*i-1;k++)
         
    printf("%c", ch);
      
  printf("\n");
   
   }

} 
/*----------    E   --------*/
14. 删除一个字符串中的指定字符。
#include <stdio.h>
void del_char(char *p, char ch)
{
  char *pch;
   while (*p != '\0') {
    if (*p == ch) {
      for (pch = p; *pch != '\0'; pch++)
        *pch = *(pch+1);
    }
   else
    p++;    
  }   
} 

int main(void)
{
  char ch;
  char a[] = "hello world";
  scanf("%c", &ch);  
  
  del_char(a, ch);
  printf("%s\n", a);
}

/*-- E --*/
15. 统计一个字符串中子字符串的个数
#include <stdio.h>
#include <string.h>
int main(void)
{
  int i, j, k;
  int num = 0; 
  int len1, len2;
  char str1[80], str2[10];
  scanf("%s", str1);
  scanf("%s", str2);
 
  len1 = strlen(str1);    
  len2 = strlen(str2) - 1;    
 
   for (i = 0; i < len1 - len2; i++) {
    for (j = 0, k = i; str2[j] == str1[k]; k++, j++) 
    {
      if (j == len2)
        num++;
    }
   }
  printf("%d\n", num);
} 
/*----- E -----*/



/************************ 
      Chapter3  系统类   
***********************/
1. Rtx51 Tiny是如何实现任务调度，切换的？
  时间片轮转，每个任务执行一定的时间退出执行下个任务如此循环。一个时间片内任务可以通过调用系统函数结束自身的执行转去执行下个任务。任务执行超过一个时间片系统强制终止该任务的执行转去执行下个任务。

2. Small Rtos51是如何实现任务调度，切换的？
  完全基于有优先级的抢占式操作系统。任务切换有两种情况：1当前任务自己放弃cpu时间； 2中断程序使优先级更高的任务就绪，所有中断退出后进行任务切换。

3. Uc/os是如何实现任务调度，切换的？
  完全基于有优先级的抢占式操作系统。任务切换有两种情况：1当前任务自己放弃cpu时间； 2中断程序使优先级更高的任务就绪，所有中断退出后进行任务切换。任务切换的过程大致是当前任务上下文入栈，最高优先级任务上下文出栈。
 


4.Linux是如何实现任务调度的？
  Linux既有时间片又有高优先级抢占。时间片到强制任务调度。时间片内有更高优先级任务就绪任务切换。

2. Bootloader移植过程要注意的事项，要做哪些工作
3. Emacs用过没有？
 用过





关于嵌入式系统的笔试题

1.嵌入式系统测试包含那些阶段？他们的目的是什么
2.和通常的PC软件比。嵌入式系统测试有那些不同？
3.做好嵌入式产品的测试，需要从哪几方面着手、

这3道题应该怎么回答啊 


以下的回答是否符合楼主的要求
不足之处欢迎补充
1. 一般来说,软件测试有7个基本阶段,即单元或模块测试、集成测试、外部功能测试、回归测试、系统测试、验收测试、安装测试。嵌入式软件测试在4个阶段上进行,即模块测试、集成测试、系统测试、硬件/软件集成测试。模块测试：模块的高内聚性、功能实现的一致性和正确性；集成测试：接口定义清楚且正确、模块或组件一起工作正常、能集成为完整的系统；系统测试：系统能正常地、有效的运行，包括性能、可靠性、安全性、兼容性等；前3个阶段适用于任何软件的测试,硬件/软件集成测试阶段是嵌入式软件所特有的,目的是验证嵌入式软件与其所控制的硬件设备能否正确地交互。
2. 嵌入式系统开发环境被认为是主机平台，软件运行环境为目标平台。相应的测试为host-target测试或cross-testing。在嵌入式软件测试中,常常要在基于目标的测试和基于宿主的测试之间作出折衷。基于目标的测试消耗较多的经费和时间,而基于宿主的测试代价较小。目前的趋势是把更多的测试转移到宿主环境中进行。在宿主环境中,可以进行逻辑或界面的测试、其它非实时测试以及与硬件无关的测试。在模拟或宿主环境中的测试消耗时间通常相对较少,用调试工具可以更快地完成调试和测试任务。而与定时问题有关的白盒测试、中断测试、硬件接口测试只能在目标环境中进行。
3. 嵌入式系统中软件的比重越来越大,复杂程度越来越高,嵌入式软件的测试正面临前所未有的挑战。测试人员最好了解业务需求，测试功能是否满足，一个软件产品满足功能是首要的。通常嵌入式系统对可靠性的要求比较高，测试性能是否满足，嵌入式系统安全性的失效可能会导致灾难性的后果,即使是非安全性系统,由于大批量生产也会导致严重的经济损失。嵌入式系统通常有自己的用户界面，界面是否良好是测试的一部分，软件的安装是使用的前提，便捷高效的安装必不可少。

 


嵌入式C开发人员的最好的0x10道笔试题
约定:
(1) 下面的测试题中，认为所有必须的头文件都已经正确的包含了
(2)数据类型     
Char			一个字节 1 byte
Int				两个字节 2 byte (16位系统，认为整型是2个字节)
long int			四个字节 4 byte
float			四个字节4 byet
double			八个字节 8 byte
long double		十个字节 10 byte
pointer			两个字节 2 byte(注意，16位系统,地址总线只有16位)

第1题: 考查对volatile关键字的认识
#include<setjmp.h>
static jmp_buf buf;
main() 
{
volatile int b;
b =3;
if(setjmp(buf)!=0) 
{
printf("%d ", b); 
exit(0);
}
b=5;
longjmp(buf , 1);
} 
请问，这段程序的输出是
(a) 3		(b) 5		(c) 0		(d) 以上均不是

第2题:考查类型转换
main()
{
struct node 
{
int a;
int b;
int c; 
};
struct node s= { 3, 5,6 };
struct node *pt = &s;
printf("%d" , *(int*)pt);
}
这段程序的输出是:
(a) 3			(b) 5			(c) 6			(d) 7

第3题:考查递归调用
int foo ( int x , int n)　
{
int val;
val =1;
if (n>0) 
{
if (n%2 == 1) val = val *x;
val = val * foo(x*x , n/2);
}
return val;
}
这段代码对x和n完成什么样的功能(操作)?
(a) x^n (x的n次幂)	(b) x*n(x与n的乘积) (c) n^x(n的x次幂) (d)以上均不是

第4题:考查指针,这道题只适合于那些特别细心且对指针和数组有深入理解的人
main() 
{
int a[5] = {1,2,3,4,5};
int *ptr = (int*)(&a+1);
printf("%d %d" , *(a+1), *(ptr-1) );
}
这段程序的输出是:
(a) 2 2			(b) 2 1			(c) 2 5			(d) 以上均不是

第5题:考查多维数组与指针
void foo(int [][3] ); 
main()
{
int a [3][3]= { { 1,2,3} , { 4,5,6},{7,8,9}};
foo(a);
printf("%d" , a[2][1]);
}
void foo( int b[][3]) 
{
++ b;
b[1][1] =9;
}
这段程序的输出是:
(a) 8			(b) 9			(c) 7			(d)以上均不对

第6题目:考查逗号表达式
main()
{
int a, b,c, d;
a=3;
b=5;
c=a,b;
d=(a,b);
printf("c=%d" ,c);
printf("d=%d" ,d);
}
这段程序的输出是:
(a) c=3 d=3			(b) c=5 d=3		(c) c=3 d=5		(d) c=5 d=5

第7题:考查指针数组
main()
{
int a[][3] = { 1,2,3 ,4,5,6};
int (*ptr)[3] =a;
printf("%d %d " ,(*ptr)[1], (*ptr)[2] );
++ptr;
printf("%d %d" ,(*ptr)[1], (*ptr)[2] );
}
这段程序的输出是:
(a) 2 3 5 6		(b) 2 3 4 5		(c) 4 5 0 0		(d) 以上均不对

第8题:考查函数指针
int *f1(void)
{
int x =10;
return(&x);
}
int *f2(void)
{
int*ptr;
*ptr =10;
return ptr;
}
int *f3(void)
{
int *ptr;
ptr=(int*) malloc(sizeof(int));
return ptr;
}
上面这3个函数哪一个最可能引起指针方面的问题
(a) 只有 f3		(b) 只有f1 and f3		(c) 只有f1 and f2		(d) f1 , f2 ,f3

第9题:考查自加操作(++)
main()
{
int i=3;
int j;
j = sizeof(++i+ ++i);
printf("i=%d j=%d", i ,j);
}
这段程序的输出是:
(a) i=4 j=2		(b) i=3 j=2		(c) i=3 j=4		(d) i=3 j=6

第10题:考查形式参数，实际参数，指针和数组
void f1(int *, int); 
void f2(int *, int); 
void(*p[2]) ( int *, int);
main()
{
int a;
int b;
p[0] = f1;
p[1] = f2;
a=3;
b=5;
p[0](&a , b);
printf("%d\t %d\t" , a ,b);
p[1](&a , b);
printf("%d\t %d\t" , a ,b);
}
void f1( int* p , int q)
{
int tmp;
tmp =*p;
*p = q;
q= tmp;
}
void f2( int* p , int q)
{
int tmp;
tmp =*p;
*p = q;
q= tmp;
} 
这段程序的输出是:
(a) 5 5 5 5		(b) 3 5 3 5		(c) 5 3 5 3		(d) 3 3 3 3

第11题:考查自减操作(--)
void e(int ); 
main()
{
int a;
a=3;
e(a);
}
void e(int n)
{
if(n>0)
{
e(--n);
printf("%d" , n);
e(--n);
}
}
这段程序的输出是:
(a) 0 1 2 0		(b) 0 1 2 1		(c) 1 2 0 1		(d) 0 2 1 1

第12题:考查typedef类型定义,函数指针
typedef int (*test) ( float * , float*)
test tmp;
 tmp 的类型是:

(a) 函数的指针，该函数以 两个指向浮点数(float)的指针(pointer)作为参数(arguments)Pointer to function of having two arguments that is pointer to float
(b) 整型
(c) 函数的指针，该函数以 两个指向浮点数(float)的指针(pointer)作为参数(arguments),并且函数的返回值类型是整型
      Pointer to function having two argument that is pointer to float and return int
(d) 以上都不是

第13题:数组与指针的区别与联系
main()
{
char p;
char buf[10] ={ 1,2,3,4,5,6,9,8};
p = (buf+1)[5];
printf("%d" , p);
}
这段程序的输出是:
(a) 5		(b) 6		(c) 9		(d) 以上都不对

第14题: 考查指针数组的指针
Void f(char**);
main()
{
char * argv[] = { "ab" ,"cd" , "ef" ,"gh", "ij" ,"kl" };
f( argv );
}
void f( char **p )
{
char* t;
t= (p+= sizeof(int))[-1];
printf( "%s" , t);
}
这段程序的输出是:
(a) ab		(b) cd		(c) ef		(d) gh

第15题:此题考查的是C的变长参数,就像标准函数库里printf()那样,这个话题一般国内大学课堂是不会讲到的,不会也情有可原呵呵,
#include<stdarg.h>
int ripple ( int , ...);
main()
{
int num;
num = ripple ( 3, 5,7);
printf( " %d" , num);
}
int ripple (int n, ...)
{
int i , j;
int k; 
va_list p;
k= 0;
j = 1;
va_start( p , n); 
for (; j<n; ++j) 
{
i = va_arg( p , int);
for (; i; i &=i-1 )
++k;
}
return k;
}
这段程序的输出是:
(a) 7		(b) 6		(c) 5		(d) 3

第16题:考查静态变量的知识
int counter (int i)
{
static int count =0;
count = count +i;
return (count );
}
main()
{
int i , j;
for (i=0; i <=5; i++)
j = counter(i);
}
本程序执行到最后,j的值是:
(a) 10		(b) 15		(c) 6		(d) 7

详细参考答案
第1题:   (b)
volatile字面意思是易于挥发的。这个关键字来描述一个变量时，意味着 给该变量赋值(写入)之后，马上再读取，写入的值与读取的值可能不一样,所以说它"容易挥发"的。
这是因为这个变量可能一个寄存器，直接与外部设备相连，你写入之后，该寄存器也有可能被外部设备的写操作所改变;或者，该变量被一个中断程序，或另一个进程
改变了.
volatile 不会被编译器优化影响，在longjump 后,它的值 是后面假定的变量值,b最后的值是5,所以5被打印出来.
setjmp : 设置非局部跳转 /* setjmp.h*/
Stores context information such as register values so that the lomgjmp function can return control to the statement following the one calling setjmp.Returns 0 when it is initially called.
Lonjjmp: 执行一个非局部跳转 /* setjmp.h*/
Transfers control to the statement where the call to setjmp (which initialized buf) was made. Execution continues at this point as if longjmp cannot return the value 0.A nonvolatile automatic variable might be changed by a call to longjmp.When you use setjmp and longjmp, the only automatic variables guaranteed to remain valid are those declared volatile.
Note: Test program without volatile qualifier (result may very)
更详细介绍，请参阅 C语言的setjmp和longjmp
第2题:   (a)
结构题的成员在内存中的地址是按照他们定义的位置顺序依次增长的。如果一个结构体的指针被看成 它的第一个成员的指针,那么该指针的确指向第一个成员
第3题:  (a)
此题目较难.
这个程序的非递归版本
int what ( int x , int n)
{
int val;
int product;
product =1;
val =x;
while(n>0)
{
if (n%2 == 1) 
product = product*val; /*如果是奇数次幂, x(val)
要先乘上一次,; 
偶数次幂,最后返回时才会到这里
乘以1*/
val = val* val; 
 n = n/2; 
}
return product;
}
/* 用二元复乘策略 */
算法描述
(while n>0) 
{
if next most significant binary digit of n( power) is one
then multiply accumulated product by current val , 
reduce n(power) sequence by a factor of two using integer division .
get next val by multiply current value of itself 
}
第4题:  (c)
a的类型是一个整型数组,它有5个成员
&a的类型是一个整型数组的指针
所以&a + 1指向的地方等同于 a[6]

所以*(a+1) 等同于a[1]
ptr等同 a[6], ptr-1就等同与a[5]
第5题:  (b)

题目自身就给了足够的提示
b[0][0]  = 4
b[1][0]  = 7
第6题:  (c)
考查逗号表达式,逗号表达式的优先级是很低的，比 赋值(=)的优先级 低. 逗号表达式的值就是最后一个元素的值
逗号表达式的还有一个作用就是分割函数的参数列表..
E1, E2, ..., En
上面这个表示式的左右是,E1, E2,... En的值被分别计算出来，En计算出来的结构赋给整个逗号表达式
c=a,b; / *yields c=a* /
d=(a,b); /* d =b */
第7题:  (a)

ptr是一个数组的指针，该数组有3个int成员
第8题:  (c)
f1显然有问题，它返回一个局部变量的指针，局部变量是保存在stack中的,退出函数后，局部变量就销毁了，保留其指针没有意义，因为其指向的stack空间可能被其他变量覆盖了
f2也有问题, ptr是局部变量，未初始化，它的值是未知的，*ptr不知道指向哪里了，直接给*ptr赋值可能会覆盖重要的系统变量，这就是通常说的野指针的一种
第9题:  (b)
sizeof  操作符给出其操作数需要占用的空间大小，它是在编译时就可确定的，所以其操作数即使是一个表达式，也不需要在运行时进行计算.( ++i + ++ i  )是不会执行的，所以
i 的值还是3
第10题:  (a)
很显然选a.
f1交换*p 和 q的值，f1执行完后, *p 和 q的值的确交换了,  但 q的改变不会影响到  b的改变,  *p 实际上就是 a 
所以执行f1后,  a=b=5
这道题考查的知识范围很广,包括typedef自定义类型,函数指针,指针数组
void(*p[ 2 ]) ( int *, int);
定义了一个函数指针的数组p,p有两个指针元素.  元素是函数的指针，函数指针指向的函数是一个带2个参数,返回void的函数，所带的两个参数是 指向整型的指针，和整型
p[ 0 ] = f1; p[ 1 ] = f2 contain address of function .function name without parenthesis represent address of function Value and address of variable is passed to function only argument that is effected is a (address is passed). Because of call by value f1, f2 can not effect b
第11题:  (a)
 
考查--操作和递归调用,仔细分析一下就可以了
第12题:  (c)
建议不会的看看C专家编程
从左往有，遇到括号停下来，将第一个括号里的东西看成一个整体 
第13题:  (c)
考查什么时候数组就是指针.对某些类型T而言，如果一个表达式是 T[]  (T的数组),  这个表达式的值实际上就是指向该数组的第一个元素的指针.所以(buf+1)[5]实际上就是*(buf +6)或者buf[6]
第14题:  (b)

sizeof(int)的值是2,所以p+=sizeof(int) 指向 argv[2],这点估计大家都没有什么疑问
(p+=sizeof(int))[-1] 指向 argv[1],能理解吗，因为(p+=sizeof(int))[-1]  就相当于 (p+=2)[-1] ,也就是(p+2-1)
第15题:  (c)
在C编译器通常提供了一系列处理可变参数的宏，以屏蔽不同的硬件平台造成的差异，增加程序的可移植性。这些宏包括va_start、 va_arg和va_end等。 
采用ANSI标准形式时，参数个数可变的函数的原型声明是： 
type funcname(type para1, type para2, ...) 
这种形式至少需要一个普通的形式参数，后面的省略号不表示省略，而是函数原型的一部分。type是函数返回值和形式参数的类型。
不同的编译器，对这个可变长参数的实现不一样 ，gcc4.x中是内置函数.
关于可变长参数,可参阅 
http://www.upsdn.net/html/2004-11/26.html
http://www.upsdn.net/html/2004-11/24.html

程序分析
va_list p; /*定义一个变量 ,保存 函数参数列表 的指针*/
va_start( p , n); /*用va_start宏 初始化 变量p, 
va_start宏的第2个参数n ,
是一个固定的参数,
必须是我们自己定义的变长函数的最后一个入栈的参数
也就是调用的时候参数列表里的第1个参数*/
for (; j<n; ++j) /* j从1开始, 遍历所有可变参数 */
{
i = va_arg( p , int); /*va_arg取出当前的参数,
并认为取出的参数是一个整数(int) */
for (; i; i &=i-1 ) /*判断取出的i是否为0*/
++k; /* 如果i不为0, k自加, 
i与i-1进行与逻辑运算, 直到i 为0
这是一个技巧，下面会谈到它的功能*/
}
当我们调用ripple函数时，传递给ripple函数的 参数列表的第一个参数n的值是3 .
va_start 初始化 p士气指向第一个未命名的参数(n是有名字的参数) ,也就是 is 5 (第一个).
每次对 va_arg的调用，都将返回一个参数，并且把 p 指向下一个参数.
va_arg 用一个类型名来决定返回的参数是何种类型,以及在 var_arg的内部实现中决定移动多大的距离才到达下一个 参数
(; i; i&=i-1) k++ /* 计算i有多少bit被置1 */
5用二进制表示是 (101) 2
7用二进制表示 (111) 3
所以 k 返回 5(2+3),也即本题应该选c
举个例子，就很好理解了
令 i= 9 = 1001
i-1 = 1000 
(i-1) +1 = i
1000
+1
1 001
因为i与i-1的最右边的那位(最低位) 肯定是不同，如果i1,i-1肯定是0，反之亦然.     i & i-1 这个运算，在二相补的数字系统中，将会 消除最右边的1位
第16题:  (b)
答案是 (b)
相传高斯小学一年级的时候就会做这类等比数列的题目了.这道题考查的是静态变量的知识,当每次调用完函数之后,静态变量的值不会丢失,这与栈中的临时局部变量明显不同的地方.
所以,第一次调用counter(0)之后,count =0
第二次调用 counter(1)后 count = 0+1;
第三次调用 counter(2) count = 1+2;    /* count = count +i */
第四次调用 counter(3) count = 3+3;
第五次调用 counter(4) count = 6+4;
第六次调用 counter(5) count = 10+5;
命题人信息 Ashok K. Pathak a member ( Research Staff ) at Bharat Electronics Limited (CRL) , Ghaziabad. He has been developing embedded application for the past five years .Ashok holds a M.E in computer science and engineering . Ashok recently completed a book about' "Advanced Test in C and Embedded System Programming" , Published by BPB , ND 


C语言测试是招聘嵌入式系统程序员过程中必须而且有效的方法。这些年，我既参加也组织了许多这种测试，在这过程中我意识到这些测试能为带面试者和被面试者提供许多有用信息，此外，撇开面试的压力不谈，这种测试也是相当有趣的。
从被面试者的角度来讲，你能了解许多关于出题者或监考者的情况。这个测试只是出题者为显示其对ANSI标准细节的知识而不是技术技巧而设计吗？这个愚蠢的问题吗？如要你答出某个字符的ASCII值。这些问题着重考察你的系统调用和内存分配策略方面的能力吗？这标志着出题者也许花时间在微机上而不上在嵌入式系统上。如果上述任何问题的答案是"是"的话，那么我知道我得认真考虑我是否应该去做这份工作。
从面试者的角度来讲，一个测试也许能从多方面揭示应试者的素质：最基本的，你能了解应试者C语言的水平。不管怎么样，看一下这人如何回答他不会的问题也是满有趣。应试者是以好的直觉做出明智的选择，还是只是瞎蒙呢？当应试者在某个问题上卡住时是找借口呢，还是表现出对问题的真正的好奇心，把这看成学习的机会呢？我发现这些信息与他们的测试成绩一样有用。
有了这些想法，我决定出一些真正针对嵌入式系统的考题，希望这些令人头痛的考题能给正在找工作的人一点帮住。这些问题都是我这些年实际碰到的。其中有些题很难，但它们应该都能给你一点启迪。
这个测试适于不同水平的应试者，大多数初级水平的应试者的成绩会很差，经验丰富的程序员应该有很好的成绩。为了让你能自己决定某些问题的偏好，每个问题没有分配分数，如果选择这些考题为你所用，请自行按你的意思分配分数。
预处理器（Preprocessor）

1 . 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）

#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情：
•; #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）


•; 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
•; 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
•; 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。
2 . 写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。


#define MIN(A,B) （（A） <= (B) ? (A) : (B))

这个测试是为下面的目的而设的：
•; 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
•; 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
•; 懂得在宏中小心地把参数用括号括起来
•; 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？

least = MIN(*p++, b);   
输出*(p+1)

3. 预处理器标识#error的目的是什么？
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。


死循环（Infinite loops）
4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
这个问题用几个解决方案。我首选的方案是：

while(1)
{
?}



一些程序员更喜欢如下方案：

for(;;)
{
?}

这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是："我被教着这样做，但从没有想到过为什么。"这会给我留下一个坏印象。
第三个方案是用 goto

Loop:
...
goto Loop;


应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。

数据声明（Data declarations）

5. 用变量a给出下面的定义
a) 一个整型数（An integer）
b)一个指向整型数的指针（ A pointer to an integer）
c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r
d)一个有10个整型数的数组（ An array of 10 integers）
e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）
f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）
h)一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）

答案是：
a) int a; // An integer
b) int *a; // A pointer to an integer
c) int **a; // A pointer to a pointer to an integer
d) int a[10]; // An array of 10 integers
e) int *a[10]; // An array of 10 pointers to integers
f) int (*a)[10]; // A pointer to an array of 10 integers
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer
人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？
Static
6. 关键字static的作用是什么？
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
•; 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
•; 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
•; 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
大,多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。


Const

7．关键字const有什么含意？
我只要一听到被面试者说："const意味着常数"，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着"只读"就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）
如果应试者能正确回答这个问题，我将问他一个附加的问题：
下面的声明都是什么意思？

const int a;
int const a;
const int *a;
int * const a;
int const * a const;


前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
•; 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
•; 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
•; 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。

Volatile

8. 关键字volatile有什么含意?并给出三个不同的例子。
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
•; 并行设备的硬件寄存器（如：状态寄存器）
•; 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
•; 多线程应用中被几个任务共享的变量

回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。
假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
•; 一个参数既可以是const还可以是volatile吗？解释为什么。
•; 一个指针可以是volatile 吗？解释为什么。
•; 下面的函数有什么错误：
int square(volatile int *ptr)
{
return *ptr * *ptr;
}

下面是答案：
•; 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
•; 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
•; 这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：


int square(volatile int *ptr)
{
int a,b;
a = *ptr;
b = *ptr;
return a * b;
}


由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：

long square(volatile int *ptr)
{
int a;
a = *ptr;
return a * a;
}

位操作（Bit manipulation）

9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
对这个问题有三种基本的反应
•; 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
•; 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
•; 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：


#define BIT3 (0x1 << 3)
static int a;

void set_bit3(void) {
a |= BIT3;
}
void clear_bit3(void) {
a &= ~BIT3;
}

一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。

访问固定的内存位置（Accessing fixed memory locations）

10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：

int *ptr;
ptr = (int *)0x67a9;
*ptr = 0xaa55;

A more obscure approach is:
一个较晦涩的方法是：

*(int * const)(0x67a9) = 0xaa55;

即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。

中断（Interrupts）

11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字__interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码。

__interrupt double compute_area (double radius)
{
double area = PI * radius * radius;
printf("\nArea = %f", area);
return area;
}

这个函数有太多的错误了，以至让人不知从何说起了：
•; ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
•; ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
•; 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
•; 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。

*****
代码例子（Code examples）

12 . 下面的代码输出是什么，为什么？

void foo(void)
{
unsigned int a = 6;
int b = -20;
(a+b > 6) ? puts("> 6") : puts("<= 6");
}
这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 ">6"。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。
13. 评价下面的代码片断：

unsigned int zero = 0;
unsigned int compzero = 0xFFFF;


对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：

unsigned int compzero = ~0;

这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧...

动态内存分配（Dynamic memory allocation）
14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：
下面的代码片段的输出是什么，为什么？

char *ptr;
if ((ptr = (char *)malloc(0)) ==NULL)
else
puts("Got a null pointer");
puts("Got a valid pointer");

这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是"Got a valid pointer"。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。
Typedef
:
15 Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：

#define dPS struct s *
typedef struct s * tPS;

以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：

dPS p1,p2;
tPS p3,p4;

第一个扩展为

struct s * p1, p2;

.
上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。

晦涩的语法

16 . C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？

int a = 5, b = 7, c;
c = a+++b;

这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：

c = a++ + b;

因此, 这段代码持行后a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。
好了，伙计们，你现在已经做完所有的测试了。这就是我出的C语言测试题，我怀着愉快的心情写完它，希望你以同样的心情读完它。如果是认为这是一个好的测试，那么尽量都用到你的找工作的过程中去吧。天知道也许过个一两年，我就不做现在的工作，也需要找一个。
Nigel Jones 是一个顾问，现在住在Maryland，当他不在水下时，你能在多个范围的嵌入项目中找到他。他很高兴能收到读者的来信，他的email地址是: NAJones@compuserve.com 。
References
•; Jones, Nigel, "In Praise of the #error directive," Embedded Systems Programming, September 1999, p. 114.
•; Jones, Nigel, " Efficient C Code for Eight-bit MCUs ," Embedded Systems Programming, November 1998, p. 66. 


某网友嵌入式求职经验总结（一）  
来源: 互联网     
一、引言 
一年前的这个时候，我开始了人生的真正求职历程。在这个过程中，有幸参加过海华、迈瑞、华为、智光、周立功、理邦等几个比较大笔试和面试。虽然大部分都失败了，但是我觉得正是这一次次的失败认我真正认识自己的不足，积累经验，成长进步，为最后的成功打下坚实的基础。求职是一个展现个人综合实力的过程，除了需要专业技能之外，还需要有一定的策略。同时这也是一个逐步提高和适应的过程。就像一支球队参加真正比赛之前都要经过系列的热身赛，熟悉对手的同时也在发现自己的不足。那时候我经看看别人的面经，现在我觉得把自己的体会跟大家分享也是一件很愉快的事情。特别在这个找工作的高潮时刻，也希望我的求职经历总结能给大家一点借鉴和帮助哦……
二、海华面试 
这是我人生的第一次正式面试，挺紧张的。面试首先是做题，没有什么时间限制，做完就交。题目不多，8道好像，全是问答和编程题，没得蒙。主要考了C语言、数据结构、操作系统、编译原理、内存分配和链表的一些东西。虽然是很基础的东西，但是平时不注意不一定做得出来。题目做完了，HR拿去给技术总监看，过了一会来告诉我，技术总监对我的答题较满意，叫我去会议室进行面试。技术总监来是一个比较年轻的工程师，谈吐之间感觉巨牛。我首先介绍了项目的情况，可能是第一次吧，讲的比较细，他听了一会感觉出我实际做了点东西，懒得听我说，直接叫我停止，开始问了我几个问题。看起来不是什么技术难题，但却不好答。 
我印象比较深刻的是下面三个题目： 1、在学校实验室中编程做项目和实际编程做项目有什么不同，需要注意什么？ 2、如果在公司中碰到了行政问题和技术难题应该怎么样处理？ 3、你的职业规划或者是你未来几年打算怎么样？ 这些的回答见仁见智。我没想到他会问这些问题，开始愣了几秒中，脑子一下转不过来。不过我对自己的回答比较满意，可能技术总监也认同我的回答。接着他问我做TCP/IP方面的东西怎么样。我说没有怎么样做过网络底层的东西，主要做的应用层上面的套接字编程。然后他问我在windows和linux的驱动层和应用层做过什么东西，我就讲相关的项目和工作稍稍说了一说。然后他给我介绍了进来公司要做的一些工作，主要是做TCP/IP应用层的测试验证工作。后面也没什么问了。他出去后，HR进来和我谈了谈公司的具体情况和福利方面的东西。大概三个小时，我的第一次面试就这样结束了。
三、迈瑞笔试 
收到迈瑞的笔试其实不是很意外，但是比较突然，没有想到当天宣讲完第二天下午就开始笔试，一点准备的机会都没有，去开开眼界吧。迈瑞通知我去考软件工程师，但我C++其实不怎么懂，肯定得交白卷。还好可以和来霸王面的人一起进了硬件工程师的考场。进去后我又要了系统研究工程师的题目，觉得系统的东西具体不是很清楚，思路说说还是可以的。然而，这次考试实在对自己的打击太大了，总算看清楚自己的真实水平了。 
在硬件的题目中，考试范围很广，模电，数电，CPLD，操作系统，算法，智力，设计等都涉及到。最打击自己的是，明明看着知道怎么做，但是忘记相关的公式概念，没法下笔，更伤心的是会做的粗心做错了，唉...无药可救了。 第1题是单位的换算，我居然把1Gbyte=1000Mbyte,出来想想才知道错了，应该是1024。 第2题是一个模电的题目，考查共射三极管的电容对上限截止频率和下限截止频率影响，包括耦合电容，极间电容和布线电容。第3题是问什么是摩尔定律，摩尔定律对硬件开发有什么影响？我一个字也写不下来。第4题又是一道伤心的题目，这是我唯一一道有点把握的题目，给了两个运放，要求写出名称和表达式，一个是差动比例放大器，一个积分电路，但是由于粗心，将差动比例放大器推导推错了。接下来的题目是什么呢......第5题做不出来，题目是说电容在高频的时候可以等效成一个电感、一个电容和一个电阻的串连，问实际中在什么频率时候使用做合适。第6题是数电的题目，什么是冒险与竞争，怎么样去消除冒险与竞争。数电的最基本题目，我又空白，你说这样的题目我都做不出来，在简历上吹你熟悉模电和数电还有人会相信吗？下面一题是英语翻译题目，给一个PCI的读时序，让你翻译将上面的英文翻译成中文。接着是一个智力题目：一个人从A城市下班后乘火车到火车站，他的妻子从家里骑车刚好到车站接他回家，一天，他坐了早班火车，5：30就到了火车站，然后走路回家，他的妻子在半路上接了他，回到家里发现比平时早了10分钟，问他坐了多少时间的路？这题我又挂了。后面是选做题，3选1。一道模电，给了运放、二极管，一个AD前端信号调理电路，要找出其中的错误。唉，又没头绪，估计是二极管钳位，写了几个字。另外一个是要用CPLD语言描述出JK触发器，再用JK触发器和与、非门搭出D触发器。这题我又放弃了。最后一个是操作系统的题目，关于PCI总线的三个读取方式的，只能放弃了。后面还有哦，一个二叉树遍历的程序补充，呵呵，这是数据结构最基本最简单的题目，我又缴械了。应该是最后一题了，说说你的一个成功的项目或者课程设计，画出结构框图，说出工作原理，碰到了什么难题怎么样解决。这个当然谁到会写拉，不就吹牛嘛。 再看看系统工程师的题目，分三个部分。 
第一部分有四个可选题目，和公司的四条产品线密切相关，第一个是描述心电信号的特点和测量方法。 
第二个是描述人体生理信号的特点与测量方法。 
第三个是说说数字滤波器的特征和实现，最后一个是说说光谱吸收装置的原理好像。本来觉得第三个很眼熟，但是又不知道怎么下笔，算了，反正都不会，选了第一到吹了一通。第二题是编程题，一个是补充汉诺塔的程序，还有一部分是计算冒泡法的比较次数和用顺序法找一个最大值的平均次数。下面一道题目是设计题目，设计一个数码相机，从市场需求、功能设计、质量方面、可行性和市场风险去设计。还好这个可以写点东西，不然正的是交白卷了。最后是一个4选1的题目，考查的是精度方面的东西。 
第一个是说说游标卡尺的精度影响因素，第二个是分析数控机床的精度影响因素，第三个是分析光强测量装置的精度影响因素。第四个忘记了。我选了数控机床那个东西写了几个字。 虽然是深深收到了打击，但是也真正的看到了自己的水平。学了那么多年，最基本的东西都没有掌握，正是惭愧啊。看来是时候开始好好找找自己的方向了，明确一个目标就去复习复习吧。软件东西我懂的都是皮毛，看来和它有缘无分拉，和硬件看来还有点尘缘未了啊。 
11月1号补充：虽然没有面试的机会，但是还是关注了迈瑞的面试情况，顺便记录了些在浙大BBS上看到的浙大牛人的面经： 面试官是那天监考的工作人员，考卷也是他看的。好像他是根据考试情况来定面试内容的。从来开始讲一下他的问题吧：
1.你选择深圳工作，有考虑过深圳离你家近？
        2.如果老板给你一个很急的任务，按理来讲要7天完成，但是却要你5天之内完成，你会怎么办？
        3.你的身边有这么一个老工程师，他可能不如你厉害，但是他脾气还很不好，你会怎么和他相处？
        4.你的老板有一套方案已经确定了，而且马上要实施，而你认为自己的方案也不错，并且在某点还很有创新，你会怎么办？
        5.你对选择做硬件有什么特别的想法？
        6.我看你最后一道题答的很详细也很工整，是我想要的结果，但我还是想让你给我解释一下关键问题的解决思路。他会给我一张纸，在我画框图的过程中打断我，顺便问几个技术问题，比如运放做比较器和专门的比较器会有什么不同点等等。 最后他说可能不一定会有二面，但是11月1号上午会确定是否给offer。我的感觉是：在答最后一道自由发挥的题时，大家最好把自己最熟悉的项目写上，并且写清楚，这样会给人家留下非常好的印象。另外项目如果不是自己做的，或者解释不清楚的，简历上最好不要提，被他们盯上就不好说了。但是他们还是很Nice的。
四、华为笔试
人家说得不错，要做好一些事情，不但要有目标还需要有充分的准备。虽然我没有什么明确的目标，但是这次我有了稍稍的准备。自从被迈瑞打击了一下，我重新认识了自己。回来正经地复习了一下功课。虽然华为的硬件笔试题目出得很基础，但我也有不少做不好。但总算可以从迈瑞的失败中稍稍恢复了一点点信心，不管结果怎么样，我终于可以从头到尾做完，还提前了半个小时交卷。下面稍稍总结一下吧。
对于华为，我感觉浙大的牛人很不屑一顾。BBS上面关注的人不多，有也是华为负面的消息。迈瑞笔试那天有四个教室人，华为今天也就一个阶梯教室人。在笔试之前，华为都给参加笔试的人打了电话，问问情况。我也收了两个，不过没带手机，没接上。接到电话的人有两个被调整到技术服务类了。不过听说技术服务类比研发的待遇要好哦。在考场上，什么也不用检查，去了就考，没有通知到的也可以考，总之是来者不拒。
试卷有10道填空题，12道单选，12道多选和一道分析题。
其中分析题就叫写出2－4译码器的真值表，是不是比期末考试还简单呢，20分哦。
填空题第一道就是一道运放题目，给一些已知条件求运放的输出电阻，出来听大家讨论，好像我做错了。
第二道又不会，问2DPSK是什么键控，是通信方面的内容，在百度搜了一下，原来二相差分移相键控。下面有什么是误码率啊，什么PCM一次群，8086的寄存器是几位，给你一个128K的静态RAM和起始地址，问你最后一个字节的地址，还有VHDL和数字逻辑等等。有一道题我真写不下东西，问组合逻辑输出用做时钟容易产生什么。在单选题目考还是那些基础的东西，有问IBM-PC和兼容机的I/O端口空间，PCM32一次群一个复帧的时间，还有是问码元长0.1us，2.5秒产生一个误码，其误码率是多少，不会就蒙吧。还问到RAM和ROM的区别，静态RAM和动态RAM的存储单元结构等等。多选比较变态点。第一题问下面的逻辑门必须上来电阻的是：OC门、OE门、OD门、以上都要。
第二题是问你下面是可编程逻辑器的是：ASIC、PAL、GAL、FPGA、CPLD。第三题是RISC和CSIC的区别。第四题是总线的功能，我不知道驱动是不是总线的功能，所以没选。第五题有点难，问下面避免竞争冒险的是：采用同步时序电路，采用异步时序电路，修改状态转移表，增加延时逻辑。第六是ROM和RAM的区别，下面是8051的P3脚复用功能，接着是检波器的组成，还有常见的滤波器。第10题不会：问8KHz和10KHz的正弦波经过混频器之后，能产生下面那些频率的信号：－2K、2K、18K、1K。11题考8051的中断，最后一道不容易，问下面对负反馈那里两个是对的。 从题目的难度和广度上看，比迈瑞的简单，但是没有准备过的人也很难做出来的哦，范围广，重基础，关键还有可恶的多选选择。总的来说，我对自己的表现比较满意。没有迈瑞的那么狼狈。但是，估计没有下文了。我想这份题目做得好的人大大的是啊。
听上午接到电话的人说，华为搞硬件的主要是3个方面：DSP和算法、逻辑电路、ASIC。
唉，这三个我没有一个会，更不用说懂。就算有幸进到一面，也会被刷的，我想主要还是专业不太对有点影响。未来的事情就等它发生了再说吧。好好准备眼前的事情才是正道。
五、华为一面
华为的硬件笔试考完之后感觉不错，果然得到了一面的机会。不过我们学校去参加笔试的都可以去参加面试。不过听说华为这次做硬件的只招收DSP和逻辑两个方面，我一听就觉得自己就此终止华为的征程了，看看大公司的面试也是长长经验吧。
我的面试时间被安排在6号的9点，搞到那天6点45就得起来从下沙赶到黄龙那边的一个酒店，极度的痛苦。不知道怎么搞的，和我一起来的几个9点20的都面试完了还没有轮到我们。后来问问才知道我被安排到DSP组里面去了，后来赶紧叫他们改为逻辑。大概等到11点，终于到我了。不过当我走到面试官的前面，他却说要上洗手间，叫我等几分中，看来真是出师不利啊。
面试官很和蔼客气，大家say hello之后，我紧张的心情松了不少。然后他开始瞄我的简历，我估算了一下，不超过3秒钟。还好我做的是一页简历。他看到我后面有两个项目的实物图，就指着我在04年机械设计大赛的获奖作品问：“这个好像是什么车？”我说这个是我在省里面竞赛的一个作品，主要用一个多单片机
系统控制直流电机和舵机完成相应的功能。不过他好像不感兴趣，然后就问：“我看你的简历好像做DSP和逻辑的比较少嘛”（其实我根本就没有做过）。我赶紧说：“是的，我们研究生虽然有相关的课程，但是我们学到只要是一些入门的基础，离实际的应用还很远，我在本科的时候主要是一些基础知识的系统学习，在研究生阶段主要是跟老师做做项目，其实我现在的技能主要和我做的项目相关，在以前的基础上的其中一两个方面进行比较深入的研究。”
面试官看了看的简历说：“我看你做单片机的项目比较多嘛，我们也有做单板机软件，也有用一些小型的CPU和AD转换、DA转换的一些东西，你愿不愿意做呢？”我想DSP和逻辑肯定挂了，这个还有一线生机，赶紧说：“OK，没有问题，其实我的毕业设计就说一个单片机的数据采集和处理系统，我把实物带来了，你要不要看一下？”他点头示意可以。我心里一阵高兴，终于可以使出我的武器了。 下面的面试内容的完全按照我事先预料的方向进行了。首先我详细的介绍我带来的系统，从原理到框图，从性能到关键点说了一通。他听完，问我：“这个系统是你设计的吗？”对于这个问题我觉得还是老实做答好，不然会死得很惨的。我说不是，我参加这个项目的时候，这个系统已经设计好了，我做的工作就是对老的版本进行测试，改善，从硬件和软件两个角度去进行性能和稳定性的提高。他说：“那好，我就问你几个问题吧？”
首先问我上面一个三极管是干什么用的，我说那其实不是三极管，是一个稳压器79L05，产生一个－5V的电压给AD。然后他问我上面两个二极管是干什么用的，我说那是起保护作用，主要是限制电流反流。他一听很奇怪，他说二极管好像没有限流作用吧，我觉得他可能听错了，就补充了二极管的单向导通性，圆了一下场。
接着他叫我将系统上面的有源滤波画出来，完了，这个系统我就那个地方没有弄懂。怎么办呢？只有画吧，凭着记忆画了一个二阶的有源滤波电路，跟他说我其实忘记了，大概说这样吧。他说那你讲讲这个滤波器的工作原理吧，我连画都画不出来，原理更讲不清了。我就跟他说：“其实二阶的滤波器和一阶滤波器的推导大致原理一样的，我画个一阶的来解析一下吧”。然后就画画讲讲，其实我还讲的比较清楚的拉。他问了最后一个问题，如果你的那个传感器的线比较长，会对你的系统有什么影响，其实我也是按照大致的方向去答的拉，我说这样就会导致信号的衰减和干扰的增大。他稍稍停了一下，问我喜欢做偏硬一点的还是偏软一点的。我说相对来说，我平时对偏软一点的做的事情比较多。他说：“那我就给你定底软的岗位吧，我现在要考考你；两道C语言的题目。”然后取了一叠试卷，边找边说给我找两个简单点的题目。第一个：写一个宏名为MIN的宏，输入两个参数，求最小的那个？晕倒！我见了很多次，但是为什么偏偏在那个时候忘记呢？但是总不能说不会吧，人家都说给我找简单的了。只有硬着头皮写拉。我的答案是： ＃define MIN (A,B) ？（A>=B）B:A 他看了我的答案，马上指出我的几个错误，应该是： ＃define MIN(A,B) （A>=B）？（B）:（A） 
第二个是读程序写结果，在一个mian()函数里面循环3次调用一个有静态变量的函数，输出一个和的结果。这个我最熟悉的了，三两下就把结果和过程都写出来了。 这时，面试也差不多要结束了。面试官问我工作地点的问题。我说我是广东人，希望在深圳，他说这个没有问题。然后我再一个确认我的工作内容，他说主要是底软吧，到时候部门之间再调配一下，他看了看我的简历，发现我有ARM工业主板和LINUX的经验，他说其实他们也会做相关的东西，例如VxWorks等。 这时，面试官对我说，他对我的能力比较满意，我心里一阵狂喜，不知道是骄傲还是高兴。他主动站起来和我握手，说叫我等秘书的通知，下一轮面试通知会在这两天发出。这时我都不知道自己在做什么了，收拾了下我的东西，临走前我主动和面试官再次握了握手，感谢他的面试与指导。
六、华为二面
没想到华为的工作效率那么快，本来还以为要到8号才有二面的通知，所以6号晚上玩了一把，到1点才睡觉。当我睡得正香的时候，来了两个短信，心里一阵狂怒，凌晨两点半什么人那么无聊发短信啊。不过一看原来是华为通知7好早上9点半面试，果然和大家说的一样，集体群殴PK，不管它了，继续睡觉。
本来想睡到7点起来的，不过6点20分左右，又来了短信，还是华为通知面试的，他们不会加班到通宵吧。我们学校去参加研发一面的有4个人，其中有3个都进了二面。到了指定的酒店后，先是填表，还真是详细，什么都得填。本来安排是9点30的面试，后来拖到了10点20左右。之前，我们组的12个人都到得差不多了，大家赶紧先认识一下，到时候PK的时候也比较熟悉嘛。
时间到了，我们在一个MM的带领下进了房间，三个桌子排成三角型，中间一牌是面试官4男1女。两外两个是AB两组，反正大家随便坐，12个人分成两组PK。
首先是每个人用一张纸折一个铭牌，将自己的姓名和应聘岗位写在上面。然后面试官开始叫我们自我介绍，要说得让面试官和大家对你留下深刻的影响，说说你的特点和以后的职业规划。我发现浙大的人理想很大哦，职业规划都是要做什么技术管理结合的职业经理人。我都忘记了我是怎么样介绍我的，好像说了说我一些竞赛获奖，说了说我的业余爱好，喜欢踢足球拉，还有就是我觉得我的硬件基础比较扎实，在华为里面能发挥所长，体现价值，华为是一个大企业，我在里面也能得到锻炼和成长。不知道这样说有没有问题？ 
接着开始一个活动，在10分钟里面，每组按照发的题目将里面属于白领最忧虑的事情进行排序，然后由组里面的一个人进行陈述理由，然后其他人可以进行补充。活动刚开始我提了一个意见，但是有一个人的意见比我的更好，那就按照他的意见去做吧，我顺势将他推举为我们组的leader。
在10分钟里面，HR们过来看大家的表现，然后打分，反正我是没有怎么去排列，我只是协调一下大家的动作啊，看看时间啊。很快时间到了，他们组先进行了陈述，在陈述的过程中，面试官会打断陈述，叫另外有个人补充表述。我们这组也是。在这个表述中，我基本上没有什么话，算是话最少的了。 两个组的排列顺序很不一样，这时候面试官说，你们两个组分别陈述理由，让对方同意你的观点。然后，两个组的人就纷纷展现自己，在这个过程中，我几乎一言不发，看来犯了群殴的大忌了。
最后，面试官叫没有发过言的同学起来说两句，我是最后一个起来发言的，我就总结性的说了两点，然后就休息5分钟。 其实休息5分钟是让我们两个组在外面交流一下，统一一下观点。我知道他的意思，出来后我问两个组是不是应该统一一下观点啊，好像他们也没有退步的感觉，那就算了吧。 很快有进去了，首先面试官叫对方组的一个人起来，说说他的看法，他说同意了我们组的一个观点但是也有不同的地方。他说完之后，面试官看着我说，你们好像在外面统一了一下观点，你说说将B组的12点排在前面，你认不认同。
我突然晕了，这怎么回答呢，答认同嘛，不知道会不会被我们组认说，说不认同嘛，那面试官明说说我们统一观点，而且B组的人也妥协了。那我只有用了找迂回战术，顺着B组刚刚的内容说了些总结性的东西，既不认同也不否认认同。
面试官看我答非所问，又将问题问了一遍，我又将刚才的话说了一边。晕倒，这时那面官来了句其实我只是问你认不认同，这时候我发现我们组的leader在我的纸上写了认同两个字，我赶紧说认同认同，这才能坐下啊。 
接着就是PK时段，想不到我是我们组唯一参与的。B组也有一个人，面试官说，给你一个机会你把你的特点和长处说出来，让我们觉得你应该加入华为。对方那人说啊说，面试官还让他举了一个案例。真想不到会轮到我要参与PK，是不是因为我话太少，不够积极呢，还是什么......面试官看我有点紧张，就对我说，你看我现在给了你这么好的一个机会，你要把你的特点和长处说出来，其他人我都没有给机会啊。不知道是不是安慰我的话。然后我就慢条斯理的说，我自己性格比较随和，喜欢跟别人交流，我觉得在交流的过程中会得到很大的提高，我的基础知识比较扎实，在项目的实践过程中，发现基础技能很重要，很多高端的问题都可以用基础的知识来解决。说我本科是学硬件的，研究生学的是软件，在实践的过程中发现现在不管是硬件开始还是软件开始都是一个协同的过程，不能机械的拆分两者，说我考虑问题会从系统的角度去分析，个体不一定是最好的，但是可能对系统的贡献是最大的。最后我总结说，我的优点是我为人随和，有独立分析问题和解决问题的能力，自我适应能力和学习能力比较强，在知识结构上面，软硬件结合实际项目经验较多。
面试官接着问我平时爱好干什么啊，我就说我喜欢体育运功，特别喜欢踢足球。他居然问我踢那个位置，不知道他是不是也踢足球的，我是中场。他又问我平时都和什么人踢啊，是不是和同学踢，我说不一定，有时候和同学踢，有时候到了球场上，碰到谁就和谁踢，还说我参加过一个大型的足球比赛。 就这样传说中的华为群殴结束了，虽然没有网上说得那么恐怖，但是也领我感到有点不爽，不知道是不是我被问的缘故。后面还有10分钟的提问时间，有人问了华为集体辞职和加班的问题，还有下面的一些安排。
这时我才知道下面还有一个单对单的综合面试和综合素质测试、性格测试和英语测试。 长路漫漫啊......不知道还能不能收到三面的通知呢？等等吧......
七、智光面试 
非常感谢智光电气给我面试的机会。由于18号中午学校要进行毕业生的图像数据采集，我没有办法参加智光电气的笔试，虽然在宣讲会那天和相关的人员打了招呼，但是那天一直到下午三点多还没有收到任何通知，在浙大88上看到已经有人开始面试了，感觉这次是不是又没戏了呢？干脆回去寝室睡觉算了。这时居然接到了智光电气的电话，说明天什么时候来杭州百脑汇8楼面试...... 没有参加笔试和一面，直接参加19号的面试，这样的待遇我还是头一次，很有受尊重的感觉。有机会就不能错过，剩下的时间我就开始临时抱佛脚，听说很有用，不过面试的时候我都没有用上，因为我的面试估计也就10几分钟吧。之前我等了大概半个小时。 面试我的是一个博士，还有另外三个人。
主要就是根据简历上的东西随便问问你，但是每个技术都问得很到点子上，但是我也答得很到点上，而且还很老实，很多东西都直接说不是我设计或者不是我一个人做的，或许这样他们就不再往下问了。现在的硕士大家都知道什么水平的拉......总不能说自己是什么大牛，估计我是说了肯定逃不过他们的法眼。这次我仍然带了我的毕业课题做的板子过去，不过他们就随便看了看，也没说什么，我一点发挥的机会都没有......是不是他们看不上呢？他们问为什么用华邦的单片机做呢？我说便宜啊。就这样。另外还问我有没有做过电机方面的东西，那我就把以前机械设计竞赛和指导电子设计竞赛的一些东西说了说，大概就五六句话吧。后来有个人问我做的一个数据汇集机用什么进行电话网通信的，我说是MODEM，本来以为可以大说一顿的拉，那个工程师说可以了，知道了。那我也没什么说的了。基本上聊了一些基本问题面试也就结束。 接下来就谈待遇了，那个主面的博士问我期望多少钱，经过多次的打击，我也不好意思说了，就说我没有很高的要求，中等就可以了。他叫我尽管说。我说5K到6K吧。他说5K应该没什么问题的。估计也就这个身价了。后来聊了一些工作内容和时间的问题，基本都比较合意吧。然后就叫我准备三方了。我说两天内答复。找工作实在太累太耗时间和精力了，其实也没有什么可以选择的了，就这样......回去再想想，卖了吧。
八、理邦面试
自从上次在智光面试完之后，也没有什么合适的单位到来。在智光面试完，我正准备签三方的时候，他们的HR告诉我，要等广州总部的总工电话面试，但是快两个礼拜了都没有音讯，估计我是被他们放弃了。正好1号深圳理邦来浙大宣讲，就去碰碰运气吧。 那天宣讲完马上开始笔试，还好之前抱了下佛脚。原本我应聘的是嵌入式软件工程师职位，需要考一份软件题，不过一想到软件的算法，心里有点慌慌，要了份硬件的题目来做。题目不多，八九道简答题，主要涉及晶体管、运放、滤波、触发器、AD、通信、单片机等一些很基础的东西。我已经是身经百考的人了，每个公司的硬件题目都差不多的，大部分做起来没有什么问题，除了一个压控电流源和一道场效应管的题目没做，其他的问题不是很大，估计有下文，果然晚上接到了面试的电话。 理邦公司给你第一感觉很实在，很规范化，而且很守时。面试安排在9点20，我怕迟到早点到了，说20就是20，我在面试的时候发现他们原来是有表的，难怪时间那么准，一次面试，经历了三个面试官的车轮战，对于我来说，还是头一次。 
第一战：技术面试， 我原来是他们通知的第二个来面试的人。面试的时候，和他有好几米的距离，感觉有点紧张。上来第一个问题是你喜欢做什么样的工作，然后开始按照你的简历上面的所做的项目来问，我都忘了我怎么回答的了，总之就是不停的说。我第一次感觉到我的简历没有被浪费，他们用黄色的荧光笔在上面画了不少东西，看来我还是有一点东西能让他们感兴趣的。它对我应聘嵌入式软件工程师去考硬件题目有点奇怪，那也没什么好解释的，就觉得自己对硬件更有把握一点。这时又问了一些linux和ucos方面的东西等等，最后问我技术上面有什么问题需要问的。这个我还真的没有怎么备，不问感觉好像对公司和个人不关心的，我问他们像我这种非生物医疗专业的人进去做会不会很困难。他说没关系，我看你的计算机学得很不错，呵呵….这句话我搞得我很不好意思。也就是十几分钟，就结束了，要走的时候，他说我考的是硬件题，技术总监要面试我硬件方面，面就面罗。
第二战：技术总监， 技术总监给你感觉和蔼而威严。他看了看我的成绩单，好像更关心的是我本科的成绩，他说你本科是机械自动化的，那你觉得你和电子、计算机专业的学生竞争有什么优势吗？说真的，在专业技术上面没有任何的优势，我主要围绕着软硬件结合和项目经验比较丰富这两方面来讲，好像说得过去了。接着他问了我单片机方面的一些东西，好像他们对UCOS这个东西比较感兴趣，问我UCOS移植到MSP430上面行不行，我说没什么大的问题，然后说了说这个移植的过程。这个过程中，我感觉我一直在不停的说，嘴都干了，都不知道我那来那么东西说。在他问我为什么要在6月份毕业的时候，一个女的HR进来了，正好，技术总监叫我跟她出去了。
第三战：面对女HR， 也许这次是我第一次真正的面对HR，感觉很不自然，而且问题回答的很糟糕。在整个过程中都非常的严肃，我不知道其他公司的HR面试是不是也这样。 在面试的时候，我看到她在一张写着资格审查的表上写了我回答的问题，她问的问题我基本上都没有什么准备过，总之，问什么就答什么，但是我犯了个错误，有些问题不需要答得太多，说多了就会有问题… 首先问我的职业规划是什么样的，我还真没有考虑过，经过上次华为二面的教训，我大概把3－5年的打算说了说，就一句话，我这段时间想在一个行业里面做研发，在技术上面多点积累，五年后可能做做技术管理方面的东西。然后问你要找什么样的公司？工作地点在那里？有没有女朋友？平时喜欢干什么？性格是偏内向还是偏外向？其实这个我自己都不是很清楚，应该是有点内向吧。问我身边都是些什么朋友？这个问题我答得比较糟糕，我也不想多说拉。接着问你父母对你的最大影响是什么啊？对加班的看法？你最艰难的时候是什么时候，这个地方我又说多了，唉…..还问了毕业时间和实习的一些情况，最后问我有没有offer，我还真的是没有啊，问我以前有没有offer，我说智光电气给我了口头的offer，她好像很关心，把这个公司和我应聘的岗位都写下了，问我他们的待遇是多少，她顺便问我期望薪资多少，我想他们也不会给太多，说了个5K到6K，估计最后成的话也就5K吧。最后她例行的问我有没有什么问题要问的，我之前还真没有考虑过哦，问了她在公司里面三年这个发展过程怎么样。 1号上午理邦一面回来感觉不是很好，但是晚上还是收到了二面的通知。
在宣讲会的时候，他们说是要小组面试，我心里想一面的时候，技术专家面了，技术总监也见了，HR也谈了，二面面什么呢，小组面试会不会是跟华为他们一样的呢？心里没有什么底，也不知道怎么准备，干脆就不准备了。 冬天早起的确是一件很艰难的事情，好不容易才爬起来，九点钟面试，我八点五十五才感到面试地点。当我进去面试的房间才知道他们的小组面试是什么回事，原来所谓的小组，是他们小组，面试我一个人，昨天面试的3个人一起来面试我，大概30分钟吧。原来还是问技术方面的问题，但是问的很深入，有很多问题我知道也做过，但是答的不完整，有些问题他们继续深入问，我只能说不知道。他们完全按照我简历上面写的项目和技能来进行考查，所以说没有做过，甚至没有什么把握的东西，最好少出现在简历上面，一旦有严格考查的公司面试，一下就暴露出来了，而且还觉得你有吹嘘的嫌疑。 面试一开始，公司技术总监就拿着我的本科成绩单和笔试题目说，我是机电毕业的学生，但是从笔试来看，我的基础不是很好，这个怎么办好呢？问我准备以后怎么样去补救。其实我觉得这份题目做的还不错的拉，我看他在那道压控二极点高通滤波器上面打了一个大叉叉，我本来还觉得这道题目会做对的呢？然后他问我一些做“月球车”比赛的事情，我回答得应该不错，他说我是这个团队的军师了，这我科万万不能接受啊，赶紧把队友的贡献说了一通，强调他们的重要作用，这个团队里面少了谁也不行。接着问我一些单片机相关的项目，这个我都答得没有什么问题。然后是一个应该是偏软件一点的技术专家问我。
首先就我用VC做的一个项目问我windows消息的机制是怎么样实现，这个问题其实我答得不是很好，我就项目上面基于消息机制的异步网络传输说了一些windows消息机制的一些东西，他接着我说的问我知不知道将关联消息和消息响应函数的那个宏是怎么样实现的，有没有看过代码，我只能说没有看过，但是我说我知道它的原理，是用一个静态的函数表将消息和消息响应函数关联在一起的，他又顺着问题往下问我知不知道这个函数表叫什么，我又只能说不知道了。
下面他看我上面写着有linux下C/C++开发的经验，就开始从这里问我了。看我上面写着做过字符设备的驱动，其实我只是做做实验看看代码而已，我就把字符设备驱动的框架说了一说，他又接着我的回答，问我知不知道操作系统怎么样找到设备相应的处理函数的，我也没怎么样想，就直接说不知道了，但是我说我觉得他们应该是怎么样的，我想应该回答得到点上面了。接着他问我有没有做过linux上面的应用开发，我还是老老实实的告诉他吧，没有做过。他好像对我在简历上面的不老实有点不满。然后他继续问我相关于嵌入式和linux方面的东西，比如说移植啊，bootloader啊，会不会做randisk啊等等，大部分我只能say no了，但是我也不是完全举手投降，把相关的知识点答了一些，可能这也为我前面的不足做了一下弥补吧。
最后是HR发问，还是一些常规但是不好答的问题：你觉得什么是成功？你觉得人生的意义是什么？你觉得自己有什么缺点？你为什么要选择理邦？你觉得到了理邦公司你能做些什么样的贡献？如果现在给你offer你会不会签？等等…我觉得这些问题的回答非常关键，可能前面你都答的不错，但是这问题回答不好，也会被out的。我觉得今天我这些问题答的还是可以的，虽然不是很好，总之这些问题怎么回答还是见仁见智的了。最后一个环节是例行的问我有没有什么要问的，我其实也没什么问的了，但是不问不是很好，就问了一些关于实习的事情。面试结果要到下午才能知道。 想不到他们效率那么的快，在中午我正在食堂打饭的时候，他们的电话来了。虽然有点吵，但是还要赶紧接拉。HR先把面试结论告诉我，没怎么听清，大概是说我知识面比较宽，但是深度不够，基础不是很扎实等等等等，但是作为一个嵌入式软件工程师来说，还是可以培养的，下午可以来签约了，然后是待遇的情况，说了一通时候，告诉我要带什么什么。 还考虑什么呢，下午赶紧把需要的东西带齐，奔赴浙大签约了。签约只是一个5分钟的过程，他们把资料收好，给我出了张公司的接收函，再给我一张联系方式，整个签约就结束了，巨快。我就这样卖出去了，尽管有很大的遗憾，但是最后我选择了一个高校，跟理邦办了违约手续。
九、经验总结
1、要有备而来，尽量将面试官引导到你最擅长的地方。其实他们也希望这样的吧，否则他很难发现你的能力和特长，而他不知道你的长处，就只有按照他的思路来考你，对你乱开枪，这样大家都没有得到想要的结果。
        2、诚实最重要，懂就懂，不会就不会，东西不是你做就不要乱认。面试你的都是这一行的资深工程师，要忽悠他们可没那么容易。
        3、对于不会回答的题目，不一定要给出准确的答案，只要往正确地将大致的思路说清楚就可以了，关键是你把你思考的过程告诉面试官。
        4、要有自信心，当被问到确实不会的问题是，可以问问面试官，他们会给你一些提示或者思路，你或许能做出来呢？
        5、平时要主要积累和准备，不然当面试机会来临的时候就手忙脚乱的拉，不过有时候临时抱佛脚也挺有用的，总之，没有准备很难有好发挥。
        6、投[url=v]简历[/url]要有目的性，瞄准一家之后，做好各方面的情报工作，在网上收集试题、面经等等。再投一些同类的公司，他们只是您的热身对手，重在参与，发现不足，锻炼心理，演练战术。
        7、笔试不可怕，笔过两会就经验丰富了，考什么你心里很自然会清楚的。硬件的当然是数模电基础、单片机接口和C语言拉。嵌入式方面少不了操作系统、网络原理、驱动等一些内容，但都是基础，比期末考试还要容易呢。
        8、求职是一个复杂的过程，职场如战场。您完全可以把它看作一场战斗，优胜劣汰，除了有足够的枪支弹药，还需要有战略战术的指导。 祝大家求职顺利，个个早日找到理想的工作岗位。

C/C++模块
1、为什么C语言中，一个结构体变量占内存的字节数有时候不等于各成员变量占字节数之和？
若有如下定义:
struct data
{
int i;
char ch;
double f;
}b;
则结构变量b占用内存的字节数是多少？16个
2、关键字static 的作用是什么？
在C 语言中，关键字static 有三个明显的作用：
•在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
•在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
•在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
3、关键字const 有什么含意？
const int a;         // a是一个常整型数
int const a;           // a是一个常整型数
const int *a;    // a是一个指向常整型数的指针（也就是整型数是不可修改的，但指针可以）
int * const a;   // a 是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）
int const * a const;   // a 是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）
前两个的作用是一样，a 是一个常整型数。第三个意味着a 是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a 是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a 是一个指向常整
型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。顺带提一句，也许你可能会问，即使不用关键字const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const 呢？我也如下的几下理由：
•关键字const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const 的程序员很少会留下的垃圾让别人来清理的。）
•通过给优化器一些附加的信息，使用关键字const 也许能产生更紧凑的代码。
•合理地使用关键字const 可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。
4、overload和override的区别
重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。
如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。
子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。
5、改错题
void test2()
{
　char string[10], str1[10];
　int i;
　for(i=0; i<10; i++)
　{
　　str1 = 'a';
　}
　strcpy( string, str1 );
}
　　试题3：
void test3(char* str1)
{
　char string[10];
　if( strlen( str1 ) <= 10 )
　{
　　strcpy( string, str1 );
　}
}
　对试题2，如果面试者指出字符数组str1不能在数组内结束可以给3分；如果面试者指出strcpy(string, str1)调用使得从str1[url=]内存[/url]起复制到string内存起所复制的字节数具有不确定性可以给7分，在此基础上指出库函数strcpy工作方式的给10分；

　　对试题3，if(strlen(str1) <= 10)应改为if(strlen(str1) < 10)，因为strlen的结果未统计’\0’所占用的1个字节。

　试题4：
void GetMemory( char *p )
{
　p = (char *) malloc( 100 );
}
void Test( void ) 
{
　char *str = NULL;
　GetMemory( str ); 
　strcpy( str, "hello world" );
　printf( str );
}
　　试题5：
char *GetMemory( void )
{ 
　char p[] = "hello world"; 
　return p; 
}
void Test( void )
{ 
　char *str = NULL; 
　str = GetMemory(); 
　printf( str ); 
}
　　试题6：
void GetMemory( char **p, int num )
{
　*p = (char *) malloc( num );
}

void Test( void )
{
　char *str = NULL;
　GetMemory( &str, 100 );
　strcpy( str, "hello" ); 
　printf( str ); 
}
　　试题7：

void Test( void )
{
　char *str = (char *) malloc( 100 );
　strcpy( str, "hello" );
　free( str ); 
　... //省略的其它语句
}

　　解答：
　　试题4传入中GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值，执行完
char *str = NULL;
GetMemory( str ); 
　　后的str仍然为NULL；

　　试题5中
char p[] = "hello world"; 
return p; 
　　的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。

　　试题6的GetMemory避免了试题4的问题，传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句
*p = (char *) malloc( num );
　　后未判断内存是否申请成功，应加上：
if ( *p == NULL )
{
　...//进行申请内存失败处理
}
　　试题7存在与试题6同样的问题，在执行
char *str = (char *) malloc(100);
　　后未进行内存是否申请成功的判断；另外，在free(str)后未置str为空，导致可能变成一个“野”指针，应加上：
str = NULL;
　　试题6的Test函数中也未对malloc的内存进行释放。

//为了实现链式操作，将目的地址返回，加3分！
char * strcpy( char *strDest, const char *strSrc ) 
{
　assert( (strDest != NULL) && (strSrc != NULL) );
　char *address = strDest; 
　while( (*strDest++ = * strSrc++) != ‘\0’ ); 
　　return address;
}
6、为什么标准头文件都有类似以下的结构？
#ifndef __INCvxWorksh
#define __INCvxWorksh 
#ifdef __cplusplus

extern "C" {
#endif 
/*...*/ 
#ifdef __cplusplus
}

#endif 
#endif /* __INCvxWorksh */
　　解答：
　　头文件中的编译宏
#ifndef　__INCvxWorksh
#define　__INCvxWorksh
#endif 
　　的作用是防止被重复引用。

　　作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在symbol库中的名字与C语言的不同。例如，假设某个函数的原型为： 
void foo(int x, int y);
　　该函数被C编译器编译后在symbol库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。_foo_int_int这样的名字包含了函数名和函数参数数量及类型信息，C++就是考这种机制来实现函数重载的。
　　为了实现C和C++的混合编程，C++提供了C连接交换指定符号extern "C"来解决名字匹配问题，函数声明前加上extern "C"后，则编译器就会按照C语言的方式将该函数编译为_foo，这样C语言中就可以调用C++的函数了。
试题5：编写一个函数，作用是把一个char组成的字符串循环右移n个。
比如原来是“abcdefghi”如果n=2，移位后应该是“hiabcdefgh” ，函数头是这样的：
//pStr是指向以'\0'结尾的字符串的指针
//steps是要求移动的n
void LoopMove ( char * pStr, int steps )
{
　//请填充...
}
　　正确解答1：

void LoopMove ( char *pStr, int steps )
{
　int n = strlen( pStr ) - steps;
　char tmp[MAX_LEN]; 
　strcpy ( tmp, pStr + n ); 
　strcpy ( tmp + steps, pStr); 
　*( tmp + strlen ( pStr ) ) = '\0';
　strcpy( pStr, tmp );
}
　　正确解答2：
void LoopMove ( char *pStr, int steps )
{
　int n = strlen( pStr ) - steps;
　char tmp[MAX_LEN]; 
　memcpy( tmp, pStr + n, steps ); 
　memcpy(pStr + steps, pStr, n ); 
　memcpy(pStr, tmp, steps ); 
}
　剖析：
　　这个试题主要考查面试者对标准库函数的熟练程度，在需要的时候引用库函数可以很大程度上简化程序编写的工作量。

7、编写类String的构造函数、析构函数和赋值函数，已知类String的原型为：

class String
{ 
　public: 
　　String(const char *str = NULL); // 普通构造函数 
　　String(const String &other); // 拷贝构造函数 
　　~ String(void); // 析构函数 
　　String & operate =(const String &other); // 赋值函数 
　private: 
　　char *m_data; // 用于保存字符串 
};
　　解答：
//普通构造函数
String::String(const char *str) 
{
　if(str==NULL) 
　{
　　m_data = new char[1]; // 得分点：对空字符串自动申请存放结束标志'\0'的空
　　//加分点：对m_data加NULL 判断
　　*m_data = '\0'; 
　} 
　else
　{
　　int length = strlen(str); 
　　m_data = new char[length+1]; // 若能加 NULL 判断则更好 
　　strcpy(m_data, str); 
　}
}

// String的析构函数
String::~String(void) 
{
　delete [] m_data; // 或delete m_data;
}

//拷贝构造函数
String::String(const String &other) 　　　// 得分点：输入参数为const型
{ 
　int length = strlen(other.m_data); 
　m_data = new char[length+1]; 　　　　//加分点：对m_data加NULL 判断
　strcpy(m_data, other.m_data); 
}

//赋值函数
String & String::operate =(const String &other) // 得分点：输入参数为const型
{ 
　if(this == &other) 　　//得分点：检查自赋值
　　return *this; 
　delete [] m_data; 　　　　//得分点：释放原有的内存资源
　int length = strlen( other.m_data ); 
　m_data = new char[length+1]; 　//加分点：对m_data加NULL 判断
　strcpy( m_data, other.m_data ); 
　return *this; 　　　　　　　　//得分点：返回本对象的引用
}
　　剖析：
　　能够准确无误地编写出String类的构造函数、拷贝构造函数、赋值函数和析构函数的面试者至少已经具备了C++基本功的60%以上！

　　在这个类中包括了指针类成员变量m_data，当类中包括指针类成员变量时，一定要重载其拷贝构造函数、赋值函数和析构函数，这既是对C++程序员的基本要求，也是《Effective　C++》中特别强调的条款。
7、请说出static和const关键字尽可能多的作用
解答：
　　static关键字至少有下列n个作用：
　　（1）函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
　　（2）在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；
　　（3）在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
　　（4）在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
　　（5）在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。 

　　const关键字至少有下列n个作用：
　　（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
　　（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
　　（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
　　（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
　　（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。
8、数组指针
1.main() 
{
  int  a[5] = {1,2,3,4,5};
  int *ptr =  (int*)(&a+1);   //&a+5*sizeof(int)
  int *ptr1 =  (int*)(aw+1);   //a[1]
int *ptr2 =  (int*)(&aw+2);  //&a+2*5*sizeof(int)

  printf("%d %d" , *(a+1), *(ptr-1) );  结果：2，5
}
2.    void foo( int b[][3])   
{
  ++ b;      //b=b+1 ,b的首地址变为a[1][0]
  b[1][1] =9;
}
main()
{
  int a[3][3]= { { 1,2,3} , { 4,5,6},{7,8,9}};
  foo(a);
  printf("%d" , a[2][1]);           //结果为9
}
9、数组越界问题
下面这个程序执行后会有什么错误或者效果:
 #define MAX 255
int main()
{
    unsigned char A[MAX],i;
    for (i=0;i<=MAX;i++)
        A[i]=i;
}
解答：MAX=255,数组A的下标范围为:0..MAX-1,这是其一,其二 当i循环到255时,循环内执行: A[255]=255;这句本身没有问题，但是返回for (i=0;i<=MAX;i++)语句时,由于unsigned char的取值范围在(0..255),i++以后i又为0了..无限循环下去.
注：char类型为一个字节，取值范围是[-128，127]，unsigned char [0 ,255]
10、memset ,memcpy 和strcpy 的根本区别？
#include "memory.h"
memset用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化为‘ '或‘\0'；例:char a[100];memset(a, '\0', sizeof(a)); 
memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度；例：char a[100],b[50]; memcpy(b, a, sizeof(b));注意如用sizeof(a)，会造成b的内存地址溢出。 
strcpy就只能拷贝字符串了，它遇到'\0'就结束拷贝；
例：char a[100],b[50];strcpy(a,b);如用strcpy(b,a)，要注意a中的字符串长度（第一个‘\0'之前）是否超过50位，如超过，则会造成b的内存地址溢出。
strcpy 
原型：extern char *strcpy(char *dest,char *src); 
用法：#include 
功能：把src所指由NULL结束的字符串复制到dest所指的数组中。
说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。
返回指向dest的指针。
memcpy 
原型：extern void *memcpy(void *dest, void *src, unsigned int count);
用法：#include 
功能：由src所指内存区域复制count个字节到dest所指内存区域。
说明：src和dest所指内存区域不能重叠，函数返回指向dest的指针。
Memset
原型：extern void *memset(void *buffer, char c, int count);
用法：#include 
功能：把buffer所指内存区域的前count个字节设置成字符c。
说明：返回指向buffer的指针。
11、ASSERT()是干什么用的
ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。例如，变量n在程序中不应该为0，如果为0可能导致错误，你可以这样写程序： 
...... 
ASSERT( n != 0); 
k = 10/ n; 
...... 
ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略。 
assert()的功能类似，它是ANSI C标准中规定的函数，它与ASSERT的一个重要区别是可以用在Release版本中。  
12、析构函数和虚函数的用法和作用？
析构函数也是特殊的类成员函数，它没有返回类型，没有参数，不能随意调用，也没有重载。程序在类对象生命期结束的时候，由系统自动调用释放在构造函数中分配的资源。这种在运行时，能依据其类型确认调用那个函数的能力称为多态性，或称迟后联编。另：析构函数一般在对象撤消前做收尾工作，比如回收内存等工作，
虚拟函数的功能是使子类可以用同名的函数对父类函数进行重载，并且在调用时自动调用子类重载函数，如果是纯虚函数，则纯粹是为了在子类重载时有个统一的命名而已。
13、全局变量和局部变量
全局变量的生命周期是整个程序运行的时间，而局部变量的生命周期则是局部函数或过程调用的时间段。其实现是由编译器在编译时采用不同内存分配方法。全局变量在main函数调用后，就开始分配，如果是静态变量则是在main函数前就已经初始化了。而局部变量则是在用户栈中动态分配的（还是建议看编译原理中的活动记录这一块）

20、一些知识点总结
1. 传指针时，我们可以通过指针来修改它在外部所指向的内容。但如果要修改外部指针所指向的对象是不可能的。例如传递外部指针到函数内来分配空间，必须传递指针的指针或指针的引用。 
2. char carry[10] = {0}; 编译器会将其后所有的东西都置0； 
3. 函数返回值为const时，返回的东西付给一个类型相同的标示后其不能为左值； 
4. const int *i; int const *i; int * const i; 前两个功能相同，说明I所指向的内容不变；最后一个说明指针指向的地址不变，但内容可变。 
5. 类中的const成员函数。定义为在原型后加const。常量函数不能修改类中的任何属性。但有两种方法可以修改。 
a) {（myclass *）this->member1 = values;} 
b) 将一个成员定义成mutable即可被常量函数修改。 
6. 类中的常量const 类型的，不能在类中被用来定义数组。而enum {ONE=100; TWO=2};定义的ONE、TWO却可以。通常的enum定义的置分配问题：enum A{ L=9, Z};此时Z的值为10。 
7. 用const定义的int可用来开辟数组，但const定义的常量数组中的元素，不能用来定义数组。 
8. 用sizeof计算变量的空间，如果是数组，按实际空间返回；常量字符串（实际上是在静态内存区开辟的变量）sizeof返回比实际长度加一。如果是指针则不考虑它指向的空间大小，仅仅返回指针类型的大小。如果用sizeof计算函数的行参，即使是属组也仅仅返回一个相关类型指针的大小。 
9. 形如int iarray[] = {12, 124, 433};编译器会自动给iarray分配3个元素的长度。元素长度的个数计算公式为sizeof(iarray) / sizeof(*iarray)。 
10. 拷贝构造函数：当行参和实参结合时，如果是复杂对象的传值类型，则调用拷贝构造函数生成一个临时对象作为实参，退出函数时，临时对象被调用析构函数释放。当返回值是复杂对象是，也是调用拷贝构造函数来赋值。这就出现构造函数和析构函数被调用次数不相等的情况。拷贝构造函数的原型为A(A&)，我们可在类中重载。（缺省的拷贝构造函数是使用位（bit）拷贝方法：浅层拷贝，不拷贝指针指向的内容）。 
11. volatile类型的变量告诉编译器，本变量不需要进行代码优化。在多线程的应用中，我们如果读入一个变量到寄存器，此时时间片到期，去处理其他线程了，在重新获得处理机时，volatile类型告诉处理机，重新从变量读取数据到寄存器，而不是用寄存器数据直接处理，这样可以防止脏数据。 
12. class 和struct在一定程度上有相同的功能，只不过前者缺省的成员是私有的，后者在缺省时成员为共有的。故而class不是c++必需的保留字 
13. c和c++编译器，对相同的函数名编译后生成的相同的标示不同，故而在引用c的库文件时必须使用extern “C”告诉编译器，它是c的函数，按c的规则编译。通常我们使用的标准头文件已被处理过。 
14. #include “filename”； #include <filename>，前者先在当前目录下寻找文件，如果找不到再到系统规定的路径下找，后者直接到系统规定的路径下找。 
15. 任何地方分配的静态变量（static）,其生命周期和主进程相同。第二次定义一个已存在的static变量，对变量的内用无影响，但它的可见范围只在定义的范围内。（考研曾作错！）(从静态变量的特性不难理解，类中的static类型是所有对象共享的) 
16. 内联函数（inline）在实现上实际和宏类似，在内联函数出现的地方将函数展开来避免函数调用时的出栈、如栈，提高效率。但内联函数的代价是：代码增大。inline函数适合成员函数和自由函数。在类中实现的函数自动为内联函数。inline必须定义到函数的实现上，例如：inline int PlusOne(int) 是无效的。友元函数在类的体内被实现自动变为内联函数。 
17. #include <iostream.h> 
#define DEBUG(X) cout<<#X"="<<X<<endl 
其中的#X表示X被当作字符串输出。 
18. assert(0 != 0); 如果assert中的条件为假，则运行期间回退出程序，且报告出错代码的行号。（#include <assert.h>） 
19. 静态对象在main结束或exit()被调用时才调用自身的析构函数。这意味着，在对象的析构函数中调用exit()是很危险的，有可能进入一个死循环中。调用abort()来退出函数，静态对象的析构函数并不会被调用。我们可以用atexit()来指定跳出main或调用exit时要执行的操作，用atexit注册的函数，可以在所有对象的析构函数之前调用。 
void exit_fn2(void) 
{ 
printf("Exit function #2 called\n"); 
} //处理函数 
atexit(exit_fn2); 
20. 全局变量实际上用的是静态存储。静态变量的构造是在进入main之前调用的，在main结束时调用它的析构函数。变量的名字由小范围（c++而言）： 
//*.cpp 
int a; //静态变量,但为 extern int a; 即它是全局的，外部可见的 
static int b; //静态变量,static 和extern相反，只在*.cpp中有效，对其他单元（文件）是不可见的。函数的定义和上面相同。 
main() 
{ } 
类的静态成员变量可以如下赋值：int X::s=23;（在*.cpp中，无论公私都可以） 
21. 名字空间(namespace): 定义一个名字空间，然后使用unsing就可以将当前的类型上下文转换名字空间所定地的. 
namespace math 
{ 
enum sign{positive, negative}; 
class integer{ 
int i； 
sign s; 
public: 
interger(int I=0): i(i) {………} 
sign Sign() {………} 
………………….. 
};//end class 
interger A, B, C; 
interger divide(interger, interger); 
}//no ; 

void q() 
{ 
using namespace math; 
interger A; //hides math::A 
A.Sign(negative); 
Math::A.Sign(positive); 
} 
22. 一般对于函数flaot f(int a, int b); 某些c++编译器编译后生成_f_int_int的名字，有些c编译器则生成_f的名字。故在c++中链接c的库函数时要用extern “C”告诉编译器，按c的规则来编译函数。类似的还有extern “C”{#include “myhead.h”},c++还支持extern “C++”{}. 
23. 在函数调用时，传引用也是将指针压栈。 
24. 构造函数、析构函数、赋值构造函数、重载的=，四者的调用顺序：(三种函数都已实现) 
a) X x; X a=x; 
result: 
X:construct 
X:copy_struct 
b) X x; X a; a=x; 
Result: 
X:construct 
X:construct 
X:copy_stru 
operator = 
X:destruct 
如果没有赋值构造函数则结果： 
X:construct 
X:construct 
operator = 
X:destruct 
（如果直接X a=x;这不掉用一般的构造函数，调用复制构造函数） 
指向类的成员函数的指针：设 int X:: a(void){} 
X x; 
int (X:: *pf)(void)= &X::a; 
(x.*pf)(); 
指向成员变量的指针： 设int i; 是X的成员变量 
int X::*pm = &X::i; 
X x;
取自"http://wiki.xyzp.net/%E7%99%BE%E5%BA%A6%E9%9D%A2%E8%AF%95%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3-%E9%99%84%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E9%A2%98.htm"

数据库方面：
1、存储过程和函数的区别
存储过程是用户定义的一系列sql语句的集合，涉及特定表或其它对象的任务，用户可以调用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉及特定用户表。
2、事务是什么？
事务是作为一个逻辑单元执行的一系列操作，一个逻辑工作单元必须有四个属性，称为 ACID（原子性、一致性、隔离性和持久性）属性，只有这样才能成为一个事务：
原子性
事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。
一致性
事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。
隔离性
由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。
持久性
事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。
3、游标的作用？如何知道游标已经到了最后？
游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS可以判断是否到了最后，通常此变量不等于0表示出错或到了最后。
4、触发器分为事前触发和事后触发，这两种触发有何区别。语句级触发和行级触发有何区别。
事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触发器可以获取事件之前和新的字段值。
语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。
5、对数据库的一张表进行操作,同时要对另一张表进行操作,如何实现?
答案：将操作多个表的操作放入到事务中进行处理 
6、.触发器怎么工作的? 
答案：触发器主要是通过事件进行触发而被执行的，当对某一表进行诸如UPDATE、 INSERT、 DELETE 这些操作时，数据库就会自动执行触发器所定义的SQL 语句，从而确保对数据的处理必须符合由这些SQL 语句所定义的规则。
网络编程
1、TCP/IP 建立连接的过程?(3-way shake) 
　　答案： 在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 
　　第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 
　　第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 
　　第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 
2、ICMP是什么协议,处于哪一层? 
　　答案：Internet控制报文协议，处于网络层（IP层） 
　 
3、winsock建立连接的主要实现步骤? 
　　答案：服务器端：socker()建立套接字，绑定（bind）并监听（listen），用accept（）等待客户端连接。客户端：socker()建立套接字，连接（connect）服务器，连接上后使用send()和recv（），在套接字上写读数据，直至数据交换完毕，closesocket()关闭套接字。 
　　服务器端：accept（）发现有客户端连接，建立一个新的套接字，自身重新开始等待连接。该新产生的套接字使用send()和recv（）写读数据，直至数据交换完毕，closesocket()关闭套接字。 
4、动态连接库的两种方式? 
　　答案：调用一个DLL中的函数有两种方法： 
　　1．载入时动态链接（load-time dynamic linking），模块非常明确调用某个导出函数，使得他们就像本地函数一样。这需要链接时链接那些函数所在DLL的导入库，导入库向系统提供了载入DLL时所需的信息及DLL函数定位。 
　　2．运行时动态链接（run-time dynamic linking），运行时可以通过LoadLibrary或LoadLibraryEx函数载入DLL。DLL载入后，模块可以通过调用GetProcAddress获取DLL函数的出口地址，然后就可以通过返回的函数指针调用DLL函数了。如此即可避免导入库文件了。 
7、IP组播有那些好处? 
　　答案：Internet上产生的许多新的应用，特别是高带宽的多媒体应用，带来了带宽的急剧消耗和网络拥挤问题。组播是一种允许一个或多个发送者（组播源）发送单一的数据包到多个接收者（一次的，同时的）的网络技术。组播可以大大的节省网络带宽，因为无论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包。所以说组播技术的核心就是针对如何节约网络资源的前提下保证服务质量。 
8、OSI和TCP/IP
1、OSI的七层网络结构图（功能及特点）
1)   物理层：为数据链路层提供物理连接，在其上串行传送比特流，即所传送数据的单位是比特。此外，该层中还具有确定连接设备的电气特性和物理特性等功能。
2)   数据链路层：负责在网络节点间的线路上通过检测、流量控制和重发等手段，无差错地传送以帧为单位的数据。为做到这一点，在每一帧中必须同时带有同步、地址、差错控制及流量控制等控制信息。
3)   网络层：为了将数据分组从源（源端系统）送到目的地（目标端系统），网络层的任务就是选择合适的路由和交换节点，使源的传输层传下来的分组信息能够正确无误地按照地址找到目的地，并交付给相应的传输层，即完成网络的寻址功能。
4)   传输层：传输层是高低层之间衔接的接口层。数据传输的单位是报文，当报文较长时将它分割成若干分组,然后交给网络层进行传输。传输层是计算机网络协议分层中的最关键一层，该层以上各层将不再管理信息传输问题。
5)   会话层：该层对传输的报文提供同步管理服务。在两个不同系统的互相通信的应用进程之间建立、组织和协调交互。例如，确定是双工还是半双工工作。
6)   表示层：该层的主要任务是把所传送的数据的抽象语法变换为传送语法，即把不同计算机内部的不同表示形式转换成网络通信中的标准表示形式。此外，对传送的数据加密（或解密）、正文压缩（或还原）也是表示层的任务。
7)   应用层：该层直接面向用户，是OSI中的最高层。它的主要任务是为用户提供应用的接口，即提供不同计算机间的文件传送、访问与管理，电子邮件的内容处理，不同计算机通过网络交互访问的虚拟终端功能等。
2、TCP/IP（功能及特点）
1)   网络接口层：这是TCP/IP协议的最低一层，包括有多种逻辑链路控制和媒体访问协议。网络接口层的功能是接收IP数据报并通过特定的网络进行传输，或从网络上接收物理帧，抽取出IP数据报并转交给网际层。
2)   网际网层（IP层）：该层包括以下协议：IP（网际协议）、ICMP（Internet Control Message Protocol,因特网控制报文协议）、ARP（Address Resolution Protocol，地址解析协议）、RARP（Reverse Address Resolution Protocol，反向地址解析协议）。该层负责相同或不同网络中计算机之间的通信,主要处理数据报和路由。在IP层中，ARP协议用于将IP地址转换成物理地址,RARP协议用于将物理地址转换成IP地址，ICMP协议用于报告差错和传送控制信息。IP协议在TCP/IP协议组中处于核心地位。
3)   传输层：该层提供TCP（传输控制协议）和UDP（User Datagram Protocol，用户数据报协议）两个协议，它们都建立在IP协议的基础上，其中TCP提供可靠的面向连接服务，UDP提供简单的无连接服务。传输层提供端到端，即应用程序之间的通信，主要功能是数据格式化、数据确认和丢失重传等。
4)   应用层：TCP/IP协议的应用层相当于OSI模型的会话层、表示层和应用层，它向用户提供一组常用的应用层协议,其中包括：Telnet、SMTP、DNS等。此外，在应用层中还包含有用户应用程序，它们均是建立在TCP/IP协议组之上的专用程序。
3、参考模型和TCP/IP参考模型的区别：OSI
1)   OSI模型有7层，TCP/IP只有4层；
2)   OSI先于协议出现，因此不会偏向于任何一组特定的协议，通用性更强，但有些功能不知该放哪一层上，因此不得不加入一些子层；TCP/IP后于协议出现，仅是将已有协议的一个描述，因此两者配合的非常好；但他不适合其他的协议栈，不容易描述其他非TCP/IP的网络；
3)   OSI中网络层同时支持无连接和面向连接的通信，但在传输层上只支持面向连接的通信；TCP/IP中网络层只支持无连接通信，传输层同时支持两种通信；
4)   在技术发生变化时，OSI模型比TCP/IP模型中的协议更容易被替换。
4、请你详细的解释一下IP协议的定义，在哪个层上面，主要有什么作用？ TCP与UDP呢？　
解：与IP协议配套使用的还有三个协议:
ARP-地址解析协议
RARP－逆地址解析协议
ICMP－因特网控制报文协议ICMP
IP协议－网际协议
IP地址、IP包头
5、交换机和路由器
1. 请问交换机和路由器分别的实现原理是什么？分别在哪个层次上面实现的？
将网络互相连接起来要使用一些中间设备（或中间系统），ＩＳＯ的术语称之为中继（relay）系统。根据中继系统所在的层次，可以有以下五种中继系统：
1)       物理层（即常说的第一层、层Ｌ1）中继系统，即转发器（repeater）。
2)       数据链路层（即第二层，层Ｌ2），即网桥或桥接器（bridge）。
3)       网络层（第三层，层Ｌ3）中继系统，即路由器（router）。
4)       网桥和路由器的混合物桥路器（brouter）兼有网桥和路由器的功能。
5)       在网络层以上的中继系统，即网关（gateway）.
当中继系统是转发器时，一般不称之为网络互联，因为这仅仅是把一个网络扩大了，而这仍然是一个网络。高层网关由于比较复杂，目前使用得较少。因此一般讨论网络互连时都是指用交换机和路由器进行互联的网络。本文主要阐述交换机和路由器及其区别。   
2. 第二层交换机和路由器的区别：
传统交换机从网桥发展而来，属于ＯＳＩ第二层即数据链路层设备。它根据ＭＡＣ地址寻址，通过站表选择路由，站表的建立和维护由交换机自动进行。路由器属于ＯＳＩ第三层即网络层设备，它根据ＩＰ地址进行寻址，通过路由表路由协议产生。因特网的路由选择协议：内部网关协议IGP和外部网关协议EGP
3. 第三层交换机和路由器的区别：
在第三层交换技术出现之前，几乎没有必要将路由功能器件和路由器区别开来，他们完全是相同的：提供路由功能正在路由器的工作，然而，现在第三层交换机完全能够执行传统路由器的大多数功能。
综上所述，交换机一般用于ＬＡＮ－ＷＡＮ的连接，交换机归于网桥，是数据链路层的设备，有些交换机也可实现第三层的交换。路由器用于ＷＡＮ－ＷＡＮ之间的连接，可以解决异性网络之间转发分组，作用于网络层。他们只是从一条线路上接受输入分组，然后向另一条线路转发。这两条线路可能分属于不同的网络，并采用不同协议。相比较而言，路由器的功能较交换机要强大，但速度相对也慢，价格昂贵，第三层交换机既有交换机线速转发报文能力，又有路由器良好的控制功能，因此得以广播应用。
高质量C++／C编程指南笔试题
一、请填写BOOL , float, 指针变量 与“零值”比较的 if 语句。（10分）
请写出 BOOL  flag 与“零值”比较的 if 语句。（3分）
标准答案：
    if ( flag )
    if ( !flag )
如下写法均属不良风格，不得分。
	if (flag == TRUE)	
	if (flag == 1 )		
	if (flag == FALSE)  
	    if (flag == 0)		
请写出 float  x 与“零值”比较的 if 语句。（4分）
标准答案示例：
const float EPSINON = 0.00001;
if ((x >= - EPSINON) && (x <= EPSINON)
不可将浮点变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”此类形式。
   

如下是错误的写法，不得分。
	if (x == 0.0)	
	if (x != 0.0)		
	
请写出 char  *p 与“零值”比较的 if 语句。（3分）
标准答案：
    if (p == NULL)
    if (p != NULL)
如下写法均属不良风格，不得分。
	if (p == 0)	
	if (p != 0)		
	if (p)  
	    if (!)		

二、以下为Windows NT下的32位C++程序，请计算sizeof的值（10分）

	char  str[] = “Hello” ;
	char   *p = str ;
int     n = 10;
请计算
sizeof (str ) =  6   （2分） 
         
sizeof ( p ) =   4   （2分）
          
sizeof ( n ) =   4   （2分）
void Func ( char str[100])
{
请计算
 sizeof( str ) =   4     （2分）
}


void *p = malloc( 100 );
请计算
sizeof ( p ) =  4      （2分）


三、简答题（25分）
1、头文件中的 ifndef/define/endif 干什么用？（5分）
答：防止该头文件被重复引用。
2、#include  <filename.h>   和  #include  “filename.h” 有什么区别？（5分）
答：对于#include  <filename.h> ，编译器从标准库路径开始搜索 filename.h
    对于#include  “filename.h” ，编译器从用户的工作路径开始搜索 filename.h
3、const 有什么用途？（请至少说明两种）（5分）
答：（1）可以定义 const 常量
（2）const可以修饰函数的参数、返回值，甚至函数的定义体。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
4、在C++ 程序中调用被 C编译器编译后的函数，为什么要加 extern “C”？ （5分）
答：C++语言支持函数重载，C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为： void foo(int x, int y);
该函数被C编译器编译后在库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。
C++提供了C连接交换指定符号extern“C”来解决名字匹配问题。
5、请简述以下两个for循环的优缺点（5分）

for (i=0; i<N; i++)
{
if (condition)
    DoSomething();
else
    DoOtherthing();
}
if (condition)
{
for (i=0; i<N; i++)
    DoSomething();
}
else
{
    for (i=0; i<N; i++)
    DoOtherthing();
}
优点：程序简洁
缺点：多执行了N-1次逻辑判断，并且打断了循环“流水线”作业，使得编译器不能对循环进行优化处理，降低了效率。
优点：循环的效率高
缺点：程序不简洁


四、有关内存的思考题（每小题5分，共20分）

void GetMemory(char *p)
{
p = (char *)malloc(100);
}
void Test(void) 
{
char *str = NULL;
GetMemory(str);	
strcpy(str, "hello world");
printf(str);
}
请问运行Test函数会有什么样的结果？
答：程序崩溃。
因为GetMemory并不能传递动态内存，
Test函数中的 str一直都是 NULL。
strcpy(str, "hello world");将使程序崩溃。

char *GetMemory(void)
{	
char p[] = "hello world";
return p;
}
void Test(void)
{
char *str = NULL;
str = GetMemory();	
printf(str);
}
请问运行Test函数会有什么样的结果？
答：可能是乱码。
因为GetMemory返回的是指向“栈内存”的指针，该指针的地址不是 NULL，但其原现的内容已经被清除，新内容不可知。
void GetMemory2(char **p, int num)
{
*p = (char *)malloc(num);
}
void Test(void)
{
char *str = NULL;
GetMemory(&str, 100);
strcpy(str, "hello");	
printf(str);	
}
请问运行Test函数会有什么样的结果？
答：
（1）能够输出hello
（2）内存泄漏

void Test(void)
{
char *str = (char *) malloc(100);
	strcpy(str, “hello”);
	free(str);	    
	if(str != NULL)
	{
	  strcpy(str, “world”);	
printf(str);
}
}
请问运行Test函数会有什么样的结果？
答：篡改动态内存区的内容，后果难以预料，非常危险。
因为free(str);之后，str成为野指针，
if(str != NULL)语句不起作用。


五、编写strcpy函数（10分）
已知strcpy函数的原型是
	char *strcpy(char *strDest, const char *strSrc);
	其中strDest是目的字符串，strSrc是源字符串。
（1）不调用C++/C的字符串库函数，请编写函数 strcpy
char *strcpy(char *strDest, const char *strSrc);
{
    assert((strDest!=NULL) && (strSrc !=NULL));	// 2分
    char *address = strDest;						// 2分
    while( (*strDest++ = * strSrc++) != ‘\0’ )		// 2分
       NULL ; 
    return address ;								// 2分
}
（2）strcpy能把strSrc的内容复制到strDest，为什么还要char * 类型的返回值？
答：为了实现链式表达式。							// 2分
例如	int length = strlen( strcpy( strDest, “hello world”) );
六、编写类String的构造函数、析构函数和赋值函数（25分）
已知类String的原型为：
	class String
	{
	  public:
		String(const char *str = NULL);	// 普通构造函数
		String(const String &other);	    // 拷贝构造函数
		~ String(void);					    // 析构函数
		String & operate =(const String &other);	// 赋值函数
	  private:
		char  	*m_data;				// 用于保存字符串
	};
	请编写String的上述4个函数。
标准答案：
// String的析构函数
	String::~String(void)               // 3分
{
	delete [] m_data;	                     
// 由于m_data是内部数据类型，也可以写成 delete m_data;
	}
	// String的普通构造函数             
	String::String(const char *str)      // 6分
{
	if(str==NULL)                          
	{
		m_data = new char[1];    // 若能加 NULL 判断则更好
		*m_data = ‘\0’;                      
	}	                                       
	else
	{
		int length = strlen(str);           
		m_data = new char[length+1];  // 若能加 NULL 判断则更好      
		strcpy(m_data, str);                
	}
}	
// 拷贝构造函数
	String::String(const String &other)   // 3分
	{	
	int length = strlen(other.m_data);	 
	m_data = new char[length+1];      // 若能加 NULL 判断则更好    
	strcpy(m_data, other.m_data);         
}
// 赋值函数
	String & String::operate =(const String &other)    // 13分
	{	
		// (1) 检查自赋值                     // 4分
		if(this == &other)
			return *this;
	
// (2) 释放原有的内存资源            // 3分
		delete [] m_data;
		
		// （3）分配新的内存资源，并复制内容 // 3分
	int length = strlen(other.m_data);	
	m_data = new char[length+1];         // 若能加 NULL 判断则更好
		strcpy(m_data, other.m_data);
		
		// （4）返回本对象的引用            // 3分
		return *this;
}

算法	
1、对于一个字节（8bit）的数据，求其中“1”的个数，要求算法的执行效率尽可能地高。
解答：
首先，很自然的，你想到除法和求余运算，并给出了如下的答案：
方法1：使用除、余操作
#include
#define BYTE unsigned char
int main(int argc, char *argv[])
{
int i, num = 0;
BYTE a;
/* 接收用户输入 */
printf("\nPlease Input a BYTE(0~255):");
scanf("%d", &a);
/* 计算1 的个数 */
for (i = 0; i < 8; i++)
{
if (a % 2 == 1)
{
num++;
}
a = a / 2;
}
printf("\nthe num of 1 in the BYTE is %d", num);
return 0;
}
很遗憾，众所周知，除法操作的运算速率实在是很低的，这个答案只能意味着面试者被淘汰！
好，精明的面试者想到了以位操作代替除法和求余操作，并给出如下答案：
方法2：使用位操作
#include
#define BYTE unsigned char
int main(int argc, char *argv[])
{
int i, num = 0;
BYTE a;
/* 接收用户输入 */
printf("\nPlease Input a BYTE(0~255):");
scanf("%d", &a);
/* 计算1 的个数 */
for (i = 0; i < 8; i++)
{
num += (a >> i) &0x01;
}
/*或者这样计算1 的个数：*/
/* for(i=0;i<8;i++)
{
if((a>>i)&0x01)
num++;
}
*/
printf("\nthe num of 1 in the BYTE is %d", num);
return 0;
}
方法二中num += (a >> i) &0x01;操作的执行效率明显高于方法一中的
if (a % 2 == 1)
{
num++;
}
a = a / 2;
到这个时候，面试者有被录用的可能性了，但是，难道最快的就是这个方法了吗？没有更快的了吗？方法二真
的高山仰止了吗？
能不能不用做除法、位操作就直接得出答案的呢？于是你想到把0~255 的情况都罗列出来，并使用分支操作，
给出如下答案：
方法3：使用分支操作
#include
#define BYTE unsigned char
int main(int argc, char *argv[])
{
int i, num = 0;
BYTE a;
/* 接收用户输入 */
printf("\nPlease Input a BYTE(0~255):");
scanf("%d", &a);
/* 计算1 的个数 */
switch (a)
{
case 0x0:
num = 0;
break;
case 0x1:
case 0x2:
case 0x4:
case 0x8:
case 0x10:
case 0x20:
case 0x40:
case 0x80:
num = 1;
break;
case 0x3:
case 0x6:
case 0xc:
case 0x18:
77
case 0x30:
case 0x60:
case 0xc0:
num = 2;
break;
//...
}
printf("\nthe num of 1 in the BYTE is %d", num);
return 0;
}
方法三看似很直接，实际执行效率可能还会小于方法二，因为分支语句的执行情况要看具体字节的值，如果a=0，
那自然在第1 个case 就得出了答案，但是如果a=255，则要在最后一个case 才得出答案，即在进行了255
次比较操作之后！
看来方法三不可取！但是方法三提供了一个思路，就是罗列并直接给出值，离最后的方法四只有一步之遥。眼
看着就要被这家著名外企录用，此时此刻，绝不对放弃寻找更快的方法。
终于，灵感一现，得到方法四，一个令你心潮澎湃的答案，快地令人咋舌，算法中不需要进行任何的运算。你
有足够的信心了，把下面的答案递给面试官：
方法4：直接得到结果
#include
#define BYTE unsigned char
/* 定义查找表 */
BYTE numTable[256] =
{
0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3,
3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3,
4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4,
3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3,
4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6,
6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4,
5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3,
4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4,
4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6,
7, 6, 7, 7, 8
};
int main(int argc, char *argv[])
{
int i, num = 0;
BYTE a = 0;
/* 接收用户输入 */
printf("\nPlease Input a BYTE(0~255):");
scanf("%d", &a);
/* 计算1 的个数 */
/* 用BYTE 直接作为数组的下标取出1 的个数，妙哉！ */
78
printf("\nthe num of 1 in the BYTE is %d", checknum[a]);
return 0;
}
这是个典型的空间换时间算法，把0~255 中1 的个数直接存储在数组中，字节a 作为数组的下标，checknum[a]
直接就是a 中“1”的个数！算法的复杂度如下：
时间复杂度：O(1)
空间复杂度：O(2n)
恭喜你，你已经被这家著名的外企录用！老总向你伸出手，说：“Welcome to our company”。
2、从一道笔试题谈算法优化
引子
每年十一月各大IT公司都不约而同、争后恐后地到各大高校进行全国巡回招聘。与此同时，网上也开始出现大量笔试面试题；网上流传的题目往往都很精巧，既能让考查基础知识，又在平淡中隐含了广阔的天地供优秀学生驰骋。
这两天在网上淘到一道笔试题目（注1），虽然真假未知，但的确是道好题，题目如下：
       从10亿个浮点数中找出最大的1万个。
这是一道似易实难的题目，一般同学最容易中的陷阱就是没有重视这个“亿”字。因为有10亿个单精度浮点数元素的数组在32位平台上已经达到3.7GB之巨，在常见计算机平台（如Win32）上声明一个这样的数组将导致堆栈溢出。正确的解决方法是分治法，比如每次处理100万个数，然后再综合起来。不过这不是本文要讨论的主旨，所以本文把上题的10亿改为1亿，把浮点数改为整数，这样可以直接地完成这个问题，有利于清晰地讨论相关算法的优化（注2）。
不假思索
拿到这道题，马上就会想到的方法是建立一个数组把1亿个数装起来，然后用for循环遍历这个数组，找出最大的1万个数来。原因很简单，因为如果要找出最大的那个数，就是这样解决的；而找最大的1万个数，只是重复1万遍而已。
template< class T >
void solution_1( T BigArr[], T ResArr[] )
{
       for( int i = 0; i < RES_ARR_SIZE; ++i )
       {
              int idx = i;
              for( int j = i+1; j < BIG_ARR_SIZE; ++j )
              {
                     if( BigArr[j] > BigArr[idx] )
                            idx = j;
              }
              ResArr[i] = BigArr[idx];
              std::swap( BigArr[idx], BigArr[i] );
       }
}
设BIG_ARR_SIZE ＝ 1亿，RES_ARR_SIZE = 1万，运行以上算法已经超过40分钟（注3），远远超过我们的可接受范围。
稍作思考
从上面的代码可以看出跟SelectSort算法的核心代码是一样的。因为SelectSort是一个O(n^2)的算法（solution_1的时间复杂度为O(n*m)，因为solution_1没有将整个大数组全部排序），而我们又知道排序算法可以优化到O(nlogn)，那们是否可以从这方面入手使用更快的排序算法如MergeSor、QuickSort呢？但这些算法都不具备从大至小选择最大的N个数的功能，因此只有将1亿个数按从大到小用QuickSort排序，然后提取最前面的1万个。
template< class T, class I >
void solution_2( T BigArr[], T ResArr[] )
{
       std::sort( BigArr, BigArr + BIG_ARR_SIZE, std::greater_equal() );
       memcpy( ResArr, BigArr, sizeof(T) * RES_ARR_SIZE );
}
因为STL里的sort算法使用的是QuickSort，在这里直接拿来用了，是因为不想写一个写一个众人皆知的QuickSort代码来占篇幅（而且STL的sort高度优化、速度快）。
对solution_2进行测试，运行时间是32秒，约为solution_1的1.5%的时间，已经取得了几何数量级的进展。
深入思考
压抑住兴奋回头再仔细看看solution_2，你将发现一个大问题，那就是在solution_2里所有的元素都排序了！而事实上只需找出最大的1万个即可，我们不是做了很多无用功吗？应该怎么样来消除这些无用功？
如果你一时没有头绪，那就让我慢慢引导你。首先，发掘一个事实：如果这个大数组本身已经按从大到小有序，那么数组的前1万个元素就是结果；然后，可以假设这个大数组已经从大到小有序，并将前1万个元素放到结果数组；再次，事实上这结果数组里放的未必是最大的一万个，因此需要将前1万个数字后续的元素跟结果数组的最小的元素比较，如果所有后续的元素都比结果数组的最小元素还小，那结果数组就是想要的结果，如果某一后续的元素比结果数组的最小元素大，那就用它替换结果数组里最小的数字；最后，遍历完大数组，得到的结果数组就是想要的结果了。
template< class T >
void solution_3( T BigArr[], T ResArr[] )
{
       //取最前面的一万个
       memcpy( ResArr, BigArr, sizeof(T) * RES_ARR_SIZE );
       //标记是否发生过交换
       bool bExchanged = true;
       //遍历后续的元素
       for( int i = RES_ARR_SIZE; i < BIG_ARR_SIZE; ++i )
       {
              int idx;
              //如果上一轮发生过交换
              if( bExchanged )
              {
                     //找出ResArr中最小的元素
                     int j;
                     for( idx = 0, j = 1; j < RES_ARR_SIZE; ++j )
                     {
                            if( ResArr[idx] > ResArr[j] )
                                   idx = j;
                     }
              }
              //这个后续元素比ResArr中最小的元素大，则替换。
              if( BigArr[i] > ResArr[idx] )
              {
                     bExchanged = true;
                     ResArr[idx] = BigArr[i];
              }
              else
                     bExchanged = false;
       }
}
上面的代码使用了一个布尔变量bExchanged标记是否发生过交换，这是一个前文没有谈到的优化手段——用以标记元素交换的状态，可以大大减少查找ResArr中最小元素的次数。也对solution_3进行测试一下，结果用时2.0秒左右（不使用bExchanged则高达32分钟），远小于solution_2的用时。
深思熟虑
在进入下一步优化之前，分析一下solution_3的成功之处。第一、solution_3的算法只遍历大数组一次，即它是一个O(n)的算法，而solution_1是O(n*m)的算法，solution_2是O(nlogn)的算法，可见它在本质上有着天然的优越性；第二、在solution_3中引入了bExchanged这一标志变量，从测试数据可见引入bExchanged减少了约99.99%的时间，这是一个非常大的成功。
上面这段话绝非仅仅说明了solution_3的优点，更重要的是把solution_3的主要矛盾摆上了桌面——为什么一个O(n)的算法效率会跟O(n*m)的算法差不多（不使用bExchanged）？为什么使用了bExchanged能够减少99.99%的时间？带着这两个问题再次审视solution_3的代码，发现bExchanged的引入实际上减少了如下代码段的执行次数：
for( idx = 0, j = 1; j < RES_ARR_SIZE; ++j )
{
       if( ResArr[idx] > ResArr[j] )
              idx = j;
}
上面的代码段即是查找ResArr中最小元素的算法，分析它可知这是一个O(n)的算法，到此时就水落石出了！原来虽然solution_3是一个O(n)的算法，但因为内部使用的查找最小元素的算法也是O(n)的算法，所以就退化为O(n*m)的算法了。难怪不使用bExchanged使用的时间跟solution_1差不多；这也从反面证明了solution_3被上面的这一代码段导致性能退化。使用了bExchanged之后因为减少了很多查找最小元素的代码段执行，所以能够节省99.99%的时间！
至此可知元凶就是查找最小元素的代码段，但查找最小元素是必不可少的操作，在这个两难的情况下该怎么去优化呢？答案就是保持结果数组（即ResArr）有序，那样的话最小的元素总是最后一个，从而省去查找最小元素的时间，解决上面的问题。但这也引入了一个新的问题：保持数组有序的插入算法的时间复杂度是O(n)的，虽然在这个问题里插入的数次比例较小，但因为基数太大（1亿），这一开销仍然会令本方案得不偿失。
难道就没有办法了吗？记得小学解应用题时老师教导过我们如果解题没有思路，那就多读几遍题目。再次审题，注意到题目并没有要求找到的最大的1万个数要有序（注4），这意味着可以通过如下算法来解决：
1)            将BigArr的前1万个元素复制到ResArr并用QuickSort使ResArr有序，并定义变量MinElemIdx保存最小元素的索引，并定义变量ZoneBeginIdx保存可能发生交换的区域的最小索引；
2)            遍历BigArr其它的元素，如果某一元素比ResArr最小元素小，则将ResArr中MinElemIdx指向的元素替换，如果ZoneBeginIdx == MinElemIdx则扩展ZoneBeginIdx；
3)            重新在ZoneBeginIdx至RES_ARR_SIZE元素段中寻找最小元素，并用MinElemIdx保存其它索引；
4)            重复2)直至遍历完所有BigArr的元素。
依上算法，写代码如下：
template< class T, class I >
void solution_4( T BigArr[], T ResArr[] )
{
       //取最前面的一万个
       memcpy( ResArr, BigArr, sizeof(T) * RES_ARR_SIZE );
       //排序
       std::sort( ResArr, ResArr + RES_ARR_SIZE, std::greater_equal() );
       //最小元素索引
       unsigned int MinElemIdx = RES_ARR_SIZE - 1;
       //可能产生交换的区域的最小索引 
       unsigned int ZoneBeginIdx = MinElemIdx;
       //遍历后续的元素
       for( unsigned int i = RES_ARR_SIZE; i < BIG_ARR_SIZE; ++i )
       {     
              //这个后续元素比ResArr中最小的元素大，则替换。
              if( BigArr[i] > ResArr[MinElemIdx] )
              {
                     ResArr[MinElemIdx] = BigArr[i];
                     if( MinElemIdx == ZoneBeginIdx )
                            --ZoneBeginIdx;
                     //查找最小元素
                     unsigned int idx = ZoneBeginIdx;
                     unsigned int j = idx + 1;
                     for( ; j < RES_ARR_SIZE; ++j )
                     {
                            if( ResArr[idx] > ResArr[j] )
                                   idx = j;
                     }
                     MinElemIdx = idx;
              }
       }
}
经过测试，同样情况下solution_4用时约1.8秒，较solution_3效率略高，总算不负一番努力。
苦想冥思
这次优化从solution_4产生的输出来入手。把solution_4的输出写到文件，查看后发现数组基本无序了。这说明在程序运行一定时间后，频繁的替换几乎将原本有序的结果数组全部换血。结果数组被替换的元素越多，查找最小元素要遍历的范围就越大，当被替换的元素个数接近结果数组的大小时，solution_4就退化成solution_3。因为solution_4很快退化也就直接导致它的效率没有本质上的提高。
找出了原因，就应该找出一个解决的办法。通过上面的分析，知道solution_3和solution_4最消耗时间的是查找最小元素这一操作，将它减少（或去除）才有可能从本质上提高效率。这样思路又回到保持结果数组有序这一条老路上来。在上一节我们谈到保持数组有序的插入算法将带来大量的元素移动，频繁的插入操作将使这一方法在效率上得不偿失。有没有办法让元素移动去掉呢？答案也是有的——那就是使用链表。这时新的问题又来了，链表因为是非随机存取数据结构，插入前寻找位置的算法又是O(n)的。解决新的问题的答案是使用AVL树，但AVL树虽然插入和查找都是O(logn)，可是需要在插入后进行调整保持平衡，这又是一个耗费大量时间的操作。分析到现在，发现我们像进了迷宫，左冲右突都找不到突破口。
现在请静下来想一想，如果思考结果没有跳出上面这个怪圈，那我不幸地告诉你：你被我误导了。这个故意的误导是要告诫大家：进行算法优化必须时刻保持自己头脑清醒，否则时刻都有可能陷入这样的迷宫当中。现在跳出这个怪圈重新思考，根据前文的分析，可知目标是减少（或去除）查找最小元素的操作次数（或查找时间），途径是让ResArr保持有序，难点在于给ResArr排序太费时。反过来想一想，是否需要时刻保持ResArr有序？答案为否，因为当查找最小元素需要遍历的范围较小时，速度还是很快的，这样就犯不着在每替换一个元素的时候都排序一次，而仅需要在无序元素较多的时候适时地排序即可（即保持查找最小元素要遍历的范围较小）。这个思想有用吗？写代码来测试一下：
template< class T, class I >
void solution_5( T BigArr[], T ResArr[] )
{
       //同solution_4，略
       //这个后续元素比ResArr中最小的元素大，则替换。
       if( BigArr[i] > ResArr[MinElemIdx] )
       {
              ResArr[MinElemIdx] = BigArr[i];
              if( MinElemIdx == ZoneBeginIdx )
                     --ZoneBeginIdx;
              //太多杂乱元素的时候排序
              if( ZoneBeginIdx < 9400 )
              {
                     std::sort( ResArr, ResArr + RES_ARR_SIZE, std::greater() );
                     ZoneBeginIdx = MinElemIdx = RES_ARR_SIZE - 1;
                     continue;
              }
       //同solution_4，略
}
代码中的9400是经过试验得出的最好数值，即在有600个元素无序的时候进行一次排序。测试的结果令人惊喜，用时仅400毫秒左右，约为solution_4的五分之一，这也证明了上述思想是正确的。
殚思极虑
脚步永远向前，在取得solution_5这样的成果之后，仍然有必要分析和优化它。对这一看似已经完美的算法进行下一次优化要从哪里着手？这时候要借助于性能剖分工具了，常用的有Intel的VTune以及Microsoft Visual C++自带的profile等。使用MS profile对solution_5分析产生的报告如下（略去一些无关数据）：
          Func             Func+Child           Hit
        Time   %         Time      %      Count  Function
---------------------------------------------------------
      37.718   1.0     3835.317  99.5        1 _main (algo.obj)
     111.900   2.9     3220.082  83.6        1 solution_5(int * ...
       0.000   0.0     3074.063  79.8      112 _STL::sort(int *,...
       ……
可以发现sort函数的调用用去了将近80%的时间，这表明sort函数是问题所在，优化应该从这里着手。但正如前文所说，STL的sort已经高度优化速度很快了，再对他作优化是极难的；而且sort函数里又调用了其它STL内部函数，如蛛丝般牵来绕去，读得懂已经不是一般人可完成的了，优化从何谈起？
我们不能左右天气，但我们可以左右心情；我们不能修改sort函数，但我们可以控制sort的调用。再看看solution_5里对sort的调用有没有什么蛛丝马迹可寻：
       std::sort( ResArr, ResArr + RES_ARR_SIZE, std::greater() );
这个调用是把结果数组ResArr重新排序一遍。需要把整个ResArr完全重新排序吗？答案是需要的，但可以不使用这个方法。因为ResArr里的元素绝大部分是有序的（结合上文可知前面94%的元素都有序），待排序的只是6%。只要把这600个数据重新排序然后将前后两个有序数组归并为一个有序数组即可（归并算法的时间复杂度为O(n+m)），将因为排序的数据量较少而大大节约时间。写代码如下：
template< class T, class I >
void solution_6( T BigArr[], T ResArr[] )
{
       //同solution_5，略
       //太多杂乱元素的时候排序
       if( ZoneBeginIdx < 9400 )
       {
              std::sort( ResArr + 9400, ResArr + RES_ARR_SIZE, std::greater() );
              std::merge(ResArr, ResArr + 9400, ResArr + 9400, ResArr + RES_ARR_SIZE, BigArr, std::greater() );
              memcpy( ResArr, BigArr, sizeof(T) * RES_ARR_SIZE );
       //同solution_5，略
}
经测试，solutio_6的运行时间为250毫秒左右，比solution_5快了将近一半，通过profile分析报告计算sort函数和merge函数的占用时间总计约为执行时间的19.6%，远小于solution_5的占用时间。
结束语
一番努力之后，终于将一个原来需要近一个小时才能解决的问题用250毫秒完成，文章到这里要完结，不过上述算法仍有可优化的余地，这就要读者朋友自己去挖掘了。我希望看到这篇文章的人不仅仅是赞叹算法的奇妙，更希望能够学会算法优化的方法和技巧。对于算法优化的方法，我总结如下（仅供参考及抛砖引玉之用）：
         不断地否定自己的方法[全文]
         减少重复计算[solution_3]；
         不要做没要求你做的事[solution_3]； 
         深化对需求的理解[solution_4]；
         温故而知新，多重读自己的算法代码[solution_4]；
         从程序的输出（或者中间结果）里找突破[solution_5]；
         时刻保持头脑清醒，常常跳出习惯的框框[solution_5]；
         善于使用工具[solution_6]；
         养成解决一个问题思考多个方案的习惯[全文]。
最后要讲的一点就是STL里提供了一个可以直接完成这一问题的算法——nth_element。经测试，nth_element在大数组比较小的时候速度比以上算法都要快，但在大数组尺寸为1亿的时候所用的时间为1.3秒左右，是solution_6运行时间的5倍。原因在于nth_elenemt的实现方法跟本文介绍的算法大不相同，有兴趣的朋友可以去阅读其源码。建议大家在一般情况下使用STL的nth_element，它在数量为十万级的时候仍有极好的性能。
参考资料：
       [1] 侯捷 《STL源码剖析》 华中科技大学出版社 2002年6月
       [2] Anany Levitin 潘彦[译] 《算法设计与分析基础》 清华大学出版社 2004年6月
       [3] http://job.csdn.net/n/20051216/31105.html
注：
       [1] 此题目版权归出题人或者其单位所有
       [2] 本文所有的优化都针对于平均情况，即大数组由随机数构成且无序
       [3] 所有测试均设BIG_ARR_SIZE = 1亿，RES_ARR_SIZE = 1万，测试的机器配置为：CPU P4EE 3.0G + 512 M memory，HyperThreading Enabled，操作系统：Windows 2000 pro，编译器： MS VC++ 6.0 + sp6，STL库： STLport 4.6.2。
       [4] 如果要求有序，可以通过先找出结果，再对结果排序完成要求

3、基本排序算法
冒泡排序程序:
void BubbleSort(int a[], n)
	{
	        int i,j;
	        int x;
		     for(i=1;i<n;i++) 
	      {   for(j=0;j<n-i;j++) //找到一组中最大的
			   {  if(a[j]>a[j+1]) {//进行交换
                                 x  = a[j];
                                 a[j] = a[j+1];
                                 a[j+1] = x;    }
                    };
		      }
    }
选择排序程序:
	void SelectSort(int a[], int n )
	{
	           int i,j,k;
                   int x;
	           for (i=1;i<n;i++) {  //进行n-1次选择和交换
	               k=i-1;
 	               for (j=i;j<n;j++)  {
                          if (a[j]<a[k]) 
		                 k=j ;   //使a[k]为最小值
                   }
                   x=a[i-1]; 
              a[i-1]=a[k]; 
              a[k]=x ;
  	         }
}
二分查找算法：
1)        递归方法实现：
int BSearch(elemtype a[],elemtype x,int low,int high)
//在下届为low，上界为high的数组a中折半查找数据元素x//
{
  int mid;
  if(low>high) return -1;
  mid=(low+high)/2;
  if(x==a[mid]) return mid;
  if(x<a[mid]) return(BSearch(a,x,low,mid-1));
  else return(BSearch(a,x,mid+1,high));
}
2)        非递归方法实现：
int BSearch(elemtype a[],keytype key,int n)
{
  int low,high,mid;
  low=0;high=n-1;
  while(low<=high)  
   {
      mid=(low+high)/2;
      if(a[mid].key==key) return mid;
      else if(a[mid].key<key) low=mid+1;
      else high=mid-1;
   }
  return -1;
}
4、STL简介    
STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的。现在虽说它主要出现在C++中，但在被引入C++之前该技术就已经存在了很长的一段时间。 
      STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模版函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。
在C++标准中，STL被组织为下面的13个头文件：<algorithm>、<deque>、<functional>、<iterator>、<vector>、<list>、<map>、<memory>、<numeric>、<queue>、<set>、<stack>和<utility>。以下笔者就简单介绍一下STL各个部分的主要特点。

1、算法
大家都能取得的一个共识是函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的――你可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。

STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以你所指定的规则对序列进行稳定性排序等等。这样一来，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能并大大地提升效率。

算法部分主要由头文件<algorithm>，<numeric>和<functional>组成。<algorithm>是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<numeric>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<functional>中则定义了一些模板类，用以声明函数对象。

三、容器
在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。

经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用已有的实现构造自己的特定类型下的数据结构，通过设置一些模版类，STL容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。

容器部分主要由头文件<vector>,<list>,<deque>,<set>,<map>,<stack>和<queue>组成。对于常用的一些容器和容器适配器（可以看作由其它容器实现的容器），可以通过下表总结一下它们和相应头文件的对应关系。

数据结构 描述 实现头文件 
向量(vector) 连续存储的元素 <vector> 
列表(list) 由节点组成的双向链表，每个结点包含着一个元素 <list> 
双队列(deque) 连续存储的指向不同元素的指针所组成的数组 <deque> 
集合(set) 由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序 <set> 
多重集合(multiset) 允许存在两个次序相等的元素的集合 <set> 
栈(stack) 后进先出的值的排列 <stack> 
队列(queue) 先进先出的执的排列 <queue> 
优先队列(priority_queue) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列 <queue> 
映射(map) 由{键，值}对组成的集合，以某种作用于键对上的谓词排列 <map> 
多重映射(multimap) 允许键对有相等的次序的映射 <map> 

四、迭代器
下面要说的迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些（至少笔者是这样）。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化，这种简化在STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过迭代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。

迭代器部分主要由头文件<utility>,<iterator>和<memory>组成。<utility>是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，<iterator>中提供了迭代器使用的许多方法，而对于<memory>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,<memory>中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器。
补充资料：
1、Struct对sizeof的详解
C++ 编译器为了使CPU的性能达到最佳, 会对 struct 的内存结构进行优化,如32位的计算机的数据传输值是4 bytes, 64位计算机 数据传输是 8 bytes,这样,struct 在默认的情况上,编译器会对 struct 的结构进行数据对齐((32位机)4的倍数或(64 位机)8的倍 数), 以下以32位机在vc6.0环境下：
例1：struct s1 { 
	char ch;                           //1bit+对齐
	char *ptr;                          //4bytes
	union { 
		short a, b; 
		unsigned int c:2, d:1; 
	}un ;                              //4 bytes
		struct s1 *next;                  //4 bytes
}st;
struct data
{
	int i;                     //4
	char *ch;                 //4
	double f;                 //8
}b;
	printf("%d\n",sizeof(b));          //结果：16
	printf("%d\n",sizeof(st.un));       //结果：4
	printf("%d\n",sizeof(st));         //结果：16
例2：struct s1
{
   short d;      //2bytes+2bytes对齐
	int a;
   short b;     //2bytes+2bytes对齐
}a1;
struct s2
{
 short d;      //2bytes
   short b;      //2bytes
	int a;       //4bytes
}a2;
struct s3{
   short d;     //2bytes+2bytes对齐
	int a;
   short b;     //2bytes
   char st;     //1bytes+1bites对齐
}a3;
	 printf("c=%d\n " ,sizeof(a1));      //结果：12
	 printf("c=%d\n " ,sizeof(a2));      //结果：8
	 printf("c=%d\n " ,sizeof(a3));      //结果：12
自然对界
struct 是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float 等）的变量，也可以是一些复合数据类型（如array、struct、union 等）的数据单元。对于结构体，编译器会自动进行成员变量的对齐，以提高运算效率。缺省情况下，编译器为结构体的每个成员按其自然对界（natural alignment）条件分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。
自然对界(natural alignment)即默认对齐方式，是指按结构体的成员中size 最大的成员对齐。
例如：
struct naturalalign
{
char a;
short b;
char c;
};
在上述结构体中，size 最大的是short，其长度为2 字节，因而结构体中的char 成员a、c 都以2 为单位对齐，sizeof(naturalalign)的结果等于6；
如果改为：
struct naturalalign
{
char a;
int b;
char c;
};
其结果显然为12。
指定对界
一般地，可以通过下面的方法来改变缺省的对界条件：
· 使用伪指令#pragma pack (n)，编译器将按照n 个字节对齐；
· 使用伪指令#pragma pack ()，取消自定义字节对齐方式。
注意：如果#pragma pack (n)中指定的n 大于结构体中最大成员的size，则其不起作用，结构体仍然按照size 最大的成员进行对界。
例如：
#pragma pack (n)
struct naturalalign
{
char a;
int b;
char c;
};
#pragma pack ()
当n 为4、8、16 时，其对齐方式均一样，sizeof(naturalalign)的结果都等于12。
而当n 为2时，其发挥了作用，使得sizeof(naturalalign)的结果为6。
例3（面试题）：#include <iostream.h>
#pragma pack(8)
struct example1
{
	short a;
	long b;
};
struct example2
{
	char c;
	example1 struct1;
	short e;
};
#pragma pack()
int main(int argc, char* argv[])
{
	example2 struct2;
	cout << sizeof(example1) << endl;                //结果：8
	cout << sizeof(example2) << endl;                //结果：16
	cout << (unsigned int)(&struct2.struct1) - (unsigned int)(&struct2) << endl;
                                                      //结果：4
	return 0;
}
解析：程序中#pragma pack (8)虽然指定了对界为8，但是由于struct example1 中的成员最大size 为4（long 变量size 为4），故struct example1 仍然按4 字节对界，struct example1 的size为8，即第18 行的输出结果；
struct example2 中包含了struct example1，其本身包含的简单数据成员的最大size 为2（short
变量e），但是因为其包含了struct example1，而struct example1 中的最大成员size 为4，struct
example2 也应以4 对界，#pragma pack (8)中指定的对界对struct example2 也不起作用，故sizeof(example2)的输出结果为16；
由于struct example2 中的成员以4 为单位对界，故其char 变量c 后应补充3 个空，其后才是
成员struct1 的内存空间，20 行的输出结果为4。
本文主要包括两个部分,第一部分重点介绍在VC中怎么样采用sizeof来求结构的大小,以及容易出现的问题并给出解决问题的方法; 第二部分总结出VC中sizeof的主要用法.
 
一. sizeof应用在结构上的情况
请看下面的结构:
struct MyStruct{
double dda1 ;
char dda ;
int type ;
} ;
对结构MyStruct采用sizeof会出现什么结果呢? sizeof(MyStruct)为多少呢? 也许你会这样求: sizeof(MyStruct) = sizeof(double) + sizeof(char) + sizeof(int) =13.
但是当在VC中测试上面结构的大小时,你会发现sizeof(MyStruct)为16. 你知道为什么在VC中会得出这样一个结果吗?
其实,这是VC对变量存储的一个特殊处理. 为了提高CPU的存储速度,VC对一些变量的起始地址做了“对齐”处理. 在默认情况下,VC规定各成员变量存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数.
下面列出常用类型的对齐方式(vc6.0,32位系统).
类型    对齐方式(变量存放的起始地址相对于结构的起始地址的偏移量)
Char    偏移量必须为sizeof(char)即1的倍数
Int              偏移量必须为sizeof(int)即4的倍数
Float    偏移量必须为sizeof(float)即4的倍数
double 偏移量必须为sizeof(double)即8的倍数
Short   偏移量必须为sizeof(short)即2的倍数
 
各成员变量在存放的时候根据在结构中出现的顺序依次申请空间,同时按照上面的对齐方式调整位置,空缺的字节VC会自动填充. 同时VC为了确保结构的大小为结构的字节边界数(即该结构中占用最大空间的类型所占用的字节数)的倍数,所以在为最后一个成员变量申请空间后,还会根据需要自动填充空缺的字节.
下面用前面的例子来说明VC到底怎么样来存放结构的.
struct MyStruct {
double dda1 ;
char dda ;
int type ;
} ;
为上面的结构分配空间的时候,VC根据成员变量出现的顺序和对齐方式,先为第一个成员dda1分配空间,其起始地址跟结构的起始地址相同(刚好偏移量0刚好为sizeof(double)的倍数),该成员变量占用sizeof(double)=8个字节; 接下来为第二个成员dda分配空间,这时下一个可以分配的地址对于结构的起始地址的偏移量为8,是sizeof(char)的倍数,所以把dda存放在偏移量为8的地方满足对齐方式,该成员变量占用sizeof(char)=1个字节; 接下来为第三个成员type分配空间,这时下一个可以分配的地址对于结构的起始地址的偏移量为9,不是sizeof(int)=4的倍数,为了满足对齐方式对偏移量的约束问题,VC自动填充3个字节(这三个字节没有放什么东西),这时下一个可以分配的地址对于结构的起始地址的偏移量为12,刚好是sizeof(int)=4的倍数,所以把type存放在偏移量为12的地方,该成员变量占用sizeof(int)=4个字节; 这时整个结构的成员变量已经都分配了空间,总的占用的空间大小为: 8+1+3+4=16,刚好为结构的字节边界数(即结构中占用最大空间的类型所占用的字节数sizeof(double)=8)的倍数,所以没有空缺的字节需要填充. 所以整个结构的大小为:sizeof(MyStruct)=8+1+3+4=16,其中有3个字节是VC自动填充的,没有放任何有意义的东西.
下面再举个例子,交换一下上面的MyStruct的成员变量的位置,使它变成下面的情况:
struct MyStruct{
char dda ;
double dda1 ;
int type ;
} ;
这个结构占用的空间为多大呢? 在VC6.0环境下,可以得到sizeof(MyStruc)为24. 结合上面提到的分配空间的一些原则,分析下VC怎么样为上面的结构分配空间的.(简单说明)
struct MyStruct{
char dda ; // 偏移量为0,满足对齐方式,dda占用1个字节
double dda1 ; /* 下一个可用的地址的偏移量为1,不是sizeof(double)=8的倍数,需要补足7个字节才能使偏移量变为8(满足对齐方式),因此VC自动填充7个字节,dda1存放在偏移量为8的地址上,它占用8个字节. */
int type ; /* 下一个可用的地址的偏移量为16,是sizeof(int)=4的倍数,满足int的对齐方式,所以不需要VC自动填充,type存放在偏移量为16的地址上,它占用4个字节 */
} ; /* 所有成员变量都分配了空间,空间总的大小为1+7+8+4=20,不是结构的节边界数(即结构中占用最大空间的类型所占用的字节数sizeof(double)=8)的倍数,所以需要填充4个字节,以满足结构的大小为sizeof(double)=8的倍数 */
所以该结构总的大小为: sizeof(MyStruc)为1+7+8+4+4=24. 其中总的有7+4=11个字节是VC自动填充的,没有放任何有意义的东西.
VC对结构的存储的特殊处理确实提高CPU存储变量的速度,但是有时候也带来了一些麻烦,我们也屏蔽掉变量默认的对齐方式,自己可以设定变量的对齐方式.
VC中提供了#pragma pack(n)来设定变量以n字节对齐方式. n字节对齐就是说变量存放的起始地址的偏移量有两种情况: 第一、如果n大于等于该变量所占用的字节数,那么偏移量必须满足默认的对齐方式; 第二、如果n小于该变量的类型所占用的字节数,那么偏移量为n的倍数,不用满足默认的对齐方式. 结构的总大小也有个约束条件,分下面两种情况: 如果n大于所有成员变量类型所占用的字节数,那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数; 否则必须为n的倍数. 下面举例说明其用法.
#pragma pack(push) // 保存对齐状态
#pragma pack(4) // 设定为4字节对齐
struct test{
char m1 ;
double m4 ;
int m3 ;
} ;
#pragma pack(pop) // 恢复对齐状态
以上结构的大小为16,下面分析其存储情况,首先为m1分配空间,其偏移量为0,满足我们自己设定的对齐方式(4字节对齐),m1占用1个字节. 接着开始为m4分配空间,这时其偏移量为1,需要补足3个字节,这样使偏移量满足为n=4的倍数(因为sizeof(double)大于n),m4占用8个字节. 接着为m3分配空间,这时其偏移量为12,满足为4的倍数,m3占用4个字节. 这时已经为所有成员变量分配了空间,共分配了16个字节,满足为n的倍数. 如果把上面的#pragma pack(4)改为#pragma pack(16),那么我们可以得到结构的大小为24.(请读者自己分析)
 
二. sizeof用法总结
在VC中,sizeof有着许多的用法,而且很容易引起一些错误. 下面根据sizeof后面的参数对sizeof的用法做个总结.
A. 参数为数据类型或者为一般变量. 例如sizeof(int),sizeof(long)等等. 这种情况要注意的是不同系统或者不同编译器得到的结果可能是不同的. 例如int类型在16位系统中占2个字节,在32位系统中占4个字节.
B. 参数为数组或指针. 下面举例说明.
int a[50] ; // sizeof(a)=4*50=200 ; 求数组所占的空间大小
int *a=new int[50] ; /* sizeof(a)=4 ; a为一个指针,sizeof(a)是求指针的大小,在32位系统中,当然是占4个字节. */
C. 参数为结构或类. Sizeof应用在类和结构的处理情况是相同的. 但有两点需要注意,第一、结构或者类中的静态成员不对结构或者类的大小产生影响,因为静态变量的存储位置与结构或者类的实例地址无关; 第二、没有成员变量的结构或类的大小为1,因为必须保证结构或类的每一个实例在内存中都有唯一的地址.
下面举例说明.
Class Test{
int a ;
static double c ;
} ; // sizeof(Test)=4.
 
Test *s ; // sizeof(s)=4, s为一个指针
 
Class test1{ } ; // sizeof(test1)=1
D. 参数为其他. 下面举例说明.
int func(char s[5]) ;
{
cout<< sizeof(s) << endl ; /* 数的参数在传递的时候系统处理为一个指针,所以sizeof(s)实际上为求指针的大小 */
return 1 ;
}
 
sizeof(func(“1234”))=4 ; // 因为func的返回类型为int,所以相当于求sizeof(int).
 
以上为sizeof的基本用法,在实际的使用中要注意分析VC的分配变量的分配策略,这样的话可以避免一些错误.


2、百度笔试题
1 编程： 
　　用C语言实现一个revert函数，它的功能是将输入的字符串在原串上倒序后返回。 
2 编程： 
　　用C语言实现函数void * memmove(void *dest,const void *src,size_t n)。memmove函数的功能是拷贝src所指的内存内容前n个字节到dest所指的地址上。 
3 英文拼写纠错： 
　　在用户输入英文单词时，经常发生错误，我们需要对其进行纠错。假设已经有一个包含了正确英文单词的词典，请你设计一个拼写纠错的程序。 
（1）请描述你解决这个问题的思路；
（2）请给出主要的处理流程，算法，以及算法的复杂度；
（3）请描述可能的改进（改进的方向如效果，性能等等，这是一个开放问题）。
4 寻找热门查询： 
　　搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。 
（1）请描述你解决这个问题的思路；
（2）请给出主要的处理流程，算法，以及算法的复杂度。
5 集合合并： 
　　给定一个字符串的集合，格式如： {aaa bbb ccc}， {bbb ddd}，{eee fff}，{ggg}，{ddd hhh} 要求将其中交集不为空的集合合并，要求合并完成后的集合之间无交集，例如上例应输出 {aaa bbb ccc ddd hhh}，{eee fff}， {ggg} 
（1）请描述你解决这个问题的思路；
（2）请给出主要的处理流程，算法，以及算法的复杂度
（3）请描述可能的改进（改进的方向如效果，性能等等，这是一个开放问题）。
//////////////////////////////// 
1 题 
char *revert(char * str)
{
int n=strlen(str);
int i=0;
char c;
for(i=0;i {
c=str;
str=str[n-i];
str[n-i]=c;
}
return str;
}
/////////////////////////////////// 
2 题 
void * memmove(void *dest,const void *src,size_t n)
{
assert((dest!=0)&&(src!=0));
char * temp=(char * )dest;
char * ss=(char * )src;
int i=0;
for(;i {
　　*temp =*ss ;
}
return temp;
}
///////////////////////////////////////////////// 
3 题 
(1)思路: 字典以字母键树组织，在用户输入同时匹配 
(2) 流程:
每输入一个字母： 
沿字典树向下一层，
a）若可以顺利下行，则继续至结束，给出结果；
b)若该处不能匹配，纠错处理，给出拼写建议,继续至a）；
算法:
1.在字典中查找单词
字典采用27叉树组织,每个节点对应一个字母,查找就是一个字母
一个字母匹配.算法时间就是单词的长度k.
2.纠错算法 
情况:当输入的最后一个字母不能匹配时就提示出错,简化出错处理，动态提示可能 处理方法: 
(a)当前字母前缺少了一个字母：搜索树上两层到当前的匹配作为建议；
(b)当前字母拼写错误：当前字母的键盘相邻作为提示；（只是简单的描述，可 以有更多的）
根据分析字典特征和用户单词已输入部分选择(a),(b)处理 
复杂性分析：影响算法的效率主要是字典的实现与纠错处理 
(a）字典的实现已有成熟的算法，改进不大，也不会成为瓶颈；
(b)纠错策略要简单有效 ,如前述情况，是线性复杂度；
(3)改进 
策略选择最是重要，可以采用统计学习的方法改进。 
////////////////////////////////////////////// 
4 题 
(1)思路：用哈希做 
(2) 首先逐次读入查询串，算哈希值，保存在内存数组中，同时统计频度（注意值与日志项对应关系） my.chinahrlab.com 选出前十的频度，取出对应的日志串，简单不过了。哈希的设计是关键。 
////////////////////////////////////////////////// 
5 题 
（1）思路：先将集合按照大小排列后,优先考虑小的集合是否与大的集合有交集。有就合并，如果小集合与所有其他集合都没有交集，则独立。独立的集合在下一轮的比较中不用考虑。这样就可以尽量减少字符串的比较次数。当所有集合都独立的时候，就终止。 
（2）处理流程： 
1.将集合按照大小排序，组成集合合并待处理列表
2.选择最小的集合，找出与之有交集的集合，如果有，合并之；如果无，则与其它集合是独立集合，从待处理列表 中删除。
3.重复直到待处理列表为空 
算法： 1。将集合按照大小从小到大排序,组成待处理的集合列表。 2。取出待处理集合列表中最小的集合，对于集合的每个元素，依次在其他集合中搜索是否有此元素存在： 
1>若存在，则将此小集合与大集合合并，并根据大小插入对应的位置 。转3。 
2>若不存在，则在该集合中取下一个元素。如果无下一个元素，即所有元素都不存在于其他集合。则表明此集合独立，从待处理集合列表中删除。并加入结果集合列表。转3。 
3。如果待处理集合列表不为空，转2。 
如果待处理集合列表为空，成功退出，则结果集合列表就是最终的输出。 
算法复杂度分析： 
　　假设集合的个数为n，最大的集合元素为m 排序的时间复杂度可以达到n*log(n) 然后对于元素在其他集合中查找，最坏情况下为（n-1）*m 查找一个集合是否与其他集合有交集的最坏情况是m*m*(n-1) 合并的时间复杂度不会超过查找集合有交集的最坏情况。所以最终最坏时间复杂度为O(m*m*n*n) 
　　需要说明的是：此算法的平均时间复杂度会很低，因为无论是查找还是合并，都是处于最坏情况的概率很小，而且排序后优先用最小集合作为判断是否独立的对象，优先与最大的集合进行比较，这些都最大的回避了最坏情况。 
(3)可能的改进： 
　　首先可以实现将每个集合里面的字符串按照字典序进行排列，这样就可以将查找以及合并的效率增高。另外，可能采取恰当的数据结构也可以将查找以及合并等操作的效率得到提高。 
取自"http://wiki.xyzp.net/%E7%99%BE%E5%BA%A611%E6%9C%884%E6%97%A5%E7%BD%91%E4%B8%8A%E7%AC%94%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%EF%BC%88%E4%BB%85%E4%BE%9B%E5%8F%82%E8%80%83%EF%BC%89.htm"
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
1）此题10分 
　　对任意输入的正整数N，编写C程序求N!的尾部连续0的个数，并指出计算复杂度。如：18！＝6402373705728000，尾部连续0的个数是3。 　　（不用考虑数值超出计算机整数界限的问题） 
2）此题10分 　　编写一个C语言函数，要求输入一个url，输出该url是首页、目录页或者其他url 
　　如下形式叫做首页： 
　militia.info/ 
　www.apcnc.com.cn/ 
　http://www.cyjzs.comwww.greena888.com/ 
　www.800cool.net/ 
　http://hgh-products.my-age.net/ 
　如下形式叫做目录页： 
　thursdaythree.net/greenhouses--gas-global-green-house-warming/ 
　http://www.mw.net.tw/user/tgk5ar1r/profile/ 
　http://www.szeasy.com/food/yszt/chunjie/ 
　www.fuckingjapanese.com/Reality/ 
请注意： 
　a） url有可能带http头也有可能不带 
　b）动态url（即含有"？"的url）的一律不算目录页，如： 
　www.buddhismcity.net/utility/mailit.php?l=/activity/details/3135/ 
　www.buddhismcity.net/utility/mailit.php?l=/activity/details/2449/ 
　另：如果你会linux，请用linux下的grep命令实现第2题的功能（附加5分）。 
3）此题40分 
　如果必须从网页中区分出一部分"重要网页"（例如在10亿中选8亿），比其他网页更值得展现给用户，请提出一种方案。 
4）此题40分 
　　假设有10亿网页已经被我们存下来，并提供如下信息：网页全文（即网页的源码）、全文长度、网页正文（即网页中提取的主体文字）、正文长度，以及其他网页提取物等，现在希望去掉其中的重复网页，请提出可行的方案，计算出每个网页对应的重复度，你可以自己对网页重复下定义，也可以提出需要哪些更多的网页提取物来实现更好的去重复方案。 
取自"http://wiki.xyzp.net/%E7%99%BE%E5%BA%A6%E7%AC%94%E8%AF%95%E9%A2%98%282005%29.htm"
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、   
题目大致是这样的： 
　　第一部分选择题： 
　　有几道网络相关的题目，巨简单，比如第一题是TCP、RIP、IP、FTP中哪个协议是传输层的......。有一道linux的chown使用题目。其他的全是数据结构的题目！什么链，表，码的，不知所云．唉，我可以没有学过数据结构的人呐！真残忍！这一部分迅速猜完！ 
　　第二部分简答题： 
　　1、在linux中如何编译C程序，使之成为可执行文件？如何调试？ 
答案： 1)检查程序中.h文件所在的目录，将其加入系统PATH中； 
2)执行C编译：#gcc [源文件名] -o [目标文件名] 
　     　执行C++编译：#g++ [源文件名] -o [目标文件名] 
3)改变目标文件为可执行文件：#chmod +x [目标文件名] 
4)如需将多个可执行文件连续执行，可生成批处理文件： 
　　　　#vi [批处理文件名] 
　　　　可执行文件1 
　　　　可执行文件2 
　　　　　　　　......... 
　　　　　　　　最后将该批处理文件属性该位可执行。 
　　调试：在编译时使用-g参数，就可以使用gdb进行调试。 
　　2、写出内存分配和释放的函数，并指出区别。 
答案： C语言的标准内存分配函数：malloc，calloc，realloc，free等。
　　malloc与calloc的区别为1块与n块的区别：
　　　　malloc调用形式为(类型*)malloc(size)：在内存的动态存储区中分配一块长度为“size”字节的连续区域，返回该区域的首地址。
　　　　calloc调用形式为(类型*)calloc(n，size)：在内存的动态存储区中分配n块长度为“size”字节的连续区域，返回首地址。
　　　　realloc调用形式为(类型*)realloc(*ptr，size)：将ptr内存大小增大到size。
　　　　free的调用形式为free(void*ptr)：释放ptr所指向的一块内存空间。
　　C++中为new/delete函数。
　　3、写出socket函数，并指出其功能。 
　　socket():建立socket通信描述符；
　　bind()：将套接字和机器上的一定的端口关联；
　　connect()：连接到远程主机；
　　listen()：使套接字做好连接的准备，规定等待服务请求队列的长度；
　　accept()：接受连接，一旦有客户端发出连接，accept返回客户地址信息和一个新的sock；
　　有了这个新的sock，双方就可以开始收发数据：
　　send()和recv()：用于流式套接字或者数据套接字的通讯；
　　sendto()和recvfrom()：用于无连接的数据报套接字；
　　close()：关闭套接字；
　　shutdown()：选择性的关闭套接字，可以只允许某一方向的通讯关闭；
　　getpeername()：返回流式套接字时对端peer信息；
　　gethostname()：返回程序所运行的机器的主机名字；
　　gethostbyname()：返回本机IP；
　　第三部分编程题： 
　　1、从文件中读取字符串数据，反序显示并大小写转换。 
　　2、给定26字母表以及对应的密码表，编程实现加密及解密功能。 
　　第四部分思考题(正是传说中的字典纠错题)： 
　　用户在输入英文单词时经常出错，现对其进行就错。给定一个正确的英文词典，考虑纠错实现。1)指出思路。2)流程、算法难易程度及可能的改进策略。 
一道算法题目答案 
int Replace(Stringtype &S,Stringtype T,Stringtype V);//将串S中所有子串T替换为V,并返回置换次数 
{ 
for(n=0,i=1;i〈=Strlen(S)-Strlen(T)+1;i++) //注意i的取值范围 
if(!StrCompare(SubString(S,i,Strlen(T)),T)) //找到了与T匹配的子串 
{ //分别把T的前面和后面部分保存为head和tail 
StrAssign(head,SubString(S,1,i-1)); 
StrAssign(tail,SubString(S,i+Strlen(T),Strlen(S)-i-Strlen(T)+1)); 
StrAssign(S,Concat(head,V)); 
StrAssign(S,Concat(S,tail)); //把head,V,tail连接为新串 
i+=Strlen(V); //当前指针跳到插入串以后 
n++; 
}//if 
return n; 
}//Replace 
分析:i+=Strlen(V);这一句是必需的,也是容易忽略的.如省掉这一句,则在某些情况下,会引起不希望的后果,虽然在大多数情况下没有影响.请思考:设S='place', T='ace', V='face',则省掉i+=Strlen(V);运行时会出现什么结果? （无限递归face） 

百度2005年的笔试题 
1.实现 void delete_char(char * str, char ch);
    　把str中所有的ch删掉 
2.把字符串S中所有A子串换成B,这个没给函数原型 
3.搜索引擎的日志要记录所有查询串,有一千万条查询,不重复的不超过三百万
　要统计最热门的10条查询串. 内存<1G. 字符串长 0-255
　(1) 主要解决思路 //具体用词和原题不大一样
　(2) 算法及其复杂度分析
4.有字典,设计一个英文拼写纠正算法 (1) 思想 (2) 算法及复杂度 (3) 改进 
5. { aaa, bb, ccc, dd }, { bbb, ff }, { gg } 等一些字符串的集合
　要求把交集不为空的集合并起来,如上例会得到 { aaa, bb, ccc, dd, ff }, {gg}
　(1) 思想 (2) 算法及复杂度 (3) 改进 
取自"http://wiki.xyzp.net/%E7%99%BE%E5%BA%A6%E7%AC%94%E8%AF%95%E9%A2%982005.htm"
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、
一、选择题：15分 共10题 
1.一个含有n个顶点和e条边的简单无向图，在其邻接矩阵存储结构中共有____个零元素。 
A．e　　　 B．2e　　　 C．n2-e　　 D．n2-2e 
2.____是面向对象程序设计语言中的一种机制。这种机制实现了方法的定义与具体的对象无关，而对方法的调用则可以关联于具体的对象。 
A．继承（Inhertance） B．模板（Template） 
C．对象的自身引用（Self-Reference） D．动态绑定（Dynamic Binding） 
3.应用层DNS协议主要用于实现 网络服务功能. 
A. IP地址到网络设备名字的映射 B. IP地址到网络硬件地址的映射 
C. 网络设备名字到IP地址的映射 D. 网络硬件地址到IP地址的映射 
4.linux默认情况下，一个进程最多能打开多少文件？ 
A.64 B. 128 C. 512 D. 1024 
5.下面结构体 
struct s1 { 
char ch, *ptr; 
union { 
short a, b; 
unsigned int c:2, d:1; 
} 
struct s1 *next; 
}; 
的大小是_____： 
A. 12字节 B.16字节 C.20字节 D. 24字节 
6.任何一个基于"比较"的内部排序的算法，若对6个元素进行排序，则在最坏情况下所需的比较次数至少为____。 
A．10 B．11 C．21 D．36 
7.以下不是进程间通讯的是___ 
A 共享内存 B 信号量 C线程局部存储 D 消息队列 
8.下面程序，求count的值 
int func(x) 
{ 
int count= 0; 
x=9999; 
while(x) 
{ 
Count ++; 
x = x&(x-1); 
} 
return count; 
} 
A 8； B 10； C 5； D 11 
9.使用malloc系统调用分配的内存是在____ 上分配的？ 
A 栈； B bss； C 物理内存； D 堆 
10.最坏情况下，合并两个大小为n的已排序数组所需要的比较次数_____ 
A.2n B.2n-1 C.2n+1 D.2n-2 
二、简答题：20分，共3题 
1.（5分）下面这段代码是把中英文混合字符串(汉字用两个字节表示，特点是第一个字节的最高位为1)中的大写字母转化为小写字母，请找出其中的bug，注意各种异常情况。 
for (char *piterator = szWord; *piterator != 0; piterator++) 
{ 
if (*piterator & 0x80 != 0) 
{ 
piterator++; 
} 
else if (*piterator >= 'A' && *piterator <= 'Z') 
piterator += 32; 
} 
2.（5分）对给定的上亿条无序的url，请按照domain、site以及path分别排序，并请指出排序过程中可能会遇到的哪些问题？如何提高效率？ 
例如：http://www.baidu.com/path/about.html，domain、site以及path的定义分别如下： 
Domain:baidu.com 
Site:www.baidu.com 
Path: www.baidu.com/path 
3.（10分）某型CPU的一级数据缓存大小为16K字节，cache块大小为64字节；二级缓存大小为256K字节，cache块大小为4K字节，采用二路组相联。经测试，下面两段代码运行时效率差别很大，请分析哪段代码更好，以及可能的原因。 
为了进一步提高效率，你还可以采取什么办法？ 
A段代码 
int matrix[1023][15]; 
const char *str = "this is a str"; 
int i, j, tmp, sum = 0; 
tmp = strlen(str); 
for(i = 0; i < 1023; i++) { 
for(j = 0; j < 15; j++) { 
sum += matrix[i][j] + tmp; 
} 
} 
B段代码 
int matrix[1025][17]; 
const char *str = "this is a str"; 
int i, j, sum = 0; 
for(i = 0; i < 17; i++) { 
for(j = 0; j < 1025; j++) { 
sum += matrix[j][i] + strlen(str); 
} 
} 
三、编程题：30分 共1题 
注意：要求尽可能提供完整代码，如果可以编译运行酌情加分。 
1.内存中有一个长数组，条目数为10万，数组单元为结构体struct array，sizeof(struct array)为512字节。结构有一int型成员变量weight。现需要取得按weight值从大到小排序的前500个数组单元，请实现算法，要求效率尽可能高。 
四、设计题：35分 共1题 
注意：请尽可能详细描述你的数据结构、系统架构、设计思路等，建议多写一些伪代码或者流程说明。 
1.请设计一个字典。以字符串为索引，存储用户定义的定长结构。要求有增、删、查、改的功能。已经给定一个函数，可以由字符串映射到一个签名，每个签名由两个unsigned int类型组成。假设每一个字符串能够对应唯一的一个签名，完全没有重复（或者重复的概率可以忽略），并且签名分布足够均匀。 
请描述你的数据结构？内存如何申请？增、删、查、改的功能如何实现？如果操作很频繁，该如何优化？ 
取自"http://wiki.xyzp.net/2006%E7%99%BE%E5%BA%A6%E7%AC%94%E8%AF%95%E9%A2%98.htm"
总结一下教训： 
1、介绍项目的时候不能一味的按照事前想好的模板说，应该根据所申请的工作的性质，多说一些和自己申请的工作内内容相近的东西说。我在介绍我的项目的时候，说了很多硬件的东西，而相关的Linux下的C编程却没有提到多少，一大失败之处。 
百度电话面试题目： 
1.谈谈你对数据库中索引的理解
2.现在普通关系数据库用得数据结构是什么类型的数据结构
3.索引的优点和缺点
4.session和cache的区别是什么
5.如果有几千个session，怎么提高效率
6.session是存储在什么地方，以什么形式存储的。


16道嵌入式Ｃ语言面试题(经典) 

预处理器（Preprocessor
1. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
#define SECONDS_PER_DAY (60 * 60 * 24)UL
我在这想看到几件事情：
1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
3). 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
4). 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。
 
2. 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。
#define MIN(A,B) ((A) <= (B) (A) : (B))
这个测试是为下面的目的而设的：
1). 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
2). 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
3). 懂得在宏中小心地把参数用括号括起来
4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
least = MIN(*p++, b);
 
3. 预处理器标识#error的目的是什么？
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种
问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。

死循环（Infinite loops）
4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
这个问题用几个解决方案。我首选的方案是：
while(1) { }
一些程序员更喜欢如下方案：
for(;;) { }
这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的
基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。
第三个方案是用 goto
Loop:
...
goto Loop;
应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。

数据声明（Data declarations）
5. 用变量a给出下面的定义
a) 一个整型数（An integer）
b) 一个指向整型数的指针（A pointer to an integer）
c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）
d) 一个有10个整型数的数组（An array of 10 integers）
e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）
f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）
答案是：
a) int a; // An integer
b) int *a; // A pointer to an integer
c) int **a; // A pointer to a pointer to an integer
d) int a[10]; // An array of 10 integers
e) int *a[10]; // An array of 10 pointers to integers
f) int (*a)[10]; // A pointer to an array of 10 integers
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer

人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。
但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道
所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？
 
Static
6. 关键字static的作用是什么？
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。
 
Const
7．关键字const是什么含意？
我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？
const int a;
int const a;
const int *a;
int * const a;
int const * a const;
前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。

Volatile
8. 关键字volatile有什么含意 并给出三个不同的例子。
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。
假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
1). 一个参数既可以是const还可以是volatile吗？解释为什么。
2). 一个指针可以是volatile 吗？解释为什么。
3). 下面的函数有什么错误：
int square(volatile int *ptr)
{
return *ptr * *ptr;
}
下面是答案：
1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
int square(volatile int *ptr)
{
int a,b;
a = *ptr;
b = *ptr;
return a * b;
}
由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
long square(volatile int *ptr)
{
int a;
a = *ptr;
return a * a;
}

位操作（Bit manipulation）
9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
对这个问题有三种基本的反应
1). 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
2). 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
3). 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
#define BIT3 (0x1<<3)
static int a;
void set_bit3(void)
{
a |= BIT3;
}
void clear_bit3(void)
{
a &= ~BIT3;
}
一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。

访问固定的内存位置（Accessing fixed memory locations）
10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
int *ptr;
ptr = (int *)0x67a9;
*ptr = 0xaa55;
一个较晦涩的方法是：
*(int * const)(0x67a9) = 0xaa55;
即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。

中断（Interrupts）
11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字__interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
__interrupt double compute_area (double radius)
{
     double area = PI * radius * radius;
     printf(" Area = %f", area);
     return area;
}
这个函数有太多的错误了，以至让人不知从何说起了：
1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。

代码例子（Code examples）
12 . 下面的代码输出是什么，为什么？
void foo(void)
{
     unsigned int a = 6;
     int b = -20;
     (a+b > 6) puts("> 6") : puts("<= 6");
}
这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“>6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。

13. 评价下面的代码片断：
unsigned int zero = 0;
unsigned int compzero = 0xFFFF;
对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：
unsigned int compzero = ~0;
这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧…
 
动态内存分配（Dynamic memory allocation）
14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？
char *ptr;
if ((ptr = (char *)malloc(0)) == NULL)
puts("Got a null pointer");
else
puts("Got a valid pointer");
这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是“Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。

Typedef
15. Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
#define dPS struct s *
typedef struct s * tPS;
以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：
dPS p1,p2;
tPS p3,p4;
第一个扩展为
struct s * p1, p2;
上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。

晦涩的语法
16. C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
int a = 5, b = 7, c;
c = a+++b;
这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：
c = a++ + b;
因此, 这段代码持行后a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是:这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题


华为嵌入式系统面试题
（1）什么是预编译，何时需要预编译： 
答案： 
１、总是使用不经常改动的大型代码体。 
２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。 
（2）char * const p      char const * p      const char *p 上述三个有什么区别？ 
答案： 
char * const p; //常量指针，p的值不可以修改 
char const * p；//指向常量的指针，指向的常量值不可以改 const char *p； //和char const *p 
（3）char str1[] = "abc"; char str2[] = "abc"; const char str3[] = "abc"; const char str4[] = "abc"; const char *str5 = "abc"; const char *str6 = "abc"; char *str7 = "abc"; char *str8 = "abc"; cout < < ( str1 == str2 ) < < endl; cout < < ( str3 == str4 ) < < endl; cout < < ( str5 == str6 ) < < endl; cout < < ( str7 == str8 ) < < endl; 

结果是：0 0 1 1 str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。 
（4）以下代码中的两个sizeof用法有问题吗？ 
[C易] void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母 {    for( size_t i=0; i <sizeof(str)/sizeof(str[0]); ++i )        if( 'a' <=str[i] && str[i] <='z' )            str[i] -= ('a'-'A' ); } char str[] = "aBcDe"; cout < < "str字符长度为: " < < sizeof(str)/sizeof(str[0]) < < endl; UpperCase( str ); cout < < str < < endl; 答案：函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，因为还有'\0'，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。 
（5）一个32位的机器,该机器的指针是多少位答案： 
指针是多少位只要看地址总线的位数就行了。80386以后的机子都是32的数据总线。所以指针的位数就是4个字节了。 
6。main() {  int a[5]={1,2,3,4,5};    int *ptr=(int *)(&a+1);    printf("%d,%d",*(a+1),*(ptr-1)); } 答案：2。5 *(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5 &a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int） int *ptr=(int *)(&a+1); 则ptr实际是&(a[5]),也就是a+5 原因如下： &a是数组指针，其类型为 int (*)[5]; 而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同 a是长度为5的int数组指针，所以要加 5*sizeof(int) 所以ptr实际是a[5] 但是prt与(&a+1)类型是不一样的(这点很重要) 所以prt-1只会减去sizeof(int*) a,&a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5]. 
7、请问以下代码有什么问题： 
int  main() 
{ 
char a; 
char *str=&a; 
strcpy(str,"hello"); 
printf(str);
return 0; 
} 答案：没有为str分配内存空间，将会发生异常。问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。 
8、char* s="AAA"; printf("%s",s); s[0]='B'; printf("%s",s); 有什么错？
答案："AAA"是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。 cosnt char* s="AAA"; 然后又因为是常量，所以对是s[0]的赋值操作是不合法的。 
9、写一个“标准”宏，这个宏输入两个参数并返回较小的一个。
答案：.#define Min(X, Y) ((X)>(Y)?(Y):(X))  //结尾没有‘；’ 
10、嵌入式系统中经常要用到无限循环，你怎么用C编写死循环。
答案：while(1){}或者for(;;) 
11、关键字static的作用是什么？
答案：定义静态变量 
12、关键字const有什么含意？
答案：表示常量不可以修改的变量。 
13、关键字volatile有什么含意？并举出三个不同的例子？
答案：提示编译器对象的值可能在编译器未监测到的情况下改变。 
14、int (*s[10])(int) 表示的是什么啊？
答案：int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。 
15。有以下表达式： 
int a=248; 
b=4;
int const c=21;
const int *d=&a;
 int *const e=&b;
int const *f const =&a; 
请问下列表达式哪些会被编译器禁止？为什么？
答案：*c=32;d=&b;*d=43;e=34;e=&a;f=0x321f; *c 这是个什么东东，禁止 *d 说了是const， 禁止 e = &a 说了是const 禁止 const *f const =&a; 禁止 
16交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3; 
答案：有两种解法, 一种用算术算法, 一种用^(异或) a = a + b; b = a - b; a = a - b; or a = a^b;// 只能对int,char.. b = a^b; a = a^b; or a ^= b ^= a; 
17.c和c++中的struct有什么不同？
答案：c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private 
18.
#include <stdio.h>  
#include <stdlib.h>  
void getmemory(char *p)  
{    
p=(char *) malloc(100);    
strcpy(p,"hello world");  
}  
int main( )  
{    
char *str=NULL;    
getmemory(str);    
printf("%s/n",str);    
free(str);    
return 0;    
} 答案：程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险 
19.
char szstr[10];  
strcpy(szstr,"0123456789");  产生什么结果？为什么？
答案：  长度不一样，会造成非法的OS 
20.列举几种进程的同步机制，并比较其优缺点。
答案：  原子操作 信号量机制    自旋锁    管程，会合，分布式系统 
21.进程之间通信的途径
答案：共享存储系统消息传递系统管道：以文件系统为基础 
22.进程死锁的原因
答案：资源竞争及进程推进顺序非法 
23.死锁的4个必要条件
答案：互斥、请求保持、不可剥夺、环路 
24.死锁的处理
答案：鸵鸟策略、预防策略、避免策略、检测与解除死锁 
25.  操作系统中进程调度策略有哪几种？
答案：FCFS(先来先服务)，优先级，时间片轮转，多级反馈 
26.类的静态成员和非静态成员有何区别？
答案：类的静态成员每个类只有一个，非静态成员每个对象一个 
27.纯虚函数如何定义？使用时应注意什么？
答案：virtual void f()=0; 是接口，子类必须要实现 
28.数组和链表的区别
答案：数组：数据顺序存储，固定大小  链表：数据可以随机存储，大小可动态改变 
29.ISO的七层模型是什么？tcp/udp是属于哪一层？tcp/udp有何优缺点？
答案：应用层表示层会话层运输层网络层物理链路层物理层 tcp /udp属于运输层 TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。 tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好 udp: 不提供稳定的服务，包头小，开销小  
30：(void *)ptr 和 (*(void**))ptr的结果是否相同？其中ptr为同一个指针
答案：.(void *)ptr 和 (*(void**))ptr值是相同的 
31：
int main()    
{    
int x=3;    
printf("%d",x);    
return 1;      
} 问函数既然不会被其它函数调用，为什么要返回1？
答案：mian中，c标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息 
32，要对绝对地址0x100000赋值，我们可以用 (unsigned int*)0x100000 = 1234; 那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？
答案：*((void (*)( ))0x100000 ) ( ); 首先要将0x100000强制转换成函数指针,即: (void (*)())0x100000 然后再调用它: *((void (*)())0x100000)(); 用typedef可以看得更直观些: typedef void(*)() voidFuncPtr; *((voidFuncPtr)0x100000)(); 
33，已知一个数组table，用一个宏定义，求出数据的元素个数答案：#define NTBL #define NTBL (sizeof(table)/sizeof(table[0])) 
34、线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈? 
答案：进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。每个线程有自己的堆栈。 DLL中有没有独立的堆栈，这个问题不好回答，或者说这个问题本身是否有问题。因为DLL中的代码是被某些线程所执行，只有线程拥有堆栈，如果DLL中的代码是EXE中的线程所调用，那么这个时候是不是说这个DLL没有自己独立的堆栈？如果DLL中的代码是由DLL自己创建的线程所执行，那么是不是说DLL有独立的堆栈？以上讲的是堆栈，如果对于堆来说，每个DLL有自己的堆，所以如果是从DLL中动态分配的内存，最好是从DLL中删除，如果你从DLL中分配内存，然后在EXE中，或者另外一个DLL中删除，很有可能导致程序崩溃 
35、
unsigned short A = 10; 
printf("~A = %u\n", ~A); 
char c=128; 
printf("c=%d\n",c); 
输出多少？并分析过程
答案：第一题，～A ＝0xfffffff5,int值 为－11，但输出的是uint。所以输出4294967285 第二题，c＝0x10,输出的是int，最高位为1，是负数，所以它的值就是0x00的补码就是128，所以输出－128。这两道题都是在考察二进制向int或uint转换时的最高位处理。  


（二）
1. -1,2,7,28,,126请问28和126中间那个数是什么？为什么？
答案：第一题的答案应该是4^3-1=63 规律是n^3-1(当n为偶数0，2，4)      n^3+1(当n为奇数1，3，5) 
2.用两个栈实现一个队列的功能？要求给出算法和思路！
答案：设2个栈为A,B, 一开始均为空. 入队: 将新元素push入栈A; 出队: (1)判断栈B是否为空； (2)如果不为空，则将栈A中所有元素依次pop出并push到栈B； (3)将栈B的栈顶元素pop出；这样实现的队列入队和出队的平摊复杂度都还是O(1), 比上面的几种方法要好。 
3.在c语言库函数中将一个字符转换成整型的函数是atol()吗，这个函数的原型是什么？
答案：函数名: atol 功 能: 把字符串转换成长整型数 用 法: long atol(const char *nptr); 程序例: #include <stdlib.h> #include <stdio.h> int main(void) { long l; char *str = "98765432"; l = atol(lstr); printf("string = %s integer = %ld\n", str, l); return(0); } 
4。对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现? 
答案：c用宏定义，c++用inline 
5。直接链接两个信令点的一组链路称作什么? 
答案：PPP点到点连接 
7。软件测试都有那些种类? 
答案：黑盒：针对系统功能的测试    白合：测试函数功能，各函数接口 
8。确定模块的功能和模块的接口是在软件设计的那个队段完成的? 
答案：概要设计阶段 
9。enum string    {    x1,    x2,    x3=10,    x4,    x5,    }x;    问x；答案：取值在0。1。10。11。12中的一个 
10。
unsigned char *p1;    
unsigned long *p2;    
p1=(unsigned char *)0x801000;    
p2=(unsigned long *)0x810000;    
请问p1+5=  ;        p2+5=  ; 
答案：801005； 810014。不要忘记了这个是16进制的数字，p2要加20变为16进制就是14 
选择题: 
 1.Ethternet链接到Internet用到以下那个协议?  A.HDLC;B.ARP;C.UDP;D.TCP;E.ID  
2.属于网络层协议的是:  A.TCP;B.IP;C.ICMP;D.X.25 
 3.Windows消息调度机制是:  A.指令队列;B.指令堆栈;C.消息队列;D.消息堆栈; 答案：b，a，c 
四.找错题:
1.请问下面程序有什么错误?    
int a[60][250][1000],i,j,k;    
for(k=0;k <=1000;k++)    
for(j=0;j <250;j++)      
for(i=0;i <60;i++)      
a[i][j][k]=0; 
答案：把循环语句内外换一下 
2。以下是求一个数的平方的程序,请找出错误:    
#define SQUARE(a)  ((a)*(a))    
int a=5;    
int b;    
b=SQUARE(a++); 
答案：这个没有问题，s（a＋＋），就是（（a＋＋）×（a＋＋））唯一要注意的就是计算后a＝7了 
3、
typedef unsigned char BYTE      
int examply_fun(BYTE gt_len; BYTE *gt_code)      
{        
BYTE *gt_buf;      
gt_buf=(BYTE *)MALLOC(Max_GT_Length);      ......      if(gt_len>Max_GT_Length)        
{        
return GT_Length_ERROR;          
}       
 .......      
} 
答案：要释放内存问答题: 1.IP Phone的原理是什么? 答案：IPV6 2.TCP/IP通信建立的过程怎样，端口有什么作用？答案：三次握手，确定是哪个应用程序使用该协议 
（三）
1、局部变量能否和全局变量重名？
答案：能，局部会屏蔽全局。要用全局变量，需要使用"::" 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内 
2、如何引用一个已经定义过的全局变量？
答案：extern 可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错 
3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？
答案：可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错 
4、语句for( ；1 ；)有什么问题？它是什么意思？
答案：和while(1)相同。 
5、do……while和while……do有什么区别？
答案：前一个循环一遍再判断，后一个判断以后再循环。 
6、请写出下列代码的输出内容
＃include <stdio.h> 
main() 
{ 
int a,b,c,d; 
a=10; b=a++; 
c=++a; 
d=10*a++; 
printf("b，c，d：%d，%d，%d"，b，c，d）; 
return 0; 
} 
答案：10，12，120  a=10;  b=a++;//a=11 b=10  c=++a;//a=12 c=12  d=10*a++;//a=13 d=120 


高级题
1、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
答案：全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。 static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件 static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 
2、程序的局部变量存在于（）中，全局变量存在于（）中，动态申请数据存在于（ ）中。
答案：栈；静态区；堆 
3、设有以下说明和定义： 
typedef union {long i; int k[5]; 
char c;
} DATE; 
struct data { int cat; DATE cow; double dog;} too; 
DATE max; 
则语句 printf("%d",sizeof(too)+sizeof(max));的执行结果是：______ 
答案：DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20 data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32. 所以结果是 20 + 32 = 52. 当然...在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 = 20 
4、队列和栈有什么区别？
答案：队列先进先出，栈后进先出÷ 
6、已知一个单向链表的头，请写出删除其某一个结点的算法，要求，先找到此结点，然后删除。
答案：slnodetype *Delete(slnodetype *Head,int key){}中if(Head->number==key) { Head=Pointer->next; free(Pointer); break; } Back = Pointer;        Pointer=Pointer->next; if(Pointer->number==key) {            Back->next=Pointer->next; free(Pointer); break; } void delete(Node* p) {    if(Head = Node)    while(p) } 
7、请找出下面代码中的所以错误说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba” 
1、＃include"string.h" 2、main() 3、{ 4、 char*src="hello,world"; 5、 char* dest=NULL; 6、 int len=strlen(src); 7、 dest=(char*)malloc(len); 8、 char* d=dest; 9、 char* s=src[len]; 10、 while(len--!=0) 11、 d++=s--; 12、 printf("%s",dest); 13、 return 0; 14、} 答案：还要加上＃include <stdio.h> int main(){ char* src = "hello,world"; int len = strlen(src); char* dest = (char*)malloc((len+1)*sizeof(char));  //要为\0分配一个空间 char* d = dest; char* s = &src[len-1]; //指向最后一个字符 while( len-- != 0 ) *d++=*s--; *d = 0; //尾部要加\0 printf("%s\n",dest); free(dest);// 使用完，应当释放空间，以免造成内存汇泄露 return 0; }    

华为笔试题（3） 
2006-09-29 19:41 
一、判断题（对的写T，错的写F并说明原因，每小题4分，共20分） 
1、有数组定义int a[2][2]={{1},{2,3}};则a[0][1]的值为0。（    正确 ） 
2、int (*ptr) (),则ptr是一维数组的名字。（错误  int (*ptr) ();定义一个指向函数的指针变量    ） 
3、指针在任何情况下都可进行>, <,>=, <=,==运算。（  错误  ） 
4、switch(c) 语句中c可以是int ,long,char ,float ,unsigned int 类型。（  错，不能用实形 ） 
二、填空题（共30分） 
1、在windows下，写出运行结果，每空2分，共10分。 char str[ ]= ＂Hello＂; char *p=str; int n=10; sizeof(str)=(      ) sizeof(p)=(      ) sizeof(n)=(      ) void func(char str[100]){    } sizeof(str)=(    )  
答案：6，4，4，4, 具体解释请参看我的空间里的“C/C++程序员应聘试题剖析” 
2、void getmemory(char **p, int num) { *p=(char *) malloc(num);} void test(void) {  char *str=NULL;    getmemory(&str,100);    strcpy(str,＂hello＂);    printf(str); } 运行test函数有什么结果？（     ）10分  
答案：输出hello，但是发生内存泄漏。 
3、设int arr[]={6,7,8,9,10};      
int *ptr=arr;    
*(ptr++)+=123;  
printf(＂%d,%d＂,*ptr,*(++ptr)); (   ) 10分
答案：8， 
8。这道题目的意义不大，因为在不同的编译器里printf的参数的方向是不一样的，在vc6.0下是从有到左，这里先*(++ptr) 后*pt，
于是结果为8，8 
三、编程题（第一小题20，第二小题30分） 
1、  不使用库函数，编写函数int strcmp(char  *source, char *dest) 相等返回0，不等返回-1； 
答案：
一、int strcmp(char*source, char *dest) 
{  
assert((source!=NULL)&&(dest!=NULL));  
int i,j;  
for(i=0; source[i]==dest[i]; i++)  
{  
if(source[i]=='\0' && dest[i]=='\0')    
return 0;  
else    
return -1;  
} 
} 
答案：
二、 int strcmp(char *source, char *dest) 
{    
while ( (*source != '\0') && (*source == *dest))    
{ 
source++;
 dest++;    
}    
return ( (*source) - (*dest) ) ? -1 : 0; 
} 
2、  写一函数int fun(char *p)判断一字符串是否为回文，是返回1，不是返回0，出错返回-1 答案：一、 int fun(char *p) {  if(p==NULL)  return -1;  else  {  int length = 0;  int i = 0;  int judge = 1;  length = strlen(p);  for(i=0; i <length/2; i++)  {    if(p[i]!=p[length-1-i])    judge = 0;    break;  }  if(judge == 0)    return 0;  else    return 1;  } } 答案：二、 int fun(char *p){ int len = strlen(p) - 1; char *q = p + len; if (!p) return -1; while (p < q) { if ((*p++) != (*q--)) return 0; } return 1;}  
华为笔试网络题（3）
2006-09-30 12:48
1.在OSI 7 层模型中,网络层的功能有( ) 
A.确保数据的传送正确无误  B.确定数据包如何转发与路由 C.在信道上传送比特流    D.纠错与流控 
2.FDDI 使用的是___局域网技术。( ) 
A.以太网;    B.快速以太网;    C.令牌环;    D.令牌总线。 
3.下面那种LAN 是应用CSMA/CD协议的（) 
A.令牌环    B.FDDI    C.ETHERNET    D.NOVELL 
4.TCP 和UDP 协议的相似之处是 ( ) 
A.面向连接的协议    B.面向非连接的协议    C.传输层协议    D.以上均不对 
5.应用程序PING 发出的是___报文.( ) 
A.TCP 请求报文。    B.TCP 应答报文。    C.ICMP 请求报文。  D.ICMP 应答报文。 
6.以下说法错误的是(多) ( ) 
A.中继器是工作在物理层的设备    B.集线器和以太网交换机工作在数据连路层 C.路由器是工作在网络层的设备    D.桥能隔离网络层广播 
7.当桥接收的分组的目的MAC地址在桥的映射表中没有对应的表项时,采取的策略是( ) 
A.丢掉该分组  B.将该分组分片    C.向其他端口广播该分组    D.以上答案均不对 
8.LAN Switch 在网络层次模型中的地位( ) 
A.物理层    B.链路层    C.网络层    D.以上都不是 
9.小于___的TCP/UDP端口号已保留与现有服务一一对应,此数字以上的端口号可自由分配。( ) 
A.199      B.100    C.1024      D.2048 
10.当一台主机从一个网络移到另一个网络时,以下说法正确的是 ( ) 
A.必须改变它的IP 地址和MAC 地址    B.必须改变它的IP 地址,但不需改动MAC 地址 C.必须改变它的MAC 地址,但不需改动IP 地址    D.MAC 地址.IP 地址都不需改动
答案：1.B; 2.C; 3.C; 4.C; 5.C; 6.BD; 7.C; 8.B; 9.C; 10.B.  
华为笔试题（4）
2006-09-30 13:00
1. 找错 
void test1() 
{    
char string[10];    
char* str1="0123456789";    
strcpy(string, str1); 
} 答：表面上并且编译都不会错误。但如果string数组原意表示的是字符串的话，那这个赋值就没有达到意图。最好定义为char string[11]，这样最后一个元素可以存储字符串结尾符'\0'; void test2() {    char string[10], str1[10];  for(int I=0; I <10;I++)  {    str1[I] ='a';  }  strcpy(string, str1); } 答：strcpy使用错误，strcpy只有遇到字符串末尾的'\0'才会结束，而str1并没有结尾标志，导致strcpy函数越界访问，不妨让str1[9]='\0'，这样就正常了。 void test3(char* str1) {    char string[10];    if(strlen(str1) <=10) {    strcpy(string, str1); } } 答：这又会出现第一道改错题的错误了。strlen(str1)算出来的值是不包含结尾符'\0'的，如果str1刚好为10个字符＋1结尾符，string就得不到结尾符了。可将strlen(str1) <=10改为strlen(str1) <10。 
2. 找错 
#define MAX_SRM 256 DSN get_SRM_no() 
{    static int SRM_no;    
int I;    
for(I=0;I <MAX_SRM;I++,SRM_no++)  
{    
SRM_no%=MAX_SRM;    
if(MY_SRM.state==IDLE)    
{      break;    }  
}  
if(I>=MAX_SRM)    
return (NULL_SRM);  
else    
return SRM_no; 
} 答：我不知道这段代码的具体功能，但明显有两个错误 1，SRM_no没有赋初值 2，由于static的声明，使该函数成为不可重入（即不可预测结果）函数，因为SRM_no变量放在程序的全局存储区中，每次调用的时候还可以保持原来的赋值。这里应该去掉static声明。 
3. 写出程序运行结果 
int sum(int a) 
{    
auto int c=0;    
static int b=3;  
c+=1;  
b+=2;  
return(a+b+c); 
}  
void main() 
{    
int I;  
int a=2;  
for(I=0;I <5;I++)  
{    
printf("%d,", sum(a));  
} 
} 答：8,10,12,14,16 该题比较简单。只要注意b声明为static静态全局变量，其值在下次调用时是可以保持住原来的赋值的就可以。 
4. int func(int a) 
{    
int b;    
switch(a)    
{        
case 1: b=30;       
case 2: b=20;        
case 3: b=16;        
default: b=0;    
}    
return b; 
} 则func(1)=? 
答：func(1)=0，因为没有break语句，switch中会一直计算到b=0。这是提醒我们不要忘了break。呵呵。 
5:  
int a[3];  
a[0]=0; 
a[1]=1; 
a[2]=2;  
int *p, *q;  
p=a;  
q=&a[2]; 
则a[q-p]=? 
答：a[q-p]=a[2]=2;这题是要告诉我们指针的运算特点 
6. 定义 int **a[3][4], 则变量占有的内存空间为：_____ 
答：此处定义的是指向指针的指针数组，对于32位系统，指针占内存空间4字节，因此总空间为3×4×4＝48。 
7. 编写一个函数，要求输入年月日时分秒，输出该年月日时分秒的下一秒。如输入2004年12月31日23时59分59秒，则输出2005年1月1日0时0分0秒。 
答： /*输入年月日时分秒，输出年月日时分秒的下一秒，输出仍然在原内存空间*/ 
void NextMinute(int *nYear,int *nMonth,int *nDate,int *nHour,int *nMinute,int *nSecond) 
{  
int nDays;  
(*nSecond)++;  // 秒加1  
if(*nSecond>=60)  // 秒满60，做出特殊处理，下面时，日，月等类同  	{    
*nSecond=0;    
(*nMinute)++;    
if(*nMinute>=60)    
{      
*nMinute=0;      
(*nHour)++;      
if(*nHour>=24)      
{        
*nHour=0;        
(*nDate)++;        
switch(*nMonth)        
{          
case 1:          
case 3:          
case 5:          
case 7:          
case 8:          
case 10:          
case 12:            
nDays=31;          
break;          
case 2:// 判断闰年            
if(*nYear%400==0¦¦*nYear%100!=0&&*nYear%4==0)            {            
nDays=29;            
}           
else            
{            
nDays=28;            
}          
break;          
default:            
nDays=30;          
break;        
}        
if(*nDate>nDays)        
{          
*nDate=1;          
(*nMonth)++;          
if(*nMonth>12)          
{          
*nMonth=1;          
(*nYear)++;          
}        
}      
}    
}  
} 
} /*示例可运行代码*/ 
Void main()
{  
int nYear=2004,nMonth=12,nDate=31,nHour=59,nMinute=59,nSecond=59; 
NextMinute(&nYear,&nMonth,&nDate,&nHour,&nMinute,&nSecond);  
printf("The result:%d-%d-%d%d:%d:%d",nYear,nMonth,nDate,nHour,nMinute,nSecond); }    
华为硬件笔试题
2006-09-30 13:01
一 选择 13个题目,没有全部抄下来,涉及的课程有电路,模拟电路,数字电路,信号与系统,微机原理,网络,数字信号处理 有关于 1.微分电路 2.CISC,RISC 3.数据链路层 
二 填空 10个题目,没有全部抄下来,涉及的课程有电路,模拟电路,数字电路,信号与系统,微机原理,网络,数字信号处理 有关于 
1.TIC6000 DSP 2.二极管 3.RISC 4.IIR 
三 简答 
1.x(t)的傅立叶变换为X(jw)=$(w)+$(w-PI)+$(w-5) h(t)=u(t)-u(t-2) 问: (1),x(t)是周期的吗? (2),x(t)*h(t)是周期的吗? (3),两个非周期的信号卷积后可周期吗? 2.简述分组交换的特点和不足四 分析设计 1.波形变换题目 从正弦波->方波->锯齿波->方波,设计电路 2.74161计数器组成计数电路,分析几进制的 3.用D触发器构成2分频电路 4.判断MCS-51单片机的指令正确还是错误,并指出错误原因 (1) MUL R0,R1 (2) MOV A,@R7 (3) MOV A,#3000H (4) MOVC @A+DPTR,A (5) LJMP #1000H () 5.MCS-51单片机中,采用12Mhz时钟,定时器T0采用模式1(16位计数器),请问在下面程序中,p1.0的输出频率 MOV TMOD,#01H SETB TR0 LOOP:MOV TH0,#0B1H MOV TL0,#0E0H LOOP1:JNB TF0,LOOP1 CLR TR0 CPL P1.0 SJMP LOOP      
华为硬件面试题
2006-09-30 13:02
全都是几本模电数电信号单片机题目　　 
1.用与非门等设计全加法器 　　 
2.给出两个门电路让你分析异同 　　 
3.名词:sram,ssram,sdram 　　 
4.信号与系统:在时域与频域关系 　　 
5.信号与系统:和4题差不多 　　 
6.晶体振荡器,好像是给出振荡频率让你求周期(应该是单片机的,12分之一周期.. 　　..) 　　 
7.串行通信与同步通信异同,特点,比较 　　 
8.RS232c高电平脉冲对应的TTL逻辑是?(负逻辑?) 　　 
9.延时问题,判错 　　 
10.史密斯特电路,求回差电压 　　 
11.VCO是什么,什么参数(压控振荡器?) 　　 
12. 用D触发器做个二分颦的电路.又问什么是状态图 
13. 什么耐奎斯特定律,怎么由模拟信号转为数字信号 　　 
14. 用D触发器做个4进制的计数 　　 
15.那种排序方法最快? 　　 
一、 研发（软件）
用C语言写一个递归算法求N！； 　　
给一个C的函数，关于字符串和数组，找出错误； 　　
防火墙是怎么实现的？　　
你对哪方面编程熟悉？  

硬件： 
1、继电器控制电路。 
2、SDRAM是怎么工作的 
3、写出逻辑表达式说明A2A1A0大于B2B1B0。 
4、常用触发器有几种 
5、示波器有几种触发方式，举出三种  
    
华为3COM数据通信工程师试题
2006-09-29 18:53
1 H.323协商
答案：12个包协商，先H225然后H245，需要注意的是面试官可能会问到跟SIP的比较 
2 ipsec为什么是三层的。L2tp为什么是二层的？ 
答案：IPSec (Internet 协议安全)是一个工业标准网络安全协议，为 IP 网络通信提供透明的安全服务，保护 TCP/IP 通信免遭窃听和篡改，可以有效抵御网络攻击，同时保持易用性。IPSec有两个基本目标：1）保护IP数据包安全；2）为抵御网络攻击提供防护措施。 第三层保护的优点 　　通常IPSec提供的保护需要对系统做一定的修改。但是IPSec在IP传输层即第三层的"策略执行"（strategic implementation）几乎不需要什么额外开销就可以实现为绝大多数应用系统、服务和上层协议提供较高级别的保护；为现有的应用系统和操作系统配置IPSec几乎无须做任何修改，安全策略可以在Active Directory里集中定义也可以在某台主机上进行本地化管理。　　IPSec策略在ISO参考模型第三层即网络层上实施的安全保护，其范围几乎涵盖了TCP/IP协议簇中所有IP协议和上层协议，如TCP、UDP、ICMP，Raw（第255号协议）、甚至包括在网络层发送数据的客户自定义协议。在第三层上提供数据安全保护的主要优点就在于：所有使用IP协议进行数据传输的应用系统和服务都可以使用IPSec，而不必对这些应用系统和服务本身做任何修改。　　运作于第三层以上的其他一些安全机制，如安全套接层SSL，仅对知道如何使用SSL的应用系统（如Web浏览器）提供保护，这极大地限制了SSL的应用范围；而运作于第三层以下的安全机制，如链路层加密，通常只保护了特定链路间的数据传输，而无法做到在数据路径所经过的所有链路间提供安全保护，这使得链接层加密无法适用于 Internet 或路由 Intranet 方案中的端对端数据保护。 L2TP（第二层隧道协议）通过使用虚拟专用网 (VPN) 连接和第二层隧道协议 (L2TP)，可以通过 Internet 或其他公共网络访问专用网。L2TP 是一个工业标准 Internet 隧道协议，它和点对点隧道协议 (PPTP) 的功能大致相同。利用L2TP来构建企业的VPN，一样需要运营商支持，因为LAC一般是在传统电话交换网络中部署的，并且一个公司的分支机构以及移动办公的员工在地域上分布很广，所以需要各地的运营商都具备LAC才能够实现企业大范围构建VPN网络。当然企业也可以构建自己的基于L2TP的VPN网络在L2TP VPN中，用户端的感觉就像是利用PPP协议直接接到了企业总部的PPP端接设备上一样，其地址分配可以由企业通过DHCP来分配，认证方式可以沿用PPP一直沿用的各种认证方式，并且L2TP是IETF定义的，其MIB库也将定义出来从而可以实现全局的网络管理。 
3 ospf中包的ttl值是多少？ 
答案：1，因为224.0.0.5/224.0.0.6是本地链路组播 
4 OSPF为什么要划分区域？
答案：RD用于BGP区分VPN路由，RT用于在各VRF中导入或导出路由 
5 MPLS VPN的标签一共有几层。内网的标签放在哪里。
答案：如果没有流量工程则是2层，内网标签在隧道标签之后 
6 MPLS中RD和RT的作用分别是什么？
答案：减少CPU负载，区域间使用距离矢量算法，因此其它区域的泛洪不会影响区域的SPF运算，这里注意面试官可能会问OSPF多区域如何防止环路。(注意答本质而不是现象，免得面试官追问) 
7 RR防止环路的机制。
答案：RR中通过ORIGIN ID和CLUSTER ID防止环路，若RR收到带有自己CLUSTER ID的路由则丢弃 
8 BGP控制out-bound用local-pre，控制进来的用med. 
答案：正确 
9 ospf是工作在哪个协议上的？
答案：IP，OSPF协议号89 
10 ospf的LSA类型。
答案：1，2，3，4，5，6，7，没有什么好说的，注意考官问到第6类LSA，组播再准备多点 
11 简述OSPF的基本工作机制。
答案：这个没什么可以说了，把知道的都说出来就行了 
12 ppp的lcp和ncp协商过程。
答案：LCP过程协商二层链路相关参数，MTU/PPP压缩/认证协议类型等~~~NCP协商第三层协议，IP地址，IP压缩等等，这里记住最好不要说CDP 
13 笔试中还有一道PSTN的信令控制有哪三种？
答案：这个我只知道随路信令和共路信令，信工同学提供的答案是：监视\号码\音信号\，知道正确答案的朋友麻烦纠正一下 
14sloari 8.0查看进程的命令是什么？linux 7.3查看IP的命令是什么？
答案：不知道华为为什么问这个，第一个是PS吧？第二个是IFCONFIG /A 
15 IP是5.32.0.0,掩码255.224.0.0。请问最大的有效地址是多少。
答案：最大主机地址5。64。255。254 
17 lx/lh的有效距离是多少？
答案：？？？ 
18 IP 包头几个字节？加上数据部分几个字节
答案：应该是问IPV4，一般20字节，加上源路由选择等后最大60字节，加上数据部分还是根据链路MTU决定 
20 CQ能不能有一种流量dominate第二种流量? 
答案：CQ不能有一种流量DOMINATE其它任何流量 21 FTP下载一个文件完成。有几个TCP连接答案：4个



1 、Char a[10]
Sizeof(a) strlen(a)
各为多少
2、什么是对象
3、a=0x10
b=0x01
c= a^b<<1
 答案 0x10 先左移再或
4、结构体在32位 ubuntu中的大小
struct  A
{
int i；
char a[5]；
unsigned char b；
};

5、写出swap（x，y）函数
(x)=(x)+(y);
(y)=(x)–(y);
(x)=(x)–(y);

6、请找出下面代码中的所以错误
说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba” 
#include"string.h"
main()
{
char*src="hello,world";
char* dest=NULL;
 int len=strlen(src);
dest=(char*)malloc(len);
char* d=dest;
 char* s=src[len];
 while(len--!=0)
 d++=s--;
 printf("%s",dest);
 return 0;
}
答：
方法1：
int main(){
char* src = "hello,world";
int len = strlen(src);
char* dest = (char*)malloc(len+1);//要为\0分配一个空间
char* d = dest;
char* s = &src[len-1];//指向最后一个字符
while( len-- != 0 )
*d++=*s--;
*d = 0;//尾部要加\0
printf("%s\n",dest);
free(dest);// 使用完，应当释放空间，以免造成内存汇泄露
return 0;
}
方法2：
#include <stdio.h>
#include <string.h>
main()
{
char str[]="hello,world";
int len=strlen(str);
char t;
for(int i=0; i<len/2; i++)
{
t=str[i];
str[i]=str[len-i-1]; str[len-i-1]=t;
}
printf("%s",str);
return 0;
}
7、 typedef void(fuc*)(int, int)的作用
8请问下面程序有什么错误?
int a[60][250][1000],i,j,k;
for(k=0;k<=1000;k++)
	for(j=0;j<250;j++)
		for(i=0;i<60;i++)

9、
const char* p 
char const* p 
char * const p 的用途

10、输出是什么 为什么
main()
{
	int a[5]={1,2,3,4,5};
	int *ptr=(int *)(&a+1);
	printf(“%d，%d”,*(a+1),*(ptr-1));
}
请问输出：
 【标准答案】2,5

11、实现函数
memcpy(void* dest, void* source, size_t count)
memmove(void *dst,const void *src,int count)

void* mymemcpy(void* dest, void* source, size_t count)
{
       char *ret = (char *)dest;
       char *dest_t = ret;
       char *source_t = (char *)source;
       
       while (count--){
           *dest_t++ = *source_t++;
        }  
return ret;
}      
 
void *my_memmove(void *dst,const void *src,int count)
{
   char *ret;
   char *dst_t;
   char *src_t;
  
   ret = (char *)dst;
 
   if ((unsigned char*)dst <= (unsigned char*)src
|| (unsigned char *)dst >= ((unsigned char *)src + count))
   {
         dst_t = (char *)dst;
      src_t = (char *)src;
     
      while (count--)
      {
         *dst_t++ = *src_t++;
      }
   }else{
     dst_t = (char *)dst + count - 1;
     src_t = (char *)src + count - 1;
     while (count--)
      {
        *dst_t-- = *src_t--;
      }
   }
 
   return(ret);
 
}


数字电路
1、同步电路和异步电路的区别是什么？（仕兰微电子）
2、什么是同步逻辑和异步逻辑？（汉王笔试）
同步逻辑是时钟之间有固定的因果关系。异步逻辑是各时钟之间没有固定的因果关系。 
3、什么是"线与"逻辑，要实现它，在硬件特性上有什么具体要求？（汉王笔试）
线与逻辑是两个输出信号相连可以实现与的功能。在硬件上，要用oc门来实现，由于不用
oc门可能使灌电流过大，而烧坏逻辑门。同时在输出端口应加一个上拉电阻。
4、什么是Setup 和Holdup时间？（汉王笔试）
5、setup和holdup时间,区别.（南山之桥）
6、解释setup time和hold time的定义和在时钟信号延迟时的变化。（未知）
7、解释setup和hold time violation，画图说明，并说明解决办法。（威盛VIA
2003.11.06 上海笔试试题）
Setup/hold time 是测试芯片对输入信号和时钟信号之间的时间要求。建立时间是指触发器的时钟信号上升沿到来以前，数据稳定不变的时间。输入信号应提前时钟上升沿（如上升沿有效）T时间到达芯片，这个T就是建立时间-Setup time.如不满足setup time,这个数据就不能被这一时钟打入触发器，只有在下一个时钟上升沿，数据才能被打入触发器。保持时间是指触发器的时钟信号上升沿到来以后，数据稳定不变的时间。如果hold time不够，数据同样不能被打入触发器。建立时间(Setup Time)和保持时间（Hold time）。建立时间是指在时钟边沿前，数据信号需要保持不变的时间。保持时间是指时钟跳变边沿后数据信号需要保持不变的时间。如果不满足建立和保持时间的话，那么DFF将不能正确地采样到数据，将会出现
metastability的情况。如果数据信号在时钟沿触发前后持续的时间均超过建立和保持时间，那么超过量就分别被称为建立时间裕量和保持时间裕量。
8、说说对数字逻辑中的竞争和冒险的理解，并举例说明竞争和冒险怎样消除。（仕兰微电子）
9、什么是竞争与冒险现象？怎样判断？如何消除？（汉王笔试）
在组合逻辑中，由于门的输入信号通路中经过了不同的延时，导致到达该门的时间不一致叫竞争。产生毛刺叫冒险。如果布尔式中有相反的信号则可能产生竞争和冒险现象。解决方法：一是添加布尔式的消去项，二是在芯片外部加电容。
10、你知道那些常用逻辑电平？TTL与COMS电平可以直接互连吗？（汉王笔试）常用逻辑电平：12V，5V，3.3V；TTL和CMOS不可以直接互连，由于TTL是在0.3-3.6V之间，而CMOS则是有在18V的有在12V的有在5V的。CMOS输出接到TTL是可以直接互连。TTL接到CMOS需要在输出端口加一上拉电阻接到5V或者12V。
11、如何解决亚稳态。（飞利浦－大唐笔试）亚稳态是指触发器无法在某个规定时间段内达到一个可确认的状态。当一个触发器进入亚稳态时，既无法预测该单元的输出电平，也无法预测何时输出才能稳定在某个正确的电平上。在这个稳定期间，触发器输出一些中间级电平，或者可能处于振荡状态，并且这种无用的输出电平可以沿信号通道上的各个触发器级联式传播下去。
12、IC设计中同步复位与 异步复位的区别。（南山之桥）
13、MOORE 与 MEELEY状态机的特征。（南山之桥）
14、多时域设计中,如何处理信号跨时域。（南山之桥）
15、给了reg的setup,hold时间，求中间组合逻辑的delay范围。（飞利浦－大唐笔试）Delay < period - setup – hold
16、时钟周期为T,触发器D1的建立时间最大为T1max，最小为T1min。组合逻辑电路最大延迟为T2max,最小为T2min。问，触发器D2的建立时间T3和保持时间应满足什么条件。（华为）
17、给出某个一般时序电路的图，有Tsetup,Tdelay,Tck->q,还有 clock的delay,写出决定最大时钟的因素，同时给出表达式。（威盛VIA 2003.11.06 上海笔试试题）
18、说说静态、动态时序模拟的优缺点。（威盛VIA 2003.11.06 上海笔试试题）
19、一个四级的Mux,其中第二级信号为关键信号如何改善timing。（威盛VIA2003.11.06 上海笔试试题）
20、给出一个门级的图，又给了各个门的传输延时，问关键路径是什么，还问给出输入，使得输出依赖于关键路径。（未知）
21、逻辑方面数字电路的卡诺图化简，时序（同步异步差异），触发器有几种（区别，优点），全加器等等。（未知）
22、卡诺图写出逻辑表达使。（威盛VIA 2003.11.06 上海笔试试题）
23、化简F(A,B,C,D)= m(1,3,4,5,10,11,12,13,14,15)的和。（威盛）
24、please show the CMOS inverter schmatic,layout and its cross sectionwith P-well process.Plot its transfer curve (Vout-Vin) And also explain the
operation region of PMOS and NMOS for each segment of the transfer curve? （威盛笔试题circuit design-beijing-03.11.09）
25、To design a CMOS invertor with balance rise and fall time,please definethe ration of channel width of PMOS and NMOS and explain?
26、为什么一个标准的倒相器中P管的宽长比要比N管的宽长比大？（仕兰微电子）
27、用mos管搭出一个二输入与非门。（扬智电子笔试）
28、please draw the transistor level schematic of a cmos 2 input AND gate andexplain which input has faster response for output rising edge.(less delay
time)。（威盛笔试题circuit design-beijing-03.11.09）
29、画出NOT,NAND,NOR的符号，真值表，还有transistor level的电路。（Infineon笔试）
30、画出CMOS的图，画出tow-to-one mux gate。（威盛VIA 2003.11.06 上海笔试试题）
31、用一个二选一mux和一个inv实现异或。（飞利浦－大唐笔试）
32、画出Y=A*B+C的cmos电路图。（科广试题）
33、用逻辑们和cmos电路实现ab+cd。（飞利浦－大唐笔试）
34、画出CMOS电路的晶体管级电路图，实现Y=A*B+C(D+E)。（仕兰微电子）
35、利用4选1实现F(x,y,z)=xz+yz'。（未知）
36、给一个表达式f=xxxx+xxxx+xxxxx+xxxx用最少数量的与非门实现（实际上就是化简）。
37、给出一个简单的由多个NOT,NAND,NOR组成的原理图，根据输入波形画出各点波形。（Infineon笔试）
38、为了实现逻辑（A XOR B）OR （C AND D），请选用以下逻辑中的一种，并说明为什么？1）INV 2）AND 3）OR 4）NAND 5）NOR 6）XOR 答案：NAND（未知）
39、用与非门等设计全加法器。（华为）
40、给出两个门电路让你分析异同。（华为）
41、用简单电路实现，当A为输入时，输出B波形为…（仕兰微电子）
42、A,B,C,D,E进行投票，多数服从少数，输出是F（也就是如果A,B,C,D,E中1的个数比0多，那么F输出为1，否则F为0），用与非门实现，输入数目没有限制。（未知）
43、用波形表示D触发器的功能。（扬智电子笔试）
44、用传输门和倒向器搭一个边沿触发器。（扬智电子笔试）
45、用逻辑们画出D触发器。（威盛VIA 2003.11.06 上海笔试试题）
46、画出DFF的结构图,用verilog实现之。（威盛）
47、画出一种CMOS的D锁存器的电路图和版图。（未知）
48、D触发器和D锁存器的区别。（新太硬件面试）
49、简述latch和filp-flop的异同。（未知）
50、LATCH和DFF的概念和区别。（未知）
51、latch与register的区别,为什么现在多用register.行为级描述中latch如何产生的。（南山之桥）
52、用D触发器做个二分颦的电路.又问什么是状态图。（华为）
53、请画出用D触发器实现2倍分频的逻辑电路？（汉王笔试）
54、怎样用D触发器、与或非门组成二分频电路？（东信笔试）
55、How many flip-flop circuits are needed to divide by 16? (Intel) 16分频？
56、用filp-flop和logic-gate设计一个1位加法器，输入carryin和current-stage，输出carryout和next-stage. （未知）
57、用D触发器做个4进制的计数。（华为）
58、实现N位Johnson Counter,N=5。（南山之桥）
59、用你熟悉的设计方式设计一个可预置初值的7进制循环计数器，15进制的呢？（仕兰微电子）
60、数字电路设计当然必问Verilog/VHDL，如设计计数器。（未知）
61、BLOCKING NONBLOCKING 赋值的区别。（南山之桥）
62、写异步D触发器的verilog module。（扬智电子笔试）
模拟电路
1基尔霍夫定理的内容是什么？（仕兰微电子） 
基尔霍夫电流定律是一个电荷守恒定律,即在一个电路中流入一个节点的电荷与流出同一个节点的电荷相等.基尔霍夫电压定律是一个能量守恒定律,即在一个回路中回路电压之和为零.
2、平板电容公式(C=εS/4πkd)。（未知） 
3、最基本的如三极管曲线特性。（未知） 
4、描述反馈电路的概念，列举他们的应用。（仕兰微电子） 
5、负反馈种类（电压并联反馈，电流串联反馈，电压串联反馈和电流并联反馈）；负反馈的优点（降低放大器的增益灵敏度，改变输入电阻和输出电阻，改善放大器的线性和非 线性失真，有效地扩展放大器的通频带，自动调节作用）（未知） 
6、放大电路的频率补偿的目的是什么，有哪些方法？（仕兰微电子） 
7、频率响应，如：怎么才算是稳定的，如何改变频响曲线的几个方法。（未知） 
8、给出一个查分运放，如何相位补偿，并画补偿后的波特图。（凹凸） 
9、基本放大电路种类（电压放大器，电流放大器，互导放大器和互阻放大器），优缺点，特别是广泛采用差分结构的原因。（未知） 
10、给出一差分电路，告诉其输出电压Y 和Y-,求共模分量和差模分量。（未知） 
11、画差放的两个输入管。（凹凸） 
12、画出由运放构成加法、减法、微分、积分运算的电路原理图。并画出一个晶体管级的运放电路。（仕兰微电子） 
13、用运算放大器组成一个10倍的放大器。（未知） 
14、给出一个简单电路，让你分析输出电压的特性（就是个积分电路），并求输出端某点的rise/fall时间。(Infineon笔试试题) 
15、电阻R和电容C串联，输入电压为R和C之间的电压，输出电压分别为C上电压和R上电压，要求制这两种电路输入电压的频谱，判断这两种电路何为高通滤波器，何为低通滤波器。当RC<q,还有 clock的delay,写出决定最大时钟的因素，同时给出表达式。（威盛VIA 2003.11.06 上海笔试试题） 
18、说说静态、动态时序模拟的优缺点。（威盛VIA 2003.11.06 上海笔试试题） 
19、一个四级的Mux,其中第二级信号为关键信号 如何改善timing。（威盛VIA2003.11.06上海笔试试题） 
20、给出一个门级的图，又给了各个门的传输延时，问关键路径是什么，还问给出输入，使得输出依赖于关键路径。（未知） 
21、逻辑方面数字电路的卡诺图化简，时序（同步异步差异），触发器有几种（区别，优点），全加器等等。（未知） 
22、卡诺图写出逻辑表达使。（威盛VIA 2003.11.06 上海笔试试题） 
23、化简F(A,B,C,D)= m(1,3,4,5,10,11,12,13,14,15)的和。（威盛） 
24、please show the CMOS inverter schmatic,layout and its cross sectionwith P-well process.Plot its transfer curve (Vout-Vin) And also explain the operationregion of PMOS and NMOS for each segment of the transfer curve? （威盛笔试题circuit design-beijing-03.11.09） 
25、To design a CMOS invertor with balance rise and fall time,please define the ration of channel of PMOS and NMOS and explain? 
26、为什么一个标准的倒相器中P管的宽长比要比N管的宽长比大？（仕兰微电子） 
27、用mos管搭出一个二输入与非门。（扬智电子笔试） 
28、please draw the transistor level schematic of a cmos 2 input AND gate and 
explain which input has faster res0824ponse for output rising edge.(less delay
time)。（威盛笔试题circuit design-beijing-03.11.09） 
29、画出NOT,NAND,NOR的符号，真值表，还有transistor level的电路。（Infineon笔试
） 
30、画出CMOS的图，画出tow-to-one mux gate。（威盛VIA 2003.11.06 上海笔试试题）

31、用一个二选一mux和一个inv实现异或。（飞利浦－大唐笔试） 
32、画出Y=A*B C的cmos电路图。（科广试题） 
33、用逻辑们和cmos电路实现ab cd。（飞利浦－大唐笔试） 
34、画出CMOS电路的晶体管级电路图，实现Y=A*B C(D E)。（仕兰微电子） 
35、利用4选1实现F(x,y,z)=xz yz’。（未知） 
36、给一个表达式f=xxxx xxxx xxxxx xxxx用最少数量的与非门实现（实际上就是化简）
。 
37、给出一个简单的由多个NOT,NAND,NOR组成的原理图，根据输入波形画出各点波形。（
Infineon笔试） 
38、为了实现逻辑（A XOR B）OR （C AND D），请选用以下逻辑中的一种，并说明为什么
？1）INV 2）AND 3）OR 4）NAND 5）NOR 6）XOR 答案：NAND（未知） 
39、用与非门等设计全加法器。（华为） 
40、给出两个门电路让你分析异同。（华为） 
41、用简单电路实现，当A为输入时，输出B波形为…（仕兰微电子） 
42、A,B,C,D,E进行投票，多数服从少数，输出是F（也就是如果A,B,C,D,E中1的个数比0 
多，那么F输出为1，否则F为0），用与非门实现，输入数目没有限制。（未知） 
43、用波形表示D触发器的功能。（扬智电子笔试） 
44、用传输门和倒向器搭一个边沿触发器。（扬智电子笔试） 
45、用逻辑们画出D触发器。（威盛VIA 2003.11.06 上海笔试试题） 
46、画出DFF的结构图,用verilog实现之。（威盛） 
47、画出一种CMOS的D锁存器的电路图和版图。（未知） 
48、D触发器和D锁存器的区别。（新太硬件面试） 
49、简述latch和filp-flop的异同。（未知） 
50、LATCH和DFF的概念和区别。（未知） 
51、latch与register的区别,为什么现在多用register.行为级描述中latch如何产生的。
（南山之桥） 
52、用D触发器做个二分颦的电路.又问什么是状态图。（华为） 
53、请画出用D触发器实现2倍分频的逻辑电路？（汉王笔试） 
54、怎样用D触发器、与或非门组成二分频电路？（东信笔试） 
55、How many flip-flop circuits are needed to divide by 16? (Intel) 16分频？
56、用filp-flop和logic-gate设计一个1位加法器，输入carryin和current-stage，输出
carryout和next-stage. （未知） 
57、用D触发器做个4进制的计数。（华为） 
58、实现N位Johnson Counter,N=5。（南山之桥） 
59、用你熟悉的设计方式设计一个可预置初值的7进制循环计数器，15进制的呢？（仕兰微
电子） 
60、数字电路设计当然必问Verilog/VHDL，如设计计数器。（未知） 
61、BLOCKING NONBLOCKING 赋值的区别。（南山之桥） 
62、写异步D触发器的verilog module。（扬智电子笔试） 
module dff8(clk , res0824et, d, q); 
input clk; 
input res0824et; 
input [7:0] d; 
output [7:0] q; 
reg [7:0] q; 
always @ (posedge clk or posedge res0824et) 
if(res0824et) 
q <= 0; 
else 
q <= d; 
endmodule 
63、用D触发器实现2倍分频的Verilog描述？ （汉王笔试） 
module divide2( clk , clk_o, res0824et); 
input clk , res0824et; 
output clk_o; 
wire in; 
reg out ; 
always @ ( posedge clk or posedge res0824et) 
if ( res0824et) 
out <= 0; 
else 
out <= in; 
assign in = ~out; 
assign clk_o = out; 
endmodule 
64、可编程逻辑器件在现代电子设计中越来越重要，请问：a) 你所知道的可编程逻辑器件有哪些？ b) 试用VHDL或VERILOG、ABLE描述8位D触发器逻辑。（汉王笔试） 
PAL，PLD，CPLD，FPGA。 
module dff8(clk , res0824et, d, q); 
input clk; 
input res0824et; 
input d; 
output q; 
reg q; 
always @ (posedge clk or posedge res0824et) 
if(res0824et) 
q <= 0; 
else 
q <= d; 
endmodule 
65、请用HDL描述四位的全加法器、5分频电路。（仕兰微电子） 
66、用VERILOG或VHDL写一段代码，实现10进制计数器。（未知） 
67、用VERILOG或VHDL写一段代码，实现消除一个glitch。（未知） 
68、一个状态机的题目用verilog实现（不过这个状态机画的实在比较差，很容易误解的）。（威盛VIA 2003.11.06 上海笔试试题） 
69、描述一个交通信号灯的设计。（仕兰微电子） 
70、画状态机，接受1，2，5分钱的卖报机，每份报纸5分钱。（扬智电子笔试） 
71、设计一个自动售货机系统，卖soda水的，只能投进三种硬币，要正确的找回钱数。（1）画出fsm（有限状态机）；（2）用verilog编程，语法要符合fpga设计的要求。（未知） 
72、设计一个自动饮料售卖机，饮料10分钱，硬币有5分和10分两种，并考虑找零：（1）画出fsm（有限状态机）；（2）用verilog编程，语法要符合fpga设计的要求；（3）设计工程中可使用的工具及设计大致过程。（未知） 
73、画出可以检测10010串的状态图,并verilog实现之。（威盛） 
74、用FSM实现101101的序列检测模块。（南山之桥） a为输入端，b为输出端，如果a连续输入为1101则b输出为1，否则为0。例如a： 0001100110110100100110 b： 0000000000100100000000 
请画出state machine；请用RTL描述其state machine。（未知） 
75、用verilog/vddl检测stream中的特定字符串（分状态用状态机写）。（飞利浦－大唐笔试） 
76、用verilog/vhdl写一个fifo控制器(包括空，满，半满信号)。（飞利浦－大唐笔试）

77、现有一用户需要一种集成电路产品，要求该产品能够实现如下功能：y=lnx，其中，x为4位二进制整数输入信号。y为二进制小数输出，要求保留两位小数。电源电压为3~5v假设公司接到该项目后，交由你来负责该产品的设计，试讨论该产品的设计全程。（仕兰微电子） 
78、sram，falsh memory，及dram的区别？（新太硬件面试） 
79、给出单管DRAM的原理图(西电版《数字电子技术基础》作者杨颂华、冯毛官205页图9 －14b)，问你有什么办法提高refres0824h time，总共有5个问题，记不起来了。（降低温度，增大电容存储容量）（Infineon笔试） 
80、Please draw schematic of a common SRAM cell with 6 transistors,point out which nodes can store data and which node is word line control? （威盛笔试题circuit design-beijing-03.11.09） 
81、名词:sram,ssram,sdram 名词IRQ,BIOS,USB,VHDL,SDR IRQ: Interrupt ReQuest     BIOS: Basic Input Output System   USB: Universal Serial Bus VHDL: VHIC Hardware Description Language    SDR: Single Data Rate 
压控振荡器的英文缩写(VCO)。动态随机存储器的英文缩写(DRAM)。 
名词解释，无聊的外文缩写罢了，比如PCI、ECC、DDR、interrupt、pipeline IRQ,BIOS,
USB,VHDL,VLSI VCO(压控振荡器) RAM (动态随机存储器)，FIR IIR DFT(离散傅立叶变换
)或者是中文的，比如：a.量化误差 b.直方图 c.白平衡
IC设计基础（流程、工艺、版图、器件）
1、我们公司的产品是集成电路，请描述一下你对集成电路的认识，列举一些与集成电路
相关的内容（如讲清楚模拟、数字、双极型、CMOS、MCU、RISC、CISC、DSP、ASIC、FPGA
等的概念）。（仕兰微面试题目）
2、FPGA和ASIC的概念，他们的区别。（未知）
答案：FPGA是可编程ASIC。
ASIC:专用集成电路，它是面向专门用途的电路，专门为一个用户设计和制造的。根据一
个用户的特定要求，能以低研制成本，短、交货周期供货的全定制，半定制集成电路。与
门阵列等其它ASIC(Application Specific IC)相比，它们又具有设计开发周期短、设计
制造成本低、开发工具先进、标准产品无需测试、质量稳定以及可实时在线检验等优点
3、什么叫做OTP片、掩膜片，两者的区别何在？（仕兰微面试题目）
4、你知道的集成电路设计的表达方式有哪几种？（仕兰微面试题目）
5、描述你对集成电路设计流程的认识。（仕兰微面试题目）
6、简述FPGA等可编程逻辑器件设计流程。（仕兰微面试题目）
7、IC设计前端到后端的流程和eda工具。（未知）
8、从RTL synthesis到tape out之间的设计flow,并列出其中各步使用的tool.（未知）
9、Asic的design flow。（威盛VIA 2003.11.06 上海笔试试题）
10、写出asic前期设计的流程和相应的工具。（威盛）
11、集成电路前段设计流程，写出相关的工具。（扬智电子笔试）
先介绍下IC开发流程：
1.）代码输入（design input)
用vhdl或者是verilog语言来完成器件的功能描述，生成hdl代码
语言输入工具：SUMMIT VISUALHDL
            MENTOR RENIOR
图形输入:    composer(cadence); 
            viewlogic (viewdraw)
2.）电路仿真（circuit simulation)
将vhd代码进行先前逻辑仿真，验证功能描述是否正确
数字电路仿真工具：
    Verolog： CADENCE    Verolig-XL
              SYNOPSYS    VCS
              MENTOR      Modle-sim
    VHDL :    CADENCE    NC-vhdl
              SYNOPSYS    VSS
              MENTOR      Modle-sim
模拟电路仿真工具：
              ***ANTI HSpice pspice，spectre micro microwave:    eesoft : hp
3.）逻辑综合（synthesis tools)
逻辑综合工具可以将设计思想vhd代码转化成对应一定工艺手段的门级电路；将初级仿真
中所没有考虑的门沿（gates delay）反标到生成的门级网表中,返回电路仿真阶段进行再
仿真。最终仿真结果生成的网表称为物理网表。
12、请简述一下设计后端的整个流程？（仕兰微面试题目）
13、是否接触过自动布局布线？请说出一两种工具软件。自动布局布线需要哪些基本元
素？（仕兰微面试题目）
14、描述你对集成电路工艺的认识。（仕兰微面试题目）
15、列举几种集成电路典型工艺。工艺上常提到0.25,0.18指的是什么？（仕兰微面试题
目）
16、请描述一下国内的工艺现状。（仕兰微面试题目）
17、半导体工艺中，掺杂有哪几种方式？（仕兰微面试题目）
18、描述CMOS电路中闩锁效应产生的过程及最后的结果？（仕兰微面试题目）
19、解释latch-up现象和Antenna effect和其预防措施.（未知）
20、什么叫Latchup?（科广试题）
21、什么叫窄沟效应? （科广试题）
22、什么是NMOS、PMOS、CMOS？什么是增强型、耗尽型？什么是PNP、NPN？他们有什么差
别？（仕兰微面试题目）
23、硅栅COMS工艺中N阱中做的是P管还是N管，N阱的阱电位的连接有什么要求？（仕兰微
面试题目）
24、画出CMOS晶体管的CROSS-OVER图（应该是纵剖面图），给出所有可能的传输特性和转
移特性。（Infineon笔试试题）
25、以interver为例,写出N阱CMOS的process流程,并画出剖面图。（科广试题）
26、Please explain how we describe the resistance in semiconductor. Compare 
the resistance of a metal,poly and diffusion in tranditional CMOS process.（威
盛笔试题circuit design-beijing-03.11.09）
27、说明mos一半工作在什么区。（凹凸的题目和面试）
28、画p-bulk 的nmos截面图。（凹凸的题目和面试）
29、写schematic note（？）， 越多越好。（凹凸的题目和面试）
30、寄生效应在ic设计中怎样加以克服和利用。（未知）
31、太底层的MOS管物理特性感觉一般不大会作为笔试面试题，因为全是微电子物理，公
式推导太罗索，除非面试出题的是个老学究。IC设计的话需要熟悉的软件: Cadence, 
Synopsys, Avant，UNIX当然也要大概会操作。
32、unix 命令cp -r, rm,uname。（扬智电子笔试）
单片机、MCU、计算机原理
1、简单描述一个单片机系统的主要组成模块，并说明各模块之间的数据流流向和控制流
流向。简述单片机应用系统的设计原则。（仕兰微面试题目）
2、画出8031与2716（2K*8ROM）的连线图，要求采用三-八译码器，8031的P2.5,P2.4和
P2.3参加译码，基本地址范围为3000H-3FFFH。该2716有没有重叠地址？根据是什么？若
有，则写出每片2716的重叠地址范围。（仕兰微面试题目）
3、用8051设计一个带一个8*16键盘加驱动八个数码管（共阳）的原理图。（仕兰微面试
题目）
4、PCI总线的含义是什么？PCI总线的主要特点是什么？ （仕兰微面试题目）
5、中断的概念？简述中断的过程。（仕兰微面试题目）
6、如单片机中断几个/类型，编中断程序注意什么问题；（未知）
7、要用一个开环脉冲调速系统来控制直流电动机的转速，程序由8051完成。简单原理如
下：由P3.4输出脉冲的占空比来控制转速，占空比越大，转速越快；而占空比由K7-K0八
个开关来设置，直接与P1口相连（开关拨到下方时为"0"，拨到上方时为"1"，组成一个八
位二进制数N），要求占空比为N/256。 （仕兰微面试题目）
　　 下面程序用计数法来实现这一功能，请将空余部分添完整。 
　　 MOV P1，#0FFH 
　　 LOOP1 ：MOV R4，#0FFH 
　　 -------- 
　　 MOV R3，#00H 
　　 LOOP2 ：MOV A，P1 
　　 -------- 
　　 SUBB A，R3 
　　 JNZ SKP1 
　　 -------- 
　　 SKP1：MOV C，70H 
　　 MOV P3.4，C 
　　 ACALL DELAY ：此延时子程序略 
　　 -------- 
　　 -------- 
　　 AJMP LOOP1 
8、单片机上电后没有运转，首先要检查什么？（东信笔试题）
9、What is PC Chipset? （扬智电子笔试）
芯片组（Chipset）是主板的核心组成部分，按照在主板上的排列位置的不同，通常分为
北桥芯片和南桥芯片。北桥芯片提供对CPU的类型和主频、内存的类型和最大容量、
ISA/PCI/AGP插槽、ECC纠错等支持。南桥芯片则提供对KBC（键盘控制器）、RTC（实时时
钟控制器）、USB（通用串行总线）、Ultra DMA/33(66)EIDE数据传输方式和ACPI（高级
能源管理）等的支持。其中北桥芯片起着主导性的作用，也称为主桥（Host Bridge）。
　　除了最通用的南北桥结构外，目前芯片组正向更高级的加速集线架构发展，Intel的
8xx系列芯片组就是这类芯片组的代表，它将一些子系统如IDE接口、音效、MODEM和USB直
接接入主芯片，能够提供比PCI总线宽一倍的带宽，达到了266MB/s。
10、如果简历上还说做过cpu之类，就会问到诸如cpu如何工作，流水线之类的问题。
（未知）
11、计算机的基本组成部分及其各自的作用。（东信笔试题）
12、请画出微机接口电路中，典型的输入设备与微机接口逻辑示意图（数据接口、控制接
口、所存器/缓冲器）。 （汉王笔试）
13、cache的主要部分什么的。（威盛VIA 2003.11.06 上海笔试试题）
14、同步异步传输的差异（未知）
15、串行通信与同步通信异同,特点,比较。（华为面试题）
16、RS232c高电平脉冲对应的TTL逻辑是?(负逻辑?) （华为面试题）
信号与系统
1、的话音频率一般为300~3400HZ，若对其采样且使信号不失真，其最小的采样频率应为
多大？若采用8KHZ的采样频率，并采用8bit的PCM编码，则存储一秒钟的信号数据量有多
大？（仕兰微面试题目）
2、什么耐奎斯特定律,怎么由模拟信号转为数字信号。（华为面试题）
3、如果模拟信号的带宽为 5khz,要用8K的采样率，怎么办？ (lucent) 两路？
4、信号与系统:在时域与频域关系。（华为面试题）
5、给出时域信号，求其直流分量。（未知）
6、给出一时域信号，要求（1）写出频率分量，（2）写出其傅立叶变换级数；（3）当波
形经过低通滤波器滤掉高次谐波而只保留一次谐波时，画出滤波后的输出波形。（未知）
7、sketch 连续正弦信号和连续矩形波(都有图)的傅立叶变换 。（Infineon笔试试题）
8、拉氏变换和傅立叶变换的表达式及联系。（新太硬件面题）
DSP、嵌入式、软件等
1、请用方框图描述一个你熟悉的实用数字信号处理系统，并做简要的分析；如果没有，
也可以自己设计一个简单的数字信号处理系统，并描述其功能及用途。（仕兰微面试题
目）
2、数字滤波器的分类和结构特点。（仕兰微面试题目）
3、IIR，FIR滤波器的异同。（新太硬件面题）
4、拉氏变换与Z变换公式等类似东西，随便翻翻书把如.h(n)=-a*h(n-1)+b*δ(n) a.求h
(n)的z变换；b.问该系统是否为稳定系统；c.写出FIR数字滤波器的差分方程；（未知）
5、DSP和通用处理器在结构上有什么不同，请简要画出你熟悉的一种DSP结构图。（信威
dsp软件面试题）
6、说说定点DSP和浮点DSP的定义（或者说出他们的区别）（信威dsp软件面试题）
7、说说你对循环寻址和位反序寻址的理解.（信威dsp软件面试题）
8、请写出【－8，7】的二进制补码，和二进制偏置码。用Q15表示出0.5和－0.5.（信威
dsp软件面试题）
9、DSP的结构（哈佛结构）；（未知）
10、嵌入式处理器类型(如ARM)，操作系统种类（Vxworks,ucos,winCE,linux），操作系
统方面偏CS方向了，在CS篇里面讲了；（未知）
11、有一个LDO芯片将用于对手机供电，需要你对他进行评估，你将如何设计你的测试项
目？
12、某程序在一个嵌入式系统（200M CPU，50M SDRAM）中已经最优化了，换到零一个系
统（300M CPU，50M SDRAM）中是否还需要优化？ （Intel） 
13、请简要描述HUFFMAN编码的基本原理及其基本的实现方法。（仕兰微面试题目）
14、说出OSI七层网络协议中的四层（任意四层）。（仕兰微面试题目）
15、A） （仕兰微面试题目）
　　＃i nclude 
　　void testf(int*p) 
　　{ 
　　*p+=1; 
　　} 
　　main() 
　　{ 
　　int *n,m[2]; 
　　n=m; 
　　m[0]=1; 
　　m[1]=8; 
　　testf(n); 
　　printf("Data value is %d ",*n); 
　　} 
　　------------------------------ 
　　B) 
　　＃i nclude 
　　void testf(int**p) 
　　{ 
　　*p+=1; 
　　} 
　　main() 
　　{int *n,m[2]; 
　　n=m; 
　　m[0]=1; 
　　m[1]=8; 
　　testf(&n); 
　　printf(Data value is %d",*n); 
　　} 
　　下面的结果是程序A还是程序B的？ 
　　Data value is 8 
　　那么另一段程序的结果是什么？ 
16、那种排序方法最快? （华为面试题）
17、写出两个排序算法,问哪个好？（威盛）
18、编一个简单的求n!的程序 。（Infineon笔试试题）
19、用一种编程语言写n!的算法。（威盛VIA 2003.11.06 上海笔试试题）
20、用C语言写一个递归算法求N！；（华为面试题） 
21、给一个C的函数，关于字符串和数组，找出错误；（华为面试题） 
22、防火墙是怎么实现的？ （华为面试题）
23、你对哪方面编程熟悉？（华为面试题）
24、冒泡排序的原理。（新太硬件面题）
25、操作系统的功能。（新太硬件面题）
26、学过的计算机语言及开发的系统。（新太硬件面题）
27、一个农夫发现围成正方形的围栏比长方形的节省4个木桩但是面积一样.羊的数目和正
方形围栏的桩子的个数一样但是小于36，问有多少羊？（威盛）
28、C语言实现统计某个cell在某.v文件调用的次数(这个题目真bt) （威盛VIA 
2003.11.06 上海笔试试题）
29、用C语言写一段控制手机中马达振子的驱动程序。(威胜)
30、用perl或TCL/Tk实现一段字符串识别和比较的程序。（未知）
31、给出一个堆栈的结构，求中断后显示结果，主要是考堆栈压入返回地址存放在低端地
址还是高端。（未知）
32、一些DOS命令，如显示文件，拷贝，删除。（未知）
33、设计一个类，使得该类任何形式的派生类无论怎么定义和实现，都无法产生任何对象
实例。（IBM）
34、What is pre-emption? (Intel)
35、What is the state of a process if a resource is not available? (Intel)
36、三个 float a,b,c;问值（a+b）+c==(b+a)+c， (a+b)+c==(a+c)+b。(Intel) 
37、把一个链表反向填空。 (lucent)
38、x^4+a*x^3+x^2+c*x+d 最少需要做几次乘法？ (Dephi)
____________________________________________________________________________

主观题
1、你认为你从事研发工作有哪些特点？（仕兰微面试题目）
2、说出你的最大弱点及改进方法。（威盛VIA 2003.11.06 上海笔试试题）
3、说出你的理想。说出你想达到的目标。 题目是英文出的，要用英文回答。（威盛VIA 
2003.11.06 上海笔试试题）
4、我们将研发人员分为若干研究方向，对协议和算法理解（主要应用在网络通信、图象
语音压缩方面）、电子系统方案的研究、用MCU、DSP编程实现电路功能、用ASIC设计技术
设计电路（包括MCU、DSP本身）、电路功能模块设计（包括模拟电路和数字电路）、集成
电路后端设计（主要是指综合及自动布局布线技术）、集成电路设计与工艺接口的研究。
你希望从事哪方面的研究？（可以选择多个方向。另外，已经从事过相关研发的人员可以
详细描述你的研发经历）。（仕兰微面试题目）
5、请谈谈对一个系统设计的总体思路。针对这个思路，你觉得应该具备哪些方面的知
识？（仕兰微面试题目）
6、设想你将设计完成一个电子电路方案。请简述用EDA软件（如PROTEL）进行设计（包括
原理图和PCB图）到调试出样机的整个过程。在各环节应注意哪些问题？电源的稳定，电
容的选取，以及布局的大小。（汉王笔试） 



共同的注意点 
1.一般情况下，面试官主要根据你的简历提问，所以一定要对自己负责，把简历上的东西搞明白； 
2.个别招聘针对性特别强，就招目前他们确的方向的人，这种情况下，就要投其所好，尽量介绍其所关心的东西。 
3.其实技术面试并不难，但是由于很多东西都忘掉了，才觉得有些难。所以最好在面试前把该看的书看看。 
4.虽然说技术面试是实力的较量与体现，但是不可否认，由于不用面试官/公司所专领域及爱好不同，也有面试也有很大的偶然性，需要冷静对待。不能因为被拒，就否认自己或责骂公司。 
5.面试时要take it easy，对越是自己钟情的公司越要这样。



扬智电子笔试（硬件）题目
http://file.yingjiesheng.net/list/company/semiconductor/ali/2007/04/07/3464.html

第一题：用mos管搭出一个二输入与非门。
第二题：集成电路前段设计流程，写出相关的工具。
第三题：名词IRQ,BIOS,USB,VHDL,SDR
第四题：unix 命令cp -r, rm,uname
第五题：用波形表示D触发器的功能
第六题：写异步D触发器的verilog module
第七题：What is PC Chipset?
第八题：用传输门和倒向器搭一个边沿触发器
第九题：画状态机，接受1，2，5分钱的卖报机，每份报纸5分钱


扬智DSP笔试题目
1.h(n)=-a*h(n-1)+b*δ(n)
a.求h(n)的z变换
b.问该系统是否为稳定系统
c.写出FIR数字滤波器的差分方程
2.写出下面模拟信号所需的最小采样带宽
a.模拟信号的频率范围是0－4khz
b.模拟信号的频率范围是2－4khz
3.名词解释
a.量化误差
b.直方图
c.白平衡
d.MMX
4.写出下面几种格式中用到的压缩技术
a.JPEG
b.MPEG2
c.MP3

扬智笔试题
1.什么是进程(Process)和线程(Thread),有何区别？
2.MFC和SDK有何区别？
3.IRP是什么，有何作用？
4.Windows2000操作系统下用户模式和内核模式下编程有何区别？
5.驱动程序的BUFFER能swap到磁盘上去吗？为什么？
6.试编写3个函数实现
a.建立一个双向链表
b.插入一个节点
c.删除一个节点
7.Hardware interrupt和software中断的区别，简述及应用
8.试编写一个函数计算一个字符串中A得个数。
9.画出其相应流程图并编写一个函数并实现一个整数到二进制数的转换
如输入6，输出110；
10
a.编写一个递归函数删除一个目录
b.编写一个非递归函数删除一个目录
比较其性能
附加题
简单叙述编程经历

笔试：c++，考的n基础，但是不是很好做 
1) c++中引用编译过的c代码为什么要用“extern c” 
2) 类与struct的区别 
3）数据库建表的sql语句，注意主键与外键是如何建立的 
4）文件的外排序，考虑到cpu,内存，硬盘空间等。 


扬智（科技）软件笔试题目
1. Queue is a useful structure
(a): What is a queue?
(b): Write 5 operations or functions, without details, that can be done
       on a queue.
2. Insert a sequence fo keys(24,49,13,20,59,23,90,35) into a data   
structure, which has no keys initially. Depict the data structure
after these insertions , if it is:
(a): a heap tree
(b): an AVL tree
3. (a) What is a synchronous I/O bus?
(b) What is an asnchronous I/O bus?
(c) Compare the advantages and disadvantages of synchronous and a
      synchronous I/O bus.
4. Explain the following terminology:
(a): Baud rate
(b): Handshaking
(c): Memory mapped I/O
5. Explain the key issues in supporting a real-time operation system 
for embedded system.
6. Explain the mapping of visual addresses to real addresses under paging

by
(a) direct mapping
(b) associative mapping
(c) combined direct/associated mapping
7. Please explain what is "write-back" and "write-through" ,and discuss the
advantage and disadvantage about these two methods.
8. Explain the concept and benefit of threads
9. What is hardware interrupt? What is software interrupt? What is 
exception? Please tell me all you know about interrupt.
10.Write a recursive function that tests wether a string is a palindrome. 
A palindrome is s string such as "abcba" or "otto" that reads the same in
both directions.If you can write this function recursively,you can write
an iterative version of this function instead.



1：一个函数如下
char *f()
{
char a[5]；
char b[5];
a[0]='a';
a[1]='b';
a[2]='c';
a[3]='d';
a[4]='e';
strcpy(b,a);
return b;
}
请问：一：该函数中用a作为一个字符串是否存在问题？
      二、该函数返回的b是否可用，为什么？
2：函数如下
void f()
{
char *a;
a=(char*)malloc(5);
strcpy(a,"abc");
a="cde";
free(a);
}
请问：该函数存在哪些问题？
Linux问题测试
3：从internet上得到一个Linux Kernel的软件包
linux-2.4-20.tz请写出将其编译安装的过程。
4：请问802.1d是什么协议的标准，它处在第几层？
5：在Linux编程中若一个用户程序希望将一组数据传递给
Kernel有几种方式？他们的优缺点是什么？
网络测试题目：
6：什么是基于状态的防火墙？ 54yjs.cn 应届生求职

7：什么是伪UDP头，它的作用是什么？
8：如图所示的网络拓扑：
PC1              GW                 PC2
------           ------------         ------
|    |           | |    | |         |    |
|    |<--------->| |    | |<------->|    |
------           ------------         ------
192.168.3.2 192.168.3.1 192.168.4.1   192.168.4.2 54yjs.cn 应届生就业 
请问如果欲使PC1顺利访问PC2，在PC1和PC2需要加入什么样
的路由，假设PC1和PC2采用的是Linux系统，请用命令的形式
写出这个路由的添加命令。

发表于 @ 2008年05月29日 13:10:00|评论(2 )|编辑
新一篇: 无法保存网页的解决办法！ | 旧一篇: DirectX 




评论
#tyrone3000 发表于2008-05-29 13:11:21  IP: 60.209.89.* 
模拟电路
1基尔霍夫定理的内容是什么？（仕兰微电子） 
基尔霍夫电流定律是一个电荷守恒定律,即在一个电路中流入一个节点的电荷与流出同一个
节点的电荷相等.
基尔霍夫电压定律是一个能量守恒定律,即在一个回路中回路电压之和为零.
2、平板电容公式(C=εS/4πkd)。（未知） 
3、最基本的如三极管曲线特性。（未知） 
4、描述反馈电路的概念，列举他们的应用。（仕兰微电子） 
5、负反馈种类（电压并联反馈，电流串联反馈，电压串联反馈和电流并联反馈）；负反馈
的优点（降低放大器的增益灵敏度，改变输入电阻和输出电阻，改善放大器的线性和非 线
性失真，有效地扩展放大器的通频带，自动调节作用）（未知） 
6、放大电路的频率补偿的目的是什么，有哪些方法？（仕兰微电子） 
7、频率响应，如：怎么才算是稳定的，如何改变频响曲线的几个方法。（未知） 
8、给出一个查分运放，如何相位补偿，并画补偿后的波特图。（凹凸） 
9、基本放大电路种类（电压放大器，电流放大器，互导放大器和互阻放大器），优缺点，
特别是广泛采用差分结构的原因。（未知） 
10、给出一差分电路，告诉其输出电压Y 和Y-,求共模分量和差模分量。（未知） 
11、画差放的两个输入管。（凹凸） 
12、画出由运放构成加法、减法、微分、积分运算的电路原理图。并画出一个晶体管级的
运放电路。（仕兰微电子） 
13、用运算放大器组成一个10倍的放大器。（未知） 
14、给出一个简单电路，让你分析输出电压的特性（就是个积分电路），并求输出端某点
的rise/fall时间。(Infineon笔试试题) 
15、电阻R和电容C串联，输入电压为R和C之间的电压，输出电压分别为C上电压和R上电压
，要求制这两种电路输入电压的频谱，判断这两种电路何为高通滤波器，何为低通滤波器
。当RC<q,还有 clock的delay,写出决定最大时钟的因素，同时给出表达式。（威盛VIA 2
003.11.06 上海笔试试题） 
18、说说静态、动态时序模拟的优缺点。（威盛VIA 2003.11.06 上海笔试试题） 
19、一个四级的Mux,其中第二级信号为关键信号 如何改善timing。（威盛VIA2003.11.06
上海笔试试题） 
20、给出一个门级的图，又给了各个门的传输延时，问关键路径是什么，还问给出输入，
使得输出依赖于关键路径。（未知） 
21、逻辑方面数字电路的卡诺图化简，时序（同步异步差异），触发器有几种（区别，优
点），全加器等等。（未知） 
22、卡诺图写出逻辑表达使。（威盛VIA 2003.11.06 上海笔试试题） 
23、化简F(A,B,C,D)= m(1,3,4,5,10,11,12,13,14,15)的和。（威盛） 
24、please show the CMOS inverter schmatic,layout and its cross sectionwith P-
well process.Plot its transfer curve (Vout-Vin) And also explain the operation



１）将一个字符串逆序 （可以运行，环境vc6.0）
　code：
#include<stdio.h>
#include<string.h>
#include <malloc.h>
void s_back(char * a )
{
 int i=0;
 char temp =0;
 char * ps;
 char * pe;
 if (a == NULL)
    return;
 ps = a;
 while (*a!=0)           
  a++;
 pe = a;
 for(i=0; i<(pe-ps)/2; i++){
 temp = *(ps+i);
 *(ps+i) = *(pe-i-1);
 *(pe-i-1) = temp;
 }
}

int main()
{
 char * a;
 a = (char *)malloc(100);
 if( a == NULL )
     printf( "Insufficient memory available\n" );
 else
  memcpy(a,"a123456789",11);
 printf("%s\n",a);
 s_back(a);
 printf("%s\n",a);
 free(a);
 return 0;
}
 
 
 
２）计算一个字节（byte）里有多少位（bit)被置1。
　１）code：
#include<stdio.h>
int b_check(char x)
{
 int i=0;
 int count=0;

 for(i=0;i<8;i++){
   if(1==((x>>i)&1))
   count++;
 }

 return count;
}

int main()
{
 int x=0xff;
 printf("%d\n",b_check(x));
 return 0;
}
3) 字符串复制
#include <stdio.h> 
#include <string.h>
char *__strcpy(char *strDest, const char *strSrc)
{
 char *tempptr = strDest ;
 
 if ( strDest == NULL || strSrc == NULL)
  return NULL ;
 if ( strlen(strDest) < strlen(strSrc) )
  return NULL ;
 if ( strDest == strSrc)
  return strDest ;
 while( (*strDest++ = *strSrc++) != '\0') ;
 
 return tempptr ;
}
int main(int argc ,char *argv)
{
 
 char src[] = "123456";
 char dst[] = "654321";
 if ( NULL == __strcpy(dst,src) ){
  printf ("__strcpy() error!\n") ;
  return 1; 
 }
 printf ("%s\n", dst) ;
 
 return 0 ;
}
1.用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
　　
　　#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
　　我在这想看到几件事情：
　　1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
　　2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
　　3). 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
　　4). 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。
　　
　　
2. 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。
#define MIN(A,B) ((A) <= (B)？(A) : (B))
　　这个测试是为下面的目的而设的：
　　1). 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
　　2). 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
　　3). 懂得在宏中小心地把参数用括号括起来
　　4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
　　least = MIN(*p++, b);
　　
3. 预处理器标识#error的目的是什么？
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种
　　问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。
　　
　　死循环（Infinite loops）
　　
　　4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
　　
　　这个问题用几个解决方案。我首选的方案是：
　　while(1) { }
　　一些程序员更喜欢如下方案：
　　for(;;) { }
　　这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的
　　基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。
　　第三个方案是用 goto
　　Loop:
　　...
　　goto Loop;
　　应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。
　　
　　数据声明（Data declarations）
　　
　　5. 用变量a给出下面的定义
　　a) 一个整型数（An integer）int a;
　　b) 一个指向整型数的指针（A pointer to an integer）int *a;
　　c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）int **a;
　　d) 一个有10个整型数的数组（An array of 10 integers）int a[10];
　　e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）int *a[10];
　　f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）int (*a)[10];
　　g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）int (*a)(int);
　　h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）int (*a[10])(int)
　　
　　答案是：
　　a) int a; // An integer
　　b) int *a; // A pointer to an integer
　　c) int **a; // A pointer to a pointer to an integer
　　d) int a[10]; // An array of 10 integers
　　e) int *a[10]; // An array of 10 pointers to integers
　　f) int (*a)[10]; // A pointer to an array of 10 integers
　　g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer
　　h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer
　　
　　
　　人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。
　　但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道
　　所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？
　　
　　
　　Static
　　
　　6. 关键字static的作用是什么？
　　
　　这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
　　1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
　　2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
　　3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
　　大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。
　　
　　
　　Const
　　
　　7．关键字const是什么含意？
　　我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？
　　
　　const int a;
　　int const a;
　　const int *a;
　　int * const a;
　　int const * a const;
　　
　　前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
　　1). 关键字const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
　　2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
　　3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。
　　
　　Volatile
　　
　　8. 关键字volatile有什么含意 并给出三个不同的例子。
　　
　　一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
　　1). 并行设备的硬件寄存器（如：状态寄存器）
　　2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
　　3). 多线程应用中被几个任务共享的变量
　　回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。
　　假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
　　1). 一个参数既可以是const还可以是volatile吗？解释为什么。
　　2). 一个指针可以是volatile 吗？解释为什么。
　　3). 下面的函数有什么错误：
　　int square(volatile int *ptr)
　　{
　　return *ptr * *ptr;
　　}
　　下面是答案：
　　1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
　　2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
　　3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
　　int square(volatile int *ptr)
　　{
　　int a,b;
　　a = *ptr;
　　b = *ptr;
　　return a * b;
　　}
　　由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
　　long square(volatile int *ptr)
　　{
　　int a;
　　a = *ptr;
　　return a * a;
　　}
　　
　　位操作（Bit manipulation）
　　
　　9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
　　
　　对这个问题有三种基本的反应
　　1). 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
　　2). 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式 来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
　　3). 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
　　#define BIT3 (0x1<<3)
　　static int a;
　　void set_bit3(void)
　　{
　　a |= BIT3;
　　}
　　void clear_bit3(void)
　　{
　　a &= ~BIT3;
　　}
　　一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。
　　
　　访问固定的内存位置（Accessing fixed memory locations）
　　
　　10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
　　
　　这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
　　int *ptr;
　　ptr = (int *)0x67a9;
　　*ptr = 0xaa55;
　　
　　一个较晦涩的方法是：
　　*(int * const)(0x67a9) = 0xaa55;
　　
　　即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。
　　
　　中断（Interrupts）
　　
　　11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
　　
　　__interrupt double compute_area (double radius)
　　{
　　 double area = PI * radius * radius;
　　 printf(" Area = %f", area);
　　 return area;
　　}
　　
　　这个函数有太多的错误了，以至让人不知从何说起了：
　　1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
　　2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
　　3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
　　4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。
　　
　　代码例子（Code examples）
　　12 . 下面的代码输出是什么，为什么？
　　
　　void foo(void)
　　{
　　 unsigned int a = 6;
　　 int b = -20;
　　 (a+b > 6) ?puts("> 6") : puts("<= 6");
　　}
　　
　　这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“>6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于 6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。
　　
　　13. 评价下面的代码片断：
　　
　　unsigned int zero = 0;
　　unsigned int compzero = 0xFFFF;
　　/*1's complement of zero */
　　
　　对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：
　　
　　unsigned int compzero = ~0;
　　
　　这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
　　到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧…
　　
　　
　　
　　动态内存分配（Dynamic memory allocation）
　　
　　
　　
　　14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
　　
　　这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？
　　
　　char *ptr;
　　if ((ptr = (char *)malloc(0)) == NULL)
　　puts("Got a null pointer");
　　else
　　puts("Got a valid pointer");
　　
　　这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是“Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。
　　
　　Typedef
　　
　　15. Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
　　#define dPS struct s *
　　typedef struct s * tPS;
　　
　　以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
　　这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：
　　dPS p1,p2;
　　tPS p3,p4;
　　
　　第一个扩展为
　　struct s * p1, p2;
　　
　　上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。
　　
　　晦涩的语法
　　
　　16. C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
　　int a = 5, b = 7, c;
　　c = a+++b;
　　
　　这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：
　　c = a++ + b;
　　因此, 这段代码持行后a = 6, b = 7, c = 12。
　　如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是:这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题



１）将一个字符串逆序 （可以运行，环境vc6.0）
　code：
#include<stdio.h>
#include<string.h>
#include <malloc.h>
void s_back(char * a )
{
 int i=0;
 char temp =0;
 char * ps;
 char * pe;
 if (a == NULL)
    return;
 ps = a;
 while (*a!=0)           
  a++;
 pe = a;
 for(i=0; i<(pe-ps)/2; i++){
 temp = *(ps+i);
 *(ps+i) = *(pe-i-1);
 *(pe-i-1) = temp;
 }
}

int main()
{
 char * a;
 a = (char *)malloc(100);
 if( a == NULL )
     printf( "Insufficient memory available\n" );
 else
  memcpy(a,"a123456789",11);
 printf("%s\n",a);
 s_back(a);
 printf("%s\n",a);
 free(a);
 return 0;
}
 
 
 
２）计算一个字节（byte）里有多少位（bit)被置1。
　１）code：
#include<stdio.h>
int b_check(char x)
{
 int i=0;
 int count=0;

 for(i=0;i<8;i++){
   if(1==((x>>i)&1))
   count++;
 }

 return count;
}

int main()
{
 int x=0xff;
 printf("%d\n",b_check(x));
 return 0;
}
3) 字符串复制
#include <stdio.h> 
#include <string.h>
char *__strcpy(char *strDest, const char *strSrc)
{
 char *tempptr = strDest ;
 
 if ( strDest == NULL || strSrc == NULL)
  return NULL ;
 if ( strlen(strDest) < strlen(strSrc) )
  return NULL ;
 if ( strDest == strSrc)
  return strDest ;
 while( (*strDest++ = *strSrc++) != '\0') ;
 
 return tempptr ;
}
int main(int argc ,char *argv)
{
 
 char src[] = "123456";
 char dst[] = "654321";
 if ( NULL == __strcpy(dst,src) ){
  printf ("__strcpy() error!\n") ;
  return 1; 
 }
 printf ("%s\n", dst) ;
 
 return 0 ;
}
1.用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
　　
　　#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
　　我在这想看到几件事情：
　　1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
　　2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
　　3). 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
　　4). 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。
　　
　　
2. 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。
#define MIN(A,B) ((A) <= (B)？(A) : (B))
　　这个测试是为下面的目的而设的：
　　1). 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
　　2). 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
　　3). 懂得在宏中小心地把参数用括号括起来
　　4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
　　least = MIN(*p++, b);
　　
3. 预处理器标识#error的目的是什么？
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种
　　问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。
　　
　　死循环（Infinite loops）
　　
　　4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
　　
　　这个问题用几个解决方案。我首选的方案是：
　　while(1) { }
　　一些程序员更喜欢如下方案：
　　for(;;) { }
　　这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的
　　基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。
　　第三个方案是用 goto
　　Loop:
　　...
　　goto Loop;
　　应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。
　　
　　数据声明（Data declarations）
　　
　　5. 用变量a给出下面的定义
　　a) 一个整型数（An integer）int a;
　　b) 一个指向整型数的指针（A pointer to an integer）int *a;
　　c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）int **a;
　　d) 一个有10个整型数的数组（An array of 10 integers）int a[10];
　　e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）int *a[10];
　　f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）int (*a)[10];
　　g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）int (*a)(int);
　　h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）int (*a[10])(int)
　　
　　答案是：
　　a) int a; // An integer
　　b) int *a; // A pointer to an integer
　　c) int **a; // A pointer to a pointer to an integer
　　d) int a[10]; // An array of 10 integers
　　e) int *a[10]; // An array of 10 pointers to integers
　　f) int (*a)[10]; // A pointer to an array of 10 integers
　　g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer
　　h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer
　　
　　
　　人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。
　　但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道
　　所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？
　　
　　
　　Static
　　
　　6. 关键字static的作用是什么？
　　
　　这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
　　1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
　　2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
　　3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
　　大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。
　　
　　
　　Const
　　
　　7．关键字const是什么含意？
　　我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？
　　
　　const int a;
　　int const a;
　　const int *a;
　　int * const a;
　　int const * a const;
　　
　　前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
　　1). 关键字const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
　　2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
　　3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。
　　
　　Volatile
　　
　　8. 关键字volatile有什么含意 并给出三个不同的例子。
　　
　　一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
　　1). 并行设备的硬件寄存器（如：状态寄存器）
　　2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
　　3). 多线程应用中被几个任务共享的变量
　　回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。
　　假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
　　1). 一个参数既可以是const还可以是volatile吗？解释为什么。
　　2). 一个指针可以是volatile 吗？解释为什么。
　　3). 下面的函数有什么错误：
　　int square(volatile int *ptr)
　　{
　　return *ptr * *ptr;
　　}
　　下面是答案：
　　1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
　　2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
　　3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
　　int square(volatile int *ptr)
　　{
　　int a,b;
　　a = *ptr;
　　b = *ptr;
　　return a * b;
　　}
　　由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
　　long square(volatile int *ptr)
　　{
　　int a;
　　a = *ptr;
　　return a * a;
　　}
　　
　　位操作（Bit manipulation）
　　
　　9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
　　
　　对这个问题有三种基本的反应
　　1). 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
　　2). 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式 来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
　　3). 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
　　#define BIT3 (0x1<<3)
　　static int a;
　　void set_bit3(void)
　　{
　　a |= BIT3;
　　}
　　void clear_bit3(void)
　　{
　　a &= ~BIT3;
　　}
　　一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。
　　
　　访问固定的内存位置（Accessing fixed memory locations）
　　
　　10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
　　
　　这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
　　int *ptr;
　　ptr = (int *)0x67a9;
　　*ptr = 0xaa55;
　　
　　一个较晦涩的方法是：
　　*(int * const)(0x67a9) = 0xaa55;
　　
　　即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。
　　
　　中断（Interrupts）
　　
　　11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
　　
　　__interrupt double compute_area (double radius)
　　{
　　 double area = PI * radius * radius;
　　 printf(" Area = %f", area);
　　 return area;
　　}
　　
　　这个函数有太多的错误了，以至让人不知从何说起了：
　　1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
　　2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
　　3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
　　4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。
　　
　　代码例子（Code examples）
　　12 . 下面的代码输出是什么，为什么？
　　
　　void foo(void)
　　{
　　 unsigned int a = 6;
　　 int b = -20;
　　 (a+b > 6) ?puts("> 6") : puts("<= 6");
　　}
　　
　　这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“>6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于 6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。
　　
　　13. 评价下面的代码片断：
　　
　　unsigned int zero = 0;
　　unsigned int compzero = 0xFFFF;
　　/*1's complement of zero */
　　
　　对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：
　　
　　unsigned int compzero = ~0;
　　
　　这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
　　到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧…
　　
　　
　　
　　动态内存分配（Dynamic memory allocation）
　　
　　
　　
　　14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
　　
　　这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？
　　
　　char *ptr;
　　if ((ptr = (char *)malloc(0)) == NULL)
　　puts("Got a null pointer");
　　else
　　puts("Got a valid pointer");
　　
　　这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是“Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。
　　
　　Typedef
　　
　　15. Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
　　#define dPS struct s *
　　typedef struct s * tPS;
　　
　　以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
　　这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：
　　dPS p1,p2;
　　tPS p3,p4;
　　
　　第一个扩展为
　　struct s * p1, p2;
　　
　　上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。
　　
　　晦涩的语法
　　
　　16. C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
　　int a = 5, b = 7, c;
　　c = a+++b;
　　
　　这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：
　　c = a++ + b;
　　因此, 这段代码持行后a = 6, b = 7, c = 12。
　　如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是:这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题



﻿收集的一些嵌入式软件工程师面试题目 


1、将一个字符串逆序 
2、将一个链表逆序 
3、计算一个字节里（byte）里面有多少bit被置1 
4、搜索给定的字节(byte) 
5、在一个字符串中找到可能的最长的子字符串 
6、字符串转换为整数 
7、整数转换为字符串 

linux 嵌入式面试 杂集一
2008年10月08日 星期三 11:24 A.M.
C语言测试是招聘嵌入式系统程序员过程中必须而且有效的方法。这些年，我既参加也组织了许多这种测试，在这过程中我意识到这些测试能为面试者和被面试者提供许多有用信息，此外，撇开面试的压力不谈，这种测试也是相当有趣的。
        从被面试者的角度来讲，你能了解许多关于出题者或监考者的情况。这个测试只是出题者为显示其对ANSI标准细节的知识而不是技术技巧而设计吗？这是个愚蠢的问题吗？如要你答出某个字符的ASCII值。这些问题着重考察你的系统调用和内存分配策略方面的能力吗？这标志着出题者也许花时间在微机上而不是在嵌入式系统上。如果上述任何问题的答案是"是"的话，那么我知道我得认真考虑我是否应该去做这份工作。
        从面试者的角度来讲，一个测试也许能从多方面揭示应试者的素质：最基本的，你能了解应试者C语言的水平。不管怎么样，看一下这人如何回答他不会的问题也是满有趣。应试者是以好的直觉做出明智的选择，还是只是瞎蒙呢？当应试者在某个问题上卡住时是找借口呢，还是表现出对问题的真正的好奇心，把这看成学习的机会呢？我发现这些信息与他们的测试成绩一样有用。
        有了这些想法，我决定出一些真正针对嵌入式系统的考题，希望这些令人头痛的考题能给正在找工作的人一点帮助。这些问题都是我这些年实际碰到的。其中有些题很难，但它们应该都能给你一点启迪。
        这个测试适于不同水平的应试者，大多数初级水平的应试者的成绩会很差，经验丰富的程序员应该有很好的成绩。为了让你能自己决定某些问题的偏好，每个问题没有分配分数，如果选择这些考题为你所用，请自行按你的意思分配分数。

预处理器（Preprocessor）

1 . 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
         #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情：
1) #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
2)懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
3) 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
4) 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。

2 . 写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。
        #define MIN(A,B) （（A） <= (B) ? (A) : (B)) 
这个测试是为下面的目的而设的：
1) 标识#define在宏中应用的基本知识。这是很重要的。因为在 嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
2)三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
3) 懂得在宏中小心地把参数用括号括起来
4) 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
        least = MIN(*p++, b);

3. 预处理器标识#error的目的是什么？
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。


死循环（Infinite loops）

4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
这个问题用几个解决方案。我首选的方案是：

while(1)
{

}

一些程序员更喜欢如下方案：

for(;;)
{

}

这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是："我被教着这样做，但从没有想到过为什么。"这会给我留下一个坏印象。

第三个方案是用 goto
Loop:
...
goto Loop;
应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。


数据声明（Data declarations） 

5. 用变量a给出下面的定义
a) 一个整型数（An integer） 
b)一个指向整型数的指针（ A pointer to an integer） 
c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r 
d)一个有10个整型数的数组（ An array of 10 integers） 
e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） 
f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） 
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） 
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）

答案是： 
a) int a; // An integer 
b) int *a; // A pointer to an integer 
c) int **a; // A pointer to a pointer to an integer 
d) int a[10]; // An array of 10 integers 
e) int *a[10]; // An array of 10 pointers to integers 
f) int (*a)[10]; // A pointer to an array of 10 integers 
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer 
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer 

人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？

Static 

6. 关键字static的作用是什么？
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所有函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。

大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。


Const 

7．关键字const有什么含意？
我只要一听到被面试者说："const意味着常数"，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着"只读"就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）
如果应试者能正确回答这个问题，我将问他一个附加的问题：
下面的声明都是什么意思？

const int a;
int const a;
const int *a;
int * const a;
int const * a const;

/******/
前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
1) 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
2) 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
3) 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。


Volatile 

8. 关键字volatile有什么含意?并给出三个不同的例子。
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
1) 并行设备的硬件寄存器（如：状态寄存器）
2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3) 多线程应用中被几个任务共享的变量（每一次被线程改变在内存的值都相应地改变）
#define mem1 *(volatile unsigned int*)(0x40020000)
把mem1定义为*(volatile unsigned int*)(0x40020000)
的同义语。
也就是以后访问mem1就相当于从32的无符号地址处0x40020000取数据。
而*(volatile unsigned int*)(0x40020000)
这个声明的意思是：把0x40020000这个十六进制转换成32位的无符号的指针，
之后解除这个指针的引用，也就是从0x40020000这个地址处读数据。
volatile unsigned int*
前面的关键字volatile表示这个地址处的值可能处在不断地变换之中，比如可能是os修改了该地址处的值，也可能是别的线程修改了该地址处的值。也就是说要求编译器不要对从该地址处读数据的代码进行优化。 
在C/C++中使用这些代码的时候一般是写底层的程序！

回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。
假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
1)一个参数既可以是const还可以是volatile吗？解释为什么。
2); 一个指针可以是volatile 吗？解释为什么。
3); 下面的函数有什么错误：

int square(volatile int *ptr)
{
        return *ptr * *ptr;
}

下面是答案：
1)是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
2); 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
3) 这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：

int square(volatile int *ptr) 
{
    int a,b;
    a = *ptr;
    b = *ptr;
    return a * b;
}

由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：

long square(volatile int *ptr) 
{
    int a;
    a = *ptr;
    return a * a;
}

位操作（Bit manipulation） 

9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
对这个问题有三种基本的反应
1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
2) 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
#define BIT3 (0x1 << 3)//增强移植性
static int a;

void set_bit3(void) 
{
    a |= BIT3;
}
void clear_bit3(void) 
{
    a &= ~BIT3;
}

一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。


访问固定的内存位置（Accessing fixed memory locations） 

10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
    int *ptr;
    ptr = (int *)0x67a9; 
    *ptr = 0xaa55;

A more obscure approach is: 
一个较晦涩的方法是：

    *(int * const)(0x67a9) = 0xaa55;

即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。

中断（Interrupts） 

11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。

__interrupt double compute_area (double radius) 
{
    double area = PI * radius * radius;
    printf("\nArea = %f", area);
    return area;
}

这个函数有太多的错误了，以至让人不知从何说起了：
1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
4) 与第三点一脉相承，printf()用到R0，当ISR的计算结果也会用到R0。经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用
__asm
	       { 
		MOV R0,x
		ADD y,R0,x/y //计算x/y 时R0 会被修改
	       }
       在计算x/y 时R0 会被修改,从而影响R0+x/y 的结果.用一个C 程序的变量代替
R0就可以解决这个问题:
		__asm
	      {
		MOV var,x
		ADD y,var,x/y
	      }
	内嵌汇编器探测到隐含的寄存器冲突就会报错
前景越来越光明了。.
代码例子（Code examples）

12 . 下面的代码输出是什么，为什么？

void foo(void)
{
    unsigned int a = 6;
    int b = -20;
    (a+b > 6) ? puts("> 6") : puts("<= 6");
}
这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 ">6"。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型(小范围转为大范围)。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。

13. 评价下面的代码片断：

unsigned int zero = 0;
unsigned int compzero = 0xFFFF; 
/*1's complement of zero */

对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：
unsigned int compzero = ~0;
这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧...
动态内存分配（Dynamic memory allocation） 

14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：
下面的代码片段的输出是什么，为什么？

char *ptr;
if ((ptr = (char *)malloc(0)) == NULL) 
    puts("Got a null pointer");
else
    puts("Got a valid pointer");

这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是"Got a valid pointer"。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。

Typedef 

15 Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：

#define dPS struct s *
typedef struct s * tPS;

以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：

dPS p1,p2;
tPS p3,p4;

第一个扩展为
struct s * p1, p2;//简单的代替
.上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。

晦涩的语法
16 . C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？

int a = 5, b = 7, c;
c = a+++b;

这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：

c = a++ + b;//和（a++）+b=13一样

因此, 这段代码持行后a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。


好了，伙计们，你现在已经做完所有的测试了。这就是我出的C语言测试题，我怀着愉快的心情写完它，希望你以同样的心情读完它。如果是认为这是一个好的测试，那么尽量都用到你的找工作的过程中去吧。天知道也许过个一两年，我就不做现在的工作，也需要找一个。
雇佣合适的人对于Fog Creek软件公司来说是非常关键的。在我们这个领域，有三类人可以挑选。在一个极端, 是哪些混进来的, 甚至缺乏最基本的工作技巧. 只要问这类人两三个简单的问题，再读一下他们的简历，就可以轻易地剔除他们。另一个极端的类型是 才华横溢的超级明星 这些人仅仅为了好玩就用汇编语言为Palm Pilot（一种手掌电脑）写了一个Lisp（一种人工智能编程语言）编译器。在这两种极端类型中间的是一大群不能确定水平的候选者，也许他们中的某些人能干些什么？这里的关键是明白超级明星和那一大堆属于中间类型的人的区别，因为Fog Creek软件公司只雇佣超级明星。下面我要介绍一些找出超级明星的技巧。
Fog Creek公司最重要的雇佣标准是:
有头脑, 并且
完成工作
就是这些了。符合这样标准的人就是我们公司需要的员工了。 记住这条标准。 每天上床前背诵这条标准。我们公司的目标之一就是雇佣拥有这样的潜质的人，而不是雇佣懂某些技术的人。任何人所拥有的某些具体技术都会在几年内过时，所以，雇佣有能力学习新技术的人，要比雇佣那些只在这一分钟知道SQL编程是怎么回事的人对公司更划算一点。
有头脑确实是一个很难定义的品质。但是让我们看一些在面试时能提问的一些问题，通过这些提问，我们可以找出拥有这种品质的人。完成工作非常关键。看起来有头脑但是不能完成工作的人经常拥有博士学位，在大公司工作过，但是在公司中没有人听他们的建议，因为他们是完全脱离实际的。比起准时交活儿，他们宁愿对于一些学院派的东西沉思。这些人由以下特性而可以识别出来。他们总是爱指出两个根本不同的概念间的相似性。例如，他们会说“Spreadsheets是一种特殊的编程语言”,然后花一个礼拜写一篇动人的，智慧的白皮书。这篇白皮书论述了，作为一个编程语言，spreadsheet关于计算语言特性的方方面面。聪明，但是没用。
现在，我们来谈谈完成工作但是没有头脑的人。他们爱做蠢事。从来也没有考虑过将来得靠他们自己或者别的什么人来亡羊补牢。通过制造新的工作，他们成为了公司的负债而不是资产。因为他们不仅没有为公司贡献价值，还浪费了好员工的时间。这些人通常到处粘贴大堆的代码，而不愿意写子程序。他们是完成了工作，但是不是以最聪明的方式完成工作。
面试时最重要的法则是:
做决定
在面试结束时，对于被面试者，你不得不做一个直截了当的决定。这个决定只有两个结果：雇佣或者不雇佣. 回到你的电脑前，立刻用电子邮件通知招聘负责人你的决定。电子邮件的主题应该是雇佣或者不雇佣。接着你需要在正文中写两段来支持你的决定.
没有其他的答案。永远不要说，“雇佣你，但是不能在我的团队中”。这是非常粗鲁的，因为你在暗示应试者没有聪明到能有和你一起工作的资格，但是以他的头脑适合进入那些天生输家队伍。如果你发觉自己被诱惑，想说出那句“雇佣你，但是不能在我的队伍中”，那么就简单的把这句话变成“不雇佣”再说出口。这样就没事了。甚至如果某个人在特定领域很能干，但是在别的队伍中将会表现不好，也是不雇佣。事物变化的如此之快，我们需要的是在任何地方都能成功的人。如果某些情况下你发现了一个白痴专家（拥有某些特殊能力的白痴），这个专家对于SQL非常，非常，非常的精通，但是除此之外什么也学不会，不雇佣。在Fog Creek公司他们没有将来。
永远不要说，“也许，我吃不准”。如果你吃不准，意味着不雇佣。看，比你想象的容易的多。吃不准？就说不！同样，如果你不能作出决定，那意味着不雇佣。不要说，”嗯，雇佣，我想是这样的。但是关于...，我想知道 ...”。这种情况就是不雇佣。
最重要的是记住这点，放弃一个可能的好人要比招进一个坏人强（译者按：中国有位哲人说过，宁可错杀一千，不可放过一个，呵呵）。一个不合格的求职者如果进入了公司，将要消耗公司大量的金钱和精力。其他优秀员工的还要浪费时间来修复这个人的错误。如果现在你还在犹豫，不雇佣。
如果你是Fog Creek公司的面试官，当你拒绝了大量的应聘者时，不要为Fog Creek公司将因此雇不到任何人了而忧虑。这不是你的问题。这是招聘负责人的问题。这是人力资源部的问题。这是Joel（译者注: Fog Creek公司的老板，本文作者）的问题。但不是你的问题。不停地问自己，哪种情况更糟糕？一种情况是我们变成了一个庞大的，糟糕的软件公司，充斥着许多脑袋空空如可可果壳的家伙，另一种情况是我们是一个小而高品质的公司。当然，找到优秀的应聘者（并聘用他们）是很重要的。找到有头脑而且完成工作的人是公司中的每个员工的日常工作之一。但是当你作为Joel Creek公司的一员真的开始面试一个应聘者时，要装作现在正有很多优秀的人想打破头挤进Fog Creek公司。总之，无论找到一个不错的应聘者是多么的难，永远不要降低你的标准。
但是你如何作出雇佣或者不雇佣这样艰难的决定？你只要在面试过程中不停地问自己：这个人有头脑吗？这个人能完成工作吗？要作出正确的回答，在面试时你必须问对问题。
开个玩笑，下面我要问个有史以来最差的面试问题: “Oracle 8i中的数据类型varchar和varchar2有什么区别”这是一个可怕的问题。掌握这种琐碎的技术细节和Fog Creek公司想雇佣你之间没有任何联系。谁会去记这种东西？如果有在线帮助，你可以在15秒内找到答案。
实际上，还有更差的问题，等会儿我会谈到的。
现在我们要谈到有趣的部分了：面试时提哪些问题。我的面试问题清单来自于我去微软公司找第一份工作的经历。这里实际上有几百个微软面试问题。每个人都有偏爱的问题。你也可以发展一套自己的面试问题以及面试的个人风格，这样你就可以比较容易地作出雇佣/不雇佣的决定。以下是我成功使用过的一些面试技巧，
在面试前，我读一遍应试者的简历，然后在一张纸片上随便写以下我的面试计划。这个计划实际上就是我要问的问题清单。以下是一个例子（用来面试程序员的）：
1. 介绍 
2. 应试者参加过的项目 
3. 无法回答的问题 
4. C语言函数 
5. 你满意吗？ 
6. 设计问题 
7. 挑战 
8. 你还有什么问题？ 
在面试前，我非常，非常当心，避免自己先入为主。如果在面试前你就已经想当然地认为，一个麻省理工的博士一定是一个有头脑的人。那么在接下来的一小时的面试时间内，无论那个麻省理工的博士说什么都不能改变你的最初印象。如果在面试前你就认为这个应试者是个傻瓜，那么他面试时说什么也无济于事。面试就象一个非常精巧的天平。一小时的面试结束后就要对一个人下结论是不容易的（但是你又必须在面试结束后得出结论）。一些不起眼的细节可能会影响最后的结论。如果你在面试开始前对于应试者有了一点了解的话，就好比天平的某一端加上了重重的砝码。这样面试本身就会变得没有用处了。以前有一次在面试前，一个招聘负责人跑进我的房间说，“你肯定会爱上这个家伙的!" 对一个男孩? 天哪，这简直让我发疯。我本来应该说，“嗯，如果你这么确定我会喜欢他，为什么你不干脆雇佣他,何必让我浪费时间来面试？”但是那时我还太年轻幼稚, 所以还是面试了那个人。当这个家伙开始说一些蠢话时，我对自己说，“哇塞，这应该是个例外情况，也许是大智若愚。”我开始带着玫瑰色眼镜看他了。于是我以说“雇佣”结束了面试，虽然他是一个糟糕的面试者。接下来发生了什么事？除了我，其他的面试官都说，不要雇佣这个人。教训是，不要听别的人的话，在面试应试者前不要四处打探这个面试者的情况。最重要的是不要和别的面考官谈论应试者，除非你们都已经作出了独立的判断。这才是科学的做法。
作为面试步骤的第一步，介绍的目的是让应试者放轻松。我通常花30秒钟，讲一下我是谁，接下来面试会如何进行。我总是使得应试者确信，我们关心的是他（她）如何解决问题的，而不是他（她）的最终答案是对还是错。顺便说一下，面试时，你不要和应试者隔着一个桌子坐着，否则在你和面试者之间就有了一个障碍，并且暗示着一种比较正式严肃的气氛，这样应试者就很难放松了。更好的办法是把桌子靠墙放着，或者和应试者坐在桌子的同一边，这样有助于应试者放松。只有应试者不会因为紧张而表现失常，你才能更有效的进行面试.
第二步的内容就是问应试者最近做了些什么项目。对刚毕业的学生, 如果有论文就问问论文, 没有的话, 就问问他们做过什么很喜欢的大作业.例如，有时候我会问一下，“你最喜欢上学期哪门课程？不一定要和计算机相关的。”事实上，如果应试者回答的课程和计算机没有关系，我会比较高兴。有时候你会发现这个计算机系应届生选择了尽可能少的计算机相关课程，但是却选修了很多和音乐相关的课程。但是他（她）却说最喜欢的课程是《面向对象数据库》。哼哼，不错啊. 不过如果你直接承认你喜欢音乐胜于计算机, 而不是在这儿胡说八道的话, 我会更高兴一点。
当面试有工作经验的人时，你可以让他们谈一下前一份工作。
我问这个问题的目的是在寻找一样品质：热情。在应试者谈到他（她）最近做过的项目时，你观察到以下迹象都是不错的：
谈到他们做过的项目时变得热情洋溢；他们的语速更快，语言更生动活泼。这说明他们对某些东西有兴趣，有热情（因为现实中有许多人对所做的项目根本漠不关心呢）。即使他们激动地表达对做过的项目的负面感情，这也是一个好的信号。“我曾经为上一个老板安装Foo Bar Mark II，但他是个傻瓜！”表现出热情的人就是我们要雇佣的人。差的应试者对工作根本就不关心，所以根本不会激动。一个非常好的信号是当应试者很激动地谈论上一份工作，以至于暂时忘记了他们正在被面试。有时候应试者刚开始面试时表现的很紧张 -- 这是很正常的现象，所以我通常忽略不计。但是当他们谈到单色计算艺术（Computational Monochromatic Art）时，这个家伙变得极端兴奋, 一点都不紧张了。不错，我喜欢这样的应试者，因为他们关心他们做的事。（什么是单色计算艺术？拔掉你的电脑显示器的电源就可以看到了） 
能认真地去解释事情。某些人被我拒掉的原因就是他们不会用普通人能明白的语言去解释他们做过的项目。很多工科专业的人总是以为所有人都知道Bates理论（译者注: Bates Theorem，一种经济学的理论）或者Peano公理组（译者注: Peano's Axioms，数论中的一些定理）是什么。如果应试者开始满口行话了，让他们停一停，然后你说，“能帮我个忙吗？就是为了练习一下，你能把刚才说的用我老祖母也能理解的话说一遍吗？”但即便如此, 有些人还是继续用那些术语, 而且根本没法让人明白他们在说什么。天哪！ 
如果这个项目是一个团队项目，看看他们是否在有承担领导责任的迹象？一个应试者可能会说：“我们用的是X方法，但是老板说应该是Y，而客户说应该是Z。”我会问，“那么你怎么做的？”一个好的回答可能是“我设法和团队中别的人开了个会，然后一起搞出个办法...”坏的回答看起来象，“嗯，我什么也不能做。这样的问题我解决不了。”记住，聪明并且能完成工作。要搞清楚某人是否能完成工作的一个办法就是看看他（她）过去是否倾向于完成任务。事实上，你可以主动要求他们给你个例子证明他们能担任领导作用，完成任务。－例如克服公司的陈规陋习。 
现在我们谈谈清单上的第三款，无法回答的问题。这很有趣。这个主意的关键在于问一些不可能有答案的问题，就是想看一下应试者怎么办。“西雅图有多少眼科医生？”“华盛顿纪念碑有多重？”“洛杉机有多少加油站？”“纽约有多少钢琴调音师？”
聪明的应试者猜到你不是要测验他们的专业知识，他们会积极地给出一个估计。“嗯，洛杉机的人口是七百万；每个人平均拥有2.5辆轿车...”当然如果他们的估计完全错误了也没有关系。重要的是他们能积极地试着回答问题。他们可能会试着搞清楚每个加油站的储量。“嗯，需要四分钟给一个储油罐加满油，一个加油站有十个油泵每天运行十八个小时...”他们也可能试着从占地面积来估计。有时, 他们的想法的创造力让你吃惊. 而有时, 他们直接要一个LA的黄页去查。这都是好迹象。 
不聪明的应试者则被难住了。他们目瞪口呆地望着你，好像你来自火星。你不得不提示：“嗯，如果你想建立一个象洛杉机那么大的城市，你需要建立多少个加油站？”你还可以提示他们：“加满一个储油罐要多长时间？”不过，这些榆木疙瘩脑袋还是只会坐在那里发呆，你得拖着他们往前走才行。这类人不会解决问题，我们可不要这样的人。 
关于编程问题，我通常要求应试者用C语言写一些小函数。以下是我通常会出的题目：
1. 将一个字符串逆序 
2. 将一个链表（linked list）逆序 
3. 计算一个字节（byte）里有多少bit被置1 
4. 搜索给定的字节（byte） 
5. 在一个字符串中找到可能的最长的子字符串，该字符串是由同一字符组成的 
6. 字符串转换成整数 
7. 整数转换成字符串（这个问题很不错，因为应试者要用到堆栈或者strev函数） 
注意，通常你不会希望他们写的代码多于5行，因为你没有时间理解太长的代码。
现在我们来详细看一看其中几个问题: 第一个问题: 逆序一个字符串。我这辈子还没有见过那个面试者能把这题目一次做对。所有的应试者都试图动态生成缓冲区，然后将逆序的字符串输出到该缓冲区中。问题的关键在于，谁负责分配这个缓冲区？谁又负责释放那个缓冲区？通过这个问题，我发现了一个有趣的事实，就是大多数认为自己懂C的人实际上不理解指针和内存的概念。他们就是不明白。这真叫人吃惊，无法想象这种人也能做程序员。但他们真的就是！这个问题可以从多个角度判断应试者：
他们的函数运行快吗？看一下他们多少此调用了strlen函数。我曾经看到应试者写的strrev的算法竟然只有O(n^2) 的效率，而标准的算法效率应该是O(n)，效率如此底下的原因是因为他们在循环中一次又一次调用strlen函数。 
他们使用指针运算吗（译者按：原文为pointer arithmetic，指的是加减指针变量的值）？使用指针运算是个好现象。许多所谓的“C程序员”竟然不知道如何使用指针运算（pointer arithmetic）。当然，我在前文说过我不会因为应试者不掌握一种特定的技巧而拒绝他。但是，理解C语言中的指针不是一种技巧，而是一种与生俱来的才能。每年一所大学要招进200多个计算机系的新生，所有这些小孩子4岁就开始用BASIC语言在Atari 800s写冒险游戏了。在大学里他们还学Pascal语言，学得也很棒。直到有一天他们的教授讲了指针的概念，突然，他们开始搞不懂了。他们就是不能再理解C语言中的任何东西了。于是90%的计算机系学生转系去学政治学。为了挽回面子，他们告诉朋友，他们之所以转系是因为他们计算机系英俊貌美的异性太少。许多人注定脑子里就没有理解指针的那根弦。所以说理解指针是一种与生俱来的品质，而不是一种单纯的技巧。理解指针需要脑子转好几个弯，某些人天生不擅长转这几个弯。 
第三个问题可以考考面试者对C的位运算的掌握，但这是一种技巧，不是一种品质，所以你可以帮助他们。有趣的等他们建立了一个子函数用来计算byte中为1的位的数目，然后你要求他们优化这个子函数，尽量加快这个函数的运行速度。聪明的应试者会使用查表算法（毕竟这个表只有 256个元素，用不了多少内存），整个表只需要建立一次。跟聪明的应试者讨论一下提高时间／空间效率的不同策略是十分有意思的事情. 进一步告诉他们你不想在程序启动时初始化查询表。聪明的面试者可能会建议使用缓冲机制，对于一个特定的byte，只有在第一次被查询时进行计算，然后计算结果会被放入查询表。这样以后再被查询时直接查表就行了。而特别特别聪明的面试这会尝试有没有建立查询表的捷径，如一个byte和它的置1的bit数之间有没有规律可循？
当你观察应试者写C代码时，以下一些技巧会对你有帮助：
事先向应试者说明，你完全理解，没有一个好的编辑器光在纸上写代码是困难的，所以你不在乎他们手写的代码是否看上去不整洁。你也完全明白没有好的编译器和调试器，很难第一次就写出完全没有bug的程序，所以请他们不必为此担心。 
好程序员的标志：好程序员写完“{”符号后，通常立刻跟上“}”符号，然后再在当中填上代码。他们也倾向于使用命名规则，虽然这个规则可能很原始。如果一个变量用作循环语句的索引，好程序员通常使用尽可能少的字符为它命名。如果他们的循环语句的索引变量的名字是CurrentPagePositionLoopCounter，显而易见他们写代码的经验还不够多。偶尔，你会看到一个C程序员写下象if (0==strlen(x))一样的代码，常量被放在==的左边。这是非常好的现象。这说明他因为总是把＝和＝＝搞混，已经强迫自己养成这种习惯以避免犯错。 
好的程序员在写代码前会订一个计划，特别是当他们的代码用到了指针时。例如，如果你要求逆序一个链表，好程序员通常会在纸的一边画上链表的草图，并表明算法中的索引指针当前移动到的位置。他们不得不这样做。正常人是不可能不借助草图就开始写一个逆序链表的程序的。差的程序员立刻开始写代码。 
不可避免的，你会在他们的程序中发现bug，于是我们现在来到了第五个问题：你对代码满意吗？ 你可能想问，“好吧，bug在哪里？”这是来自地狱的一针见血的问题，要回答这个问题可要大费口舌。所有的程序员都会犯错误，这不是问题。但他们必须能找到错误。对于字符串操作的函数，他们通常会忘记在输出缓冲区加上字符串结束符。所有的函数，他们都会犯off-by-one错误（译者按：指的是某个变量的最大值和最小值可能会和正常值差1)。他们会忘掉正常的C语句结尾的分号。如果输入是零长度字符串，他们的函数会运行错误。如果malloc调用失败而他们没有为此写好错误处理代码，程序会崩溃。一次就能把所有事情做对的程序员非常,非常,非常地少.不过要是真的碰上一个的话, 提问就更有意思了. 你说,"还有Bug"。他们会再仔细地检查一遍代码。这个时候, 观察一下他们内心是否开始动摇了, 只是表面上勉强坚持说代码没有问题。总之，在程序员写完代码后，问一下他们是否对代码满意是个好主意。就像Regis那样问他们！（译者按，Regis Philbin是美国ABC电视网的游戏电视节目主持人，他的口头禅是“这是你的最后的答案吗？”）
第六部分：关于设计的问题。让应试者设计某样东西。Jabe Blumenthal，Excel的原始设计者，喜欢让应试者设计房子。Jabe说，曾经有一个应试者跑到白板前，画了一个方块，这就是他的全部设计。天哪，一个方块！立刻拒绝这样的家伙。你喜欢问什么样的设计问题？
好的程序员会问更多的信息。房子为谁造的？我们公司的政策是，我们不会雇佣那些在设计前不问为谁设计的人。通常，我会很烦恼我得打断他们的设计，说“事实上，你忘记问这个房子是给谁设计的了。这个房子是给一群长颈鹿造的。” 
笨笨的应试者认为设计就像画画，你想画什么就画什么。聪明的应试者明白设计的过程是一系列艰难的权衡。一个很棒的设计问题是：设计一个放在街角的垃圾箱。想一想你得做多少权衡！垃圾箱必须易于清空，但是很难被偷走；易于放进垃圾，但是碰到狂风大作，里面的垃圾不会被吹出来；垃圾箱必须坚固而便宜。在某些城市，垃圾箱必须特别设计，以防恐怖分子在里面藏一个定时炸弹。 
有创造力的应试者会给出有趣而独特的设计。我最喜欢的问题之一是为盲人设计一个放调味品的架子（译者按：原文为spice rack，老外的厨房里有个专门放调味品的架子,上面放了很多小罐罐，里面装了各种各样的调料）通常许多应试者的建议是把布莱叶文（一种盲人使用的文字）刻在放调料的罐子上，这样文字会卷起来而变形。我碰到一个应试者，他的设计是把调料放在抽屉里，因为他觉得水平地感知布莱叶文比垂直地做更方便。（试试看！）这个答案这样有创意，使我震惊！我面试了有一打得程序员，从来没有人想到过类似的答案。这样有创意的答案确实跃过了普通人考虑问题的条条框框。仅仅因为这个答案太有创意了，而且应试者别的方面还过得去，我雇佣了这个应试者，他现在已经成为Excel团队中一个优秀的项目经理了（译者按，本文作者曾在微软工作过）。 
总是争取一个确定的了结。这也是完成工作的特质的一部分。有时候应试者会犹犹豫豫不能作出一个决定,试图回避困难的问题，留着困难的问题不作决定就直接向下进行,这很不好。好的应试者有一种推动事情自然地前进的倾向，即使你有意把他们拖回来。如果关于某个话题的讨论开始原地打转变得没有意义了，好的应试者会说，“嗯，我们可以整天谈论这个，但是我们得做点什么。为什么我们不开始...” 
于是我们来到了第七部分，挑战。这部分很好玩。在面试中留心一下, 当面试者的回答绝对的百分之百毫无争议时, 你可以说: " 嗯, 等一下等一下." 然后花上两分钟玩一下魔鬼的游戏（译者按，原文为devil's advocate，魔鬼代言人指的是违背自己的良知，为错误邪恶的观点辩护）. 记住一定要在你可以肯定他正确时和他争论。
这个很有意思.
软弱的应试者会屈服。那我就和他说拜拜了。 
坚定的应试者会找到一个办法说服你。他们会以肯尼迪总统的口才来说服你，“也许我误会了你的意思，”他们这样开头，但是正文仍是坚定地站稳立场。这样的人我就雇佣。 
不得不承认，面试双方的地位并不是平等的。有可能应试者由于害怕你的权力而不敢于你争辩。但是，好的应试者有足够的热情和勇气坚持正确的观点，他们由于热切希望说服你而会暂时忘记正在被面试。这样的人就是我们要雇佣的人。
最后，可以问一下应试者有什么想问的。一些人喜欢看看应试者这时是否会问一些聪明的问题。这是市面上流行的面试书籍的标准技巧。我个人不在乎应试者问什么，因为这时我已经做了决定。麻烦在于，应试者也许已经见了5、6个人，进行了好几轮面试，他们可能很累了，以至于不能为每轮面试都准备一个聪明而独特的问题。所以如果他们没有可问的，没关系。
我总是留下面试的最后5分钟来推销我的公司。这很重要。即使我不打算雇佣眼前这个应试者。如果你幸运的找到一个很棒的应试者，你当然愿意做任何事情说服他（她）来你的公司。即使他们不是好的应试者，你也要尽力让他们为Fog Creek公司激动，这样面试结束时他们会对Fog Creek公司留下一个很好的印象。记住，应试者并不仅仅是可能的雇员，他们也是顾客，也是我们公司的推销员。如果他们觉得我们的公司很棒，他们也许会推荐朋友来面试。
啊哈，我记得我说过我会给出一些应该避免的非常不好的反面的试题例子。
首先，避免不合法的问题。有关种族，宗教，性别，出生国，年龄，服役记录，是否老兵，性取向，生理障碍的问题都是不合法的。即使他们的简历说他们1990年在军中服役，也不要问有关问题。也许这会让他们愉快地谈论在海湾战争中的经历。但是你的问题还是不合法的。如果简历上写着他们上过Technion in Haifa, 不要问他们是否是以色列人, 即使只是为了闲谈, 因为这是违法的. 下面有一个很好的不合法的例子。点击这里有很多关于什么是违法的讨论。（但是这个网站的其余问题够愚蠢的。）
其次，不要在问题中给予应试者暗示，我们公司喜欢或者不喜欢什么样的员工。我能想到的一个例子是问应试者是否有小孩或者是否结婚了。应试者也许会想我们不喜欢有家庭拖累的员工。
最后，不要问那些脑筋急转弯的题目，例如6根火柴怎么拼出4个三角形。象这样的灵机一动的问题是不能看出应试者是否有“有头脑/完成工作”的品质。
面试与其说是科学不如说是艺术。但是只要你记住有头脑/完成工作这个原则，你就可以应对自如。有机会就问问你的同事他们喜欢的面试问题和答案。这是我们公司员工午饭时热衷的话题之一。
linux 嵌入式面试 杂集二
2008年10月08日 星期三 11:28 A.M.
1、将一个字符串逆序 
2、将一个链表逆序 
3、计算一个字节里（byte）里面有多少bit被置1 
4、搜索给定的字节(byte) 
5、在一个字符串中找到可能的最长的子字符串 
6、字符串转换为整数 
7、整数转换为字符串
一．ANSI C/C++方面的知识 
1、简答题。
1、 如何在C中初始化一个字符数组。
逐个字符赋值：char s[] = {‘A’,’B’,’C’,’D’};
字符串赋值：char s[] = {“ABCD”};
对于二维字符数组：char s[2][10] = {“cheng”,”jinzhou”};

2、 如何在C中为一个数组分配空间。
如果是栈的形式，Type s[N]定义后系统自动分配空间，分配的空间大小受操作系统限制；
若是堆的形式，Type *s; s = (Type *)malloc(sizeof(Type) * N); 分配的空间大小不受操作系统限制。

3、 如何初始化一个指针数组。
这里有必要重新对比一下指针数组与数组指针的差异。
a. 指针数组：数组里存储的是指针。
如：int * s[ 5 ] 表示数组s里存储了5个指向整型的指针。
          Char * s[ 3 ] = {“aaaaa”,”bbb”,”ccccc”} 表示数组s里存储3个指向字符型的指针，分别指向字符串aaaaa、bbb、ccccc。
b. 数组指针：其实就是数组，里面存放的是数据。
如：int ( * s )[ 5 ] 表示数组s里存储了5个整型数据。

4、 如何定义一个有10个元素的整数型指针数组。
Int * s [ 10 ];

5、 s[10]的另外一种表达方式是什么。
* ( s + 10 )
二维数组S [ 5 ][ 8 ]的表示方法：*( *(s + 5) + 8 )

7、 要使用CHAR_BIT需要包含哪个头文件。
Include limits.h
在该头文件里 #define CHAR_BIT 8

8、 对(-1.2345)取整是多少？   －1

9、 如何让局部变量具有全局生命期。
使用Static，局部变量就存储在全局区（静态区），便具有全局的生命期和局部的访问控制。

10、C中的常量字符串应在何时定义？
没有理解到题目的意思，我只是想说明一点，定义常量字符串后它属于const型，不能去修改它，否则程序出错。

11
、如何在两个.c文件中引用对方的变量。
使用extern 

12、使用malloc之前需要做什么准备工作。
定义一个指针后就可以malloc了。

13、realloc函数在使用上要注意什么问题。
Realloc后返回的指针与之前malloc返回的指针指向的地址不同。

14、strtok函数在使用上要注意什么问题。
首次调用时，s必须指向要分解的字符串，随后调用要把s设成NULL

15、gets函数在使用上要注意什么问题。
这里要将Scanf( )、gets( )放在一起比较。Scanf( )是遇到空格就判断为输入结束，而gets( )则遇到回车才判断为输入结束。

16、C语言的词法分析在长度规则方面采用的是什么策略？
尚不清楚，望博友能告知，万分感谢！

17、a+++++b所表示的是什么意思？有什么问题？
根据自增运算符的右结合性，它是(a++)+(++b)的意思，但有的编译器里省略括号就不能通过，同时也降低了程序可读性。

18、如何定义Bool变量的TRUE和FALSE的值。
#define TRUE 1
#define FALSE 0

19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
Const是只读的意思，它限定一个变量不允许被改变。
#define缺乏类型检测机制，在预处理时候有可能引发错误。
Const方面的其它知识扩展：
         问题1：const变量 & const 限定的内容
下面的代码编译器会报一个错误，请问，哪一个语句是错误的呢？
　　typedef char * pStr;
　　char string[4] = "abc";
　　const char *p1 = string; // *p1 作为整体不能被修改，但p1可以修改，p1++合法
　　const pStr p2 = string; //相当于const (char*)p2=string.p2作为一个整体，不能被修改，但是下面的p2++非法修改，pstr不是简单的代替。
　　p1++;
　　p2++;
　　　　　
问题2：const变量 & 字符串常量
请问下面的代码有什么问题？
char *p = "i''''''''m hungry!"; //定义的是字符串常量
　　p[0]= ''''''''I'''' //不能修改字符串常量
　　
问题：const变量 & 字符串常量2
　　char a[3] = "abc" 合法吗？使用它有什么隐患？
没有考虑到字符串结束符‘\0’，所以会产生意想不到的错误。
　　比如以下程序：
int main()
{
       int i;
    char p[6] = {''''''''a'''''''',''''''''b'''''''',''''''''c'''''''',''''''''d'''''''',''''''''e'''''''',''''''''f''''''''};
    printf("%s",p);
    while(1);
    return 0;
}
运行后显示： abcdef@
问题3：const & 指针
类型声明中const用来修饰一个常量，有如下两种写法，那么，请问，下面分别用const限定不可变的内容是什么?　　　　
1)、const在前面
a.　const int nValue； //nValue是const
把类型int撇开，变量nValue作为一个整体，因此 nValue是const型；
b.　const char *pContent; //*pContent是const, pContent可变
把类型char撇开，变量 *pContent作为一个整体，因此 *pContent是const型；
c.　const (char *) pContent;//pContent是const,*pContent可变
把类型char * 撇开，注意这里（char * ）是一个整体，而变量 pContent作为一个整体，因此 pContent是const型；
d.　char* const pContent; //pContent是const,*pContent可变
const与变量间没有类型，变量 pContent作为一个整体，因此 pContent是const型；
e.　const char* const pContent; //pContent和*pContent都是const
这里分为两层，外层：把类型char 撇开，变量 * const pContent作为一个整体，因此 * pContent是const型；内层：没有类型，因此 pContent 是 const 型。
2)、const在后面，与上面的声明对等 (这类型更容易判断)
a. int const nValue； // nValue是const
    const与变量之间没有类型，const后面那部分整体是const型，因此nValue是const型
b. char const * pContent;// *pContent是const, pContent可变
    const与变量之间没有类型，const后面那部分整体是const型，因此 * pContent是const型
c. const(char *) pContent;//pContent是const,*pContent可变
    const与变量之间没有类型，const后面那部分整体是const型，因此 pContent是const型
d. char* const pContent;// pContent是const,*pContent可变
    const与变量之间没有类型，const后面那部分整体是const型，因此 pContent是const型
e. char const* const pContent;// pContent和*pContent都是const
分为两层，外层：撇开类型char，const后面那部分整体* const pContent是const型，因此 * pContent是const型；内层：const与pContent之间无类型，因此pContent是const型。
　　
C++中CONST
   C中常用:#define 变量名 变量值定义一个值替代,然而却有个致命缺点:缺乏类型检测机制,这样预处理理在C++中成为可能引发错误的隐患,于是引入const.
const使用:
1. 用于指针的两种情况:const是一个左结合的类型修饰符.
   int const *A; //A可变,*A不可变
   int *const A; //A不可变,*A可变
2.限定函数的传递值参数:
void function(const int Var); //传递过来的参数在函数内不可以改变.
3.限定函数返回值型.
const int function(); //此时const无意义
const myclassname function(); //函数返回自定义类型myclassname.

20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。
         volatile的本意是“易变的” 
由于访问寄存器的速度要快过RAM,所以编译器一般都会作减少存取外部RAM的优化，但有可能会读脏数据。当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
      嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。
Volatile的完全扩展：
1). 一个参数既可以是const还可以是volatile吗？解释为什么。
是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
2). 一个指针可以是volatile 吗？解释为什么。
是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
3). 下面的函数有什么错误：
int square(volatile int *ptr)
{
return *ptr * *ptr;
}
    这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
int square(volatile int *ptr) 
{
int a,b;
a = *ptr;
b = *ptr;
return a * b;
}
由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
long square(volatile int *ptr) 
{
int a;
a = *ptr;
return a * a;
} 
1 
请用最简洁的语言描述您从前的工作经历和工作成果。
测 试应聘者是否能够用几句话概要地介绍其主要的工作信息和重点业绩，而不是以流水帐的形式重复履历表有已经注明的内容。在介绍工作成果时，注意应聘者能否正 确表述其在原单位所发挥的作用。尽管有关基本能力的提问大多可以通过简历或应聘表格反映出来，但通过回答可以考察应聘者的语言表达能力、仪表神态、目光注 视程度、肢体语言等方面。
2 
您为什么重新求职？
测试应聘者的求职动机是否合理。重新求职的原因可能因为应聘者原单位的问题，但通过回答可以考察应聘者是否既能客观、委婉地说明原由。
3 
什么样的单位是您求职的第一选择？
测试在应聘者心目中是否对自己和单位的定位清晰明确，而不是盲目应聘。
专业背景
4 
您认为此工作岗位应当具备哪些素质？
测试应聘者认为的岗位素质与招聘需要的岗位素质的吻合程度。
5 
请谈谈你对您所从事专业的理解，在专业方面有哪些重要的成果？
考察应聘者的专业功底。
6 
您认为自己应聘的职位在公司里所应当承担的主要职责是什么？您个人有哪些方面的优势能够胜任这一职位？还存在哪些缺陷和不足，准备如何来弥补？
考察应聘者个人对工作的理解以及是如何考虑个人与工作之间的匹配性的。
7 
您认为自己在这个岗位上的竞争优势是什么？
通过回答找到此应聘者与其他应聘人员的优势差异。
工作模式
8 
您平时习惯于单独工作还是团队工作？
工作习惯与应聘者应征的工作岗位有关。通常需要经常与他人合作或接触的岗位 ( 如秘书、公关等 ) 建议团队工作习惯，而技术、设计类型的岗位则相对独立性较强。
9 
在工作中您喜欢用哪种形式沟通？您认为什么是最有效的沟通形式？
通常面对面直接沟通的方式最为有效，与书面沟通相比，面对面沟通发生误解的可能性较小，除非两一见面就剑拔弩张。
10 
在过去的工作中您学习到了什么？
考察应聘者是否能够从专业成就、人际关系、组织、产品、服务等多个角度来回答问题。当谈及其从前的经历时，可测试应聘者是是否是个忠诚的、懂得尊重别人的员工。
11 
您如何使自己了解业务上的最新动态？
无论什么领域，都会有大量专业资料刊登在各类刊物上。对自己的专业研究得越深入，就越需要获得新的信息来源。
12 
请介绍您原来单位的几个主要竞争对手的情况。
通过回答测试应聘者的市场竞争意识。对本单位津津乐道，但对市场状况及竞争行情不甚了解的人员不是一名全面的工作人员。
13 
您在工作中通常怎样分配时间？
测试应聘者对时间的分配和使用习惯。
14 
您未来三年内的目标是什么？如何实现？
考察应聘者是否对自己能够提出明确的目标，并有切实的行动计划；而不是“继续做好现在的工作”、“加强学习”等模糊的概念。
15 
您对我们公司以及您所应聘的岗位有什么了解？
一 名态度认真的求职者往往会在面试之前通过多种渠道去了解应聘单位。如果在应聘的开始已经向应聘者进行介绍，可测试应聘者倾听的关注程度。如果事先没有向应 聘者进行有关本单位的情况介绍，应聘者可以会借此机会提出了解单位的情况。主试人员在介绍完毕之后，仍可通过类似问题考察应聘者。
价值取向
16 
您对原来的单位和上司的看法如何？
大骂原来单位及同事的应聘者绝非一名有修养的员工。考察应聘者是否能够客观委婉地表达其看法，并结合自己放弃原来职位的意图。
17 
业余时间您通常用来做什么？
考察应聘者是否能够平衡工作与生活之间的关系。
18 
描述您上一次在工作中挨批评的情景。
测试应聘者在既属于个人隐私、又有很强的专业性的领域里的沟通能力如何，以及应聘者是否经得起批评，并了解他以前的工作环境和沟通状况。
19 
您是否愿意接受心理测试？
考察应聘者是否能够坦诚相告。
20 
您觉得怎样才算是成功？
考察应聘者是否能够把受到赏识与做出有意义的贡献联系在一起，而且可以正确地平衡事业与家庭之间的关系。
21 
您认为做人的基本原则是什么？
考察应聘者个人的行为准则和道德规范意识。
资质特性
22 
您如何描述自己的个性？
测试应聘者的个性与招聘单位的文化、风气、行为准则、岗位特点等之间的匹配程度。例如：外向性格在公关、市场等工作岗位更具优势，内向性格在科研、档案等工作岗位更具优势。
23 
请列举您的三大优点和三大缺点。
应聘者是否能够坦诚相告自身的特性，并考虑其特质是否影响到此岗位的工作及团队工作。
24 
您原来的同事通常是如何评价您的？
考察应聘者是否了解自己在他人心中的看法，并正视面临的问题。
薪资待遇
25 
是否方便告诉我您目前的待遇是多少？
26 
您所期望的待遇是多少？
如果应聘者要求与更高层的主管商谈待遇问题，招聘者可巧妙地变换提问方式，“我们只是希望清楚您能够接受的待遇范围，例如税后月薪 2000-2500 元左右。”
27 
您要求公司必须的福利有哪些？另外希望公司提供什么样的福利？
涉及到人力成本及相关法规的问题，同时通过应聘者谈到原单位的福利时可以看出单位实力，以及自身的承受能力。
背景调查
28 
您是否介意我们通过您原来的单位进行一些调查？
重要的职位是必须进行调查的。通过应聘者回答问题时的态度及调查的材料可以测试其诚实程度。


linux 嵌入式面试 四
2008年10月08日 星期三 12:19 P.M.
. What does the following program print? （中国台湾某著名计算机硬件公司2005年12月面试题） 

#include <iostream> 

using namespace std; 

int 
main (void) 
{ 
int x = 2, y, z; 
x *= (y = z = 5); 
cout << x << endl; 
z = 3; 

x == (y = z); 
cout << x << endl; 
x = (y == z); 
cout << x << endl; 
x = (y & z); 
cout << x << endl; 
x = (y && z); 
cout << x << endl; 
y = 4; 
x = (y | z); 
cout << x << endl; 
x = (y || z); 
cout << x << endl; 
return 0; 
} 


输出： 

10 
10 
1 
3 
1 
7 
1 
2. What does the following program print? (中国某著名计算机金融软件公司2005年12月面试题) 



#include <iostream> 
using namespace std; 

int Vac = 3; 
int 
main (void) 
{ 
int Vac = 10; 
::Vac++; 
cout <<::Vac << endl; 
cout << Vac << endl; 
return 0; 
} 
输出： 

4 
10 


3. What will be the output of the following code (assume the necessary include files are present)? （中国台湾某著名杀毒软件公司2005年10月面试题） 

int i = 3, j = 4; 
i?i++:++j; 
printf("%d %d\n", i, j); 
输出： 

4 4 
4.以下代码的输出结果是什么？（中国某著名计算机金融软件公司2005年面试题） 





int i = 1, j = 2; 
int k = i+++j; 
cout << k <<endl; 
输出： 
3 


5. x=x+1, x+=1, x++, 哪个效率最高？为什么? 

(1) x = x+1 

#include <stdio.h> 

int main(int argc, char* argv[]) 
{ 
int x = 0; 
x = x + 1; 
return 0; 
} 

.file "a.c" 
.text 
.globl main 
.type main, @function 
main: 
leal 4(%esp), %ecx 
andl $-16, %esp 
pushl -4(%ecx) 
pushl %ebp 
movl %esp, %ebp 
pushl %ecx 
subl $16, %esp 
movl $0, -8(%ebp) 
addl $1, -8(%ebp) 
movl $0, %eax 
addl $16, %esp 
popl %ecx 
popl %ebp 
leal -4(%ecx), %esp 
ret 
.size main, .-main 
.ident "GCC: (GNU) 4.1.2 (Ubuntu 4.1.2-0ubuntu4)" 
.section .note.GNU-stack,"",@progbits 
(2) x += 1 

#include <stdio.h> 

int main(int argc, char* argv[]) 
{ 
int x = 0; 
x+=1; 
return 0; 
} 

.file "b.c" 
.text 
.globl main 
.type main, @function 
main: 
leal 4(%esp), %ecx 
andl $-16, %esp 
pushl -4(%ecx) 
pushl %ebp 
movl %esp, %ebp 
pushl %ecx 
subl $16, %esp 
movl $0, -8(%ebp) 
addl $1, -8(%ebp) 
movl $0, %eax 
addl $16, %esp 
popl %ecx 
popl %ebp 
leal -4(%ecx), %esp 
ret 
.size main, .-main 
.ident "GCC: (GNU) 4.1.2 (Ubuntu 4.1.2-0ubuntu4)" 
.section .note.GNU-stack,"",@progbits 
(3) x++ 

#include <stdio.h> 

int main(int argc, char* argv[]) 
{ 
int x = 0; 
x++; 
return 0; 
} 

.file "c.c" 
.text 
.globl main 
.type main, @function 
main: 
leal 4(%esp), %ecx 
andl $-16, %esp 
pushl -4(%ecx) 
pushl %ebp 
movl %esp, %ebp 
pushl %ecx 
subl $16, %esp 
movl $0, -8(%ebp) 
addl $1, -8(%ebp) 
movl $0, %eax 
addl $16, %esp 
popl %ecx 
popl %ebp 
leal -4(%ecx), %esp 
ret 
.size main, .-main 
.ident "GCC: (GNU) 4.1.2 (Ubuntu 4.1.2-0ubuntu4)" 
.section .note.GNU-stack,"",@progbits 
解析：给出的答案是x++的效率最高，答案的解释如下： 

x=x+1最低，因为它的执行过程如下： 

(1)读取右x下的地址 

(2)x+1 

(3)读取左x的地址 

(4) 将右值传给左边的x（编译器并不认为左右x的地址相同） 

x+=1其次，其执行过程如下： 

(1)读取右x下的地址 

(2)x+1 

(3)将得到的值传给x（因为x的地址已经读出） 

x++效率最高，其执行过程如下： 

(1) 读取右x的地址 

(2) x自增1 

以上解释表面上看似正确，但看过相应的汇编代码后，我们不难得到不同结论：三个语句的效率是相同的，因为他们的汇编代码是完全一样的，也就是说执行时的机器指令是完全一样的，最起码在gcc的编译器上是如此。 

6. What will be the output of the following C code? （中国台湾某著名CPU生产公司2005年面试题） 



#include <stdio.h> 

#define product(x) (x*x) 

int main(void) 
{ 
int i = 3, j, k; 
j = product(i++); 
k = product(++i); 
printf("j=%d,k=%d\n",j,k); 
return 0; 
} 

输出： 

j=9,k=49 


解析： 

经过预处理后的部分代码（gcc -E 6.c），其实是做了宏替换： 

... //前面部分省略 

int main(void) 

{ 
int i = 3, j, k; 
j = (i++*i++); 
k = (++i*++i); 
printf("j=%d,k=%d\n",j,k); 
return 0; 
} 
.file "6.c" 
.section .rodata 
.LC0: 
.string "j=%d,k=%d\n" 
.text 
.globl main 
.type main, @function 
main: 
leal 4(%esp), %ecx 
andl $-16, %esp 
pushl -4(%ecx) 
pushl %ebp 
movl %esp, %ebp 
pushl %ecx 
subl $36, %esp 
movl $3, -16(%ebp) 
movl -16(%ebp), %eax 
imull -16(%ebp), %eax #第一个乘法 
movl %eax, -12(%ebp) 
addl $1, -16(%ebp) #i加上了一个1（i=4） 
addl $1, -16(%ebp) #i加上了一个1（i=5） 
addl $1, -16(%ebp) #i加上了一个1（i=6） 
addl $1, -16(%ebp) #i加上了一个1（i=7） 
movl -16(%ebp), %eax 
imull -16(%ebp), %eax #第二个乘法 
movl %eax, -8(%ebp) 
movl -8(%ebp), %eax 
movl %eax, 8(%esp) 
movl -12(%ebp), %eax 
movl %eax, 4(%esp) 
movl $.LC0, (%esp) 
call printf 
movl $0, %eax 
addl $36, %esp 
popl %ecx 
popl %ebp 
leal -4(%ecx), %esp 
ret 
.size main, .-main 
.ident "GCC: (GNU) 4.1.2 (Ubuntu 4.1.2-0ubuntu4)" 
.section .note.GNU-stack,"",@progbits 


7. If there are "int a = 5, b = 3; ", the value of a and b are _ and _ after execute " !a&&b++;" （中国某著名综合 软件公司2005年面试题） 

结果： 5和3 

8. We have two pieces of code, which one do yo prefer, and tell why. （美国某著名计算机嵌入式公司2005年10月面试题） 



A. 
// a is a variable 
写法1： 
if ('A' == a) { 
a++; 
} 
写法2： 
if(a == 'A') { 
} 
B. 
写法1： 
for(i=0;i<8;i++) { 
X = i+Y+J*7; 
printf("%d",x); 
} 
写法2： 
S=Y+J*7; 
for(i=0;i<8;i++) { 
printf("%d",i+S); 
} 

8.下面程序的结果是什么？（中国台湾某著名CPU生产公司2005年面试题） 

char 
foo (void) 
{ 
unsigned int a = 6; 
int b = -20; 
char c; 
(a + b > 6) ? (c = 1) : (c = 0); 
return c; 
} 

结果为1 

分析：unsigned int类型的数据与int类型的数据相运算后，自动转化为unsigned int类型。因此a+b的值不是-14，而是一个unsignged int类型的书4294967282。需要弄明白“C语言中的自动类型转换的规则”。 

1. 在 C++程序中调用被C编译后的函数，为什么要加extern "C"? 

C++语言支持函数重载，C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为: void foo(int x, int y). 该函数被C编译器编译后在库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。 
C++提供了C连接交换指定符号extern "C"解决名字匹配问题。 

例如，C++标准头文件都有类似以下的结构： 

#ifndef __INCvxWorksh 
#define __INCvxWorksh 
#ifdef __cplusplus 
extern "C" { 
#endif 
/*...*/ 
#ifdef __cplusplus 
} 
#endif 
#endif /* __INCvxWorksh */ 
2. 头文件中的ifndef/define/endi是干什么用的？ 



防止该头文件被重复引用 

3. #include <filename.h>和#incldue "filename.h"有什么区别？ 

对于#include <filename.h>，编译器从标准头文件的路径开始搜索filename.h，在UNIX类的系统中通常是/usr/include。 

对于#include "filename.h"，编译器从包含该头文件的C源程序文件所在的路径开始搜索filename.h 

4. 如何判断一段程序是由C编译器编译的还是由C++ 编译器编译的？（美国某著名网络开发公司2005年面试题） 

C++编译时定义了_cplusplus，而C编译时定义了_STDC_。 

5. main主函数执行完毕后，是否可能会再执行一段代码？给出说明。（美国某著名网络开发公司2005年面试题） 



#include <stdio.h> 
#include <stdlib.h> 

void func1(void), func2(void), func3(void); 

int main(void) 
{ 
atexit(func1); 
atexit(func2); 
atexit(func3); 
printf("%s\n",__func__); 
return 0; 
} 

void func1(void) 
{ 
printf("%s\n",__func__); 
} 

void func2(void) 
{ 
printf("%s\n",__func__); 
} 

void func3(void) 
{ 
printf("%s\n",__func__); 
} 

执行结果如下： 

main 
func3 
func2 
func1 
详细解释见：abort、atexit、exit和_Exit 

========================================================================================== 

1. There are two int variables: a and b, don't use "if", "?:", "switch" or other judgment statements, find out the biggest one of the two numbers.（某国某著名网络开发公司2005年面试题） 

方案一： 

int max = ((a+b) + abs(a-b))/2; 
方案二： 

int c = a -b; 
c = unsigned (c) >> (sizeof(int)*8 - 1); 


2. 如何将a、b不得值进行交换，并且不使用任何中间变量？ 

用异或语句比较简单，不用担心溢出问题.如采用： 



a=a+b; 
b=a-b; 
a=a-b; 
这样做的缺点是如果a、b都是比较大的两个数，a=a+b 时就会溢出。 



而采用： 

a=a^b; 
b=a^b; 
a=a^b; 
无须担心溢出的问题，这样就比较好。 



这样做的于那里是按位异或运算。按位异或运算符 " ^ "是二元运算符，其功能是参与运算的两数个地用的二进制位相异或，当对应的二进制位相异时，结果为1。 

3.螺旋队列 

21 22 ...... 
20 7 8 9 10 
19 6 1 2 11 
18 5 4 3 12 
17 16 15 14 13 
看清以上数字排列的规律，设1点的坐标是（0，0），x方向向右为正，y方向向下为正。例如，7的坐标为（－1，－1），2的坐标为 （0，1），3的坐标为（1，1）。编程实现输入任意一点的坐标（x,，y），输出所对应的数字。（芬兰某著名通信设别公司2005年面试题） 



========================================================================================== 

1. What is the output of the following code? （中国台湾某著名杀毒软件公司2005年10月面试题） 



#define SR(x) (x*x) 

main() 
{ 
int a, b = 3; 
a = SQR(b+2); 
printf("\n%d",a); 
} 
结果为11 





#include <stdio.h> 
#define SQR(x) (x*x) 
int 
main (void) 
{ 
int a, b = 3; 
a = SQR (b + 2); 
printf ("\n%d", a); 
return 0; 
} 


经过预处理的宏替换后的部分代码如下： 

... //以上部分省略 
int 
main (void) 
{ 
int a, b = 3; 
a = (b + 2*b + 2); 
printf ("\n%d", a); 
return 0; 
} 
宏定义具有副作用，宏展开后容易造成二义性。较好的习惯是在宏定义的参数上加入括号来保证运算的优先级，如： 

#define SQR (x) ((x)*(x)) 


2. 用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）（美国某著名计算机嵌入式公司2005年面试题） 



#define SECONDS_PER_YEAR (60*60*24*365)UL 
意识到这个表达式将使一个16位机的整型数溢出，因此要用到长整型符号L，告诉编译器这个常数是长整型数。 



3.写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。（美国某著名计算机嵌入式公司2005年面试题） 



#define MIN(x ,y) ((x)<(y)?(x):(y)) 
=========================================================================================== 



1. What does the keyword "const" means in C program? Please at least make two examples about the usage of const.（中国台湾某著名CPU生产公司2005年面试题） 

在C程序中，const的用法主要有定义常量、修饰函数参数、修饰函数返回值等3个用处。在C++程序中，它还可以修饰函数的定义体，定义类中某个成员函数为恒态函数，即不改变类中的数据成员。 

(1)可以定义const 常量(2)const可以修饰函数的参数和返回值，甚至函数的定义体。被const 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。 

2. const与 ＃define相比有什么不同？ 

C++语言可以用const定义常量，也可以用#define定义常量，但是前者比后者有更多的优点： 

（1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换中可能会产生意料不到的错误（边际效应） 

（2）有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。在C++程序中只使用const常量而不使用宏常量，即const常量完全取代宏常量。 

常量的引进是在早期的C++版本中，当时标准C规范正在制定。那时，常量被看作一个好的思想而被包含在C中。但是，C中的const的意识是“一 个不能被改变的普通变量”。在C中，它总是占用内存，而且它的名字是全局符。C编译器不能把const看成是一个编译期间的常量。在C中，如果写： 

const bufsize = 100; 
char buf[bufsize]; 
尽管看起来好像做了一件合理的事情，但这将得到一个错误的结果。因为bufsize占用内存的某个地方，所以C编译器不知道它在编译时的值。在C语言中可以选择这样书写： 





const bufsize; 
这样写在C++中是部队的，而C编译器则把它作为一个声明，这个声明指明在别的地方有内存分配。因此C默认const是外部连接的，C++默认const是内部连接的。这样，如果在C++中想完成与C中同样的事情，必须用extern把内部连接改写外部连接： 

extern const bufsize; // declaration only 


这种方法也可用在C语言中。在C语言中使用限定符const不是很有用，即使是在常数表达式里（必须在编译期间被求出）想使用一个已命名的值，使用const也不是很有用的。C迫使程序员在预处理里使用#define。 
linux 嵌入式面试 五
2008年10月08日 星期三 12:20 P.M.
1、 如何在C中初始化一个字符数组。
这个问题看似很简单，但是我们要将最简单的问题用最严谨的态度来对待。关键的地方：初始化、字符型、数组。最简单的方法是char array[];。这个问题看似解决了，但是在初始化上好像还欠缺点什么，个人认为：char array[5]={'1','2','3','4','5'};或者char array[5]={"12345"};或者char array[2][10]={"China","Beijing"};也许更符合“初始化”的意思。



2、 如何在C中为一个数组分配空间。
最简单的方法是：char array[5]；意思是分配给数组array一个5个字节的空间。但是我们要知道在C中数组其实就是一个名字，其实质含义就是指针，比如char array[]；是到底分配的多少空间？所以我们要将其分成为两种不同的形式给出答案：
一种是栈的形式：char array[5]；
一种是堆的形式：char *array; array=(char *)malloc(5);//C++: array=new char[5];
堆和栈的含义其实我也没弄太透彻，改天明白了再发一篇。
我们要明白的是，第一种形式空间分配的大小可能会受操作系统的限制,比如windows会限制在2M；第二种形式成空间分配很灵活，想分配多少分配多少，只要RAM够大。



3、 如何初始化一个指针数组。
首先明确一个概念，就是指向数组的指针，和存放指针的数组。
指向数组的指针：char (*array)[5];含义是一个指向存放5个字符的数组的指针。
存放指针的数组：char *array[5];含义是一个数组中存放了5个指向字符型数据的指针。
按照题意，我理解为初始化一个存放指针的数组，char *array[2]={"China","Beijing"}；其含义是初始化了一个有两个指向字符型数据的指针的数组，这两个指针分别指向字符串"China"和"Beijing"。



4、如何定义一个有10个元素的整数型指针数组。
既然只是定义而不是初始化，那就很简单且没有争议了：int *array[10];。



5、 s[10]的另外一种表达方式是什么。
前面说过了，数组和指针其实是数据存在形态的两种表现形式，如果说对于数组s[]，我们知道*s=s[0]，那么s[10]的另一种表达方式就是：*(s+10)。



6、 GCC3.2.2版本中支持哪几种编程语言。
这个问题实在变态，就像问你#error的作用是什么一样。不可否认，gcc是linux下一个亮点，是一个备受无数程序员 推崇的编译器，其优点省略1000字，有兴趣可以自己查，我翻了翻书，书上曰：支持C,C++,Java,Obj- C,Ada,Fortran,Pascal,Modula-3等语言，这个“等”比较要命，不过我认为已经很全了，如果认为还是不全，干脆把ASM也加上 算了，不过那已经不算是编译了。



7、 要使用CHAR_BIT需要包含哪个头文件。
如果结合上面的问题，答题的人估计会认为自己撞鬼了，这个问题实在是……搜索了一下，应该是limits.h。



8、 对(-1.2345)取整是多少？
其实不同的取整函数可能有不同的结果，不过这个数没有太大的争议，答案是-1。



9、 如何让局部变量具有全局生命期。
具体的生命期的概念我觉得我还要好好深入的学习一下，但是这个题目还算比较简单，即用static修饰就可以了，但是只是生命期延长，范围并没有扩大，除非把这个变量定义在函数体外的静态区，不过那样就变成全局变量了，仿佛不符合题目要求。



10、C中的常量字符串应在何时定义？
这个问题说实话不是很理解题干的意思，据我理解，有两种情况，一种是预处理阶段，用#define定义；还有就是使用const修饰词，不过const修 饰的是一个变量，其含义是“只读”，称之为常量并不准确，但是确实可以用操作变量的方法当常量用。所以还是第一种比较靠谱。



11、如何在两个.c文件中引用对方的变量。
这个问题也问的挺含糊的，怎么说呢，最简单最直接的方法是为变量添加extern修饰词，当然，这个变量必须是全局变量。还有一种就是利用函数调用来进行 变量的间接引用，比如这个C文件中的一个函数引用另外一个C中的函数，将变量通过实参的形式传递过去。不过题目既然说是引用，那么还是用第一个答案好了。



12、使用malloc之前需要做什么准备工作。
其实准备工作很多啊，比如你需要一台计算机之类的。玩笑话，我们首先要知道malloc的用途，简单的说就是动态的分配一段空间，返回这段空间的头指针。 实际的准备工作可以这么分：需要这段空间的指针是否存在，若不存在，则定义一个指针用来被赋值，还要清楚要返回一个什么类型的指针，分配的空间是否合理； 如果指针已经存在，那么在重新将新的空间头地址赋值给这个指针之前，要先判断指针是否为NULL，如果不是要free一下，否则原来的空间就会被浪费，或 者出错，free之后就按照前一种情形考虑就可以了。



13、realloc函数在使用上要注意什么问题。
这个函数我也才知道的，汗一个。据我的初步理解，这个函数的作用是重新分配空间大小，返回的头指针不变，只是改变空间大小。既然是改变，就有变大、变小和为什么改变的问题。变大，要注意不能大到内存溢出；变小，那变小的那部分空间会被征用，原有数据不再存在；为什么改变，如果是想重新挪作他用，还是先free了吧。



14、strtok函数在使用上要注意什么问题。
这个问题我不知道能不能回答全面，因为实在是用的很少。这个函数的作用是分割字符串，但是要分割的字符串不能是常量，这是要注意的。比如先定义一个字符 串：char array[]="part1,part2";，strtok的原形是char *strtok(char *string, char *delim);，我们将","作为分隔符，先用pt=strtok(array,",");，得到的结果print出来就是"part1"，那后面的 呢，要写成pt=strtok(NULL,",");，注意，要用NULL，如果被分割的字符串会被分成N段，那从第二次开始就一直要用NULL。总结起 来，需要注意的是：被分割的字符串和分隔符都要使用变量；除第一次使用指向字符串的指针外，之后的都要使用NULL；注意使用这个函数的时候千万别把指针 跟丢了，不然就全乱了。



15、gets函数在使用上要注意什么问题。
这是一个键盘输入函数，将输入字符串的头地址返回。说到要注意的问题，我还是先查了一下网上的一些情况，需要注意的就是gets以输入回车结束，这个地球 人都知道，但是很多人不知道的是，当你输入完一个字符串后，这个字符串可能依然存在于这个标准输入流之中，当再次使用gets的时候，也许会把上次输入的 东西读出来，所以应该在使用之后用fflush(stdin);处理一下，将输入流清空。最后也还是要注意溢出的问题。关于这个答案我比较含糊，不知道有 没有高人高见？



16、C语言的词法分析在长度规则方面采用的是什么策略？
我无语……闻所未闻啊……还是搜索了一下，有一篇文章，地址是：http://202.117.80.9/jp2005/20/kcwz/wlkc/wlkc/03/3_5_2.htm，是关于词法分析器的。其中提到了两点策略： (1) 按最长匹配原则确定被选的词型；(2) 如果一个字符串能为若干个词型匹配，则排列在最前面的词型被选中。不知道是不是题干的要求，还是其他什么。我乃一介草民，望达人指点迷津！



17、a+++++b所表示的是什么意思？有什么问题？
这个东西（称之为东西一点都不过分）其实并没有语法错误，按照C对运算符等级的划分，++的优先级大于+，那么这句话会被编译器看做：(a++)+ (++b)，这回明白了吧。有什么问题，语法上没有问题，有的是道德上的问题！作为一个优秀的程序员，我们要力求语句的合法性和可读性，如果写这句的人是 在一个team里，那么他基本会被打的半死……最后讨论一下结果：假设a之前的值是3，b是4，那么运行完这个变态语句后，a的值是4，b是5，语句的结 果是8。



18、如何定义Bool变量的TRUE和FALSE的值。
不知道这个题有什么陷阱，写到现在神经已经大了，一般来说先要把TURE和FALSE给定义了，使用#define就可以：
#define TURE 1
#define FALSE 0
如果有一个变量需要定义成bool型的，举个例子：bool a=TURE;就可以了。



19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
首先，这个题干抽了10题回答的一个大嘴巴。关于常量的概念看来我要好好看看书了……我说过了，const修饰词可以将一个变量修饰为“只读”，这个就能 称为常量么？姑且认为可以。回到题目中，const是只读的意思，它限定一个变量不允许被改变，谁都不能改！既然是修饰变量，那么变量的类型就可以丰富多 彩，int啊，char啊，只要C认识的都可以；但是#define就不可以了，在预处理阶段缺乏类型检测机制，有可能会出错。还有就是变量可以 extern，但是#define就不可以。貌似const还可以节省RAM，这个我倒是没有考证过。至于const的用法和作用，有很多，我会总结后发 上来。



20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。
终于最后一题了，容易么……如果这个测试是一个关于嵌入式的，那么这道题非常重要！！从词面上讲，volatile的意思是易变的，也就是说，在程序运行 过程中，有一些变量可能会被莫名其妙的改变，而优化器为了节约时间，有时候不会重读这个变量的真实值，而是去读在寄存器的备份，这样的话，这个变量的真实 值反而被优化器给“优化”掉了，用时髦的词说就是被“和谐”了。如果使用了这个修饰词，就是通知编译器别犯懒，老老实实去重新读一遍！可能我说的太“通俗 ”了，那么我引用一下“大师”的标准解释：
volatile的本意是“易变的” 。
由于访问寄存器的速度要快过RAM,所以编译器一般都会作减少存取外部RAM的优化，但有可能会读脏数据。当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。
linux 嵌入式面试 杂集六
2008年10月08日 星期三 12:24 P.M.
C语言面试题
     1、局部变量能否和全局变量重名？

答：能，局部会屏蔽全局。要用全局变量，需要使用"::"

局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。

2、如何引用一个已经定义过的全局变量？

答：extern

可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。
3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？

答：可以，在不同的C文件中以static形式来声明同名全局变量。

可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错

4、语句for( ；1 ；)有什么问题？它是什么意思？

答：和while(1)相同。

5、do……while和while……do有什么区别？

答：前一个循环一遍再判断，后一个判断以后再循环

6、请写出下列代码的输出内容

#include
main()
{
int a,b,c,d;
a=10;
b=a++;
c=++a;
d=10*a++;
printf("b，c，d：%d，%d，%d"，b，c，d）;
return 0;
}

答：10，12，120

7、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？

全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。

从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。

static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件

static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;
static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；
static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝.
8、程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。

9、设有以下说明和定义：

typedef union {long i; int k[5]; char c;} DATE;
struct data { int cat; DATE （不属于标准类型不须对齐）cow; double dog;} too;
DATE max;

则语句 printf("%d",sizeof(struct date)+sizeof(max));的执行结果是：___52____

答：DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20
data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32.
所以结果是 20 + 32 = 52.

当然...在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 = 20

10、队列和栈有什么区别？

队列先进先出，栈后进先出

11、写出下列代码的输出内容

#include
int inc(int a)
{
return(++a);
}
int multi(int*a,int*b,int*c)
{
return(*c=*a**b);
}
typedef int(FUNC1)(int in);
typedef int(FUNC2) (int*,int*,int*);

void show(FUNC2 fun,int arg1, int*arg2)
{
INCp=&inc;
int temp =p(arg1);
fun(&temp,&arg1, arg2);
printf("%d\n",*arg2);
}

main()
{
int a;
show(multi,10,&a);
return 0;
}

答：110

12、请找出下面代码中的所以错误

说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba”

1、#include"string.h"
2、main()
3、{
4、 char*src="hello,world";
5、 char* dest=NULL;
6、 int len=strlen(src);
7、 dest=(char*)malloc(len);
8、 char* d=dest;
9、 char* s=src[len];
10、 while(len--!=0)
11、 d++=s--;
12、 printf("%s",dest);
13、 return 0;
14、}

答：

方法1：

int main()
{
char* src = "hello,world";
int len = strlen(src);
char* dest = (char*)malloc(len+1);//要为\0分配一个空间
char* d = dest;
char* s = &src[len-1];//指向最后一个字符
while( len-- != 0 )
*d++=*s--;
*d = 0;//尾部要加\0
printf("%s\n",dest);
free(dest);// 使用完，应当释放空间，以免造成内存汇泄露
return 0;
}

方法2：

#include
#include
main()
{
char str[]="hello,world";
int len=strlen(str);
char t;
for(int i=0; i　　　{
t=str[i];
str[i]=str[len-i-1]; str[len-i-1]=t;
}
printf("%s",str);
return 0;
}

1.-1,2,7,28,63,126请问28和126中间那个数是什么？为什么？

第一题的答案应该是4^3-1=63

规律是n^3-1(当n为偶数0，2，4)n^3+1(当n为奇数1，3，5)

答案：63

2.用两个栈实现一个队列的功能？要求给出算法和思路！

设2个栈为A,B, 一开始均为空.

入队:
将新元素push入栈A;
出队:
(1)判断栈B是否为空；
(2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；
(3)将栈B的栈顶元素pop出；

这样实现的队列入队和出队的平摊复杂度都还是O(1), 比上面的几种方法要好。
3.在c语言库函数中将一个字符转换成整型的函数是atool()吗，这个函数的原型是什么？

函数名: atol
功 能: 把字符串转换成长整型数
用 法: long atol(const char *nptr);
程序例:
#include
#include
int main(void)
{
long l;
char *str = "98765432";
l = atol(lstr);
printf("string = %s integer = %ld\n", str, l);
return(0);
}

13.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?

c用宏定义，c++用inline

14.直接链接两个信令点的一组链路称作什么?

PPP点到点连接

15.接入网用的是什么接口?

16.voip都用了那些协议?

17.软件测试都有那些种类?

黑盒：针对系统功能的测试
白合：测试函数功能，各函数接口

18.确定模块的功能和模块的接口是在软件设计的那个队段完成的?

概要设计阶段

19.
enum string
{
x1,
x2,
x3=10,
x4,
x5,
}x;

问x= 0x801005，0x8010f4 ;

20.
unsigned char *p1;
unsigned long *p2;
p1=(unsigned char *)0x801000;
p2=(unsigned long *)0x810000;

请问p1+5= ;
p2+5= ;

选择题:

21.Ethternet链接到Internet用到以下那个协议?

A.HDLC;B.ARP;C.UDP;D.TCP;E.ID

22.属于网络层协议的是:

A.TCP;B.IP;C.ICMP;D.X.25

23.Windows消息调度机制是:

A.指令队列;B.指令堆栈;C.消息队列;D.消息堆栈;

24.
unsigned short hash(unsigned short key)
{
return (key>>)%256
}

请问hash(16),hash(256)的值分别是:

A.1.16;B.8.32;C.4.16;D.1.32

找错题:

25.请问下面程序有什么错误?

int a[60][250][1000],i,j,k;
for(k=0;k<=1000;k++)
for(j=0;j<250;j++)
for(i=0;i<60;i++)
a[i][j][k]=0;

把循环语句内外换一下

26.
#define Max_CB 500
void LmiQueryCSmd(Struct MSgCB * pmsg)
{
unsigned char ucCmdNum;
......
for(ucCmdNum=0;ucCmdNum
{
......;
}

死循环

27.以下是求一个数的平方的程序,请找出错误:

#define SQUARE(a)((a)*(a))
int a=5;
int b;
b=SQUARE(a++);

28.
typedef unsigned char BYTE
int examply_fun(BYTE gt_len; BYTE *gt_code)
{
BYTE *gt_buf;
gt_buf=(BYTE *)MALLOC(Max_GT_Length);
......
if(gt_len>Max_GT_Length)
{
return GT_Length_ERROR;
}
.......
}

问答题:

29.IP Phone的原理是什么?

IPV6

30.TCP/IP通信建立的过程怎样，端口有什么作用？

三次握手，确定是哪个应用程序使用该协议

31.1号信令和7号信令有什么区别，我国某前广泛使用的是那一种？

32.列举5种以上的电话新业务？


1.static变量和static 函数各有什么特点？
3.描述一下嵌入式基于ROM的运行方式基于ram的运行方式有什么区别。
4.task 有几种状态？
5.task 有几种通讯方式？
6.C函数允许重入吗？
7.嵌入式操作系统和通用操作系统有什么差别？
linux 嵌入式面试 杂集七
2008年10月08日 星期三 12:27 P.M.
1、局部变量能否和全局变量重名？ 

答：能，局部会屏蔽全局。要用全局变量，需要使用"::" 

局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。 

2、如何引用一个已经定义过的全局变量？ 

答：extern 

可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。 

3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？ 

答：可以，在不同的C文件中以static形式来声明同名全局变量。 

可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错 

4、语句for( ；1 ；)有什么问题？它是什么意思？ 

答：和while(1)相同。 

5、do……while和while……do有什么区别？ 

答：前一个循环一遍再判断，后一个判断以后再循环 

6、请写出下列代码的输出内容 

#include<stdio.h> 
main() 
{ 
int a,b,c,d; 
a=10; 
b=a++; 
c=++a; 
d=10*a++; 
printf("b，c，d：%d，%d，%d"，b，c，d）; 
return 0; 
} 

答：10，12，120 

7、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？ 

全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。 

从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。 

static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件 

static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用; 

static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值； 

static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 

8、程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。 

9、设有以下说明和定义： 

typedef union {long i; int k[5]; char c;} DATE; 
struct data { int cat; DATE cow; double dog;} too; 
DATE max; 

则语句 printf("%d",sizeof(struct date)+sizeof(max));的执行结果是：___52____ 

答：DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20 
data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32. 
所以结果是 20 + 32 = 52. 

当然...在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 = 20 

10、队列和栈有什么区别？ 

队列先进先出，栈后进先出 

11、写出下列代码的输出内容 

#include<stdio.h> 
int inc(int a) 
{ 
return(++a); 
} 
int multi(int*a,int*b,int*c) 
{ 
return(*c=*a**b); 
} 
typedef int(FUNC1)(int in); 
typedef int(FUNC2) (int*,int*,int*); 

void show(FUNC2 fun,int arg1, int*arg2) 
{ 
INCp=&inc; 
int temp =p(arg1); 
fun(&temp,&arg1, arg2); 
printf("%d\n",*arg2); 
} 

main() 
{ 
int a; 
show(multi,10,&a); 
return 0; 
} 

答：110 

12、请找出下面代码中的所以错误 

说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba” 

1、#include"string.h" 
2、main() 
3、{ 
4、 char*src="hello,world"; 
5、 char* dest=NULL; 
6、 int len=strlen(src); 
7、 dest=(char*)malloc(len); 
8、 char* d=dest; 
9、 char* s=src[len]; 
10、 while(len--!=0) 
11、 d++=s--; 
12、 printf("%s",dest); 
13、 return 0; 
14、} 

答： 

方法1： 

int main() 
{ 
char* src = "hello,world"; 
int len = strlen(src); 
char* dest = (char*)malloc(len+1);//要为\0分配一个空间 
char* d = dest; 
char* s = &src[len-1];//指向最后一个字符 
while( len-- != 0 ) 
*d++=*s--; 
*d = 0;//尾部要加\0 
printf("%s\n",dest); 
free(dest);// 使用完，应当释放空间，以免造成内存汇泄露 
return 0; 
}
linux 嵌入式面试 杂集八
2008年10月08日 星期三 12:28 P.M.
程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。

char * const p;
char const * p
const char *p

上述三个有什么区别？

char * const p; //常量指针，p的值不可以修改
char const * p；//指向常量的指针，指向的常量值不可以改
const char *p； //和char const *p

char str1[] = "abc";
char str2[] = "abc";

const char str3[] = "abc";
const char str4[] = "abc";

const char *str5 = "abc";
const char *str6 = "abc";

char *str7 = "abc";
char *str8 = "abc";

cout << ( str1 == str2 ) << endl;
cout << ( str3 == str4 ) << endl;
cout << ( str5 == str6 ) << endl;
cout << ( str7 == str8 ) << endl;

结果是：0 0 1 1

解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。

以下代码中的两个sizeof用法有问题吗？

void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母
{
for( size_t i="0"; i



约定:
1) 下面的测试题中, 认为所有必须的头文件都已经正确的包含了
2) 数据类型
char 一个字节 1 byte
int 两个字节 2 byte (16位系统, 认为整型是2个字节)
long int 四个字节 4 byte
float 四个字节4 byet
double 八个字节 8 byte
long double 十个字节 10 byte
pointer 两个字节 2 byte(注意, 16位系统, 地址总线只有16位)
第1题: 考查对volatile关键字的认识
#include
static jmp_buf buf;
main()
{
volatile int b;
b =3;
if(setjmp(buf)!=0)
{
printf(“%d “, b);
exit(0);
}
b=5;
longjmp(buf , 1);
}
请问, 这段程序的输出是
(a) 3
(b) 5
(c) 0
(d) 以上均不是
第2题:考查类型转换
main()
{
struct node
{
int a;
int b;
int c;
};
struct node s= { 3, 5,6 };
struct node *pt = &s;
printf(“%d” , *(int*)pt);
}
这段程序的输出是:
(a) 3
(b) 5
(c) 6
(d) 7
第3题:考查递归调用
int foo ( int x , int n)　
{
int val;
val =1;
if (n>0)
{
if (n%2 == 1) val = val *x;
val = val * foo(x*x , n/2);
}
return val;
}
这段代码对x和n完成什么样的功能(操作)?
(a) x^n (x的n次幂)
(b) x*n(x与n的乘积)
(c) n^x(n的x次幂)
(d) 以上均不是
第4题:考查指针,这道题只适合于那些特别细心且对指针和数组有深入理解的人
main()
{
int a[5] = {1,2,3,4,5};
int *ptr = (int*)(&a+1);
printf(“%d %d” , *(a+1), *(ptr-1));
}
这段程序的输出是:
(a) 2 2
(b) 2 1
(c) 2 5
(d) 以上均不是
第5题:考查多维数组与指针
void foo(int [][3]);
main()
{
int a [3][3]= { { 1,2,3} , { 4,5,6},{7,8,9}};
foo(a);
printf(“%d” , a[2][1]);
}
void foo(int b[][3])
{
++ b;
b[1][1] =9;
}
这段程序的输出是:
(a) 8
(b) 9
(c) 7
(d)以上均不对
第6题:考查逗号表达式
main()
{
int a, b,c, d;
a=3;
b=5;
c=a,b;
d=(a,b);
printf(“c=%d” ,c);
printf(“d=%d” ,d);
}
这段程序的输出是:
(a) c=3 d=3
(b) c=5 d=3
(c) c=3 d=5
(d) c=5 d=5
第7题:考查指针数组
main()
{
int a[][3] = { 1,2,3 ,4,5,6};
int (*ptr)[3] = a;
printf(“%d %d “, (*ptr)[1], (*ptr)[2]);
++ptr;
printf(“%d %d” , (*ptr)[1], (*ptr)[2]);
}
这段程序的输出是:
(a) 2 3 5 6
(b) 2 3 4 5
(c) 4 5 0 0
(d) 以上均不对
第8题:考查函数指针
int *f1(void)
{
int x =10;
return(&x);
}
int *f2(void)
{
int*ptr;
*ptr =10;
return ptr;
}
int *f3(void)
{
int *ptr;
ptr=(int*) malloc(sizeof(int));
return ptr;
}
上面这3个函数哪一个最可能引起指针方面的问题
(a) 只有 f3
(b) 只有f1 and f3
(c) 只有f1 and f2
(d) f1 , f2 ,f3
第9题:考查自加操作(++)
main()
{
int i=3;
int j;
j = sizeof(++i+ ++i);
printf(“i=%d j=%d”, i ,j);
}
这段程序的输出是:
(a) i=4 j=2
(b) i=3 j=2
(c) i=3 j=4
(d) i=3 j=6
第10题:考查形式参数, 实际参数, 指针和数组
void f1(int *, int);
void f2(int *, int);
void(*p[2]) (int *, int);
main()
{
int a;
int b;
p[0] = f1;
p[1] = f2;
a=3;
b=5;
p[0](&a, b);
printf(“%d\t %d\t”, a, b);
p[1](&a, b);
printf(“%d\t %d\t”, a, b);
}
void f1(int* p , int q)
{
int tmp;
tmp =*p;
*p = q;
q= tmp;
}
void f2(int* p , int q)
{
int tmp;
tmp =*p;
*p = q;
q= tmp;
}
这段程序的输出是:
(a) 5 5 5 5
(b) 3 5 3 5
(c) 5 3 5 3
(d) 3 3 3 3
第11题:考查自减操作(–)
void e(int );
main()
{
int a;
a=3;
e(a);
}
void e(int n)
{
if(n>0)
{
e(–n);
printf(“%d”, n);
e(–n);
}
}
这段程序的输出是:
(a) 0 1 2 0
(b) 0 1 2 1
(c) 1 2 0 1
(d) 0 2 1 1
第12题:考查typedef类型定义,函数指针
typedef int (*test) ( float * , float*)
test tmp;
tmp 的类型是
(a) 函数的指针, 该函数以两个指向浮点数(float)的指针(pointer)作为参数(arguments)
Pointer to function of having two arguments that is pointer to float
(b) 整型
(c) 函数的指针,
该函数以两个指向浮点数(float)的指针(pointer)作为参数(arguments),并且函数的返回值类型是整型
Pointer to function having two argument that is pointer to float and
return int
(d) 以上都不是
第13题:数组与指针的区别与联系
main()
{
char p;
char buf[10] ={ 1,2,3,4,5,6,9,8};
p = (buf+1)[5];
printf(“%d” , p);
}
这段程序的输出是:
(a) 5
(b) 6
(c) 9
(d) 以上都不对
第14题: 考查指针数组的指针
void f(char**);
main()
{
char * argv[] = { “ab” ,”cd” , “ef” ,”gh”, “ij” ,”kl” };
f( argv );
}
void f( char **p )
{
char* t;
t= (p+= sizeof(int))[-1];
printf( “%s” , t);
}
这段程序的输出是:
(a) ab
(b) cd
(c) ef
(d) gh
第15题:此题考查的是C的变长参数,就像标准函数库里printf()那样,这个话题一般国内大学课堂是不会讲到的,不会情有可原
#include
int ripple ( int , );
main()
{
int num;
num = ripple ( 3, 5,7);
printf( ” %d” , num);
}
int ripple (int n, )
{
int i , j;
int k;
va_list p;
k= 0;
j = 1;
va_start(p, n);
for (; j{
i = va_arg(p , int);
for (; i; i &=i-1 )
++k;
}
return k;
}
这段程序的输出是:
(a) 7
(b) 6
(c) 5
(d) 3
第16题:考查静态变量的知识
int counter (int i)
{
static int count =0;
count = count +i;
return (count );
}
main()
{
int i , j;
for (i=0; i <=5; i++)
j = counter(i);
}
本程序执行到最后,j的值是:
(a) 10
(b) 15
(c) 6
(d) 7
详细参考答案
第1题: (b)
volatile字面意思是易于挥发的。这个关键字来描述一个变量时, 意味着 给该变量赋值(写入)之后, 马上再读取,
写入的值与读取的值可能不一样,所以说它"容易挥发"的。
这是因为这个变量可能一个寄存器, 直接与外部设备相连, 你写入之后, 该寄存器也有可能被外部设备的写操作所改变;或者,
该变量被一个中断程序, 或另一个进程
改变了.
volatile 不会被编译器优化影响, 在longjump 后,它的值 是后面假定的变量值,b最后的值是5,所以5被打印出来.
setjmp : 设置非局部跳转 /* setjmp.h*/
Stores context information such as register values so that the
lomgjmp function can return control to the statement following the
one calling setjmp.Returns 0 when it is initially called.
Lonjjmp: 执行一个非局部跳转 /* setjmp.h*/
Transfers control to the statement where the call to setjmp (which
initialized buf) was made. Execution continues at this point as if
longjmp cannot return the value 0.A nonvolatile automatic variable
might be changed by a call to longjmp.When you use setjmp and
longjmp, the only automatic variables guaranteed to remain valid are
those declared volatile.
Note: Test program without volatile qualifier (result may very)
更详细介绍, 请参阅 C语言的setjmp和longjmp
第2题: (a)
结构题的成员在内存中的地址是按照他们定义的位置顺序依次增长的。如果一个结构体的指针被看成
它的第一个成员的指针,那么该指针的确指向第一个成员
第3题: (a)
此题目较难.
这个程序的非递归版本
int what ( int x , int n)
{
int val;
int product;
product =1;
val =x;
while(n>0)
{
if (n%2 == 1)
product = product*val; /*如果是奇数次幂, x(val)要先乘上一次,;
偶数次幂, 最后返回时才会到这里乘以1*/
val = val* val;
n = n/2;
}
return product;
}
/* 用二元复乘策略 */
算法描述
(while n>0)
{
if next most significant binary digit of n( power) is one
then multiply accumulated product by current val,
reduce n(power) sequence by a factor of two using integer division.
get next val by multiply current value of itself
}
第4题: (c)
a的类型是一个整型数组,它有5个成员。&a的类型是一个整型数组的指针, 所以&a + 1指向的地方等同于a[6], 所以*(a+1)
等同于a[1]
ptr等同a[6], ptr-1就等同与a[5]
第5题: (b)
题目自身就给了足够的提示
b[0][0] = 4
b[1][0] = 7
第6题: (c)
考查逗号表达式,逗号表达式的优先级是很低的, 比 赋值(=)的优先级 低. 逗号表达式的值就是最后一个元素的值
逗号表达式的还有一个作用就是分割函数的参数列表..
E1, E2, …, En
上面这个表示式的左右是,E1, E2,… En的值被分别计算出来, En计算出来的结构赋给整个逗号表达式
c=a,b; / *yields c=a* /
d=(a,b); /* d =b */
第7题: (a)
ptr是一个数组的指针, 该数组有3个int成员
第8题: (c)
f1显然有问题, 它返回一个局部变量的指针, 局部变量是保存在stack中的,退出函数后, 局部变量就销毁了, 保留其指针没有意义,
因为其指向的stack空间可能被其他变量覆盖了
f2也有问题, ptr是局部变量, 未初始化, 它的值是未知的, *ptr不知道指向哪里了,
直接给*ptr赋值可能会覆盖重要的系统变量, 这就是通常说的野指针的一种
第9题: (b)
sizeof 操作符给出其操作数需要占用的空间大小, 它是在编译时就可确定的, 所以其操作数即使是一个表达式,
也不需要在运行时进行计算.( ++i + ++ i )是不会执行的, 所以i的值还是3
第10题: (a)
很显然选a.
f1交换*p 和 q的值, f1执行完后, *p 和 q的值的确交换了, 但q的改变不会影响到b的改变, *p 实际上就是a
所以执行f1后, a=b=5
这道题考查的知识范围很广,包括typedef自定义类型,函数指针,指针数组void(*p[ 2 ]) ( int *, int);
定义了一个函数指针的数组p,p有两个指针元素. 元素是函数的指针, 函数指针指向的函数是一个带2个参数,返回void的函数,
所带的两个参数是指向整型的指针, 和整型
p[ 0 ] = f1; p[ 1 ] = f2 contain address of function .function name
without parenthesis represent address of function Value and address
of variable is passed to function only argument that is effected is
a (address is passed). Because of call by value f1, f2 can not
effect b
第11题: (a)
考查–操作和递归调用,仔细分析一下就可以了
第12题: (c)
建议不会的看看C专家编程
从左往有, 遇到括号停下来, 将第一个括号里的东西看成一个整体
第13题: (c)
考查什么时候数组就是指针.对某些类型T而言, 如果一个表达式是 T[] (T的数组),
这个表达式的值实际上就是指向该数组的第一个元素的指针.所以(buf+1)[5]实际上就是*(buf +6)或者buf[6]
第14题: (b)
sizeof(int)的值是2,所以p+=sizeof(int) 指向 argv[2],这点估计大家都没有什么疑问
(p+=sizeof(int))[-1] 指向 argv[1],能理解吗, 因为(p+=sizeof(int))[-1] 就相当于
(p+=2)[-1] ,也就是(p+2-1)
第15题: (c)
在C编译器通常提供了一系列处理可变参数的宏, 以屏蔽不同的硬件平台造成的差异,
增加程序的可移植性。这些宏包括va_start、va_arg和va_end等。
采用ANSI标准形式时, 参数个数可变的函数的原型声明是：type funcname(type para1, type para2,
…)
这种形式至少需要一个普通的形式参数, 后面的省略号不表示省略, 而是函数原型的一部分。type是函数返回值和形式参数的类型。
不同的编译器, 对这个可变长参数的实现不一样 , gcc4.x中是内置函数.
关于可变长参数,可参阅
http://www.upsdn.net/html/2004-11/26.html
http://www.upsdn.net/html/2004-11/24.html
程序分析
va_list p; /*定义一个变量 ,保存 函数参数列表 的指针*/
va_start( p , n); /*用va_start宏 初始化变量p, va_start宏的第2个参数n, 是一个固定的参数,
必须是我们自己定义的
变长函数的最后一个入栈的参数也就是调用的时候参数列表里的第1个参数*/
for (; j{
i = va_arg( p , int); /*va_arg取出当前的参数,并认为取出的参数是一个整数(int) */
for (; i; i &=i-1 ) /*判断取出的i是否为0*/
++k; /* 如果i不为0, k自加, i与i-1进行与逻辑运算, 直到i 为0
这是一个技巧, 下面会谈到它的功能*/
}
当我们调用ripple函数时, 传递给ripple函数的 参数列表的第一个参数n的值是3. va_start
初始化p士气指向第一个未命名的参数(n是有名字的参数) ,也就是 is 5 (第一个). 每次对 va_arg的调用,
都将返回一个参数, 并且把 p 指向下一个参数. va_arg 用一个类型名来决定返回的参数是何种类型,以及在
var_arg的内部实现中决定移动多大的距离才到达下一个参数
(; i; i&=i-1) k++ /* 计算i有多少bit被置1 */
5用二进制表示是 (101) 2
7用二进制表示 (111) 3
所以 k 返回 5(2+3),也即本题应该选c
举个例子, 就很好理解了
令 i= 9 = 1001
i-1 = 1000
(i-1) +1 = i
1000
+1
1001
因为i与i-1的最右边的那位(最低位) 肯定是不同, 如果i1,i-1肯定是0, 反之亦然. i & i-1 这个运算,
在二相补的数字系统中, 将会消除最右边的1位
第16题: (b)
答案是 (b)
相传高斯小学一年级的时候就会做这类等比数列的题目了.这道题考查的是静态变量的知识,当每次调用完函数之后,静态变量的值不会丢失,这与栈中的临时局部变量明显不同的地方.
所以,第一次调用counter(0)之后,count =0
第二次调用 counter(1)后 count = 0+1;
第三次调用 counter(2) count = 1+2; /* count = count +i */
第四次调用 counter(3) count = 3+3;
第五次调用 counter(4) count = 6+4;
第六次调用 counter(5) count = 10+5;
命题人信息 Ashok K. Pathak a member ( Research Staff ) at Bharat
Electronics Limited (CRL), Ghaziabad. He has been developing
embedded application for the past five years .Ashok holds a M.E in
computer science and engineering. Ashok recently completed a book
about’ “Advanced Test in C and Embedded System Programming”,
Published by BPB , ND.


7.C++中为什么用模板类。
答：(1)可用来创建动态增长和减小的数据结构
（2）它是类型无关的，因此具有很高的可复用性。
（3）它在编译时而不是运行时检查数据类型，保证了类型安全
（4）它是平台无关的，可移植性
（5）可用于基本数据类型
8.CSingleLock是干什么的。
答：同步多个线程对一个数据类的同时访问
12.Linux有内核级线程么。
答：线程通常被定义为一个进程中代码的不同执行路线。从实现方式上划分，线程有两
种类型：“用户级线程”和“内核级线程”。 用户线程指不需要内核支持而在用户程序
中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度
和管理线程的函数来控制用户线程。这种线程甚至在象 DOS 这样的操作系统中也可实现
，但线程的调度需要用户程序完成，这有些类似 Windows 3.x 的协作式多任务。另外一
种则需要内核的参与，由内核完成线程的调度。其依赖于操作系统核心，由内核的内部
需求进行创建和撤销，这两种模型各有其好处和缺点。用户线程不需要额外的内核开支
，并且用户态线程的实现方式可以被定制或修改以适应特殊应用的要求，但是当一个线
程因 I/O 而处于等待状态时，整个进程就会被调度程序切换为等待状态，其他线程得不
到运行的机会；而内核线程则没有各个限制，有利于发挥多处理器的并发优势，但却占
用了更多的系统开支。 
Windows NT和OS/2支持内核线程。Linux 支持内核级的多线程
14.使用线程是如何防止出现大的波峰。
答：意思是如何防止同时产生大量的线程，方法是使用线程池，线程池具有可以同时提
高调度效率和限制资源使用的好处，线程池中的线程达到最大数时，其他线程就会排队
等候
15函数模板与类模板有什么区别？
答：函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化
必须由程序员在程序中显式地指定。
22.TCP/IP 建立连接的过程?(3-way shake)
答：在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
　　第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状
态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个
SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
　　第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)
，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
23.ICMP是什么协议,处于哪一层?
答：Internet控制报文协议，处于网络层（IP层
27.IP组播有那些好处?
答：Internet上产生的许多新的应用，特别是高带宽的多媒体应用，带来了带宽的急剧
消耗和网络拥挤问题。组播是一种允许一个或多个发送者（组播源）发送单一的数据包
到多个接收者（一次的，同时的）的网络技术。组播可以大大的节省网络带宽，因为无
论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包。所以说组播
技术的核心就是针对如何节约网络资源的前提下保证服务质量。
2.引用与指针有什么区别？
    1) 引用必须被初始化，指针不必。
    2) 引用初始化以后不能被改变，指针可以改变所指的对象。
    3) 不存在指向空值的引用，但是存在指向空值的指针。 
4.全局变量和局部变量在内存中是否有区别？如果有，是什么区别？
      全局变量储存在静态数据库，局部变量在堆栈。
5.什么是平衡二叉树？
      左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。
6.堆栈溢出一般是由什么原因导致的？
      没有回收垃圾资源。内存泄露
8.冒泡排序算法的时间复杂度是什么？
      时间复杂度是O(n^2)。 
9.写出float x 与“零值”比较的if语句。
      if(x>0.000001&&x<-0.000001) 软件开发网 
. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情：
1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
3). 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
4). 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。
2. 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。
#define MIN(A,B) ((A) <= (B) (A) : (B))
这个测试是为下面的目的而设的：
1). 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，
对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
2). 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
3). 懂得在宏中小心地把参数用括号括起来
4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
least = MIN(*p++, b);
3. 预处理器标识#error的目的是什么？
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种
问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。
死循环（Infinite loops）
4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
这个问题用几个解决方案。我首选的方案是：
while(1)
{
}
一些程序员更喜欢如下方案：
for(;;)
{
}
这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的
基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。
第三个方案是用 goto
Loop:
...
goto Loop;
应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。
数据声明（Data declarations）
5. 用变量a给出下面的定义
a) 一个整型数（An integer）
b) 一个指向整型数的指针（A pointer to an integer）
c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）
d) 一个有10个整型数的数组（An array of 10 integers）
e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）
f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer
argument and return an integer ）
答案是：
a) int a; // An integer
b) int *a; // A pointer to an integer
c) int **a; // A pointer to a pointer to an integer
d) int a[10]; // An array of 10 integers
e) int *a[10]; // An array of 10 pointers to integers
f) int (*a)[10]; // A pointer to an array of 10 integers
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer
人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。
但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道
所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？
Static
6. 关键字static的作用是什么？
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数
据和代码范围的好处和重要性。
Const
7．关键字const是什么含意？
我只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？
const int a;
int const a;
const int *a;
int * const a;
int const * a const;
前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
1). 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。
Volatile
8. 关键字volatile有什么含意 并给出三个不同的例子。
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。
假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
1). 一个参数既可以是const还可以是volatile吗？解释为什么。
2). 一个指针可以是volatile 吗？解释为什么。
3). 下面的函数有什么错误：
int square(volatile int *ptr)
{
return *ptr * *ptr;
}
下面是答案：
1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
int square(volatile int *ptr)
{
int a,b;
a = *ptr;
b = *ptr;
return a * b;
}
由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
long square(volatile int *ptr)
{
int a;
a = *ptr;
return a * a;
}
位操作（Bit manipulation）
9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
对这个问题有三种基本的反应
1). 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
2). 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
3). 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
#define BIT3 (0x1<<3)
static int a;
void set_bit3(void)
{
a |= BIT3;
}
void clear_bit3(void)
{
a &= ~BIT3;
}
一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。
访问固定的内存位置（Accessing fixed memory locations）
10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
int *ptr;
ptr = (int *)0x67a9;
*ptr = 0xaa55;
一个较晦涩的方法是：
*(int * const)(0x67a9) = 0xaa55;
即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。
中断（Interrupts）
11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
__interrupt double compute_area (double radius)
{
double area = PI * radius * radius;
printf(" Area = %f", area);
return area;
}
这个函数有太多的错误了，以至让人不知从何说起了：
1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。
代码例子（Code examples）
12 . 下面的代码输出是什么，为什么？
void foo(void)
{
unsigned int a = 6;
int b = -20;
(a+b > 6) puts("> 6") : puts("<= 6");
}

这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“>6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。
13. 评价下面的代码片断：
unsigned int zero = 0;
unsigned int compzero = 0xFFFF;
/*1's complement of zero */
对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：
unsigned int compzero = ~0;
这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧…
动态内存分配（Dynamic memory allocation）
14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？
char *ptr;
if ((ptr = (char *)malloc(0)) == NULL)
puts("Got a null pointer");
else
puts("Got a valid pointer");
这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是“Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。
Typedef
15. Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
#define dPS struct s *
typedef struct s * tPS;
以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：
dPS p1,p2;
tPS p3,p4;
第一个扩展为
struct s * p1, p2;
上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。
晦涩的语法
16. C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
int a = 5, b = 7, c;
c = a+++b;
这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：
c = a++ + b;
因此, 这段代码持行后a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是:这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题
系统分类: 嵌入式系统   |   用户分类: 技术分享   |   来源: 整理 
    阅读(95)    回复(1)   
3、用递归算法判断数组a[N]是否为一个递增数组。
递归的方法，记录当前最大的，并且判断当前的是否比这个还大，大则继续，否则返回false结束：
bool fun( int a[], int n )
{
if( n= =1 )
return true;
if( n= =2 )
return a[n-1] >= a[n-2];
return fun( a,n-1) && ( a[n-1] >= a[n-2] );
}
4、编写算法，从10亿个浮点数当中，选出其中最大的10000个。
用外部排序，在《数据结构》书上有
《计算方法导论》在找到第n大的数的算法上加工
5、编写一unix程序，防止僵尸进程的出现.
2.单连表的建立，把'a'--'z'26个字母插入到连表中，并且倒叙，还要打印！
方法1：
typedef struct val
{    int date_1;
     struct val *next;
}*p;
void main(void)
{    char c;
     
     for(c=122;c>=97;c--)
        { p.date=c;
          p="p-">next;
         }
     p.next=NULL;
} 
}
方法2：
node *p = NULL;
node *q = NULL;
node *head = (node*)malloc(sizeof(node));
head->data = ' ';head->next=NULL;
node *first = (node*)malloc(sizeof(node));
first->data = 'a';first->next=NULL;head->next = first;
p = first;
int longth = 'z' - 'b';
int i="0";
while ( i<=longth )
{
node *temp = (node*)malloc(sizeof(node));
temp->data = 'b'+i;temp->next=NULL;q=temp;
head->next = temp; temp->next=p;p=q;
i++;
}
print(head);
 
测试程序
#include <stdio.h>
struct A{
        char a;
        int b;
        unsigned short c;
        long d;
        unsigned long long e;
        char f;
};
struct B{
        char a;
        int b;
        unsigned short c;
        long d;
        unsigned long long e;
        char f;
}__attribute__((aligned));
struct C{
        char a;
        int b;
        unsigned short c;
        long d;
        unsigned long long e;
        char f;
}__attribute__((aligned(1)));

struct D{
        char a;
        int b;
        unsigned short c;
        long d;
        unsigned long long e;
        char f;
}__attribute__((aligned(4)));
struct E{
        char a;
        int b;
        unsigned short c;
        long d;
        unsigned long long e;
        char f;
}__attribute__((aligned(8)));
struct F{
        char a;
        int b;
        unsigned short c;
        long d;
        unsigned long long e;
        char f;
}__attribute__((packed));
int main(int argc, char **argv)
{
        printf("A = %d, B = %d, C = %d, D = %d, E = %d, F = %d/n",
                sizeof(struct A), sizeof(struct B), sizeof(struct C), sizeof(struct D), sizeof(struct E), sizeof(struct F));
        return 0;
}
在fedora 7下的测试结果：
A = 28, B = 32, C = 28, D = 28, E = 32, F = 20
A：不使用__attribute__ 默认4字节对齐
B：__attribute__((aligned)) 
      the compiler automatically sets the alignment for the declared variable or field to the largest alignment which is ever used for any data type on the target machine you are compiling for. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables or fields that you have aligned this way.
   最大对齐方式，此例中为16字节对齐，同E
C:__attribute__((aligned(1))) 不支持，除了packed 不能减小对齐字节数，以默认对齐方式对齐
D:__attribute__((aligned(4))) 四字节对齐
E：__attribute__((aligned(8))) 八字节对齐
F：__attribute__((packed)) 
     the aligned attribute can only increase the alignment; but you can decrease it by specifying packed as well. 
     The packed attribute specifies that a variable or structure field should have the smallest possible alignment―one byte for a variable, and one bit for a field, unless you specify a larger value with the aligned attribute. 
Here is a structure in which the field x is packed, so that it immediately follows a: 
          struct foo
          {
            char a;
            int x[2] __attribute__ ((packed));
          };
   变量以字节对齐，结构体域以位对齐   
cygwin下的测试结果：
A = 32, B = 32, C = 32, D = 32, E = 32, F = 20
从测试结果上看默认8字节对齐？或是只支持packed,未知
可参考的文档：
http://developer.apple.com/documentation/DeveloperTools/gcc-3.3/gcc/Variable-Attributes.html
http://www.skynet.org.cn/archiver/?tid-87.html
编程题
一个递规反向输出字符串的例子,可谓是反序的经典例程.
void inverse(char *p)
{
     if( *p = = '/0' ) 
return;
     inverse( p+1 );
     printf( "%c", *p );
}
int main(int argc, char *argv[])
{
     inverse("abc/0");
     return 0;
}
3。输出和为一个给定整数的所有组合
例如n=5
5=1+4；5=2+3（相加的数不能重复）
则输出
1，4；2，3。
答案：
＃i nclude <stdio.h>
 ＃i nclude <stdio.h>
void main()
{
unsigned long int a,i=1;
scanf("%d",&a);
if(a%2==0)
{
      for(i=1;i<a/2;i++)
      printf("%d",a,a-i);
}
else
for(i=1;i<=a/2;i++)
         printf(" %d, %d",i,a-i);
}
4。在对齐为4的情况下
struct BBB
{
    long num；
    char *name;
    short int data;
    char ha;
    short ba[5];
}*p;
p=0x1000000;
p+0x200=____;
(Ulong)p+0x200=____;
(char*)p+0x200=____;
答案：假设在32位CPU上，
sizeof(long) = 4 bytes
sizeof(char *) = 4 bytes
sizeof(short int) = sizeof(short) = 2 bytes
sizeof(char) = 1 bytes
由于是4字节对齐，
sizeof(struct BBB) = sizeof(*p) 
= 4 + 4 + 4(（2 + 1 ）+ 1补齐为4）+ 12(2*5 + 2补齐为12) = 24 bytes  
p=0x1000000;
p+0x200=____;
     = 0x1000000 + 0x200*24
(Ulong)p+0x200=____;
     = 0x1000000 + 0x200
(char*)p+0x200=____;
     = 0x1000000 + 0x200*4
5。写一段程序，找出数组中第k大小的数，输出数所在的位置。例如{2，4，3，4，7}中，第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。函数接口为：int find_orderk(const int* narry,const int n,const int k) 
要求算法复杂度不能是O(n^2）
答案：可以先用快速排序进行排序，其中用另外一个进行地址查找
代码如下，在VC++6.0运行通过。给分吧^-^
//快速排序
＃i nclude<iostream>
usingnamespacestd;
intPartition (int*L,intlow,int high)
{
inttemp = L[low];
intpt = L[low];
while (low < high)
{
while (low < high && L[high] >= pt)
--high;
L[low] = L[high];
while (low < high && L[low] <= pt)
++low;
L[low] = temp;
}
L[low] = temp;
returnlow;
}
voidQSort (int*L,intlow,int high)
{
if (low < high)
{
intpl = Partition (L,low,high);
QSort (L,low,pl - 1);
QSort (L,pl + 1,high);
}
}
intmain ()
{
intnarry[100],addr[100];
intsum = 1,t;
cout << "Input number:" << endl;
cin >> t;
while (t != -1)
{
narry[sum] = t;
addr[sum - 1] = t;
sum++;
cin >> t;
}
sum -= 1;
QSort (narry,1,sum);
for (int i = 1; i <= sum;i++)
cout << narry[i] << '/t';
cout << endl;
intk;
cout << "Please input place you want:" << endl;
cin >> k;
intaa = 1;
intkk = 0;
for (;;)
{
if (aa == k)
break;
if (narry[kk] != narry[kk + 1])
{
aa += 1;
kk++;
}
}
cout << "The NO." << k << "number is:" << narry[sum - kk] << endl;
cout << "And it's place is:" ;
for (i = 0;i < sum;i++)
{
if (addr[i] == narry[sum - kk])
cout << i << '/t';
}
return0;
}
int main(void)
{
          int MAX = 10;
int *a = (int *)malloc(MAX * sizeof(int));
int *b;
    
FILE *fp1;
FILE *fp2;
fp1 = fopen("a.txt","r");
if(fp1 == NULL)
{printf("error1");
     exit(-1);
}
     fp2 = fopen("b.txt","w");
if(fp2 == NULL)
{printf("error2");
     exit(-1);
}
int i = 0;
     int j = 0;
while(fscanf(fp1,"%d",&a[i]) != EOF)
{
i++;
j++;
if(i >= MAX)
{
MAX = 2 * MAX;
b = (int*)realloc(a,MAX * sizeof(int));
if(b == NULL)
{
printf("error3");
exit(-1);
}
a = b;
}
}
for(;--j >= 0;)
    fprintf(fp2,"%d/n",a[j]);
fclose(fp1);
fclose(fp2);
return 0;
}
2。运行的结果为什么等于15
＃i nclude "stdio.h"
＃i nclude "string.h"
void main()
{
char aa[10];
printf("%d",strlen(aa));
}
答案：sizeof()和初不初始化，没有关系；strlen()和初始化有关。
4。分析一下
＃i nclude<iostream.h>
＃i nclude <string.h>
＃i nclude <malloc.h>
＃i nclude <stdio.h>
＃i nclude <stdlib.h>
＃i nclude <memory.h>
typedef struct   AA
{
         int b1:5;
         int b2:2;
}AA;
void main()
{
        AA aa;
        char cc[100];
        strcpy(cc,"0123456789abcdefghijklmnopqrstuvwxyz");
        memcpy(&aa,cc,sizeof(AA));
        cout << aa.b1 <<endl;
        cout << aa.b2 <<endl;
}
答案： -16和１
首先sizeof(AA)的大小为4,b1和b2分别占5bit和2bit.
经过strcpy和memcpy后,aa的4个字节所存放的值是:
0,1,2,3的ASC码，即00110000,00110001,00110010,00110011
所以，最后一步：显示的是这４个字节的前５位，和之后的２位
分别为：10000,和01
因为int是有正负之分,所以是-16和１
5。求函数返回值，输入x=9999; 
int func （ x ）
{ 
     int countx = 0; 
     while ( x ) 
     { 
         countx ++; 
         x = x&(x-1); 
     } 
     return countx; 
} 
结果呢？
答案：知道了这是统计9999的二进制数值中有多少个1的函数，且有
9999＝9×1024＋512＋256＋15
9×1024中含有1的个数为2；
512中含有1的个数为1；
256中含有1的个数为1；
15中含有1的个数为4；
故共有1的个数为8，结果为8。
1000 - 1 = 0111，正好是原数取反。这就是原理。
用这种方法来求1的个数是很效率很高的。
不必去一个一个地移位。循环次数最少。
6。int a,b,c 请写函数实现C=a+b ,不可以改变数据类型,如将c改为long int,关键是如何处理溢出问题
答案：bool add (int a, int b,int *c)
{
*c=a+b;
return (a>0 && b>0 &&(*c<a || *c<b) || (a<0 && b<0 &&(*c>a || *c>b)));
}
8。改错：
＃i nclude <stdio.h>
int main(void) {
     int **p;
     int arr[100];
     p = &arr;
     return 0;
}
答案：搞错了,是指针类型不同,
int **p; //二级指针
&arr; //得到的是指向第一维为100的数组的指针
应该这样写＃i nclude <stdio.h>
int main(void) {
int **p, *q;
int arr[100];
q = arr;
p = &q;
return 0;
标准答案示例：
const float EPSINON = 0.00001;
if ((x >= - EPSINON) && (x <= EPSINON)
void *p = malloc( 100 );
请计算
sizeof ( p ) =  4      （2分）
4、在C++ 程序中调用被 C编译器编译后的函数，为什么要加 extern “C”？ （5分）
答：C++语言支持函数重载，C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为： void foo(int x, int y);
该函数被C编译器编译后在库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。
C++提供了C连接交换指定符号extern“C”来解决名字匹配问题。
                                     
1.说出下面这个程序的运行结果，并简要叙述其理由：
char buf1[10]="hello";
char buf2[10]="hello";
if (buf1==buf2)
printf("equal!");
else printf("not equal!");
因为buf1,buf2分配了不同的内存块，而比较的是数组名，实际上是两个分别指向数组起始元素地址的指针。
类string的构造函数
string::string(const char* str)
{
   if(str == NULL)
   {
      m_data = new char[1];
      *m_data = '/0';
    }
    else
    {
       int length = strlen(str);
       m_data = new char[str + 1];
       strcpy(m_data, str);
     }
}
string 的析构函数
string::~string()
{
   delete [] m_data;
}
string 的拷贝构造函数
string ::string(const string& other)
{
   int len = strlen(other.m_data);
   m_data = new char[len + 1];
   strcpy(m_data, other.m_data);
}
string 的赋值函数
string& string::operator=(const string& other)
{
   if (this == &other)
      return *this;
   delete [] m_data;
   int len = strlen(other.m_data);
   m_data = new char[len + 1];
   strcpy(m_data, other.m_data);
   return *this;
}   
不用任何局部和全局变量实现int strlen(char *a) 
int strlen(char *a) {
    if('/0' == *a)
        return 0;
    else 
        return 1 + strlen(a + 1);
}

1)求出相似度的算法.
2)写出二分查找的代码.
int binary_search(int* arr, int key, int n)
{
   int low = 0;
   int high = n - 1;
   int mid;
   while (low <= high)
   {
      mid = (high + low) / 2;
      if (arr[mid] > k)
         high = mid - 1;
      else if (arr[mid] < k)
         low = mid + 1;
      else
         return mid;
   }
   return -1;
}
  
*6)实现strcpy函数
char* strcpy(char* dest, const char* src)
{
   assert((dest != NULL) && (src != NULL));
   char* address = dest;
   while ('/0' != (*dest++ = *src++));
   return address;
}
出现次数相当频繁
*10)将一个数字字符串转换为数字."1234" -->1234
#include<iostream>
using namespace std;
int f(char* s)
{
   int k = 0;
   while (*s)
   {
      k = 10 * k + (*s++)- '0';      
   } 
   return k;
}
int main()
{
   int digit = f("4567");
   cout<<digit<<endl;
   cin.get();
}
出现次数相当频繁
11)实现任意长度的整数相加或者相乘功能。
*12)写函数完成内存的拷贝
一个内存拷贝函数的实现体
void *memcpy(void *pvTo,const void *pvFrom,size_t size)
{
assert((pvTo!=NULL)&&(pvFrom!=NULL));
byte *pbTo=(byte*)pvTo; //防止地址被改变
byte *pbFrom=(byte*)pvFrom;
while (size-- >0)
*pbTo++ = *pbForm++;
return pvTo;
} 
出现次数相当频繁
 
.笔试: 
1)写一个内存拷贝函数,不用任何库函数.就是前些时候本版讨论的那个问题.
 void* memcpy(void* pvTo, const void* pvFrom, size_t size)
 {
    assert((pvTo != NULL) && (pvFrom != NULL));
    byte* pbTo = pvTo;
    byte* pbFrom = pbFrom;
    while (size-- > 0)
    {
       *pbTo++ = *pbFrom++;
    }
    return pvTo;
 }
2)将一个单链表逆序.(这个问题是个常规的数据结构问题.不过不小心时会损失效率) 
3)客房预定的问题.根据客户报的人数,客房等级来从预备的客房中选择出所有符合要求的 
客房号.客户没有要求等级时,只考虑人数因素就可以了.要考虑有些客房已经预定的情况. 
(写代码是要考虑好彼此的效率) 
4)对于一个无序序列进行二分查找 
线排序再查找
5)将一个数字字符串转换为数字."1234" -->1234
int convert(char* str)
{
   int k = 0;
   while (*str != '/0')
   {
      k = k * 10 + *s++ - '0';
   }
   return k;
} 
四、有关内存的思考题（每小题5分，共20分）
void GetMemory(char *p)
{
p = (char *)malloc(100);
}
void Test(void) 
{
char *str = NULL;
GetMemory(str); 
strcpy(str, "hello world");
printf(str);
}
请问运行Test函数会有什么样的结果？
答：试题传入GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值，执行完
char *str = NULL; 
GetMemory( str ); 
后的str仍然为NULL；
 
  char *GetMemory(void)
{ 
char p[] = "hello world";
return p;
}
void Test(void)
{
char *str = NULL;
str = GetMemory(); 
printf(str);
}
请问运行Test函数会有什么样的结果？
答：可能是乱码。              char p[] = "hello world";       
     return p;  
的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。
 
void GetMemory2(char **p, int num)
{
*p = (char *)malloc(num);
}
void Test(void)
{
char *str = NULL;
GetMemory(&str, 100);
strcpy(str, "hello"); 
printf(str); 
}
请问运行Test函数会有什么样的结果？
答：
（1）能够输出hello
（2 ）Test函数中也未对malloc的内存进行释放。
（3）GetMemory避免了试题1的问题，传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句
*p = (char *) malloc( num ); 
后未判断内存是否申请成功，应加上：
if ( *p == NULL ) 
 { 
   ...//进行申请内存失败处理 
　}
　
 
  void Test(void)
{
char *str = (char *) malloc(100);
 strcpy(str, “hello”);
 free(str);     
 if(str != NULL) 
 {
   strcpy(str, “world”); 
printf(str);
}
}
请问运行Test函数会有什么样的结果？
答：执行
char *str = (char *) malloc(100); 
后未进行内存是否申请成功的判断；另外，在free(str)后未置str为空，导致可能变成一个“野”指针，应加上：
str = NULL;
 
 

2. 写出运行结果
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
int main(int argc, char *argv[]) {
     char a[] = "abc";
     char b[] = {'d', 'e', 'f'};
     printf("a slen=%d,b slen=%d/n", strlen(a),strlen(b));
      printf("a = %s, b = %s/n", a, b);
     printf("asize len = %d, bsize len = %d/n", sizeof(a),sizeof(b));
     return 0;
/0
c
b
a
f
e
d
}
a slen = 3,b slen = 6
a
a = abc, b = defabc
asize len = 4, bsize len = 3
注：栈分配原则：从高地址－>低地址分配；
b
It is not the above result when I test in Vmware Linux.
4. 说出错误
void test() {
    char str[10];
    char* str1 = "0123456789";//alloc in the only read data area
    strcpy(str, str1); //array index overflow
 Strcpy(str1,str)  //because str1 alloced in the only read data area
}
注：数组越界
haiou01@hotmail.com
5. 说出错误
void test() {
    char str[10], str1[10];
    for( int = 0; i < 10; i++){ //memset(str,0,sizeof(str))
//modif  i< 10-1
            str[i] = 'a';
    }
    strcpy(str1, str);//find not string file end descripe
}
8 写出运行结果
#include <stdio.h>
#include <string.h>
#define STRCPY(a, b)    strcpy(a##_p, #b)
#define STRCPY1(a, b)   strcpy(a##_p, b##_p)
int main(void)  {
        char var1_p[20];
        char var2_p[30];
        strcpy(var1_p, "aaaa");
        strcpy(var2_p, "bbbb");
        STRCPY1(var1, var2);
        STRCPY(var2, var1);
        printf("var1 = %s/n", var1_p);
        printf("var2 = %s/n", var2_p);
        return 0;
}
var1 = bbbb
var2 = var1
宏中"#"和"##"的用法 
一、一般用法 
我们使用#把宏参数变为一个字符串,用##把两个宏参数贴合在一起. 
用法: 
#include<cstdio> 
#include<climits> 
using namespace std; 
#define STR(s) #s 
#define CONS(a,b) int(a##e##b) 
int main() 
{ 
printf(STR(vck)); // 输出字符串"vck" 
printf("%d/n", CONS(2,3)); // 2e3 输出:2000 
return 0; 
} 
二、当宏参数是另一个宏的时候 
需要注意的是凡宏定义里有用'#'或'##'的地方宏参数是不会再展开. 
1, 非'#'和'##'的情况 
#define TOW (2) 
#define MUL(a,b) (a*b) 
printf("%d*%d=%d/n", TOW, TOW, MUL(TOW,TOW)); 
这行的宏会被展开为： 
printf("%d*%d=%d/n", (2), (2), ((2)*(2))); 
MUL里的参数TOW会被展开为(2). 
2, 当有'#'或'##'的时候 
#define A (2) 
#define STR(s) #s 
#define CONS(a,b) int(a##e##b) 
printf("int max: %s/n", STR(INT_MAX)); // INT_MAX #include<climits> 
这行会被展开为： 
printf("int max: %s/n", "INT_MAX"); 
printf("%s/n", CONS(A, A)); // compile error 
这一行则是： 
printf("%s/n", int(AeA)); 
A不会再被展开, 然而解决这个问题的方法很简单. 加多一层中间转换宏. 
加这层宏的用意是把所有宏的参数在这层里全部展开, 那么在转换宏里的那一个宏(_STR)就能得到正确的宏参数. 
#define A (2) 
#define _STR(s) #s 
#define STR(s) _STR(s) // 转换宏 
#define _CONS(a,b) int(a##e##b) 
#define CONS(a,b) _CONS(a,b) // 转换宏 
printf("int max: %s/n", STR(INT_MAX)); // INT_MAX,int型的最大值，为一个变量 #include<climits> 
输出为: int max: 0x7fffffff 
STR(INT_MAX) --> _STR(0x7fffffff) 然后再转换成字符串； 
printf("%d/n", CONS(A, A)); 
输出为：200 
CONS(A, A) --> _CONS((2), (2)) --> int((2)e(2)) 
三、'#'和'##'的一些应用特例 
1、合并匿名变量名 
#define ___ANONYMOUS1(type, var, line) type var##line 
#define __ANONYMOUS0(type, line) ___ANONYMOUS1(type, _anonymous, line) 
#define ANONYMOUS(type) __ANONYMOUS0(type, __LINE__) 
例：ANONYMOUS(static int); 即: static int _anonymous70; 70表示该行行号； 
第一层：ANONYMOUS(static int); --> __ANONYMOUS0(static int, __LINE__); 
第二层： --> ___ANONYMOUS1(static int, _anonymous, 70); 
第三层： --> static int _anonymous70; 
即每次只能解开当前层的宏，所以__LINE__在第二层才能被解开； 
2、填充结构 
#define FILL(a) {a, #a} 
enum IDD{OPEN, CLOSE}; 
typedef struct MSG{ 
IDD id; 
const char * msg; 
}MSG; 
MSG _msg[] = {FILL(OPEN), FILL(CLOSE)}; 
相当于： 
MSG _msg[] = {{OPEN, "OPEN"}, 
{CLOSE, "CLOSE"}}; 
3、记录文件名 
#define _GET_FILE_NAME(f) #f 
#define GET_FILE_NAME(f) _GET_FILE_NAME(f) 
static char FILE_NAME[] = GET_FILE_NAME(__FILE__); 
4、得到一个数值类型所对应的字符串缓冲大小 
#define _TYPE_BUF_SIZE(type) sizeof #type 
#define TYPE_BUF_SIZE(type) _TYPE_BUF_SIZE(type) 
char buf[TYPE_BUF_SIZE(INT_MAX)]; 
--> char buf[_TYPE_BUF_SIZE(0x7fffffff)]; 
--> char buf[sizeof "0x7fffffff"]; 
这里相当于： 
char buf[11];-
第3题:考查递归调用
int foo ( int x , int n)　{ int val; val =1;    if (n>0)   {    if (n%2 == 1) val = val *x;        val = val * foo(x*x , n/2); } return val;} 
这段代码对x和n完成什么样的功能(操作)?
(a) x^n (x的n次幂)
(b) x*n(x与n的乘积)
(c) n^x(n的x次幂)
(d) 以上均不是

第6题目:考查逗号表达式
main(){ int a, b,c, d; a=3; b=5; c=a,b; d=(a,b); printf("c=%d" ,c); printf("d=%d" ,d);}
这段程序的输出是:
(a) c=3 d=3
(b) c=5 d=3
(c) c=3 d=5
(d) c=5 d=5
第6题: (c)
考查逗号表达式,逗号表达式的优先级是很低的，比 赋值(=)的优先级 低. 逗号表达式的值就是最后一个元素的值
逗号表达式的还有一个作用就是分割函数的参数列表..

第9题:考查自加操作(++)
main(){ int i=3; int j; j = sizeof(++i+ ++i); printf("i=%d j=%d", i ,j);}
这段程序的输出是:
(a) i=4 j=2
(b) i=3 j=2
(c) i=3 j=4
(d) i=3 j=6
第9题: (b)
sizeof 操作符给出其操作数需要占用的空间大小，它是在编译时就可确定的，所以其操作数即使是一个表达式，也不需要在运行时进行计算.( ++i + ++ i )是不会执行的，所以
i 的值还是3
第10题:考查形式参数，实际参数，指针和数组
void f1(int *, int); void f2(int *, int); void(*p[2]) ( int *, int);main(){ int a; int b; p[0] = f1; p[1] = f2; a=3; b=5; p[0](&a , b); printf("%d/t %d/t" , a ,b); p[1](&a , b); printf("%d/t %d/t" , a ,b);}void f1( int* p , int q){ int tmp; tmp =*p; *p = q; q= tmp;}void f2( int* p , int q){ int tmp; tmp =*p; *p = q; q= tmp;} 
这段程序的输出是:
(a) 5 5 5 5
第11题:考查自减操作(--)
void e(int );   main(){ int a; a=3; e(a);}void e(int n){ if(n>0) {    e(--n);    printf("%d" , n);    e(--n); }}
这段程序的输出是:
(a) 0 1 2 0
第15题:此题考查的是C的变长参数,就像标准函数库里printf()那样,这个话题一般国内大学课堂是不会讲到的,不会也情有可原呵呵,
#include<stdarg.h>
int ripple ( int , ...);
 
main()
{
    int num;
    num = ripple ( 3, 5,7);
    printf( " %d" , num);
}
 
 
int ripple (int n, ...)
{
    int i , j;
    int k;
    va_list p;
    k= 0; j = 1;
    va_start( p , n);
    for (; j<n; ++j)
    {
        i = va_arg( p , int);
        for (; i; i &=i-1 )
            ++k;
    }
    return k;
}
这段程序的输出是:
(a) 7
(b) 6
(c) 5
(d) 3
第15题: (c)
在C编译器通常提供了一系列处理可变参数的宏，以屏蔽不同的硬件平台造成的差异，增加程序的可移植性。这些宏包括va_start、 va_arg和va_end等。 
采用ANSI标准形式时，参数个数可变的函数的原型声明是： 
type funcname(type para1, type para2, ...) 
这种形式至少需要一个普通的形式参数，后面的省略号不表示省略，而是函数原型的一部分。type是函数返回值和形式参数的类型。
不同的编译器，对这个可变长参数的实现不一样 ，gcc4.x中是内置函数.
关于可变长参数,可参阅
http://www.upsdn.net/html/2004-11/26.html
http://www.upsdn.net/html/2004-11/24.html
程序分析
va_list p;  /*定义一个变量 ,保存函数参数列表 的指针*/
va_start( p , n);     /*用va_start宏初始化变量p,  va_start宏的第2个参数n, 是一个固定的参数,必须是我们自己定义的变长函数的最后一个入栈的参数也就是调用的时候参数列表里的第1个参数*/
for (; j<n; ++j)     /* j从1开始,   遍历所有可变参数 */
{    i = va_arg( p , int);      /*va_arg取出当前的参数,  并认为取出的参数是一个整数(int)*/   
 for (; i; i &=i-1 )      /*判断取出的i是否为0*/      
++k;                              /* 如果i不为0,   k自加, i与i-1进行与逻辑运算, 直到i 为0  这是一个技巧，下面会谈到它的功能*/}
当我们调用ripple函数时，传递给ripple函数的 参数列表的第一个参数n的值是3 .
va_start 初始化 p指向第一个未命名的参数(n是有名字的参数) ,也就是 is 5 (第一个).
每次对 va_arg的调用，都将返回一个参数，并且把 p 指向下一个参数.
va_arg 用一个类型名来决定返回的参数是何种类型,以及在 var_arg的内部实现中决定移动多大的距离才到达下一个 参数
(; i; i&=i-1) k++        /* 计算i有多少bit被置1 */
5用二进制表示是 (101) 2
7用二进制表示 (111) 3
所以 k 返回 5(2+3),也即本题应该选c
因为i与i-1的最右边的那位(最低位) 肯定是不同，如果i1,i-1肯定是0，反之亦然.     i & i-1 这个运算，在二相补的数字系统中，将会 消除最右边的1位
 
1.　char * const p;
　　char const * p
　　const char *p
　　上述三个有什么区别？
　　char * const p; //常量指针，p的值不可以修改
　　char const * p；//指向常量的指针，指向的常量值不可以改
　　const char *p； //和char const *p
------------------------------------------------------
2.　char str1[] = "abc";
　　char str2[] = "abc";
　　const char str3[] = "abc";
　　const char str4[] = "abc";
　　const char *str5 = "abc";
　　const char *str6 = "abc";
　　char *str7 = "abc";
　　char *str8 = "abc";
　　cout << ( str1 == str2 ) << endl;
　　cout << ( str3 == str4 ) << endl;
　　cout << ( str5 == str6 ) << endl;
　　cout << ( str7 == str8 ) << endl;
   打印结果是什么？

解答：结果是：0 0 1 1
str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域
-----------------------------------------------
3. 以下代码中的两个sizeof用法有问题吗？
　　void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母
　　{
    　　for( size_t i=0; i<sizeof(str)/sizeof(str[0]); ++i )
        　if( 'a'<=str[i] && str[i]<='z' )
           str[i] -= ('a'-'A' );
　　}
　　char str[] = "aBcDe";
　　cout << "str字符长度为: " << sizeof(str)/sizeof(str[0]) << endl;
　　UpperCase( str );
　　cout << str << endl;
答：函数内的sizeof有问题。
根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。
函数外的str是一个静态定义的数组，因此其大小为6，
函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。
-------------------------------------------------
4.　main()
　　{
　　　int a[5]={1,2,3,4,5};
　　　int *ptr=(int *)(&a+1);
　　　printf("%d,%d",*(a+1),*(ptr-1));
　　}
   输出结果是什么？

　　答案：输出：2,5
　　*(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5
　　&a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）
　　int *ptr=(int *)(&a+1);
　　则ptr实际是&(a[5]),也就是a+5
　　
　　原因如下：
　　&a是数组指针，其类型为 int (*)[5];
　　而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同。
　　a是长度为5的int数组指针，所以要加 5*sizeof(int)
　　所以ptr实际是a[5]
　　但是prt与(&a+1)类型是不一样的(这点很重要)
　　所以prt-1只会减去sizeof(int*)
　　a,&a的地址是一样的，但意思不一样
    a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，
    a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5].
--------------------------------------------
5.　请问以下代码有什么问题：
　　int  main()
　　{
char a;
char *str=&a;
strcpy(str,"hello");
printf(str);
return 0;
　　}
　　答案：没有为str分配内存空间，将会发生异常。问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。
---------------------------------------------
6. char* s="AAA";
　　printf("%s",s);
　　s[0]='B';
　　printf("%s",s);
　　有什么错？
　　答案：
"AAA"是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。
cosnt char* s="AAA";
然后又因为是常量，所以对是s[0]的赋值操作是不合法的。
---------------------------------------------
7. int (*s[10])(int) 表示的是什么？
　　答案：int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。
---------------------------------------------
8.　有以下表达式：
　　int a=248; b=4;
　　int const c=21;
　　const int *d=&a;
　　int *const e=&b;
　　int const *f const =&a;
　　请问下列表达式哪些会被编译器禁止？为什么？
　　*c=32;d=&b;*d=43;e=34;e=&a;f=0x321f;

　　答案：
   *c 这是个什么东东，禁止
　　*d 说了是const， 禁止
　　e = &a 说了是const 禁止
　　const *f const =&a; 禁止
------------------------------------------
9.　#include <stdio.h>
　　#include <stdlib.h>
　　void getmemory(char *p)
　　{　
　　　p=(char *) malloc(100);
　　　strcpy(p,"hello world");
　　}　
　　int main( )
　　{
　　　char *str=NULL;
　　　getmemory(str);
　　　printf("%s/n",str);
　　　free(str);
　　　return 0;
　　}
   分析一下这段代码
　　答案：程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险
　　博主：getmemory中p是形参，是一个指针变量，getmemory(str)调用后，传入的是指针变量保存的对象地址，p=(char *) malloc(100)实际上是把申请的动态内存空间的首地址付给p指向的地址（即str指向的地址null），这个是错误的。应该修改成指向指针的指针void getmemory(char **p)，这样malloc返回的地址付给*p（即str变量本身）。
-----------------------------------------
10.　char szstr[10];
  　　strcpy(szstr,"0123456789");
  　　产生什么结果？为什么？
 
　　答案：长度不一样，会造成非法的OS
------------------------------------------
11.要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;
   那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？
　　答案：*((void (*)( ))0x100000 ) ( );
　　首先要将0x100000强制转换成函数指针,即:
　　(void (*)())0x100000
　　然后再调用它:
　　*((void (*)())0x100000)();
　　用typedef可以看得更直观些:
　　typedef void(*)() voidFuncPtr;
　　*((voidFuncPtr)0x100000)();
------------------------------------------
12. 分析下面的程序：
　　void GetMemory(char **p,int num)
　　{                          //p，指向指针的指针，*p，p指向的指针(即str)，**p，最终的对象，str指向的单元
　　　*p=(char *)malloc(num);  //申请空间首地址付给传入的被p指向的指针，即str
　　}   
   
　　int main()
　　{
     char *str=NULL;
　　　GetMemory(&str,100);   //传入指针变量本身的地址
　　　strcpy(str,"hello");
　　　free(str);
　　　if(str!=NULL)
　　　{
  　　　　strcpy(str,"world");
　　　}   
        
　　　printf("/n str is %s",str); 软件开发网 www.mscto.com
　　　getchar();
　　}  
　　问输出结果是什么？
　　答案：输出str is world。
　　free 只是释放的str指向的内存空间,它本身的值还是存在的.所以free之后，有一个好的习惯就是将str=NULL.
此时str指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储空间是可能被重新分配给其他变量的,
尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出world来。
这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。
　　当你malloc一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继续访问这块地址的。
-------------------------------------------
13.char a[10]；
strlen(a)为什么等于15？
　　#include "stdio.h"
　　#include "string.h"
　　void main()
　　{
　　　char aa[10];
　　　printf("%d",strlen(aa));
　　}
　　答案：sizeof()和初不初始化，没有关系；
　　strlen()和初始化有关。
--------------------------------------------
14.char (*str)[20];/*str是一个数组指针，即指向数组的指针．*/
　　char *str[20];/*str是一个指针数组，其元素为指针型数据．*/


　　2012最新的嵌入式软件工程师面试题笔试并且含答案

　　随着科技信息的进步，在某个领域的突破发展也是大势所趋，就像各个企业对嵌入式软件工程师 的要求也是随着需求的变化不段变化，所以2012最新的嵌入式软件工程师的面试题还是有必要了 解熟悉下的。

　　1.算术运算符，赋值运算符和关系运算符的运算优先级按从高到低依次为

　　A.算术运算、赋值运算、关系运算

　　B.算术运算、关系运算、赋值运算

　　C.关系运算、赋值运算、算术运算

　　D.关系运算、算术运算、赋值运算

　　参考答案：B

　　2.设#define N 3

　　#define Y(n) ((N+1)*n)

　　则表达式2*(N+Y(5+1))的值是

　　A.42

　　B.48

　　C.54

　　D.出错

　　深圳达内福田培训中心提供的参考答案：B

　　3.打印一个N*N的方阵，N为每边字符的个数（ 3〈N〈20 ），要求最外层为“X”，第二层为“Y ”，从第三层起每层依次打印数字0，1，2，3，...

　　例子：当N =5，打印出下面的图形：

　　X X X X X

　　X Y Y Y X

　　X Y 0 Y X

　　X Y Y Y X

　　X X X X X

　　4.多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?

　　参考答案：

　　虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.

　　而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的,这是 实现多态的关键.

　　5.执行下述程序的输出结果是  ABCDEFCDEFEF  。

　　#include

　　char b[]="ABCDEF";

　　main()

　　{

　　char *bp;

　　for (bp=b;*bp;bp+=2)

　　printf("%s",bp);

　　printf("\n");

　　}

　　6.函数 int compare(int a,int b),定义为该函数的函数指针P:为     int(*p)(int,int);p= compare;

　　#include<stdio.h>

　　void sub(char*s,int num)

　　{

　　int i ,j=num;

　　char t;

　　while(j-->1)

　　{

　　for(i=0;i<j;i++)

　　{

　　if(s[i]<s[i+1])

　　{

　　t=s[i];

　　s[i]=s[i+1];

　　s[i+1]=t;

　　}

　　}

　　}

　　}

　　main()

　　{

　　char *s="CEAeded";

　　sub(s,6);

　　printf("%s\n",s)

　　}

　　7.用变量a给出下面的定义

　　a) 一个整型数（An integer）

　　b) 一个指向整型数的指针（A pointer to an integer）

　　c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）

　　d) 一个有10个整型数的数组（An array of 10 integers）

　　e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）

　　f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）

　　g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）

　　h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）

　　深圳达内福田培训中心提供的答案是：

　　a) int a; // An integer

　　b) int *a; // A pointer to an integer

　　c) int **a; // A pointer to a pointer to an integer

　　d) int a[10]; // An array of 10 integers

　　e) int *a[10]; // An array of 10 pointers to integers

　　f) int (*a)[10]; // A pointer to an array of 10 integers

　　g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer

　　以上是2012年嵌入式软件工程师面试题，答案也都是深圳福田达内培训中心提供的参考答案，如果想了解更多关于这类的信息或是对这有什么疑问可以打电话咨询0755-82353533。


2011年海康威视嵌入式笔试题：
1、写出你所知道的C关键字
答：
ANSI C一共只有32个关键字:
auto break case char const continue default do double else enum extern float for goto if int long register return short signed static sizeof struct switch typedef union unsigned void volatile while
2、IPV4分为A B C D E五类地址，写出B类地址与C类知道的范围与子网掩码。D类地址的作用。
答：B类IP地址范围：128.0.0.0到191.255.255.255
默认的子网掩码：255.255.0.0
C类IP地址的范围：192.0.0.0到223.255.255.255
默认的子网掩码：255.255.255.0
D类地址用于多点广播（Multicast）。
3、Linux下多线程编程与多进程编程的区别
4、列出目前linux系统能支持的文件系统，列出常用的4个以上
答：yaffs    yaffs2    cramfs    jffs    ramdisk    ext2    nfs
5、定义一个标准的宏MIN，输出两个数中较小的一个。
答：#define MIN((A),(B)) ((A)<(B)?(A):(B))
6、什么是MMU，MMU的作用
答：MMU是Memory Management Unit的缩写. 针对各种CPU, MMU是个可选的配件. MMU负责的是虚拟地址 &O1663;&O1664; 物理地址的转换. 提供硬件机制的内存访问授权.
现 代的多用户多进程操作系统, 需要MMU, 才能达到每个用户进程都拥有自己的独立的地址空间的目标. 使用MMU, OS划分出一段地址区域, 在这块地址区域中, 每个进程看到的内容都不一定一样. 例如MICROSOFT WINDOWS操作系统, 地址4M-2G处划分为用户地址空间. 进程A在地址 0X400000映射了可执行文件. 进程B同样在地址 0X400000映射了可执行文件. 如果A进程读地址0X400000, 读到的是A的可执行文件映射到RAM的内容. 而进程B读取地址0X400000时则读到的是B的可执行文件映射到RAM的内容.
这就是MMU在当中进行地址转换所起的作用.
7、 C语言中，修饰符 volatile 含义是什么？其应用场合有哪些？ 
答：搞嵌入式的童鞋们经常同硬件，中断，RTOS 等打交道，所有这些都要求用到volatile 变量。  
一个定义为 volatile 的变量是说这些变量可能会被意想不到的改变，这样，编译器就不会去假设这个变量的值了，精确的说，优化器在用到这个变量时必须每
次小心的重新读取这个变量的值，而不是使用保存在寄存器里的备份。几个 volatile 的例子：  
1、  并行设备的硬件寄存器（如状态寄存器）。  
2、  一个中断服务子程序中会访问到的非自动变量。  
3、  多线程应用中被几个任务共享的变量。
8、题目给出了一个双向链表的节点定义等，定义一个函数在节点pPrex之后插入节点pNode。
例如：在节点a b之间插入节点x：


上述是我做的A卷，B卷题目有关死锁之类，进制的转换。

FPGA大公司面试笔试数电部分
1：什么是同步逻辑和异步逻辑？（汉王）
同步逻辑是时钟之间有固定的因果关系。异步逻辑是各时钟之间没有固定的因果关系。 答案应该与上面问题一致
〔补充〕：同步时序逻辑电路的特点：各触发器的时钟端全部连接在一起，并接在系统时钟端，只有当时钟脉冲到来时，电路的状态才能改变。改变后的状态将一直保持到下一个时钟脉冲的到来，此时无论外部输入 x 有无变化，状态表中的每个状态都是稳定的。   
     异步时序逻辑电路的特点：电路中除可以使用带时钟的触发器外，还可以使用不带时钟的触发器和延迟元件作为存储元件，电路中没有统一的时钟，电路状态的改变由外部输入的变化直接引起。
 
2：同步电路和异步电路的区别：
  同步电路：存储电路中所有触发器的时钟输入端都接同一个时钟脉冲源，因而所有触发器的状态的变化都与所加的时钟脉冲信号同步。
异步电路：电路没有统一的时钟，有些触发器的时钟输入端与时钟脉冲源相连，这有这些触发器的状态变化与时钟脉冲同步，而其他的触发器的状态变化不与时钟脉冲同步。
 
3：时序设计的实质：
       电路设计的难点在时序设计，时序设计的实质就是满足每一个触发器的建立/保持时间的而要求。
 
4：建立时间与保持时间的概念？
       建立时间：触发器在时钟上升沿到来之前，其数据输入端的数据必须保持不变的时间。
       保持时间：触发器在时钟上升沿到来之后，其数据输入端的数据必须保持不变的时间。
 
不考虑时钟的skew，D2的建立时间不能大于（时钟周期T - D1数据最迟到达时间T1max+T2max）；保持时间不能大于（D1数据最快到达时间T1min+T2min）；否则D2的数据将进入亚稳态并向后级电路传播
 
 
5：为什么触发器要满足建立时间和保持时间？
因为触发器内部数据的形成是需要一定的时间的，如果不满足建立和保持时间，触发器将进入亚稳态，进入亚稳态后触发器的输出将不稳定，在0和1之间变化，这时需要经过一个恢复时间，其输出才能稳定，但稳定后的值并不一定是你的输入值。这就是为什么要用两级触发器来同步异步输入信号。这样做可以防止由于异步输入信号对于本级时钟可能不满足建立保持时间而使本级触发器产生的亚稳态传播到后面逻辑中，导致亚稳态的传播。
（比较容易理解的方式）换个方式理解：需要建立时间是因为触发器的D段像一个锁存器在接受数据，为了稳定的设置前级门的状态需要一段稳定时间；需要保持时间是因为在时钟沿到来之后，触发器要通过反馈来所存状态，从后级门传到前级门需要时间。
 
6：什么是亚稳态？为什么两级触发器可以防止亚稳态传播？
       这也是一个异步电路同步化的问题，具体的可以参考《EDACN技术月刊20050401》。
亚稳态是指触发器无法在某个规定的时间段内到达一个可以确认的状态。使用两级触发器来使异步电路同步化的电路其实叫做“一步同位器”，他只能用来对一位异步信号进行同步。两级触发器可防止亚稳态传播的原理：假设第一级触发器的输入不满足其建立保持时间，它在第一个脉冲沿到来后输出的数据就为亚稳态，那么在下一个脉冲沿到来之前，其输出的亚稳态数据在一段恢复时间后必须稳定下来，而且稳定的数据必须满足第二级触发器的建立时间，如果都满足了，在下一个脉冲沿到来时，第二级触发器将不会出现亚稳态，因为其输入端的数据满足其建立保持时间。同步器有效的条件：第一级触发器进入亚稳态后的恢复时间 + 第二级触发器的建立时间 < = 时钟周期。 
更确切地说，输入脉冲宽度必须大于同步时钟周期与第一级触发器所需的保持时间之和。最保险的脉冲宽度是两倍同步时钟周期。 所以，这样的同步电路对于从较慢的时钟域来的异步信号进入较快的时钟域比较有效，对于进入一个较慢的时钟域，则没有作用 。
 
7：系统最高速度计算（最快时钟频率）和流水线设计思想：
       同步电路的速度是指同步系统时钟的速度，同步时钟愈快，电路处理数据的时间间隔越短，电路在单位时间内处理的数据量就愈大。假设Tco是触发器的输入数据被时钟打入到触发器到数据到达触发器输出端的延时时间；Tdelay是组合逻辑的延时；Tsetup是Ｄ触发器的建立时间。假设数据已被时钟打入D触发器，那么数据到达第一个触发器的Ｑ输出端需要的延时时间是Tco，经过组合逻辑的延时时间为Tdelay，然后到达第二个触发器的Ｄ端，要希望时钟能在第二个触发器再次被稳定地打入触发器，则时钟的延迟必须大于Tco＋Tdelay＋Tsetup，也就是说最小的时钟周期Tmin =Tco＋Tdelay＋Tsetup，即最快的时钟频率Fmax =1/Tmin。FPGA开发软件也是通过这种方法来计算系统最高运行速度Fmax。因为Tco和Tsetup是由具体的器件工艺决定的，故设计电路时只能改变组合逻辑的延迟时间Tdelay，所以说缩短触发器间组合逻辑的延时时间是提高同步电路速度的关键所在。由于一般同步电路都大于一级锁存，而要使电路稳定工作，时钟周期必须满足最大延时要求。故只有缩短最长延时路径，才能提高电路的工作频率。可以将较大的组合逻辑分解为较小的N块，通过适当的方法平均分配组合逻辑，然后在中间插入触发器，并和原触发器使用相同的时钟，就可以避免在两个触发器之间出现过大的延时，消除速度瓶颈，这样可以提高电路的工作频率。这就是所谓"流水线"技术的基本设计思想，即原设计速度受限部分用一个时钟周期实现，采用流水线技术插入触发器后，可用N个时钟周期实现，因此系统的工作速度可以加快，吞吐量加大。注意，流水线设计会在原数据通路上加入延时，另外硬件面积也会稍有增加。
 
8：时序约束的概念和基本策略？
时序约束主要包括周期约束，偏移约束，静态时序路径约束三种。通过附加时序约束可以综合布线工具调整映射和布局布线，是设计达到时序要求。
附加时序约束的一般策略是先附加全局约束，然后对快速和慢速例外路径附加专门约束。附加全局约束时，首先定义设计的所有时钟，对各时钟域内的同步元件进行分组，对分组附加周期约束，然后对FPGA/CPLD输入输出PAD附加偏移约束、对全组合逻辑的PAD TO PAD路径附加约束。附加专门约束时，首先约束分组之间的路径，然后约束快、慢速例外路径和多周期路径，以及其他特殊路径。 
9：附加约束的作用？
    作用：1：提高设计的工作频率（减少了逻辑和布线延时）；2：获得正确的时序分析报告；（静态时序分析工具以约束作为判断时序是否满足设计要求的标准，因此要求设计者正确输入约束，以便静态时序分析工具可以正确的输出时序报告）3：指定FPGA/CPLD的电气标准和引脚位置。
 
10：FPGA设计工程师努力的方向：
SOPC，高速串行I/O，低功耗，可靠性，可测试性和设计验证流程的优化等方面。随着芯片工艺的提高，芯片容量、集成度都在增加，FPGA设计也朝着高速、高度集成、低功耗、高可靠性、高可测、可验证性发展。芯片可测、可验证，正在成为复杂设计所必备的条件，尽量在上板之前查出bug，将发现bug的时间提前，这也是一些公司花大力气设计仿真平台的原因。另外随着单板功能的提高、成本的压力，低功耗也逐渐进入FPGA设计者的考虑范围，完成相同的功能下，考虑如何能够使芯片的功耗最低，据说altera、xilinx都在根据自己的芯片特点整理如何降低功耗的文档。高速串行IO的应用，也丰富了FPGA的应用范围，象xilinx的v2pro中的高速链路也逐渐被应用。 总之，学无止境，当掌握一定概念、方法之后，就要开始考虑FPGA其它方面的问题了。 
 
11：对于多位的异步信号如何进行同步？
       对以一位的异步信号可以使用“一位同步器进行同步”，而对于多位的异步信号，可以采用如下方法：1：可以采用保持寄存器加握手信号的方法（多数据，控制，地址）；2：特殊的具体应用电路结构,根据应用的不同而不同 ；3：异步FIFO。（最常用的缓存单元是DPRAM）
 
12：FPGA和CPLD的区别？
FPGA是可编程ASIC。  
ASIC:专用集成电路，它是面向专门用途的电路，专门为一个用户设计和制造的。根据一个用户的特定要求，能以低研制成本，短、交货周期供货的全定制，半定制集成电路。与门阵列等其它ASIC(ApplicaTIon Specific IC)相比，它们又具有设计开发周期短、设计制造成本低、开发工具先进、标准产品无需测试、质量稳定以及可实时在线检验等优点。
 
 
CPLD
FPGA
内部结构
Product－term
Look－up Table
程序存储
内部EEPROM
SRAM，外挂EEPROM
资源类型
组合电路资源丰富
触发器资源丰富
集成度
低
高
使用场合
完成控制逻辑
能完成比较复杂的算法
速度
慢
快
其他资源
－
PLL、RAM和乘法器等
保密性
可加密
一般不能保密
 
 
13：锁存器（latch）和触发器（flip-flop）区别？
       电平敏感的存储期间称为锁存器。可分为高电平锁存器和低电平锁存器，用于不同时钟之间的信号同步。
       有交叉耦合的门构成的双稳态的存储原件称为触发器。分为上升沿触发和下降沿触发。可以认为是两个不同电平敏感的锁存器串连而成。前一个锁存器决定了触发器的建立时间，后一个锁存器则决定了保持时间。
 
14：FPGA芯片内有哪两种存储器资源？
       FPGA芯片内有两种存储器资源：一种叫block ram,另一种是由LUT配置成的内部存储器（也就是分布式ram）。Block ram由一定数量固定大小的存储块构成的，使用BLOCK RAM资源不占用额外的逻辑资源，并且速度快。但是使用的时候消耗的BLOCK RAM资源是其块大小的整数倍。
 
15：什么是时钟抖动？
       时钟抖动是指芯片的某一个给定点上时钟周期发生暂时性变化，也就是说时钟周期在不同的周期上可能加长或缩短。它是一个平均值为0的平均变量。
 
16：FPGA设计中对时钟的使用？（例如分频等）
       FPGA芯片有固定的时钟路由，这些路由能有减少时钟抖动和偏差。需要对时钟进行相位移动或变频的时候，一般不允许对时钟进行逻辑操作，这样不仅会增加时钟的偏差和抖动，还会使时钟带上毛刺。一般的处理方法是采用FPGA芯片自带的时钟管理器如PLL,DLL或DCM，或者把逻辑转换到触发器的D输入（这些也是对时钟逻辑操作的替代方案）。
 
17：FPGA设计中如何实现同步时序电路的延时？
       首先说说异步电路的延时实现：异步电路一半是通过加buffer、两级与非门等（我还没用过所以也不是很清楚），但这是不适合同步电路实现延时的。在同步电路中，对于比较大的和特殊要求的延时，一半通过高速时钟产生计数器，通过计数器来控制延时；对于比较小的延时，可以通过触发器打一拍，不过这样只能延迟一个时钟周期。
 
18：FPGA中可以综合实现为RAM/ROM/CAM的三种资源及其注意事项？
       三种资源：block ram;触发器（FF），查找表（LUT）；
注意事项：1：在生成RAM等存储单元时，应该首选block ram 资源；其原因有二：第一：使用block ram等资源，可以节约更多的FF和4-LUT等底层可编程单元。使用block ram可以说是“不用白不用”，是最大程度发挥器件效能，节约成本的一种体现；第二：block ram是一种可以配置的硬件结构，其可靠性和速度与用LUT和register构建的存储器更有优势。2：弄清FPGA的硬件结构，合理使用block ram资源；3：分析block ram容量，高效使用block ram资源；4：分布式ram资源（distribute ram）
 
19：Xilinx中与全局时钟资源和DLL相关的硬件原语：
       常用的与全局时钟资源相关的Xilinx器件原语包括：IBUFG,IBUFGDS,BUFG,BUFGP,BUFGCE,BUFGMUX,BUFGDLL,DCM等。关于各个器件原语的解释可以参考《FPGA设计指导准则》p50部分。
 
20：HDL语言的层次概念？
       HDL语言是分层次的、类型的，最常用的层次概念有系统与标准级、功能模块级，行为级，寄存器传输级和门级。
 
21：查找表的原理与结构？
       查找表（look-up-table）简称为LUT，LUT本质上就是一个RAM。目前FPGA中多使用4输入的LUT，所以每一个LUT可以看成一个有4位地址线的16x1的RAM。 当用户通过原理图或HDL语言描述了一个逻辑电路以后，PLD/FPGA开发软件会自动计算逻辑电路的所有可能的结果，并把结果事先写入RAM,这样，每输入一个信号进行逻辑运算就等于输入一个地址进行查表，找出地址对应的内容，然后输出即可
 
22：ic设计前端到后端的流程和eda工具？
       设计前端也称逻辑设计，后端设计也称物理设计，两者并没有严格的界限，一般涉及到与工艺有关的设计就是后端设计。
       1：规格制定：客户向芯片设计公司提出设计要求。
       2：详细设计：芯片设计公司（Fabless）根据客户提出的规格要求，拿出设计解决方案和具体实现架构，划分模块功能。目前架构的验证一般基于systemC语言，对价后模型的仿真可以使用systemC的仿真工具。例如：CoCentric和Visual Elite等。
       3：HDL编码：设计输入工具：ultra ，visual VHDL等
       4：仿真验证：modelsim
       5：逻辑综合：synplify
       6：静态时序分析：synopsys的Prime Time
       7：形式验证：Synopsys的Formality.
 
23：寄生效应在ic设计中怎样加以克服和利用（这是我的理解，原题好像是说，ic设计过
程中将寄生效应的怎样反馈影响设计师的设计方案）？
 
24：用filp-flop和logic-gate设计一个1位加法器，输入carryin和current-stage，输出
carryout和next-stage？
process(sig_intel)
begin
       case sig_intel is
              when "000" => carryout <= '0';
                                   next_state <= '0';
              when "001" => carryout <= '1';
                                   next_state <= '0';
              when "010" => carryout <= '1';
                                   next_state <= '0';
              when "011" => carryout <= '0';
                                   next_state <= '1';
              when "100" => carryout <= '1';
                                   next_state <= '0';
              when "101" => carryout <= '0';
                                   next_state <= '1';
              when "110" => carryout <= '0';
                                   next_state <= '1';
              when "111" => carryout <= '1';
                                   next_state <= '1';
              when others => carryout <= 'X';
                                   next_state <= 'X';
       end case;
end process;
 
25：设计一个自动饮料售卖机，饮料10分钱，硬币有5分和10分两种，并考虑找零，
1.画出fsm（有限状态机）
2.用verilog编程，语法要符合fpga设计的要求
3.设计工程中可使用的工具及设计大致过程？
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity drink_auto_sale is
         port(clk: in std_logic;
                   reset:in std_logic;
                   sw101:in std_logic;
                   sw102:in std_logic;
                   buy : out std_logic;
                   back: out std_logic);
end drink_auto_sale;
architecture Behavioral of drink_auto_sale is
type state_type is(st0,st1);
signal cs ,ns : state_type;
begin
process(clk,reset)
begin
         if(reset = '1') then
                   cs <= st0;
         elsif(clk'event and clk = '1') then     
                   cs <= ns;
         end if;
end process;
 
process(reset ,cs)
begin
         case cs is
                   when st0 =>        if( sw101 = '1') then
                                                                 ns <= st1;
                                                                 buy<= '0';
                                                                 back<= '0';
                                                        elsif(sw102 = '1') then
                                                                 ns <= st0;
                                                                 buy<= '1';
                                                                 back <= '0';
                                                        else
                                                                 ns <= st0 ;
                                                                 buy <= '0';
                                                                 back <= '0';
                                                        end if;
                   when st1 => if(sw101 = '1') then
                                                                 ns <= st0;
                                                                 buy <= '1';
                                                                 back <= '0';
                                                        elsif(sw102 = '1') then
                                                                 ns <= st0;
                                                                 buy <= '1';
                                                                 back <= '1';
                                                        end if;
                   when others => ns <= st0;
                                                                 buy<= '0';
                                                                 back <= '0';
         end  case;
end process;
end Behavioral;
设计过程：设定三个状态：0分，5分；当状态为0分时，接收到5分信号脉冲后转为5分；接收到10分信号脉冲时，转到0分状态，同时弹出饮料，不找零；状态为5分时，接受到5分信号，弹出饮料，不找零，返回0分状态；当接受到10分状态时，弹出饮料，找零，并返回零分状态。
所用设计工具：ISE7.1，modelsim,synplify
（不知道为什么上面的状态机设计在synplify的RTL view中没能看到状态机流程图，所以状态转移图就没画）。
 
26：什么是"线与"逻辑,要实现它,在硬件特性上有什么具体要求?
       线与逻辑是两个输出信号相连可以实现与的功能。在硬件上,要用oc门来实现,由于不用 oc门可能使灌电流过大,而烧坏逻辑门. 同时在输出端口应加一个上拉电阻。Oc门就是集电极开路门。
 
27：什么是竞争与冒险现象?怎样判断?如何消除?
       在组合电路中，某一输入变量经过不同途径传输后，到达电路中某一汇合点的时间有先有后，这种现象称竞争；由于竞争而使电路输出发生瞬时错误的现象叫做冒险。（也就是由于竞争产生的毛刺叫做冒险）。判断方法：代数法（如果布尔式中有相反的信号则可能产生竞争和冒险现象）；卡诺图：有两个相切的卡诺圈并且相切处没有被其他卡诺圈包围，就有可能出现竞争冒险；实验法：示波器观测；
解决方法：1：加滤波电路，消除毛刺的影响；2：加选通信号，避开毛刺；3：增加冗余项消除逻辑冒险。
28：你知道那些常用逻辑电平?TTL与COMS电平可以直接互连吗？
常用逻辑电平：TTL、CMOS、LVTTL、LVCMOS、ECL（Emitter Coupled Logic）、PECL（Pseudo/Positive Emitter Coupled Logic）、LVDS（Low Voltage Differential Signaling）、GTL（Gunning Transceiver Logic）、BTL（Backplane Transceiver Logic）、ETL（enhanced transceiver logic）、GTLP（Gunning Transceiver Logic Plus）；RS232、RS422、RS485（12V，5V，3.3V）；也有一种答案是：常用逻辑电平：12V，5V，3.3V。TTL和CMOS不可以直接互连，由于TTL是在0.3-3.6V之间，而CMOS则是有在12V的有在5V的。CMOS输出接到TTL是可以直接互连。TTL接到CMOS需要在输出端口加一上拉电阻接到5V或者12V。
cmos的高低电平分别为:Vih>=0.7VDD,Vil<=0.3VDD;Voh>=0.9VDD,Vol<=0.1VDD.
ttl的为:Vih>=2.0v,Vil<=0.8v;Voh>=2.4v,Vol<=0.4v.
用cmos可直接驱动ttl;加上拉电阻后,ttl可驱动cmos.
1、当TTL电路驱动COMS电路时，如果TTL电路输出的高电平低于COMS电路的最低高电平（一般为3.5V），这时就需要在TTL的输出端接上拉电阻，以提高输出高电平的值。
2、OC门电路必须加上拉电阻，以提高输出的搞电平值。
3、为加大输出引脚的驱动能力，有的单片机管脚上也常使用上拉电阻。
4、在COMS芯片上，为了防止静电造成损坏，不用的管脚不能悬空，一般接上拉电阻产生降低输入阻抗，提供泄荷通路。
5、芯片的管脚加上拉电阻来提高输出电平，从而提高芯片输入信号的噪声容限增强抗干扰能力。
6、提高总线的抗电磁干扰能力。管脚悬空就比较容易接受外界的电磁干扰。
7、长线传输中电阻不匹配容易引起反射波干扰，加上下拉电阻是电阻匹配，有效的抑制反射波干扰。
上拉电阻阻值的选择原则包括:
1、从节约功耗及芯片的灌电流能力考虑应当足够大；电阻大，电流小。
2、从确保足够的驱动电流考虑应当足够小；电阻小，电流大。
3、对于高速电路，过大的上拉电阻可能边沿变平缓。综合考虑以上三点,通常在1k到10k之间选取。对下拉电阻也有类似道理。
OC门电路必须加上拉电阻，以提高输出的搞电平值。
OC门电路要输出“1”时才需要加上拉电阻不加根本就没有高电平
在有时我们用OC门作驱动（例如控制一个 LED）灌电流工作时就可以不加上拉电阻
OC门可以实现“线与”运算
OC门就是   集电极 开路 输出
总之加上拉电阻能够提高驱动能力。
 
29：IC设计中同步复位与异步复位的区别？
同步复位在时钟沿采复位信号，完成复位动作。异步复位不管时钟，只要复位信号满足条件，就完成复位动作。异步复位对复位信号要求比较高，不能有毛刺，如果其与时钟关系不确定，也可能出现亚稳态。
 
30：MOORE 与 MEELEY状态机的特征？
       Moore 状态机的输出仅与当前状态值有关, 且只在时钟边沿到来时才会有状态变化。
       Mealy 状态机的输出不仅与当前状态值有关, 而且与当前输入值有关。
 
31：多时域设计中,如何处理信号跨时域？
       不同的时钟域之间信号通信时需要进行同步处理，这样可以防止新时钟域中第一级触发器的亚稳态信号对下级逻辑造成影响。信号跨时钟域同步：当单个信号跨时钟域时，可以采用两级触发器来同步；数据或地址总线跨时钟域时可以采用异步fifo来实现时钟同步；第三种方法就是采用握手信号。
 
32：说说静态、动态时序模拟的优缺点？
静态时序分析是采用穷尽分析方法来提取出整个电路存在的所有时序路径，计算信号在这些路径上的传播延时，检查信号的建立和保持时间是否满足时序要求，通过对最大路径延时和最小路径延时的分析，找出违背时序约束的错误。它不需要输入向量就能穷尽所有的路径，且运行速度很快、占用内存较少，不仅可以对芯片设计进行全面的时序功能检查，而且还可利用时序分析的结果来优化设计，因此静态时序分析已经越来越多地被用到数字集成电路设计的验证中。
动态时序模拟就是通常的仿真，因为不可能产生完备的测试向量，覆盖门级网表中的每一条路径。因此在动态时序分析中，无法暴露一些路径上可能存在的时序问题；
 
33：一个四级的Mux,其中第二级信号为关键信号 如何改善timing.？
       关键：将第二级信号放到最后输出一级输出，同时注意修改片选信号，保证其优先级未被修改。（为什么？）
 
34：给出一个门级的图,又给了各个门的传输延时,问关键路径是什么,还问给出输入, 使得输出依赖于关键路径？
 
35：为什么一个标准的倒相器中P管的宽长比要比N管的宽长比大?
       和载流子有关，P管是空穴导电，N管是电子导电，电子的迁移率大于空穴，同样的电场下，N管的电流大于P管，因此要增大P管的宽长比，使之对称，这样才能使得两者上升时间下降时间相等、高低电平的噪声容限一样、充电放电的时间相等。
36：用mos管搭出一个二输入与非门？
       <数字电子技术基础>49页
 
37：画出NOT,NAND,NOR的符号,真值表,还有transistor level的电路？
省略
38：画出CMOS的图,画出tow-to-one mux gate.(威盛VIA 2003.11.06 上海笔试试题) ？
 
39：用一个二选一mux和一个inv实现异或？
其中:B连接的是地址输入端A和A非连接的是数据选择端,F对应的的是输出端,使能端固定接地置零(没有画出来).
 
40：画出CMOS电路的晶体管级电路图,实现Y=A*B+C(D+E).(仕兰微电子)？
 
41：用与非门等设计全加法器？（华为）
       《数字电子技术基础》57页。 ； .
 
42：A,B,C,D,E进行投票,多数服从少数,输出是F(也就是如果A,B,C,D,E中1的个数比0 多,那么F输出为1,否则F为0),用与非门实现,输入数目没有限制？
  F= ABC + ABD + ABE +ACD + ACE+ ADE + BCD + BCE + CDE + BDE
 
43：画出一种CMOS的D锁存器的电路图和版图？
 
44：LATCH和DFF的概念和区别？
 
45：latch与register的区别,为什么现在多用register.行为级描述中latch如何产生的？
       latch是电平触发，register是边沿触发，register在同一时钟边沿触发下动作，符合同步电路的设计思想，而latch则属于异步电路设计，往往会导致时序分析困难，不适当的应用latch则会大量浪费芯片资源。
 
46：用D触发器做个二分频的电路？画出逻辑电路？
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
 
entity two_de_fre is
         port(clk: in std_logic;
                            reset:in std_logic;
                            clk_out: out std_logic) ;
end two_de_fre;
architecture Behavioral of two_de_fre is
signal sig_clk: std_logic;
begin
process(clk)
begin
         if(reset = '1') then
                   sig_clk <= '0';
         elsif(clk'event and clk = '1') then
                   sig_clk <= not sig_clk;
         end if;
end process;
clk_out <= sig_clk;       
end Behavioral;
显示工程设计中一般不采用这样的方式来设计，二分频一般通过DCM来实现。通过DCM得到的分频信号没有相位差。
 
47：什么是状态图？
       状态图是以几何图形的方式来描述时序逻辑电路的状态转移规律以及输出与输入的关系。
 
48：用你熟悉的设计方式设计一个可预置初值的7进制循环计数器,15进制的呢？
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity seven_counter is
         port(reset:in std_logic;
                            clk: in std_logic;
                            counter_out std_logic_vector(2 downto 0));
end seven_counter;
architecture Behavioral of seven_counter is
signal sig_counter : std_logic_vector(2 downto 0);
begin
process(reset,clk)
begin
         if(reset = '1') then
                   sig_count <= "101" ;  --初值为5
         elsif(clk'event and clk = '1') then
                   sig_count <= sig_count + 1;
         end if;
end process;
counter_out <= sig_counter;                                                                                                                 
end Behavioral;
 
15进制计数器设计只需将counter_out和sig_counter改为4位就行;
 
49：你所知道的可编程逻辑器件有哪些？
       PAL,PLD,CPLD,FPGA
 
50：用VERILOG或VHDL写一段代码,实现消除一个glitch？
将传输过来的信号经过两级触发器就可以消除毛刺。（这是我自己采用的方式：这种方式消除毛刺是需要满足一定条件的，并不能保证一定可以消除）
 
51：sram,falsh memory,及dram的区别?
sram：静态随机存储器，存取速度快，但容量小，掉电后数据会丢失，不像DRAM 需要不停的REFRESH，制造成本较高，通常用来作为快取(CACHE) 记忆体使用
flash：闪存，存取速度慢，容量大，掉电后数据不会丢失
dram：动态随机存储器，必须不断的重新的加强(REFRESHED) 电位差量，否则电位差将降低至无法有足够的能量表现每一个记忆单位处于何种状态。价格比sram便宜，但访问速度较慢，耗电量较大，常用作计算机的内存使用。
 
52：有四种复用方式，频分多路复用，写出另外三种？
       四种复用方式：频分多路复用（FDMA），时分多路复用（TDMA），码分多路复用（CDMA），波分多路复用（WDM）
 
53：ASIC设计流程中什么时候修正Setup time violation 和Hold time violation?如何修正？
见前面的建立时间和保持时间
 
54：给出一个组合逻辑电路，要求分析逻辑功能。
       所谓组合逻辑电路的分析，就是找出给定逻辑电路输出和输入之间的关系，并指出电路的逻辑功能。
       分析过程一般按下列步骤进行：
1：根据给定的逻辑电路，从输入端开始，逐级推导出输出端的逻辑函数表达式。
2：根据输出函数表达式列出真值表；
3：用文字概括处电路的逻辑功能；
 
55：如何防止亚稳态？
1 降低系统时钟频率
2 用反应更快的FF
3 引入同步机制，防止亚稳态传播（可以采用前面说的加两级触发器）。
4 改善时钟质量，用边沿变化快速的时钟信号
 
56：基尔霍夫定理的内容
基尔霍夫定律包括电流定律和电压定律：
电流定律：在集总电路中，任何时刻，对任一节点，所有流出节点的支路电流的代数和恒等于零。
电压定律：在集总电路中，任何时刻，沿任一回路，所有支路电压的代数和恒等于零。
 
57：描述反馈电路的概念，列举他们的应用。
反馈，就是在电路系统中，把输出回路中的电量输入到输入回路中去。
反馈的类型有：电压串联负反馈、电流串联负反馈、电压并联负反馈、电流并联负反馈。
负反馈的优点：降低放大器的增益灵敏度，改变输入电阻和输出电阻，改善放大器的线性和非线性失真，有效地扩展放大器的通频带，自动调节作用。
电压负反馈的特点：电路的输出电压趋向于维持恒定。
电流负反馈的特点：电路的输出电流趋向于维持恒定。
58：有源滤波器和无源滤波器的区别
无源滤波器：这种电路主要有无源元件R、L和C组成
有源滤波器：集成运放和R、C组成，具有不用电感、体积小、重量轻等优点。
集成运放的开环电压增益和输入阻抗均很高，输出电阻小，构成有源滤波电路后还具有一定的电压放大和缓冲作用。但集成运放带宽有限，所以目前的有源滤波电路的工作频率难以做得很高。
 
59：什么叫做OTP片、掩膜片，两者的区别何在？
OTP means one time program，一次性编程
MTP means multi time program，多次性编程
OTP（One Time Program）是MCU的一种存储器类型
MCU按其存储器类型可分为MASK(掩模)ROM、OTP(一次性可编程)ROM、FLASHROM等类型。
MASKROM的MCU价格便宜，但程序在出厂时已经固化，适合程序固定不变的应用场合；
FALSHROM的MCU程序可以反复擦写，灵活性很强，但价格较高，适合对价格不敏感的应用场合或做开发用途；
OTP ROM的MCU价格介于前两者之间，同时又拥有一次性可编程能力，适合既要求一定灵活性，又要求低成本的应用场合，尤其是功能不断翻新、需要迅速量产的电子产品。
60、单片机上电后没有运转，首先要检查什么？
首先应该确认电源电压是否正常。用电压表测量接地引脚跟电源引脚之间的电压，看是否是电源电压，例如常用的5V。
接下来就是检查复位引脚电压是否正常。分别测量按下复位按钮和放开复位按钮的电压值，看是否正确。
然后再检查晶振是否起振了，一般用示波器来看晶振引脚的波形，注意应该使用示波器探头的“X10”档。另一个办法是测量复位状态下的IO口电平，按住复位键不放，然后测量IO口（没接外部上拉的P0口除外）的电压，看是否是高电平，如果不是高电平，则多半是因为晶振没有起振。
另外还要注意的地方是，如果使用片内ROM的话（大部分情况下如此，现在已经很少有用外部扩ROM的了），一定要将EA引脚拉高，否则会出现程序乱跑的情况。有时用仿真器可以，而烧入片子不行，往往是因为EA引脚没拉高的缘故（当然，晶振没起振也是原因只一）。经过上面几点的检查，一般即可排除故障了。如果系统不稳定的话，有时是因为电源滤波不好导致的。在单片机的电源引脚跟地引脚之间接上一个0.1uF的电容会有所改善。如果电源没有滤波电容的话，则需要再接一个更大滤波电容，例如220uF的。遇到系统不稳定时，就可以并上电容试试（越靠近芯片越好）。
 
61：给了reg的setup,hold时间，求中间组合逻辑的delay范围
       Delay < period - setup – hold
 
62：时钟周期为T,触发器D1的寄存器到输出时间最大为T1max，最小为T1min。组合逻辑电路最大延迟为T2max,最小为T2min。问，触发器D2的建立时间T3和保持时间应满足什么条件
T3setup>T+T2max,T3hold>T1min+T2min
 
63：用传输门和倒向器搭一个边沿触发器。（扬智电子笔试）
 
64：用逻辑们画出D触发器。（威盛VIA 2003.11.06 上海笔试试题）
 
65：16分频电路中需要多少触发器？
 
66：阻塞式赋值和非组塞式赋值的区别？
非阻塞赋值：块内的赋值语句同时赋值，一般用在时序电路描述中。
阻塞赋值：完成该赋值语句后才能做下一句的操作，一般用在组合逻辑描述中。
 
67：74、用FSM实现101101的序列检测模块。（南山之桥）
a为输入端，b为输出端，如果a连续输入为1101则b输出为1，否则为0。
例如a： 0001100110110100100110
b： 0000000000100100000000
请画出state machine；请用RTL描述其state machine。（未知）
 
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
entity detect_stream is
         port(clk: in std_logic;
                            reset: in std_logic;
                            data: in std_logic;
                            result : out std_logic);
end detect_stream;
architecture Behavioral of detect_stream is
type state_type is (idle,st0,st1,st2);
signal cs ,ns : state_type;
signal sig_result :std_logic;
begin
process(clk,reset)
begin
         if(reset = '1') then
                   cs <= idle;
                   result <= '0';
         elsif(clk'event and clk = '1')  then
                   cs  <= ns;
                   result <= sig_result;
         end if;
end process;
process(cs,clk)
begin
                   case cs is
                            when idle => if(data = '1') then
                                                                                    ns <= st0;
                                                                                    sig_result <= '0';
                                                                           else
                                                                                    ns <= idle;
                                                                                    sig_result <= '0';
                                                                           end if;
                            when st0 => if(data = '1') then
                                                                           ns <= st1;
                                                                           sig_result <= '0';
                                                                 else 
                                                                           ns <= idle;
                                                                           sig_result <= '0';
                                                                 end if;
                            when st1 => if(data = '0')then
                                                                           ns <= st2;
                                                                           sig_result <= '0';
                                                                 else
                                                                           ns <= idle;
                                                                           sig_result <= '0';
                                                                 end if;
                            when st2 => ns <= idle;
                                                                 if(data = '1') then
                                                                           sig_result <= '1';
                                                                 else
                                                                           sig_result <= '0';
                                                                 end if;
                            end case;
end process;
end Behavioral;
状态图： 
 
 
68：用verilog/vhdl写一个fifo控制器(包括空，满，半满信号)。（飞利浦－大唐笔试）
reg[N-1:0] memory[0:M－1]; 定义FIFO为N位字长容量M
八个always模块实现，两个用于读写FIFO，两个用于产生头地址head和尾地址tail，一个产生counter计数，剩下三个根据counter的值产生空，满，半满信号产生空，满，半满信号。
 
69：现有一用户需要一种集成电路产品，要求该产品能够实现如下功能：y=lnx，其中，x为4位二进制整数输入信号。y为二进制小数输出，要求保留两位小数。电源电压为3~5v假设公司接到该项目后，交由我们来负责该产品的设计，试讨论该产品的设计全程。（仕兰微电子）
 
70：iir，fir滤波器的异同


16道嵌入式Ｃ语言面试题
1. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情：
1). #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
2). 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
3). 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
4). 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。

2. 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。

#define MIN(A,B) ((A) <= (B) (A) : (B))
这个测试是为下面的目的而设的：
1). 标识#define在宏中应用的基本知识。这是很重要的，因为直到嵌入(inline)操作符变为标准C的一部分，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
2). 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
3). 懂得在宏中小心地把参数用括号括起来
4). 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
least = MIN(*p++, b);
3. 预处理器标识#error的目的是什么？
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种
问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。
死循环（Infinite loops）
4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
这个问题用几个解决方案。我首选的方案是：
while(1) { }
一些程序员更喜欢如下方案：
for(;;) { }
这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的
基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我留下一个坏印象。
第三个方案是用 goto
Loop:
...
goto Loop;
应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。
数据声明（Data declarations）
5. 用变量a给出下面的定义
a) 一个整型数（An integer）
b) 一个指向整型数的指针（A pointer to an integer）
c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）
d) 一个有10个整型数的数组（An array of 10 integers）
e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）
f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数 （ An array of ten pointers to functions that take an integer argument and return an integer ）
答案是：
a) int a; // An integer
b) int *a; // A pointer to an integer
c) int **a; // A pointer to a pointer to an integer
d) int a[10]; // An array of 10 integers
e) int *a[10]; // An array of 10 pointers to integers
f) int (*a)[10]; // A pointer to an array of 10 integers
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer

人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。
但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道
所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？

Static
6. 关键字static的作用是什么？
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。

Const
7．关键字const是什么含意？
我 只要一听到被面试者说：“const意味着常数”，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有 用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着“只读”就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意思？
const int a;
int const a;
const int *a;
int * const a;
int const * a const;
前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
1). 关键字const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
2). 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
3). 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。
Volatile
8. 关键字volatile有什么含意 并给出三个不同的例子。
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。
假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
1). 一个参数既可以是const还可以是volatile吗？解释为什么。
2). 一个指针可以是volatile 吗？解释为什么。
3). 下面的函数有什么错误：
int square(volatile int *ptr)
{
return *ptr * *ptr;
}
下面是答案：
1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
int square(volatile int *ptr)
{
int a,b;
a = *ptr;
b = *ptr;
return a * b;
}
由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
long square(volatile int *ptr)
{
int a;
a = *ptr;
return a * a;
}
位操作（Bit manipulation）
9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
对这个问题有三种基本的反应
1). 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
2). 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式 来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
3). 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
#define BIT3 (0x1<<3)
static int a;
void set_bit3(void)
{
a |= BIT3;
}
void clear_bit3(void)
{
a &= ~BIT3;
}
一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。
访问固定的内存位置（Accessing fixed memory locations）
10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
int *ptr;
ptr = (int *)0x67a9;
*ptr = 0xaa55;
一个较晦涩的方法是：
*(int * const)(0x67a9) = 0xaa55;
即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。
中断（Interrupts）
11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
__interrupt double compute_area (double radius)
{
     double area = PI * radius * radius;
     printf(" Area = %f", area);
     return area;
}
这个函数有太多的错误了，以至让人不知从何说起了：
1). ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
2). ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
3). 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
4). 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。
代码例子（Code examples）
12 . 下面的代码输出是什么，为什么？
void foo(void)
{
     unsigned int a = 6;
     int b = -20;
     (a+b > 6) puts("> 6") : puts("<= 6");
}
这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是“>6”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。
13. 评价下面的代码片断：
unsigned int zero = 0;
unsigned int compzero = 0xFFFF;
/*1's complement of zero */
对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：
unsigned int compzero = ~0;
这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧…
 
动态内存分配（Dynamic memory allocation）
 
14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
这 里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？
char *ptr;
if ((ptr = (char *)malloc(0)) == NULL)
puts("Got a null pointer");
else
puts("Got a valid pointer");
这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是“Got a valid pointer”。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。
Typedef
15. Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
#define dPS struct s *
typedef struct s * tPS;
以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：
dPS p1,p2;
tPS p3,p4;
第一个扩展为
struct s * p1, p2;
上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。
晦涩的语法
16. C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
int a = 5, b = 7, c;
c = a+++b;
这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：
c = a++ + b;
因此, 这段代码持行后a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是:这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题



童梦无忧网 试管婴儿论坛www.tm51.com


    本文由wyhsld36贡献
    doc文档可能在WAP端浏览体验不佳。建议您优先选择TXT，或下载源文件到本机查看。
    > 预 处 理器(Preprocessor) 1. 用预 处 理指令#define 声明一个常数,用以表明 1 年中有多少秒(忽略闰 年问 问 ) #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL 我在这 想看到几件事情: 1). #define 语 法的基本知识 (例如:不能以分号结 束,括号的使用,等等) 2). 懂得预 处 理器将为 你计 算常数表达式的值 ,因此,直接写出你是如何计 算一年中 有多少秒而不是计 算出实 实 的值 ,是更清晰而没有代价的. 3). 意识 到这 个表达式将使一个 16 位机的整型数溢出-因此要用到长 整型符号 L,告诉 编
    编 器这 个常数是的长 整型数.
    4). 如果你在你的表达式中用到 UL(表示无符号长 整型),那么 你有了一个好的起点.
    记 住,第一印象很重要.
    2. 写一个"让 准"宏 MIN,这 个宏输 入两个参数并返回较 小的一个. #define MIN(A,B) ((A) <= (B) (A) : (B))
    这 个测 应 是为 下面的目的而欢 的:
    1). 让 识 #define 在宏中应 用的基本知识 .这 是很重要的,因为 直到嵌入(inline)操作符变
    为 让 准 C 的一部分,宏是方便产 生嵌入代码 的唯一方法,对 于嵌入式系统 来说 ,为 了能达到
    要求的性能,嵌入代码 经 常是必须 的方法. 2). 三重条件操作符的知识 .这 个操作符存在 C 语 言中的原因是它使得编 编 器能产 生比 ifthen-else 更优 化的代码 ,了解这 个用法是很重要的. 3). 懂得在宏中小心地把参数用括号括起来 4). 我也用这 个问 问 开 始讨 论 宏的副作用,例如:当你写下面的代码 时 会发 生什么 事?
    least = MIN(*p++, b);
    3. 预 处 理器让 识 #error 的目的是什么 ?
    如果你不知道答案,请 看参考文献 1.这 问 问 对 区分一个正常的伙计 和一个书 呆子是很有用 的.只有书 呆子才会读 C 语 言课 本的附录 去找出象这 种
    问 问 的答案.当然如果你不是在找一个书 呆子,那么 应 应 者最好希望自己不要知道答案.
    死循环 (Infinite loops)
    4. 嵌入式系统 中经 常要用到无限循环 ,你怎么 讨 用 C 编 写死循环 呢?
    这 个问 问 用几个解决方案.我首选 的方案是:
    while(1) { }
    一些程序员 更喜欢 如下方案: for(;;) { }
    这 个实 发 方式让 我为 为 ,因为 这 个语 法没有确切表达到底怎么 回事.如果一个应 应 者值 出 这 个作为 方案,我将用这 个作为 一个机会去探究他们 这 讨 做的
    基本原理.如果他们 的基本答案是:"我被教着这 讨 做,但从没有想到过 为 什么 ."这 会
    值 我留下一个坏印象.
    第三个方案是用 goto Loop: …… goto Loop;
    应 应 者如值 出上面的方案,这 说 明或者他是一个汇 编 语 言程序员 (这 也许 是好事)或者他
    是一个想进 入新领 域的 BASIC/FORTRAN 程序员 .
    数据声明(Data declarations)
    5. 用变 量 a 值 出下面的定义 a) 一个整型数(An integer) b) 一个指向整型数的指针 (A pointer to an integer) c) 一个指向指针 的的指针 ,它指向的指针 是指向一个整型数(A pointer to a pointer to an integer) d) 一个有 10 个整型数的数组 (An array of 10 integers) e) 一个有 10 个指针 的数组 ,该 指针 是指向一个整型数的(An array of 10 pointers to integers) f) 一个指向有 10 个整型数数组 的指针 (A pointer to an array of 10 integers) g) 一个指向函数的指针 ,该 函数有一个整型参数并返回一个整型数(A pointer to a fu nction that takes an integer as an argument and returns an integer) h) 一个有 10 个指针 的数组 ,该 指针 指向一个函数,该 函数有一个整型参数并返回一个整型 数( An array of ten pointers to functions that take an integer argument and r eturn an integer )
    答案是: a) int a; // An integer b) int *a; // A pointer to an integer c) int **a; // A pointer to a pointer to an integer d) int a[10]; // An array of 10 integers e) int *a[10]; // An array of 10 pointers to integers f) int (*a)[10]; // A pointer to an array of 10 integers g) int (*a)(int); // A pointer to a function a that takes an integer argument
    and returns an integer h) int (*a[10])(int); // An array of 10 pointers to functions that take an int eger argument and return an integer
    人们 经 常声称这 里有几个问 问 是那种 要翻一下书 才能回答的问 问 ,我同意这 种 说 法.当我 写这 篇文章时 ,为 了确定语 法的正确性,我的确查 了一下书 . 但是当我被面应 的时 候,我期望被问 到这 个问 问 (或者相近的问 问 ).因为 在被面应 的这 段时 时 里,我确定我知道这 个问 问 的答案.应 应 者如果不知道 所有的答案(或至少大部分答案),那么 也就没有为 这 次面应 做准备 ,如果该 面应 者没有
    为 这 次面应 做准备 ,那么 他又能为 什么 出准备 呢?
    Static
    6. 关 关 字 static 的作用是什么 ?
    这 个简 简 的问 问 很少有人能回答完全.在 C 语 言中,关 关 字 static 有三个明显 的作用:
    1). 在函数体,一个被声明为 静动 的变 量在这 一函数被调 用过 程中维 持其值 不变 . 2). 在模块 内(但在函数体外),一个被声明为 静动 的变 量可以被模块 内所用函数访 问 , 但不能被模块 外其它函数访 问 .它是一个本地的全局变 量. 3). 在模块 内,一个被声明为 静动 的函数只可被这 一模块 内的其它函数调 用.那就是,这 个函数被限制在声明它的模块 的本地范围 内使用. 大多数应 应 者能正确回答第一部分,一部分能正确回答第二部分,同是很少的人能懂得第 三部分.这 是一个应 应 者的严 重的缺点,因为 他显 然不懂得本地化数据和代码 范围 的好处 和重要性.
    Const
    7.关 关 字 const 是什么 含意? 我只要一听到被面应 者说 :"const 意味着常数",我就知道我正在和一个业 余者打交道. 去年 Dan Saks 已经 在他的文章里完全概括了 const 的所有用法,因此 ESP(编 者:Embedded Systems Programming)的须 一位读 者应 该 非常熟悉 const 能做什么 和不能做什么 .如果你从 没有读 到那篇文章,只要能说 出 const 意味着"只读 "就可以了.尽管这 个答案不是完全的 答案,但我接受它作为 一个正确的答案.(如果你想知道更详 细 的答案,仔细 读 一下 Saks 的文章吧.)如果应 应 者能正确回答这 个问 问 ,我将问 他一个附加的问 问 :下面的声明都 是什么 意思?
    const int a; int const a; const int *a; int * const a;
    int const * a const;
    前两个的作用是一讨 ,a 是一个常整型数.第三个意味着 a 是一个指向常整型数的指针 (也 就是,整型数是不可修改的,但指针 可以).第四个意思 a 是一个指向整型数的常指针 (也 就是说 ,指针 指向的整型数是可以修改的,但指针 是不可修改的).最后一个意味着 a 是一 个指向常整型数的常指针 (也就是说 ,指针 指向的整型数是不可修改的,同时 指针 也是不 可修改的).如果应 应 者能正确回答这 些问 问 ,那么 他就值 我留下了一个好印象.顺 顺 提 一句,也许 你可能会问 ,即使不用关 关 字 const,也统 是能很容易写出功能正确的程序,那
    么 我为 什么 统 要如此看重关 关 字 const 呢?我也如下的几下理由:
    1). 关 关 字 const 的作用是为 值 读 你代码 的人值 达非常有用的信息,实 实 上,声明一个参数
    为 常量是为 了告诉 了用户 这 个参数的应 用目的.如果你曾花很多时 时 清理其它人留下的垃
    圾,你就会很快学会感谢 这 点多余的信息.(当然,懂得用 const 的程序员 很少会留下的垃 圾让 让 人来清理的.) 2). 通过 值 优 化器一些附加的信息,使用关 关 字 const 也许 能产 生更紧 凑的代码 . 3). 合理地使用关 关 字 const 可以使编 编 器很自然地保护 那些不希望被改变 的参数,防止其 被无意的代码 修改.简 而言之,这 讨 可以减少 bug 的出发 .
    Volatile
    8. 关 关 字 volatile 有什么 含意 并值 出三个不同的例子.
    一个定义 为 volatile 的变 量是说 这 变 量可能会被意想不到地改变 ,这 讨 ,编 编 器就不会去 假欢 这 个变 量的值 了.精确地说 就是,优 化器在用到这 个变 量时 必须 须 次都小心地重新读 取这 个变 量的值 ,而不是使用保存在寄存器里的备 份.下面是 volatile 变 量的几个例子:
    1). 并行欢 备 的硬件寄存器(如:状动 寄存器) 2). 一个中断服务 子程序中会访 问 到的非自动 变 量(Non-automatic variables) 3). 多线 程应 用中被几个任务 共享的变 量 回答不出这 个问 问 的人是不会被雇佣的.我认 为 这 是区分 C 程序员 和嵌入式系统 程序员 的最 基本的问 问 .嵌入式系统 程序员 经 常同硬件,中断,RTOS 等等打交道,所用这 些都要求 vo latile 变 量.不懂得 volatile 内容将会顺 来灾为 . 假欢 被面应 者正确地回答了这 是问 问 (嗯 ,怀 疑这 否会是这 讨 ),我将稍微深究一下,看 一下这 家伙是不是直正懂得 volatile 完全的重要性. 1). 一个参数既可以是 const 统 可以是 volatile 吗 ?解释 为 什么 . 2). 一个指针 可以是 volatile 吗 ?解释 为 什么 . 3). 下面的函数有什么 错 错 : int square(volatile int *ptr) { return *ptr * *ptr; }
    下面是答案: 1). 是的.一个例子是只读 的状动 寄存器.它是 volatile 因为 它可能被意想不到地改变 . 它是 const 因为 程序不应 该 应 图 去修改它. 2). 是的.尽管这 并不很常见 .一个例子是当一个中服务 子程序修该 一个指向一个 buffer 的指针 时 . 3). 这 段代码 的有个恶 作剧 .这 段代码 的目的是用来返指针 *ptr 指向值 的平方,但是,由 于*ptr 指向一个 volatile 型参数,编 编 器将产 生类 似下面的代码 : int square(volatile int *ptr) { int a,b; a = *ptr; b = *ptr; return a * b; } 由于*ptr 的值 可能被意想不到地该 变 ,因此 a 和 b 可能是不同的.结 果,这 段代码 可能返不 是你所期望的平方值 !正确的代码 如下: long square(volatile int *ptr) { int a; a = *ptr; return a * a; }
    位操作(Bit manipulation)
    9. 嵌入式系统 统 是要用户 对 变 量或寄存器进 行位操作.值 定一个整型变 量 a,写两段代码 ,第一个欢 置 a 的 bit 3,第二个清除 a 的 bit 3.在以上两个操作中,要保持其它位不变 .
    对 这 个问 问 有三种 基本的反应
    1). 不知道如何下手.该 被面者从没做过 任何嵌入式系统 的工作. 2). 用 bit fields.Bit fields 是被扔到 C 语 言死角的东 西,它保证 你的代码 在不同编 编 器 之时 是不可移植的,同时 也保证 了的你的代码 是不可重用的.我最近不幸看到 Infineon 为 其较 较 杂 的通信芯片写的驱 动 程序,它用到了 bit fields 因此完全对 我无用,因为 我的编
    编 器用其它的方式来实 发 bit fields 的.从道德讲 :永释 不要让 一个非嵌入式的家伙粘实 实 硬件的边 .
    3). 用 #defines 和 bit masks 操作.这 是一个有极高可移植性的方法,是应 该 被用到的 方法.最佳的解决方案如下: #define BIT3 (0x1<<3) static int a;
    void set_bit3(void) { a |= BIT3; } void clear_bit3(void) { a &= ~BIT3; } 一些人喜欢 为 欢 置和清除值 而定义 一个掩码 同时 定义 一些说 明常数,这 也是可以接受的. 我希望看到几个要点:说 明常数,|=和&=~操作.
    访 问 固定的内存位置(Accessing fixed memory locations)
    10. 嵌入式系统 经 常具有要求程序员 去访 问 某特定的内存位置的特点.在某工程中,要求
    欢 置一绝 对 地址为 0x67a9 的整型变 量的值 为 0xaa66.编 编 器是一个纯 粹的 ANSI 编 编 器.写
    代码 去完成这 一任务 .
    这 一问 问 测 应 你是否知道为 了访 问 一绝 对 地址把一个整型数强 制动 动 (typecast)为 一指 针 是合法的.这 一问 问 的实 发 方式随着个人风 格不同而不同.典型的类 似代码 如下:
    int *ptr; ptr = (int *)0x67a9; *ptr = 0xaa55;
    一个较 晦涩 的方法是: *(int * const)(0x67a9) = 0xaa55; 即使你的品味更接近第二种 方案,但我建议 你在面应 时 使用第一种 方案.
    中断(Interrupts)
    11. 中断是嵌入式系统 中重要的组 成部分,这 这 致了很多编 编 开 发 商提供一种 扩 展—让 让 准 C 支持中断.具代表事实 是,产 生了一个新的关 关 字__interrupt.下面的代码 就使用了 __interrupt 关 关 字去定义 了一个中断服务 子程序(ISR),请 评 论 一下这 段代码 的. __interrupt double compute_area (double radius) { double area = PI * radius * radius; printf(" Area = %f", area); return area; }
    这 个函数有太多的错 错 了,以至让 人不知从何说 起了:
    1). ISR 不能返回一个值 .如果你不懂这 个,那么 你不会被雇用的.
    2). ISR 不能值 传 参数.如果你没有看到这 一点,你被雇用的机会等同第一项 . 3). 在许 多的处 理器/编 编 器中,浮点一般都是不可重入的.有些处 理器/编 编 器需要让 让
    处 的寄存器入栈 ,有些处 理器/编 编 器就是不允许 在 ISR 中做浮点运算.此外,ISR 应 该 是短
    而有效率的,在 ISR 中做浮点运算是不明智的. 4). 与第三点一脉相承,printf()经 常有重入和性能上的问 问 .如果你丢 掉了第三和第四 点,我不会太为 为 你的.不用说 ,如果你能得到后两点,那么 你的被雇用前景越来越光明 了.
    代码 例子(Code examples)
    12 . 下面的代码 输 出是什么 ,为 什么 ? void foo(void) { unsigned int a = 6; int b = -20; (a+b > 6) puts("> 6") : puts("<= 6"); }
    这 个问 问 测 应 你是否懂得 C 语 言中的整数自动 动 动 原则 ,我发 发 有些开 发 者懂得极少这 些东
    西.不管如何,这 无符号整型问 问 的答案是输 出是">6".原因是当表达式中存在有符号
    类 型和无符号类 型时 所有的操作数都自动 动 动 为 无符号类 型. 因此-20 变 成了一个非常大
    的正整数,所以该 表达式计 算出的结 果大于 6.这 一点对 于应 当频 繁用到无符号数据类 型的 嵌入式系统 来说 是丰常重要的.如果你答错 了这 个问 问 ,你也就到了得不到这 份工作的边
    缘.
    13. 评 价下面的代码 片断: unsigned int zero = 0; unsigned int compzero = 0xFFFF; /*1's complement of zero */
    对 于一个 int 型不是 16 位的处 理器为 说 ,上面的代码 是不正确的.应 编 写如下:
    unsigned int compzero = ~0;
    这 一问 问 真正能揭 露出应 应 者是否懂得处 理器字长 的重要性.在我的经 测 里,好的嵌入式
    程序员 非常准确地明白硬件的细 节 和它的局限,然而 PC 机程序往往把硬件作为 一个无法避 免的烦 烦 . 到了这 个阶 段,应 应 者或者完全垂过 头 气了或者信心满 满 志在必得.如果显 然应 应 者不是 很好,那么 这 个测 应 就在这 里结 束了.但如果显 然应 应 者做得不错 ,那么 我就扔出下面的 追加问 问 ,这 些问 问 是比较 为 的,我想仅 仅 非常优 秀的应 应 者能做得不错 .提出这 些问 问 ,我希望更多看到应 应 者应 付问 问 的方法,而不是答案.不管如何,你就当是这 个娱 娱 吧
    …
    动 动 内存分配(Dynamic memory allocation)
    14. 尽管不像非嵌入式计 算机那么 常见 ,嵌入式系统 统 是有从堆(heap)中动 动 分配内存 的过 程的.那么 嵌入式系统 中,动 动 分配内存可能发 生的问 问 是什么 ?
    这 里,我期望应 应 者能提到内存碎片,碎片收集的问 问 ,变 量的持行时 时 等等.这 个主问
    已经 在 ESP 杂 志中被广泛地讨 论 过 了(主要是 P.J. Plauger, 他的解释 释 释 超过 我这 里能 提到的任何解释 ),所有回过 过 看一下这 些杂 志吧!让 应 应 者进 入一种 虚假的安全感觉 后 ,我拿出这 么 一个小节 目:下面的代码 片段的输 出是什么 ,为 什么 ?
    char *ptr; if ((ptr = (char *)malloc(0)) == NULL) puts("Got a null pointer"); else puts("Got a valid pointer");
    这 是一个有趣的问 问 .最近在我的一个同事不经 意把 0 值 值 值 了函数 malloc,得到了一个合
    法的指针 之后,我才想到这 个问 问 .这 就是上面的代码 ,该 代码 的输 出是"Got a valid pointer".我用这 个来开 始讨 论 这 讨 的一问 问 ,看看被面应 者是否想到库 例程这 讨 做是正 确.得到正确的答案固然重要,但解决问 问 的方法和你做决定的基本原理更重要些.
    Typedef
    15. Typedef 在 C 语 言中频 繁用以声明一个已经 存在的数据类 型的同义 字.也可以用预 处 理 器做类 似的事.例如,思考一下下面的例子: #define dPS struct s * typedef struct s * tPS;
    以上两种 情况的意图 都是要定义 dPS 和 tPS 作为 一个指向结 构 s 指针 .哪种 方法更好呢? (如果有的话 )为 什么 ?
    这 是一个非常微妙的问 问 ,任何人答对 这 个问 问 (正当的原因)是应 当被恭喜的.答案是
    :typedef 更好.思考下面的例子: dPS p1,p2; tPS p3,p4;
    第一个扩 展为 struct s * p1, p2;
    上面的代码 定义 p1 为 一个指向结 构的指,p2 为 一个实 实 的结 构,这 也许 不是你想要的.第
    二个例子正确地定义 了 p3 和 p4 两个指针 .
    晦涩 的语 法
    16. C 语 言同意一些令人震惊的结 构,下面的结 构是合法的吗 ,如果是它做些什么 ? int a = 5, b = 7, c; c = a+++b;
    这 个问 问 将做为 这 个测 测 的一个愉快的结 尾.不管你相不相信,上面的例子是完全合乎语
    法的.问 问 是编 编 器如何处 理它?水平不高的编 编 作者实 实 上会争论 这 个问 问 ,根据最处 理原则 ,编 编 器应 当能处 理尽可能所有合法的用法.因此,上面的代码 被处 理成: c = a++ + b; 因此, 这 段代码 持行后 a = 6, b = 7, c = 12. 如果你知道答案,或猜出正确答案,做得好.如果你不知道答案,我也不把这 个当作问 问 .我发 发 这 个问 问 的最大好处 是:这 是一个关 于代码 编 写风 格,代码 的可读 性,代码 的可修 改性的好的话 问

1

一.1、简答题。下面的题目必须全部答对才给分(20分)： 
1、 如何在C中初始化一个字符数组。 
2、 如何在C中为一个数组分配空间。 
3、 如何初始化一个指针数组。 
4、 如何定义一个有10个元素的整数型指针数组。 
5、 s[10]的另外一种表达方式是什么。 
6、 GCC3.2.2版本中支持哪几种编程语言。 
7、 要使用CHAR_BIT需要包含哪个头文件。 
8、 对(-1.2345)取整是多少？ 
9、 如何让局部变量具有全局生命期。 
10、C中的常量字符串应在何时定义？ 
11、如何在两个.c文件中引用对方的变量。 
12、使用malloc之前需要做什么准备工作。 
13、realloc函数在使用上要注意什么问题。 
14、strtok函数在使用上要注意什么问题。 
15、gets函数在使用上要注意什么问题。 
16、C语言的词法分析在长度规则方面采用的是什么策略？ 
17、a+++++b所表示的是什么意思？有什么问题？ 
18、如何定义Bool变量的TRUE和FALSE的值。 
19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。 
20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。    
一.2、问答题。 
1、-----------------------------------------------------------    
"匈牙利命名法"有什么优缺点？(2分)   
2、-----------------------------------------------------------    
下面x, y, *p的值是多少，有什么问题？(2分) 
int x, y, z = 2; int *p=&z; x=sizeof*p;
y=x/*p; /* x=?, *p=?, y=?, 有什么问题？*/   
3、-----------------------------------------------------------    
下面的语句是什么意思？如何声明或定义才使它们更易懂？(10分)
int (*foo())(); 
int (*foo())[]; 
int (*foo[])(); 
(*(void(*)())0)();
void (*signal(int,void(*)(int)))(int);    
4、-----------------------------------------------------------     本题(2分)。
一般使用malloc时，需要进行强制类型转换，如： char *s; s = (char *)malloc(31); 
下面中???该如何填写，才可以正确执行强制类型转换？ int (*monthp)[31]; monthp = (???)malloc(31);    
5、-----------------------------------------------------------    
关于C语言运算符优先级的记忆技巧是什么？(2分) /* 下面r的值是多少 */
int hi, low, r; hi=7;low=3; r=hi<<4+low;    
6、-----------------------------------------------------------    
指针和数组的区别是什么？
用一个简单的声明把它们区分开。(2分) 
指针和数组的声明在什么情况下是相同的？(2分)    
7、-----------------------------------------------------------    
C语言的左值(lvalue)和右值(rvalue)的含义是什么？(2分)   
8、-----------------------------------------------------------    
为什么C语言可以实现printf(char *format, ...)这样可变参数的调用形式？这样有什     么缺点？(2分)   
9、-----------------------------------------------------------    
说明C语言中术语"声明""定义""原型"的含义？(2分)    
10、-----------------------------------------------------------    
举一个例子，说明使用assert和防错代码的区别。(5分)    
11、-----------------------------------------------------------    
对语句 if else 与操作符 ? : 使用场合的比较。(2分)    
12、-----------------------------------------------------------    
编写一个函数，输入一个的整型数字，可以选择按照8/10/16进制输出字符串。 注意边界值。(5分)  

13、-----------------------------------------------------------    
本题(2分)。下面是一个16x16的黑白图标： 
static unsigned short stopwatch[] = { 0x07c6, 0x1ff7, 0x383b, 0x600c, 0x600c, 0xc006, 0xc006,
0xdf06, 0xc106, 0xc106, 0x610c, 0x610c, 0x3838, 0x1ff0, 0x07c0, 0x0000, }; 
如何修改声明，可以使之在源代码中形象地表现出图形的模样。    
14、----------------------------------------------------------- 
说出可以使用calendar[11][30]变量的四种类型定义。(5分) 如：int calendar[12][31];   /* 二维数组 */  

15、----------------------------------------------------------- 
使用strcmp，当字符串相同时会返回'\0'。但'\0'一般作为逻辑假， 因此下面的语句不容易理解: 
if (!strcmp(s, "string")) return EQUATION; 如何经过简单修改，使之更易懂？(2分) 
  
16、-----------------------------------------------------------
编写一个自己的完全C语言版本的memset函数，并且评价这个实现的性能和可移植性。(5     分)
   
17、-----------------------------------------------------------
在树和图这些数据结构中，通常使用指针来组织数据。如果我们要把这些数据保存到文     件 中，
指针是没有意义的。我们该如何解决这个问题。(2分)    
18、----------------------------------------------------------- 
用2种不同的方法计算long变量的"1"bit的个数。(2分)    
19、----------------------------------------------------------- 
任意给出一个C的基本数据类型，如何编码判断这个数据类型是有符号还是无符号的？(2     分) 
不得上机实验，写出下面代码的输出。解释这个行为是标准定义的，还是依赖实现的。(     2分)
int i; for (i = 0; i < 10; i++) {      int j = i;      printf ("%d\n", j); } 
  
20、----------------------------------------------------------- 
列出5种以上你所看过的C编程的书籍，并写简要书评。(5分) 对C的评价。如果要你改造一把菜刀，
使之更加安全，你是否会使用这样的菜刀，为什么     ？(5分)
   
一.3、分析题。 本题(各5分)。假设下面代码中的变量都是合法变量，调用外部的函数都是正确的。
回答几个问题:这些代码意图要干什么？ 是否有问题？ 
如果有问题，该如何修改，或者如何避免类似错误发生?如果没有问题，如果代码有输出，输出是什么？ 
1、-----------------------------------------------------------    
int isvowel (char c) {      return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'; }    
2、-----------------------------------------------------------    
while (c=='\t'||c=' '||c=='\n')      c=getc(f);    
3、-----------------------------------------------------------    
/* 当x=2, y=3, z=? */ if (x==0)      if (y==0)          z=-1; else      z=x+y;    
4、-----------------------------------------------------------    
/* 处理网络事件 */ 
void process_network_code(int x, int y) 
{      /* 选择modes_pointer资源 */     
switch (line) {         
case THING1:              /* 处理异常1#, 使用老的modes_pointer资源 */            
    doit1();              break;         
case THING2:              /* 处理异常2#, 需要重新启动服务 */             
   if (x == STUFF) {                  /* 重新申请modes_pointer资源，没有初始化 */                 
    do_first_stuff();                  /* 在这种条件下，有些资源不用重新申请 */                
     if (y == OTHER_STUFF)                     
     break;                  /* 申请剩下的资源，并初始化 */                 
     do_later_stuff();            
     }             
    /* 初始化modes_pointer资源 */             
    initialize_modes_pointer();             
    break;         
default:              /* 处理普通事件, 使用老的modes_pointer资源 */             
   processing();     
}      /* 使用modes_pointer资源，处理事件 */     
use_modes_pointer(); 
}    
5、-----------------------------------------------------------    
int is_gb2312_char(char c1, char c2) 
{      if (c1 >= 0xa1 && c2 >= 0xa1)         
return 1;     
else        
return 0; 
}   
6、-----------------------------------------------------------    
下面x, y的值是多少，有什么问题？
int x = 10, y = 3;
   x ^= y; y ^= x;
   x ^= y; /* x=?, y = ? */   
7、-----------------------------------------------------------    
int days[]={31,28,31,30,31,30,31,31,30,31,30,31,}; 
int calendar[12][31]; int (*monthp)[31];
int *dayp; int i;    
memset(calendar, 0, sizeof(calendar)); 
i = 0; 
for (monthp = calendar; monthp < &calendar[12]; monthp++)
{     
for (dayp = *monthp; dayp < &(*monthp)[31]; dayp++)
   {         
    if (dayp - *monthp < days[calendar - monthp])
     {             
      *dayp = i++ % 7 + 1;         
     }     
   } 
}    
8、-----------------------------------------------------------    
void printnum(long n)
{     
if (n < 0)
   {         
   putchar('-');         
   n = -n;     
   }        
   if (n >= 10) {          printnum(n/10);      }         putchar ("0123456789"[n%10]); }   
9、-----------------------------------------------------------     void * memchr(void *pv, unsigned char ch, size_t size) 
{      unsigned char *pch = (unsigned char *) pv;      unsigned char *pchEnd = pch + size;        
while (pch < pchEnd) {          if (*pch == ch)              return (pch);          pch++;      }         return NULL; }    
10、-----------------------------------------------------------     void * memchr(void *pv, unsigned char ch, size_t size) 
{      unsigned char *pch = (unsigned char *) pv;      unsigned char *pchPlant = pch + size;     
unsigned char chSave = *pchPlant;         *pchPlant = ch;      while (pch != ch) {          pch++;      }      *pchPlant = chSave;        
return ((pch == pchPlant) ? NULL : pch); }    
11、-----------------------------------------------------------     void UnsToStr(unsigned short int u, char *str)
{      char *pch;         assert(u <= 65535);      pch = &str[5];      *pch = '\0';     
do {          *--pch = u % 10 + '0';      } while ((u / 10) > 0);         strcpy(str, pch); }    
12、-----------------------------------------------------------     void *memmove(void *pvTo, void pvFrom, size_t size)
{      char *pbTo = (char *)pvTo;      char *pbFrom = (char *)pvFrom;       
((pbTo < pbFrom) ? tailmove : headmove) (pbTo, pbFrom, size);      return (pvTo); }   
13、-----------------------------------------------------------     void *memcpy(void *pvTo, void pvFrom, size_t size) 
{      char *pbTo = (char *)pvTo;      char *pbFrom = (char *)pvFrom;         while (size-- > 0);         
*pbTo++ = *pbFrom++;      return (pvTo); }   
14、-----------------------------------------------------------   
#include <stdio.h>    
int main(int argc, char *argv[]) {      char s[]="0123456789";      int i = 0;        
do {          printf ("%c", i++[s]);      } while(s[i]?1:printf("\n")-1);         return 0; }    
15、-----------------------------------------------------------    
int fibonacci(int x) {      if (x == 1 || x == 2)          return 1;      return fibonacci(x - 2) + fibonacci(x - 1); }    
16、-----------------------------------------------------------     这里有一个程序cdecl.c。写出它的工作流程。写出它的使用方法。 
给出一个典型输入用例，记录下它的输出。    
一.4、综合编程题。 要求： 1、完成需求，程序运行正确。 2、工作原理文档，使用文档完整。 
3、代码规整优美。注释得当。 4、运行速度足够快。 5、用工具分析出是哪些代码或函数造成速度瓶颈。 

1、----------------------------------------------------------- 编写一个排序程序。被排序的文件有8MB大小，一行一个随机整数(ASCII格式)。
要求对这些
整数进行 排序，并计算平均值，打印出排序所需的时间。(20分)    
2、----------------------------------------------------------- 用dummy header技巧实现一个链表DEMO。要求具有create, insert, delete, search功    
能。 编写一个应用程序，使用上面的函数。使用dummy header技巧有什么优点。(20分)   
3、----------------------------------------------------------- 用heapsort算法实现优先队列。要求具有create, insert, delete功能。 
编写一个应用程序，使用上面的函数。使用heapsort算法有什么优点。(20分)     用trie(一种多叉树)实现一个字典。要求具有create, insert, delete, search功能。    
编写一个应用程序，使用上面的函数。使用trie树有什么优点。(20分)    
二、POSIX方面的知识。 
二.1、简答题。下面的题目必须全部答对才给分：(5分) 
1、在UNIX环境中，编译流程是什么？ 
2、ABI，ELF的英文全称是什么 
3、一般UNIX的程序有多少段，举一个实际的例子说明。 
4、如何在kernel二进制代码中找一个字符串。
5、段地址F000:FFF0转换为线形地址的值是多少(16进制表达)。 
6、在一个UNIX文件系统中，文件的唯一性标志是什么？    
二.2、问答题。 
1、----------------------------------------------------------- 写一些代码。如何用文件实现信号灯？要求如果程序崩溃了，这个文件也将自动被删除     。 
为什么可以这样实现信号灯？(5分) 传统的signal函数信号处理为什么是不可靠的，信号和系统调用有何关系？(5分) 在图形库系统中往往提供timer的功能，
除了使用ALARM信号外，你还可以使用什么系统     调用来实现timer？(5分)
2、----------------------------------------------------------- 写一些代码，演示如何正确使用write系统调用。注意看好手册再回答。(2分) 
如果一个文件以rw模式打开，在进行read/write操作转换时，需要进行什么操作。(2分)       
3、----------------------------------------------------------- 解释终端结构termios.c_cc的MIN/TIME数值变化的带来read/write的特性。(5分) 
如何理解终端、控制终端、虚拟终端、控制台、tty等类同的概念？(5分) 
4、-----------------------------------------------------------     解释计算机中Copy-On-Write的概念。(2分)     调用fork之后，子进程没有继承父进程
的属性有哪些？(5分) 解释为什么每个程序在装入执行之后，总是已经预先打开了stdout、stdin、stderr？(2     分) 在fork之前，父进程打开了一个文件。
在fork之后，
如果子进程移动了文件指针， 父进程的文件指针有什么变化；如果子进程关闭了文件，父进程有什么变化？为什么会     这样？(5分) 标准输入、
输出和错误输出分别是什么
类型的缓冲，这些缓冲在用户空间还是在核心空     间？ 怎样关闭他们的缓冲？如果父进程关闭了缓冲，在fork之后建立的子进程是否也关闭了    
缓冲？(5分) vfork和fork相比，
有什么特色？(2分) system函数是否等同于fork+exec？(2分)     wait系统调用有多少种条件可以退出？(2分)   
5、----------------------------------------------------------- 系统调用和库函数调用有什么区别。(2分) 在linux2.4.x上的glibc和newlib
(一种嵌入式C库)的系统调用有什么不同？(2分) 在linux2.4.x上，对系统调用execve如果调用成功，它返回的值是多少。(2分)    
6、----------------------------------------------------------- 列出你所知道的2个内存跟踪库。(2分) 设计一个内存跟踪方案，为什么选择这个方案(5分)    
二.3、综合编程题。 要求： 1、完成需求，程序运行正确。 2、工作原理文档，使用文档完整。 3、代码规整优美。注释得当。 4、运行速度足够快。    
1、----------------------------------------------------------- 这里有一个8MB的文件，编写一个copy程序，拷贝这个文件，并计算所需时间。用工具分    
析 出是哪些代码或函数造成速度瓶颈。 提示：如果只是使用read/write调用，不是一个好的实现。(20分)   
2、----------------------------------------------------------- Linux系统中，什么时候会出现类似Y2K的问题。写一个程序证明。(20分)    
3、----------------------------------------------------------- 编写一个程序，测试系统最小的睡眠时间间隔。(20分)    
4、----------------------------------------------------------- 编写一个pipe程序，测试有N个管道，size大小的buffer情况下，pipe的传输性能是多少     ？(20分)    
5、----------------------------------------------------------- 在ext2文件系统上，单个文件最大可以达到多少？ 写一个程序获得这方面的限制。(20分)    
三、Linux编程基本使用知识。 
三.1、命令和shell 
1）编写一个脚本，统计一个目录下面所有C代码的行数。(2分) 
2）编写一个sed脚本，去除HTML文件中的HTML标记。(2分) 
3）编写一个脚本获得当前系统eth0的IP地址。(2分) 
4）编写一个脚本以交互的方式，进行DNS的设定。(2分) 
5）使用ls命令编写一个脚本，实现ls -R，递归列出当前目录下的所有目录、文件。(2     分) 
6） 在一个目录下，找soft-link files，用下面的命令，原理是可行的，但无法操作，
该如何解决？要2种方法。(2分) ls -l | grep ->    
7） 如何把标准错误输出，重定向到标准输出上。(2分)    
8） 我们的系统中的软件包是使用RPM管理的。要求下面的问题写出shell命令和运行结果。
( 5分) 如何知道系统中安装了几个软件包。 如何知道系统中安装了哪几类(group)软件包。 如何知道kernel软件包的简述。 如何知道kernel软件包
的Changelog。 如何知道kernel软件包有几个文件。 如何知道kernel软件包安装后有多大。    
三.2、编辑工具的使用。(各2分) 
1）如何使用vi进行块拷贝、粘贴、删除的操作 
2）如何设置Tab的长度，以及自动缩进的长度 
3）如何使用tag进行代码阅读 
4）如何在1～10行，有确认的进把所有的RedHat改为RedFlag 
5）在SourceNavigator中，如何跳到一个变量的声明处？如何得知光标当前的位置在那        个函数体内？    
三.3、编译器与调试器。(各2分) 
1）如何使用gcc得到宏展开的中间代码 
2）如何通过gcc在命令行中传入宏定义 
3）在那一级优化的情况下，内联函数才真正的内联到代码中 
4）gdb的watch命令如何使用，有何缺点 
5）gdb中使用什么命令可以显式调用的栈帧，如何查看某个栈帧上的局部变量 
6）如何使用gdb调试多进程 7）如何使能/禁止core dump？    
三.4、库。(各2分) 
1）如何知道XSetIMValues这个符号在那个X的库文件中 
2）如何读取C++的符号名，更具可读性 
3）请解释动态库的soname概念 
4）解释在链接时rpath选项的含义   
三.5、Makefile。(10分) 如果有一个简单的Test项目目录如下： # tree Test Test |-- common.h |-- main.cpp |-- test.cpp `-- test.h    
1）使用wildcard、patsubst函数编写一个C++项目的Makefile文件 
2）使用automake、autoconfig编写一个支持configure选项的configure.in脚本    
三.6、CVS。(10分) 
1）如果一个CVS项目中，甲添加了一个子目录模块，那么乙在update时是否会自动检     出这个新添加的子模块？如果不能，那么你有什么好的解决方案？ 
2）如何在一个CVS项目中添加一个二进制文件，这个二进制文件可以进行增量的版本管     理吗？ 
3）如何检出标记（tag）为milestone-1的版本，如何创建以milestone-1为基础的分支        milestone-1-b1，并如何把分支的修改合并到milestone-1的主分支上    
三.7、Linux/GNU编程基本知识 1、----------------------------------------------------------- Linux2.4.x有多少种类型的设备文件？分别写出来。(2分)    
2、----------------------------------------------------------- glibc动态库的搜寻次序是什么？(2分) glibc 2.1.x 与 2.2.x的动态库的搜寻次序有什么
不同？为什么会采用现在的方案？(2     分) 
来自：http://www.rosoo.net/a/embedded_o/201005/9380.html


嵌入式linux工程师面试题目C语言基础部分


在网上看到了一篇嵌入式的面试题，忽然觉得自己很渺小……在未来一段时间内我会陆续贴上我的答案，当然可能有些我做不出来，做出来的也不一定准确，在检验和提高自己的同时，希望有走过路过高人指点一二。

下面的题目必须全部答对才给分：
1、 如何在C中初始化一个字符数组。
2、 如何在C中为一个数组分配空间。
3、 如何初始化一个指针数组。
4、如何定义一个有10个元素的整数型指针数组。
5、 s[10]的另外一种表达方式是什么。
6、 GCC3.2.2版本中支持哪几种编程语言。
7、 要使用CHAR_BIT需要包含哪个头文件。
8、 对(-1.2345)取整是多少？
9、 如何让局部变量具有全局生命期。
10、C中的常量字符串应在何时定义？
11、如何在两个.c文件中引用对方的变量。
12、使用malloc之前需要做什么准备工作。
13、realloc函数在使用上要注意什么问题。
14、strtok函数在使用上要注意什么问题。
15、gets函数在使用上要注意什么问题。
16、C语言的词法分析在长度规则方面采用的是什么策略？
17、a+++++b所表示的是什么意思？有什么问题？
18、如何定义Bool变量的TRUE和FALSE的值。
19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。

这部分是ANSI C的一些问题，题目的前提是必须都答对，看似很变态，但是细想一下，这些都是最基础的，虽然我们在使用他们的时候会犯这样那样的错误，但是最终目的是不犯错误，不是么，那么好，从最基础的开始。



1、 如何在C中初始化一个字符数组。
这个问题看似很简单，但是我们要将最简单的问题用最严谨的态度来对待。关键的地方：初始化、字符型、数组。最简单的方法是char array[];。这个问题看似解决了，但是在初始化上好像还欠缺点什么，个人认为：char array[5]={'1','2','3','4','5'};或者char array[5]={"12345"};或者char array[2][10]={"China","Beijing"};也许更符合“初始化”的意思。



2、 如何在C中为一个数组分配空间。
最简单的方法是：char array[5]；意思是分配给数组array一个5个字节的空间。但是我们要知道在C中数组其实就是一个名字，其实质含义就是指针，比如char array[]；是到底分配的多少空间？所以我们要将其分成为两种不同的形式给出答案：
一种是栈的形式：char array[5]；
一种是堆的形式：char *array; array=(char *)malloc(5);//C++: array=new char[5];
堆和栈的含义其实我也没弄太透彻，改天明白了再发一篇。
我们要明白的是，第一种形式空间分配的大小可能会受操作系统的限制,比如windows会限制在2M；第二种形式成空间分配很灵活，想分配多少分配多少，只要RAM够大。



3、 如何初始化一个指针数组。
首先明确一个概念，就是指向数组的指针，和存放指针的数组。
指向数组的指针：char (*array)[5];含义是一个指向存放5个字符的数组的指针。
存放指针的数组：char *array[5];含义是一个数组中存放了5个指向字符型数据的指针。
按照题意，我理解为初始化一个存放指针的数组，char *array[2]={"China","Beijing"}；其含义是初始化了一个有两个指向字符型数据的指针的数组，这两个指针分别指向字符串"China"和"Beijing"。



4、如何定义一个有10个元素的整数型指针数组。
既然只是定义而不是初始化，那就很简单且没有争议了：int *array[10];。



5、 s[10]的另外一种表达方式是什么。
前面说过了，数组和指针其实是数据存在形态的两种表现形式，如果说对于数组s[]，我们知道*s=s[0]，那么s[10]的另一种表达方式就是：*(s+10)。



6、 GCC3.2.2版本中支持哪几种编程语言。
这个问题实在变态，就像问你#error的作用是什么一样。不可否认，gcc是linux下一个亮点，是一个备受无数程序员推崇的编译器，其优点省略1000字，有兴趣可以自己查，我翻了翻书，书上曰：支持C,C++,Java,Obj-C,Ada,Fortran,Pascal,Modula-3等语言，这个“等”比较要命，不过我认为已经很全了，如果认为还是不全，干脆把ASM也加上算了，不过那已经不算是编译了。



7、 要使用CHAR_BIT需要包含哪个头文件。
如果结合上面的问题，答题的人估计会认为自己撞鬼了，这个问题实在是……搜索了一下，应该是limits.h。



8、 对(-1.2345)取整是多少？
其实不同的取整函数可能有不同的结果，不过这个数没有太大的争议，答案是-1。



9、 如何让局部变量具有全局生命期。
具体的生命期的概念我觉得我还要好好深入的学习一下，但是这个题目还算比较简单，即用static修饰就可以了，但是只是生命期延长，范围并没有扩大，除非把这个变量定义在函数体外的静态区，不过那样就变成全局变量了，仿佛不符合题目要求。



10、C中的常量字符串应在何时定义？
这个问题说实话不是很理解题干的意思，据我理解，有两种情况，一种是预处理阶段，用#define定义；还有就是使用const修饰词，不过const修饰的是一个变量，其含义是“只读”，称之为常量并不准确，但是确实可以用操作变量的方法当常量用。所以还是第一种比较靠谱。



11、如何在两个.c文件中引用对方的变量。
这个问题也问的挺含糊的，怎么说呢，最简单最直接的方法是为变量添加extern修饰词，当然，这个变量必须是全局变量。还有一种就是利用函数调用来进行变量的间接引用，比如这个C文件中的一个函数引用另外一个C中的函数，将变量通过实参的形式传递过去。不过题目既然说是引用，那么还是用第一个答案好了。



12、使用malloc之前需要做什么准备工作。
其实准备工作很多啊，比如你需要一台计算机之类的。玩笑话，我们首先要知道malloc的用途，简单的说就是动态的分配一段空间，返回这段空间的头指针。实际的准备工作可以这么分：需要这段空间的指针是否存在，若不存在，则定义一个指针用来被赋值，还要清楚要返回一个什么类型的指针，分配的空间是否合理；如果指针已经存在，那么在重新将新的空间头地址赋值给这个指针之前，要先判断指针是否为NULL，如果不是要free一下，否则原来的空间就会被浪费，或者出错，free之后就按照前一种情形考虑就可以了。



13、realloc函数在使用上要注意什么问题。
这个函数我也才知道的，汗一个。据我的初步理解，这个函数的作用是重新分配空间大小，返回的头指针不变，只是改变空间大小。既然是改变，就有变大、变小和为什么改变的问题。变大，要注意不能大到内存溢出；变小，那变小的那部分空间会被征用，原有数据不再存在；为什么改变，如果是想重新挪作他用，还是先free了吧。



14、strtok函数在使用上要注意什么问题。
这个问题我不知道能不能回答全面，因为实在是用的很少。这个函数的作用是分割字符串，但是要分割的字符串不能是常量，这是要注意的。比如先定义一个字符串：char array[]="part1,part2";，strtok的原形是char *strtok(char *string, char *delim);，我们将","作为分隔符，先用pt=strtok(array,",");，得到的结果print出来就是"part1"，那后面的呢，要写成pt=strtok(NULL,",");，注意，要用NULL，如果被分割的字符串会被分成N段，那从第二次开始就一直要用NULL。总结起来，需要注意的是：被分割的字符串和分隔符都要使用变量；除第一次使用指向字符串的指针外，之后的都要使用NULL；注意使用这个函数的时候千万别把指针跟丢了，不然就全乱了。



15、gets函数在使用上要注意什么问题。
这是一个键盘输入函数，将输入字符串的头地址返回。说到要注意的问题，我还是先查了一下网上的一些情况，需要注意的就是gets以输入回车结束，这个地球人都知道，但是很多人不知道的是，当你输入完一个字符串后，这个字符串可能依然存在于这个标准输入流之中，当再次使用gets的时候，也许会把上次输入的东西读出来，所以应该在使用之后用fflush(stdin);处理一下，将输入流清空。最后也还是要注意溢出的问题。关于这个答案我比较含糊，不知道有没有高人高见？



16、C语言的词法分析在长度规则方面采用的是什么策略？
我无语……闻所未闻啊……还是搜索了一下，有一篇文章，地址是：http://202.117.80.9/jp2005/20/kcwz/wlkc/wlkc/03/3_5_2.htm，是关于词法分析器的。其中提到了两点策略： (1) 按最长匹配原则确定被选的词型；(2) 如果一个字符串能为若干个词型匹配，则排列在最前面的词型被选中。不知道是不是题干的要求，还是其他什么。我乃一介草民，望达人指点迷津！



17、a+++++b所表示的是什么意思？有什么问题？
这个东西（称之为东西一点都不过分）其实并没有语法错误，按照C对运算符等级的划分，++的优先级大于+，那么这句话会被编译器看做：(a++)+(++b)，这回明白了吧。有什么问题，语法上没有问题，有的是道德上的问题！作为一个优秀的程序员，我们要力求语句的合法性和可读性，如果写这句的人是在一个team里，那么他基本会被打的半死……最后讨论一下结果：假设a之前的值是3，b是4，那么运行完这个变态语句后，a的值是4，b是5，语句的结果是8。



18、如何定义Bool变量的TRUE和FALSE的值。
不知道这个题有什么陷阱，写到现在神经已经大了，一般来说先要把TURE和FALSE给定义了，使用#define就可以：
#define TURE 1
#define FALSE 0
如果有一个变量需要定义成bool型的，举个例子：bool a=TURE;就可以了。



19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
首先，这个题干抽了10题回答的一个大嘴巴。关于常量的概念看来我要好好看看书了……我说过了，const修饰词可以将一个变量修饰为“只读”，这个就能称为常量么？姑且认为可以。回到题目中，const是只读的意思，它限定一个变量不允许被改变，谁都不能改！既然是修饰变量，那么变量的类型就可以丰富多彩，int啊，char啊，只要C认识的都可以；但是#define就不可以了，在预处理阶段缺乏类型检测机制，有可能会出错。还有就是变量可以extern，但是#define就不可以。貌似const还可以节省RAM，这个我倒是没有考证过。至于const的用法和作用，有很多，我会总结后发上来。



20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。
终于最后一题了，容易么……如果这个测试是一个关于嵌入式的，那么这道题非常重要！！从词面上讲，volatile的意思是易变的，也就是说，在程序运行过程中，有一些变量可能会被莫名其妙的改变，而优化器为了节约时间，有时候不会重读这个变量的真实值，而是去读在寄存器的备份，这样的话，这个变量的真实值反而被优化器给“优化”掉了，用时髦的词说就是被“和谐”了。如果使用了这个修饰词，就是通知编译器别犯懒，老老实实去重新读一遍！可能我说的太“通俗”了，那么我引用一下“大师”的标准解释：
volatile的本意是“易变的” 。
由于访问寄存器的速度要快过RAM,所以编译器一般都会作减少存取外部RAM的优化，但有可能会读脏数据。当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。


文章出处：飞诺网(www.firnow.com):http://dev.firnow.com/course/6_system/linux/Linuxjs/200868/123594.html




