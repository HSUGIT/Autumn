最近刚刚升任嵌入式软件研发主管，急需招兵买马。
自己出了下面两道面试题，17个应聘者中，有5个是做Windows软件出身的，4个做嵌入式软件出身，3个应届大学本科毕业生，余下的是应届硕士毕业生竟无一人完全答对：

1、LINUX下的Socket套接字和Windows下的WinSock有什么共同点？请从C/C++语言开发的角度描述，至少说出两点共同点。（10分，说得好的每点加5分，没有上限。精通SOCK编程者破格录用。）

本题的目的就是考考应试者的SOCK功底，以及应用能力。答案可谓是五花八门，但是答对的少得可怜。其实答案很多，也很好回答。可见面试者功底确实一般，对SOCK编程只是一知半解。更有甚者，把TCP/IP的原理搬出来讲了一大堆，却无一条符合要求。

参考答案：
第1题，答中一个得5分，答出其它正确答案的，也得5分。
a)都基于TCP/IP协议，都提供了面向连接的TCP SOCK和无连接的UDP SOCK。
b)都是一个sock结构体。
c)都是使用sock文件句柄进行访问。
d)都具有缓冲机制。

2、请编写一个标准Shell脚本testd，实现如下功能：
A、在Linux操作系统启动的时候，自动加载/mnt/test/test程序。
B、当test异常退出之后，自动重新启动。
C、当test程序重启次数超过100次，自动复位操作系统。
假设你所拥有的资源：
A、目标机器是一台具有标准shell的嵌入式计算机，CPU为ARM7 56MB，内存16MB，软件环境基于Linux2.6.11和BusyBox1.2构建。
B、当前已有11个用户进程在运行，占用了大部分的CPU时间和内存，你可使用的内存只有2MB左右，CPU时间由系统分派。
（本题满分20分，程序15分，注释5分。程序不能运行的0分，能够运行但有BUG的10分，能够正确无误的运行的15分。清楚编写注释的5分。）

本题是考查LINUX和嵌入式编程功底的，写出程序来的不少，但是95%以上的人竟无视我假设的资源，不知道在重启test程序的时候需要加上一个适当的掩饰时间，以便资源紧张的操作系统有时间回收资源。85%的人不知道写完testd之后，要在init里边加载这个脚本，才能实现启动时自动加载的功能。有人甚至在脚本开头使用bash作为脚本解析器，我已经清清楚楚说明了用“标准shell”！用sh不就完了吗？是习惯作祟吗？

参考答案：
########################################
#testd is a daemon script to start an watch the program test
########################################
#!/bin/sh

#load *.so that may need
if [ -r /sbin/ldconfig ]; then
ldconfig
fi

#add the libs PATH that may need
export LD_LIBRARY_PATH="/lib"

#count is the counter of test started times
count=0

#main loop
while [ 1 ] ;do
#add execute property for /mnt/test/test
chmod +x /mnt/test/test
#start test
/mnt/test/test
#the running times counter
let count=count+1
echo "test running times is $count"
#Is test running too many times?
if [ "$count" -gt 100 ]; then
echo "Will reboot because of test running too many times"
reboot
fi
#wait for test stoping...
sleep 3
done
#########################################


面试来面试去，一个个吹水的挺强，但是面对苛刻资源条件编程的能力极其有限。幸好这两道题的分值不是很高，要不然大多数人恐怕要拿及格都难啊！

跟经理商量了很久，挑来挑去挑了两个沟通能力比较强，各方面也比较均衡的留用，一个是本科应届毕业生，一个嵌软出身的。

接下来的一年，我还是乖乖自己培养一两个自己想用的人吧！


1、请用方框图描述一个你熟悉的实用数字信号处理系统,并做简要的分析;如果没有,
也可以自己设计一个简单的数字信号处理系统,并描述其功能及用途。(仕兰微面试题
目)
2、数字滤波器的分类和结构特点。
(仕兰微面试题目)
3、IIR,FIR 滤波器的异同。
(新太硬件面题)
4、拉氏变换与 Z 变换公式等类似东西,随便翻翻书把如.h(n)=-a*h(n-1)+b*δ(n) a.求 h
(n)的 z 变换;b.问该系统是否为稳定系统;c.写出 FIR 数字滤波器的差分方程;(未知)
5、DSP 和通用处理器在结构上有什么不同,请简要画出你熟悉的一种 DSP 结构图。(信威
dsp 软件面试题)
6、说说定点 DSP 和浮点 DSP 的定义(或者说出他们的区别)(信威 dsp 软件面试题)
7、说说你对循环寻址和位反序寻址的理解.(信威 dsp 软件面试题)
8、请写出【-8,7】的二进制补码,和二进制偏置码。用 Q15 表示出 0.5 和-0.5.(信威
dsp 软件面试题)
9、DSP 的结构(哈佛结构)
;
(未知)
10、嵌入式处理器类型(如 ARM),操作系统种类(Vxworks,ucos,winCE,linux),操作系
统方面偏 CS 方向了,在 CS 篇里面讲了;(未知)
11、有一个 LDO 芯片将用于对手机供电,需要你对他进行评估,你将如何设计你的测试项
目?
12、某程序在一个嵌入式系统(200M CPU,50M SDRAM)中已经最优化了,换到零一个系
统(300M CPU,50M SDRAM)中是否还需要优化? (Intel)
13、请简要描述 HUFFMAN 编码的基本原理及其基本的实现方法。(仕兰微面试题目)
14、说出 OSI 七层网络协议中的四层(任意四层)。
(仕兰微面试题目)
15、A) (仕兰微面试题目)
#i nclude
void testf(int*p)
{
*p+=1;
}
main()
{
int *n,m[2];
n=m;
m[0]=1;
m[1]=8;
testf(n);
printf("Data value is %d ",*n);
}
------------------------------
B)
#i nclude
void testf(int**p)
{
*p+=1;
}
main()
{int *n,m[2];
n=m;
m[0]=1;
m[1]=8;testf(&n);
printf(Data value is %d",*n);
}
下面的结果是程序 A 还是程序 B 的?
Data value is 8
那么另一段程序的结果是什么?
16、那种排序方法最快? (华为面试题)
17、写出两个排序算法,问哪个好?(威盛)
18、编一个简单的求 n!的程序 。
(Infineon 笔试试题)
19、用一种编程语言写 n!的算法。
(威盛 VIA 2003.11.06 上海笔试试题)
20、用 C 语言写一个递归算法求 N!;(华为面试题)
21、给一个 C 的函数,关于字符串和数组,找出错误;(华为面试题)
22、防火墙是怎么实现的? (华为面试题)
23、你对哪方面编程熟悉?(华为面试题)
24、冒泡排序的原理。
(新太硬件面题)
25、操作系统的功能。
(新太硬件面题)
26、学过的计算机语言及开发的系统。
(新太硬件面题)
27、一个农夫发现围成正方形的围栏比长方形的节省 4 个木桩但是面积一样.羊的数目和正 方
形围栏的桩子的个数一样但是小于 36,问有多少羊?(威盛)
28、C 语言实现统计某个 cell 在某.v 文件调用的次数(这个题目真 bt) (威盛 VIA
2003.11.06 上海笔试试题)
29、用 C 语言写一段控制手机中马达振子的驱动程序。(威胜)
30、用 perl 或 TCL/Tk 实现一段字符串识别和比较的程序。(未知)
31、给出一个堆栈的结构,求中断后显示结果,主要是考堆栈压入返回地址存放在低端地 址
还是高端。
(未知)
32、一些 DOS 命令,如显示文件,拷贝,删除。(未知)
33、设计一个类,使得该类任何形式的派生类无论怎么定义和实现,都无法产生任何对象 实
例。
(IBM)
34、What is pre-emption? (Intel)
35、What is the state of a process if a resource is not available? (Intel)
36、三个 float a,b,c;问值(a+b)+c==(b+a)+c, (a+b)+c==(a+c)+b。(Intel)
37、把一个链表反向填空。 (lucent)
38、x^4+a*x^3+x^2+c*x+d 最少需要做几次乘法? (Dephi)


用一个宏定义FIND求一个结构体CTYPE里某个变量CNUM相对了CTYPE的编移量。
如：stuct student
  {
    int a;
    char b[20];
    double ccc;
  }
则：
FIND(student,a); //等于0
FIND(student,b）;//等于4
二楼的可以。
#define FIND(type,member) (int)(&( ((type*)0)->member) )
struct student
{
    int a;
    char b[20];
    double ccc;
};
int main(int argc,char* argv[])
{
        int i=FIND(student,a); //等于0
        i=FIND(student,b);//等于4
        return 0;
}

调试结果是对的。
题目出得很好:
其实就是考下这个宏 offsetof ,定义在文件 stddef.h 中.
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
TYPE是某struct的类型 0是一个假想TYPE类型struct,MEMBER是该struct中的一个成员. 由于该struct的基地址为0, MEMBER的地址就是该成员相对与struct头地址的偏移量.
再往深处,接触过Linux Kernel的会知道这个宏 container_of,就嵌套了宏offsetof ,其在Linux Kernel中的应用非常广泛,它用于获得某结构中某成员的入口地址.
1.运放求放大倍数的
  2.三极管基础知识（放大区，截至区，饱和区）
3.并联RC变换成串联RC
4.运放求反馈的
5.单片机和74hc595硬件连接和编程
6。数据结构-----队列，建立一个队列，写数，读数。



一　简答题

１　进制转换

２　单片机C51　用idata 及xdata　定义变量的存放区域　及其汇编指令

３　位运算　（置位　清零　取反）

二　求运放的电压增益

三　史密特触发电路的　求出高低电压阈值及回滞电压　依据输入电压画出输出电压波形

四　用门电路设计格雷码转换为自然二进码电路，要求画出电路图

五　二进Ｄ触发器狗成的同步电路
　　要求写出驱动方程，状态方程，输出方程，画出状态转移图

六　用单片机实现从串口读取四字节的数与固件中的四字节的常数比较，若相等，暂停６Ｓ后控制电机工作．继续读取，比较．．．
　　要求画出电路及写出代码

七　一个８比特的数，要求编写一端Ｃ程序实现位倒序功能．
前两天参加了周立功武汉站笔试和机试，先贴部分题目出来，希望对其他地方想应聘周立功的同学有所帮助。
一、笔试题
1、在进程中通信的手段不包括（）A：油槽  B：管道  C：文件映射  D：信号量
2、在C语言中，下面哪些是定义（）A：extern const int *pi; B:extern int a;
     C:struct MyStruct;  D:extern void fun1(void (*f)(int)) {};
3、传统的快速排序算法，在最坏情况下的时间复杂度是多少？A：O(nlog(n)) B:O(log(n)) C:O(n*n) D:O(n*n*n)
4、下面是合法的浮点数指数格式的是（）A：2.1E0.2  B：E15  C:.5E-3  D:以上都错
5、长度为n的有序线性表中进行二分查找，最坏情况下比较的次数是
     A：O(n)  B:O(2n)  C:O(log(2n))  D:O(nlog(2n))
6、以下程序运行时将在哪一行死掉（）
    struct SS
    {
         int i;
         int *p;
    };
    void main()
    {
        struct SS s;
        int *p=&s.i;
        p[0]=3;          ①
        p[1]=3;          ②
        s.p=p;
        s.p[1]=1;       ③
        s.p[0]=2;       ④
    }
   A: ①  B: ②  C: ③  D: ④
7、以下程序的运行结果是（） A：0  B：1  C：5  D：2
    union
    {
        struct
        {
            unsigned char c1:3;
            unsigned char c2:3;
            unsigned char c3:2;
        }s;
        unsigned char c;
    }u;
    int main()
   {
       u.c=100;
       printf("%d\n",u.s.c3);
       return 0;
   }
8、编写一个简单的C函数指针声明_____。
9、有5个盒子，分别装了1、4、8、32、64个球，如果将它们任意组合(至少一个)，所有可能值中最中间的一个值是____。
10、如果处理器是little_endian的，请写出0x1234在存储时候的字节序_____。
一、简答题
１.　二进制、十进制、BCD码间转换
２.　单片机C51　用idata 及xdata　定义变量的存放区域　及其汇编指令
３.　位运算指令　（置位　清零　取反）
二、求运放的电压增益（就是一个反相比例运放的变异题，只要懂虚短虚断就OK）
三、1.史密特触发电路的高低电压阈值及回滞电压　2.依据输入电压波形画出输出电压波形
四、用门电路设计格雷码转换为自然二进码电路(给出格雷码状态图），要求画出设计电路图
五、Ｄ触发器构成的同步电路（要求写出驱动方程，状态方程，输出方程，画出状态转移图）
六、用单片机实现从串口读取四字节的数与固件中的四字节的常数比较，若相等，控制继电器闭合，延时６Ｓ．否则继续读取，比较．．．
      要求画出电路及写出代码（建议用51）
七、一个８比特的数，要求编写一端Ｃ程序实现位倒序功能．如：a=b0b1b2b3b4b5b6b7,编程实现a=b7b6b5b4b3b2b1b0（要求实现的速度尽可能的快）

17号周立功单机在广州招人,本人去投了一份材料,两位招聘大人当场拿出试题考咱。
一道是英译汉,是单片机方面的;
二是设计一个四分频电路,用D触发器;
三是设计一个译码电路;
四是用单片机89C51设计一个驱动LED的电路(要求用P1.0),还有汇编程序;
咱也不怕丢脸一四还可以,二三实在不记得了,好久没看BOOK了;
用AVR久了,51又模糊了;
真希望在找工作的同行多看BOOK呀,本来很简单的,很可能一下就忘记了! 
9.20号去南航参加周立功的招聘会，人会很多，很多外地赶过来的。9点半宣讲会，10点半笔试，我考的是软件卷，共五道题
1   括号匹配问题，这题目比较经典，利用堆栈
2   实现一个将字符串去掉特定字符的函数
3  计算二叉树总节点数  以及单链表的反转 都是基础题
4   是一个C++题目，给出一段代码，找错
5
古代数学算法：
1×33=33 = 33              提取1
2×33=66 = 33+33
4×33=132= 66+66
8×33=264= 132+132           提取8
9×33=297=33+264
然后有三个小题a.推理除法运算；b.写出乘法运算的函数；c.写出除法运算的函数
总的来说题目不难，都是基础题。

题：用任意一单片机设计一个4X4的键盘并编出程序得到键值，要求有去抖，去抖时单片机可以做其它事情，按一下键盘蜂鸣器叫一下，蜂鸣器叫过程中也要单片机可以做其它事情。（提示：用定时器产生基本节拍）
题目是我做后记下来的，当时在做得时候写的很乱，被老师评为编程不怎么样。回来后想想其实很简单就一个中断函数搞定：
 
void time1_sv() interrupt 5 using 2{
 EA=0;
 TF2=0;    //清中断标志位
 if((spcnt--)==0){spcnt=0;SPEAK=0x00;}
 if(scankey()){count++;
    if(count>8){getkeyval();count=0;spcnt=30;SPEAK=0xff;}
    }
 else {count=0;}
 EA=1;
}
思路是：连续n次进入中断时都检测到有按键,那就去取按键值，并使蜂鸣器叫，蜂鸣器叫多长时间由spcnt的值决定。
试验源程序：
#include "mydef.h"
//定义外围器件地址
#define SPEAK   XBYTE[0xC000]
#define KEYIN  XBYTE[0xE000]
#define KEYOUT  XBYTE[0xF000]
#define PORTA  XBYTE[0xa000]
#define PORTB  XBYTE[0xb000]
#define LEDD   XBYTE[0x9000]
//3000个机器周期中断一次
#define TIME_H (65535-3000)/256
#define TIME_L (65535-3000)%256
//LED显示译码
uchar code table[]={0x0C0,0x0F9,0x0A4,0x0B0,0x99,0x92,0x82,0x0F8,0x80,0x90,0x88,0x83,0x0C6,0x0A1,0x86,0x8E,0x7F,0x89};
//全局变量
uchar key_value,count,spcnt;
//判断有无按键
uchar scankey()
{ KEYOUT=0x00;
  if(((~KEYIN)&0x0f)!=0) return(1);  //有键按下
  else return(0);
 }
//得到键值
void  getkeyval(void)
 {    
    KEYOUT=0x0e;
           switch(KEYIN&0x0f)
             { case 14:key_value=0;break;
              case 13:key_value=1;break;
              case 11:key_value=2;break;
              case 7:key_value=3;break;
              default:break;
             }
    KEYOUT=0x0d;
             switch(KEYIN&0x0f)
             { case 14:key_value=4;break;
              case 13:key_value=5;break;
              case 11:key_value=6;break;
              case 7:key_value=7;break;
              default:break;
             }
      KEYOUT=0x0b;
             switch(KEYIN&0x0f)
             { case 14:key_value=8;break;
              case 13:key_value=9;break;
              case 11:key_value=10;break;
              case 7:key_value=11;break;
              default:break;
             }
    KEYOUT=0x07;
             switch(KEYIN&0x0f)
             { case 14:key_value=12;break;
              case 13:key_value=13;break;
              case 11:key_value=14;break;
              case 7:key_value=15;break;
              default:break;
             }
 }
 //定时T2中断  89c52，w78e58之类的单片机都有定时器2
void time1_sv() interrupt 5 using 2{
 EA=0;
 TF2=0;    //清中断标志位
 if((spcnt--)==0){spcnt=0;SPEAK=0x00;}
 if(scankey()){count++;
    if(count>8){getkeyval();count=0;spcnt=30;SPEAK=0xff;}
    }
 else {count=0;}
 EA=1;
}
//粗劣延时mS级
void msec(uint x)
{
 unsigned int j;
 while((x--)!=0)
 {
  for(j=0;j<=123;j++)
   {;}
 }
}
//数码管显示
void dir(uchar leddat)
{
 ORTA=0x00;
 ORTB=0xff;
 LEDD=table[leddat];
 msec(2);
 ORTA=0xff;
 LEDD=table[leddat];
 ORTB=0x00;
 msec(2);
 ORTB=0xFF;
}
 
//主函数
main()
{
 
 C_T2=0;   //T2工作在定时器
 CP_RL2=0;  //自动装栽
 RCAP2H=TH2=TIME_H;
 RCAP2L=TL2=TIME_L;
 EA=1;
 ET2=1;
 TR2=1;
 while(1)
 { dir(key_value);
  }
 }


2007年11月21日
 
今天是第一次参加笔试，广州周立功公司。
 
14：30开始宣讲，17点结束。主要还是说了自己企业如何如何。
 
18点开始在长春大学13层的1楼阶梯教室进行笔试。(之前他们说,他们准备了10套卷子,天津某某大学教授出题)
 
B套卷子.16开纸2张，正反面。
 
一.有用二极管搭接的电路2个,分别是与门和或门.三极管搭接的就是非门了.
 
二.然后就是典型的三角形的放大电路,给出电压电阻,求解输出.
 
三.级联型的斯密特触发器,给出第一个触发器输出波形,要求画出输入和第二个斯密特出发器的输入与输出波形.
 
四.四个二极管和四个三极管搭接的桥型电机驱动电路, 控制四个三极管的C,用单片机写出程序.和四个二极管作用,还有2个接在电源上的电容的作用.
 
五.嗷嗷复杂的一个题,一堆电阻4个开关,接到了第一个放大器的+和-,输出接到第二个放大器,求解输出和开关的关系.把输出接到单片机口,用4位数表示输入. 用单片机控制4个开关,实现1K Hz的正弦波.
 
六.一个数组,已排序.要求给出数组首位置,长度,要查找的数值.....
int find(char n,char *a,char len,char *nsr)
n是要查找的数值,*a是首地址,len是长度,*nsr是返回结果,0未找到，1找到,同时函数返回,0未找到，1找到,
 
提示:使用折中法查找
  
总结一下, 模拟电子基础知识,主要是模拟放大电路.单片机简单C51编程(需要有实践能力).C语言编程,


模拟电路（基本概念和知识总揽）
1、基本放大电路种类（电压放大器，电流放大器，互导放大器和互阻放大器），优缺点，特别是广泛采用差分结构的原因。
2、负反馈种类（电压并联反馈，电流串联反馈，电压串联反馈和电流并联反馈）；负反 馈的优点（降低放大器的增益灵敏度，改变输入电阻和输出电阻，改善放大器的线性和非 线性失真，有效地扩展放大器的通频带，自动调节作用）
3、基尔霍夫定理的内容是什么？
基尔霍夫定律包括电流定律和电压定律。
电流定律：在集总电路中，任何时刻，对任一节点，所有流出节点的支路电流代数和恒等于零。电压定律：在集总电路中，任何时刻，沿任一回路，所有支路电压的代数和恒等于零。
4、描述反馈电路的概念，列举他们的应用？
反馈，就是在电子系统中，把输出回路中的电量输入到输入回路中去。
反馈的类型有：电压串联负反馈、电流串联负反馈、电压并联负反馈、电流并联负反馈。
负反馈的优点：降低放大器的增益灵敏度，改变输入电阻和输出电阻，改善放大器的线性和非线性失真，有效地扩展放大器的通频带，自动调节作用。
电压（流）负反馈的特点：电路的输出电压（流）趋向于维持恒定。
5、有源滤波器和无源滤波器的区别？
无源滤波器：这种电路主要有无源元件R、L和C组成
有源滤波器：集成运放和R、C组成，具有不用电感、体积小、重量轻等优点。
集成运放的开环电压增益和输入阻抗均很高，输出电阻小，构成有源滤波电路后还具有一定的电压放大和缓冲作用。但集成运放带宽有限，所以目前的有源滤波电路的工作频率难以做得很高。
6、基本放大电路的种类及优缺点，广泛采用差分结构的原因。
答：基本放大电路按其接法的不同可以分为共发射极放大电路、共基极放大电路和共集电极放大电路，简称共基、共射、共集放大电路。
共射放大电路既能放大电流又能放大电压，输入电阻在三种电路中居中，输出电阻较大，频带较窄。常做为低频电压放大电路的单元电路。
共基放大电路只能放大电压不能放大电流，输入电阻小，电压放大倍数和输出电阻与共射放大电路相当，频率特性是三种接法中最好的电路。常用于宽频带放大电路。
共集放大电路只能放大电流不能放大电压，是三种接法中输入电阻最大、输出电阻最小的电路，并具有电压跟随的特点。常用于电压放大电路的输入级和输出级，在功率放大电路中也常采用射极输出的形式。
广泛采用差分结构的原因是差分结构可以抑制温度漂移现象。
7、二极管主要用于限幅，整流，钳位．
判断二极管是否正向导通：
１．先假设二极管截止，求其阳极和阴极电位；
２．若阳极阴极电位差＞ UD ，则其正向导通；
３．若电路有多个二极管，阳极和阴极电位差最大的二极管优先导通；其导通后，其阳极阴极电位差被钳制在正向导通电压（０.7V 或０.３V ）；再判断其它二极管．



数字电路（基本概念和知识总揽）
1、数字信号：指的是在时间上和数值上都是离散的信号；即信号在时间上不连续，总是发生在一序列离散的瞬间；在数值上量化，只能按有限多个增量或阶梯取值。（模拟信号：指在时间上和数值上都是连续的信号。）
2、数字电路主要研究电路输入、输出状态之间的相互关系，即逻辑关系。分析和设计数字电路的数学工具是逻辑代数，由英国数学家布尔1849年提出，因此也称布尔代数。
3、逻辑代数有三种最基本的运算：与、或、非。基本逻辑的简单组合称为复合逻辑。
4、逻辑代数三个基本规则：代入规则、反演规则和对偶规则。
5、化简电路是为了降低系统的成本，提高电路的可靠性，以便使用最少集成电路实现功能。
6、把若干个有源器件和无源器件及其导线，按照一定的功能要求制作在同一块半导体芯片上，这样的产品叫集成电路。最简单的数字集成电路就是集成逻辑门，以基本逻辑门为基础，可构成各种功能的组合逻辑电路和时序逻辑电路。
7、TTL门电路：是目前双极型数字集成电路使用最多的一种，由于输入端和输出端的结构形成都采用了半导体三极管，所以也称晶体管-晶体管逻辑门电路。TTL与非门是TTL门电路的基本单元。最常用的集成逻辑门电路TTL门和CMOS门。
问题集锦
1、同步电路和异步电路的区别是什么？
同步电路：存储电路中所有触发器的时钟输入端都接同一个时钟脉冲源，因而所有触发器的状态的变化都与所加的时钟脉冲信号同步。
异步电路：电路没有统一的时钟，有些触发器的时钟输入端与时钟脉冲源相连，这有这些触发器的状态变化与时钟脉冲同步，而其他的触发器的状态变化不与时钟脉冲同步。
2、什么是"线与"逻辑，要实现它，在硬件特性上有什么具体要求？
将两个门电路的输出端并联以实现与逻辑的功能成为线与。
在硬件上，要用OC门来实现，同时在输出端口加一个上拉电阻。
由于不用OC门可能使灌电流过大，而烧坏逻辑门。
3、解释setup和hold time violation，画图说明，并说明解决办法。
Setup/hold time是测试芯片对输入信号和时钟信号之间的时间要求。建立时间是指触发器的时钟信号上升沿到来以前，数据稳定不变的时间。输入信号应提前时钟上升沿（如上升沿有效）T时间到达芯片，这个T就是建立时间-Setup time.如不满足setup time,这个数据就不能被这一时钟打入触发器，只有在下一个时钟上升沿，数据才能被打入触发器。

保持时间是指触发器的时钟信号上升沿到来以后，数据稳定不变的时间。如果hold time不够，数据同样不能被打入触发器。
建立时间(Setup Time)和保持时间（Hold time）。建立时间是指在时钟边沿前，数据信号需要保持不变的时间。保持时间是指时钟跳变边沿后数据信号需要保持不变的时间。如果数据信号在时钟沿触发前后持续的时间均超过建立和保持时间，那么超过量就分别被称为建立时间裕量和保持时间裕量。
4、什么是竞争与冒险现象？怎样判断？如何消除？（汉王笔试）
在组合逻辑中，由于门的输入信号通路中经过了不同的延时，导致到达该门的时间不一致叫竞争。
产生毛刺叫冒险。判断方法：代数法、图形法（是否有相切的卡诺圈）、表格法（真值表）。如果布尔式中有相反的信号则可能产生竞争和冒险现象。
解决方法：一是添加布尔式的消去项；二是在芯片外部加电容；三是加入选通信号。
5、名词：SRAM、SSRAM、SDRAM：（SRAM：静态RAM；   DRAM：动态RAM；   SSRAM：Synchronous Static Random Access Memory同步静态随机访问存储器。它的一种类型的SRAM。SSRAM的所有访问都在时钟的上升/下降沿启动。地址、数据输入和其它控制信号均于时钟信号相关。这一点与异步SRAM不同，异步SRAM的访问独立于时钟，数据输入和输出都由地址的变化控制。SDRAM：Synchronous DRAM同步动态随机存储器
6、FPGA和ASIC的概念，他们的区别。（未知） 
答案：FPGA是可编程ASIC。  ASIC:专用集成电路，它是面向专门用途的电路，专门为一个用户设计和制造的。根据一个用户的特定要求，能以低研制成本，短、交货周期供货的全定制，半定制集成电路。与门阵列等其它ASIC(Application Specific IC)相比，它们又具有设计开发周期短、设计制造成本低、开发工具先进、标准产品无需测试、质量稳定以及可实时在线检验等优点。
7、单片机上电后没有运转，首先要检查什么？
a、首先应该确认电源电压是否正常。用电压表测量接地引脚跟电源引脚之间的电压，看是否是电源电压，例如常用的5V。b、接下来就是检查复位引脚电压是否正常。分别测量按下复位按钮和放开复位按钮的电压值，看是否正确。c、然后再检查晶振是否起振了，一般用示波器来看晶振引脚的波形；经过上面几点的检查，一般即可排除故障了。如果系统不稳定的话，有时是因为电源滤波不好导致的。在单片机的电源引脚跟地引脚之间接上一个0.1uF的电容会有所改善。如果电源没有滤波电容的话，则需要再接一个更大滤波电容，例如220uF的。遇到系统不稳定时，就可以并上电容试试（越靠近芯片越好）。
8、什么是同步逻辑和异步逻辑？（汉王笔试） 
同步逻辑是时钟之间有固定的因果关系。异步逻辑是各时钟之间没有固定的因果关系。
9、你知道那些常用逻辑电平？TTL与COMS电平可以直接互连吗？（汉王笔试） 
常用逻辑电平：12V，5V，3.3V；TTL和CMOS不可以直接互连，由于TTL是在0.3-3.6V之间，而CMOS则是有在12V的有在5V的。CMOS输出接到TTL是可以直接互连。TTL接到CMOS需要在输出端口加一上拉电阻接到5V或者12V。
10、如何解决亚稳态。（飞利浦－大唐笔试） 
答：亚稳态是指触发器无法在某个规定时间段内达到一个可确认的状态。当一个触发器进入亚稳态时，既无法预测该单元的输出电平，也无法预测何时输出才能稳定在某个正确的电平上。在亚稳态期间，触发器输出一些中间级电平，或者可能处于振荡状态，并且这种无用的输出电平可以沿信号通道上的各个触发器级联式传播下去。解决方法主要有：(1) 降低系统时钟；(2) 用反应更快的FF；(3) 引入同步机制，防止亚稳态传播；(4) 改善时钟质量，用边沿变化快速的时钟信号；(5) 使用工艺好、时钟周期裕量大的器件。
11、锁存器、触发器、寄存器三者的区别。
触发器：能够存储一位二值信号的基本单元电路统称为“触发器”。
锁存器：一位触发器只能传送或存储一位数据，而在实际工作中往往希望一次传送或存储多位数据。为此可把多个触发器的时钟输入端CP连接起来，用一个公共的控制信号来控制，而各个数据端口仍然是各处独立地接收数据。这样所构成的能一次传送或存储多位数据的电路就称为“锁存器”。
寄存器：在实际的数字系统中，通常把能够用来存储一组二进制代码的同步时序逻辑电路称为寄存器。由于触发器内有记忆功能，因此利用触发器可以方便地构成寄存器。由于一个触发器能够存储一位二进制码，所以把n个触发器的时钟端口连接起来就能构成一个存储n位二进制码的寄存器。
区别：从寄存数据的角度来年，寄存器和锁存器的功能是相同的，它们的区别在于寄存器是同步时钟控制，而锁存器是电位信号控制。可见，寄存器和锁存器具有不同的应用场合，取决于控制方式以及控制信号和数据信号之间的时间关系：若数据信号有效一定滞后于控制信号有效，则只能使用锁存器；若数据信号提前于控制信号到达并且要求同步操作，则可用寄存器来存放数据。

综合类问题考查
1、二极管的导通时的压降。  答：0.7V。  
2、三极管的工作条件。答：B极（基极）在有一定的电压时，发射极电压应该在0.3V以上。  
3、TTL电平的电压值。  答：5V上下浮动10%，即4.5V—5.5V。  
4、电路分析主要讲的是什么，或者是围绕着什么讲的？  答：两个定理，即基尔霍夫电压定理，基尔霍夫电流定理。  
5、数字信号处理的实质。  
答：数字算法或数学算法。通过数学或数字算法实现频谱搬移，从而达到滤波的效果。  
6、单片机总线。  
 答：数据总线、控制总线、地址总线（三总线）。P0口为I/O口，即可以是数据线，也可以是地址线，倘若都要使用时，要用锁存器将二者分开，做地址线时，充当地址线的低8位，高8位由P2口充当。  
7、晶振的接法或分类。  
 答：内接晶振和外接晶振。晶振与口线的距离越近越好。否则，会对其他部分造成高频干扰。  
8、键盘与控制器（或者是单片机）连接时是如何工作的？  
  答：通过控制器（或者是单片机）对键盘扫描，即：通过键盘与控制器相连导线上的电平值来判断按下的键盘，从而判断相应的键盘值，通过中断，调用相应的中断服务子程序。一般是通过键盘的行扫描和列扫描判断键盘。  
9、通信的三种解调方式。  答：调频、调相、调幅。  
10、语音信号的范围和传输比特。  
答：语音信号的频率为300—3400赫兹，取上限频率。一般取4000赫兹，有抽样定理可知最低抽样频率为8000赫兹，中国采用PCM编码调制，即位8段，因此传输比特为64K。（顺便提一点，中国采用的是A律，与欧洲是一样的，即13折线，日本、美国用的是u律，15折线）  
11、2M带宽。  答：语音传输是64K,中国用的是30/32线路系统，64K*32=2048k,即为我们所说的2M.  
12、无线传输为什么都是用的高频。  
  答：从客观上来说，使用的频段是已经订好的，常用的是80M—120M。从专业角度上来分析，是因为在高频段上能提供较为理想的信道，达到信息良好的传输和带宽的资源有效利用，而且这样所提供的信道带宽也比较宽。  
13、CDMA技术。  
  答：CDMA技术是码分多址技术，是无线通讯产品和服务的新时代率先开发的、用于提供十分清晰的语音效果的数字技术。通过利用数字编码"扩谱"无线电频率技术，CDMA能够提供比其他无线技术更好的、成本更低的语音效果、保密性、系统容量和灵活性，以及更加完善的服务。  
14、CDMA的工作。  
  答：CDMA利用扩谱技术将语音分解成数字化的小片断，然后进行编码，以区别每个电话。因而，大量的用户能够共享相同的频谱，从而大大提高系统的性能。也就是说，CDMA使无线服务提供商将更多的数字化信号挤压到一定的无线网络片断中去。  
15、常用的信道复用技术。  
  答：频分多路复用(FDM)，时分多路复用(TDM)，频分多址 (FDMA)，时分多址(TDMA)，码分多址(CDMA)。  
16、单片机对系统的滤波。  
  答：单片机对系统只能实现数字滤波，即通过一种数字算法对系统进行滤波。常用的有中值滤波，平滑滤波，程序滤波等。

单片机硬件工程师面试试题

一、现代通讯网络中广泛使用的交换方式有那两种？分组和电路
二．通常所说的TCP/IP协议对应于OSI模型的哪层？你认为网络模型分层有什么好处？如果让你来制订网络体系架构，你认为应该遵循什么原则？
第四（传输）和第三（网络）；方便调试和实现；分层实现
三．两个同步的时钟信号，一个为2M，一个为8K，用双踪示波器观察两个时钟信号，这时应该用哪个信号作为触发信号，为什么？
8k，所谓触发是同步的手段，如果用2M就不能观察8K了。
四．逻辑设计中应尽量使用同步设计，什么叫做同步设计？异步设计能带来哪些问题？在哪些场合可以使用异步设计？
采用同步时钟的为同步设计。异步可能带来毛刺。（同步的概念，同步为等待事情请求，处理器触发，这当中，你不能做某事，直到处理器回复完你的请求。异步：就是这当中，你还可以做其他的事情。）
五．什么情况下需要考虑高速信号设计，常用的信号匹配方式有哪些，各优缺点？
线长和波长可比。串联和并联，串联简单但效果一般，并联好但复杂。
六．提高硬件系统可靠性，应该从哪些方面进行考虑？
硬件：电源，应用成熟电路，多问厂家，多测试。软件：看门狗，多测试。
七、What is PC Chipset? （扬智电子笔试）
芯片组（Chipset）是主板的核心组成部分，按照在主板上的排列位置的不同，通常分为北桥芯片和南桥芯片。北桥芯片提供对CPU的类型和主频、内存的类型和最大容量ISA/PCI/AGP插槽、ECC纠错等支持。南桥芯片则提供对KBC（键盘控制器）、RTC（实时时钟控制器）、USB（通用串行总线）、Ultra DMA/33(66)EIDE数据传输方式和ACPI（高级能源管理）等的支持。其中北桥芯片起着主导性的作用，也称为主桥（Host Bridge）。
除了最通用的南北桥结构外，目前芯片组正向更高级的加速集线架构发展，Intel的8xx系列芯片组就是这类芯片组的代表，它将一些子系统如IDE接口、音效、MODEM和USB直接接入主芯片，能够提供比PCI总线宽一倍的带宽，达到了266MB/s。
八、我国无线运行商有那几家？中国电信 中国联通 中国移动通讯等。

共同的注意点
1.一般情况下，面试官主要根据你的简历提问，所以一定要对自己负责，把简历上的东西搞明白；
2.个别招聘针对性特别强，就招目前他们确定方向的人，这种情况下，就要投其所好，尽量介绍其所关心的东西。
3.其实技术面试并不难，但是由于很多东西都忘掉了，才觉得有些难。所以最好在面试前把该看的书看看。
4.虽然说技术面试是实力的较量与体现，但是不可否认，由于不用面试官/公司所专领域及爱好不同，也有面试也有很大的偶然性，需要冷静对待。不能因为被拒，就否认自己或责骂公司。
5.面试时要take it easy，对越是自己钟情的公司越要这样。


嵌入式系统求职回忆录
欧浩源(ohy3686@qq.com)
20081029
一、引言
一年前的这个时候,我开始了人生的真正求职历程。在这个过程中,有幸参
加过广嵌、迈瑞、华为、智光、周立功、理邦等几个比较大笔试和面试。虽然大
部分都失败了,但是我觉得正是这一次次的失败认我真正认识自己的不足,积累
经验,成长进步,为最后的成功打下坚实的基础。求职是一个展现个人综合实力
的过程,除了需要专业技能之外,还需要有一定的策略。同时这也是一个逐步提
高和适应的过程。 就像一支球队参加真正比赛之前都要经过系列的热身赛, 熟悉
对手的同时也在发现自己的不足。 那时候我经看看别人的面经,现在我觉得把自
己的体会跟大家分享也是一件很愉快的事情。 特别在这个找工作的高潮时刻, 也
希望我以前总结的求职经历能给大家一点借鉴和帮助哦......
二、广嵌面试
这是我人生的第一次正式面试,挺紧张的。广嵌在广州科学城那边,有点偏
了,人比较少。首先是做题,没有什么时间限制,做完就交。题目不多,8 道好
像,全是问答和编程题,没得蒙。主要考了 C 语音、数据结构、操作系统、编
译原理、内存分配和链表的一些东西。虽然是很基础的东西,但是平时不注意不
一定做得出来。题目做完了,HR 拿去给技术总监看,过了一会来告诉我,技术
总监对我的答题较满意, 叫我去会议室进行面试。 技术总监来是一个比较年轻的
工程师,谈吐之间感觉巨牛。我首先介绍了项目的情况,可能是第一次吧,讲的
比较细,他听了一会感觉出我实际做了点东西,懒得听我说,直接叫我停止,开
始问了我几个问题。看起来不是什么技术难题,但却不好答。我印象比较深刻的
是下面三个题目:
1、在学校实验室中编程做项目和实际编程做项目有什么不同,需要注意什么?
2、如果在公司中碰到了行政问题和技术难题应该怎么样处理?
3、你的职业规划或者是你未来几年打算怎么样?
这些的回答见仁见智。我没想到他会问这些问题,开始愣了几秒中,脑子一
下转不过来。不过我对自己的回答比较满意,可能技术总监也认同我的回答。接
着他问我做 TCP/IP 方面的东西怎么样。我说没有怎么样做过网络底层的东西,
主要做的应用层上面的套接字编程。然后他问我在 windows 和 linux 的驱动层和
应用层做过什么东西,我就讲相关的项目和工作稍稍说了一说。然后他给我介绍
了进来公司要做的一些工作,主要是做 TCP/IP 应用层的测试验证工作。后面也
没什么问了。 他出去后, HR 进来和我谈了谈公司的具体情况和福利方面的东西。
大概三个小时,我的第一次面试就这样结束了。
三、迈瑞笔试
收到迈瑞的笔试其实不是很意外,但是比较突然, 没有想到当天宣讲完第二
天下午就开始笔试,一点准备的机会都没有,去开开眼界吧。迈瑞通知我去考软
件工程师,但我 C++其实不怎么懂,肯定得交白卷。还好可以和来霸王面的人一
起进了硬件工程师的考场。进去后我又要了系统研究工程师的题目,觉得系统的
东西具体不是很清楚,思路说说还是可以的。然而,这次考试实在对自己的打击
太大了,总算看清楚自己的真是水平了。在硬件的题目中,考试范围很广,模电,数电,CPLD,操作系统,算法,
智力,设计等都涉及到。对打击自己的是,明明看着知道怎么做,但是忘记相关
的公式概念,没法下笔,更伤心的是会做的粗心做错了,唉...无药可救了。
第 1 题是单位的换算,我居然把 1Gbyte=1000Mbyte,出来想想才知道错了,
应该是 1024。 第 2 题是一个模电的题目,考查共射三极管的电容对上限截止频
率和下限截止频率影响,包括耦合电容,极间电容和布线电容。第 3 题是问什么
是摩尔定律, 摩尔定律对硬件开发有什么影响?我一个字也写不下来。 第 4 题又
是一道伤心的题目,这是我唯一一道有点把握的题目,给了两个运放,要求写出
名称和表达式,一个是差动比例放大器,一个积分电路,但是由于粗心,将差动
比例放大器推导推错了。接下来的题目是什么呢......第 5 题做不出来,题目是说
电容在高频的时候可以等效成一个电感、一个电容和一个电阻的串连, 问实际中
在什么频率时候使用做合适。第 6 题是数电的题目,什么是冒险与竞争,怎么样
去消除冒险与竞争。数电的最基本题目,我又空白,你说这样的题目我都做不出
来,在简历上吹你熟悉模电和数电还有人会相信吗?下面一题是英语翻译题目,
给一个 PCI 的读时序, 让你翻译将上面的英文翻译成中文。 接着是一个智力题目:
一个人从 A 城市下班后乘火车到火车站,他的妻子从家里骑车刚好到车站接他
回家,一天,他坐了早班火车,5:30 就到了火车站,然后走路回家,他的妻子
在半路上接了他,回到家里发现比平时早了 10 分钟,问他坐了多少时间的路?
这题我又挂了。后面是选做题,3 选 1。一道模电,给了运放、二极管,一个 AD
前端信号调理电路,要找出其中的错误。唉,又没头绪,估计是二极管钳位,写
了几个字。另外一个是要用 CPLD 语言描述出 JK 触发器,再用 JK 触发器和与、
非门搭出 D 触发器。这题我又放弃了。最后一个是操作系统的题目,关于 PCI
总线的三个读取方式的, 只能放弃了。后面还有哦,一个二叉树遍历的程序补充,
呵呵,这是数据结构最基本最简单的题目,我又缴械了。应该是最后一题了,说
说你的一个成功的项目或者课程设计,画出结构框图,说出工作原理,碰到了什
么难题怎么样解决。这个当然谁到会写拉,不就吹牛嘛。
再看看系统工程师的题目,分三个部分。第一部分有四个可选题目,和公司
的四条产品线密切相关, 第一个是描述心电信号的特点和测量方法。 第二个是描
述人体生理信号的特点与测量方法。 第三个是说说数字滤波器的特征和实现,最
后一个是说说光谱吸收装置的原理好像。 本来觉得第三个很眼熟,但是又不知道
怎么下笔,算了,反正都不会,选了第一到吹了一通。第二题是编程题,一个是
补充汉诺塔的程序, 还有一部分是计算冒泡法的比较次数和用顺序法找一个最大
值的平均次数。下面一道题目是设计题目,设计一个数码相机,从市场需求、功
能设计、质量方面、可行性和市场风险去设计。还好这个可以写点东西,不然正
的是交白卷了。最后是一个 4 选 1 的题目,考查的是精度方面的东西。第一个是
说说游标卡尺的精度影响因素, 第二个是分析数控机床的精度影响因素, 第三个
是分析光强测量装置的精度影响因素。 第四个忘记了。我选了数控机床那个东西
写了几个字。
虽然是深深收到了打击,但是也真正的看到了自己的水平。 学了那么多年,
最基本的东西都没有掌握,正是惭愧啊。 看来是时候开始好好找找自己的方向了,
明确一个目标就去复习复习吧。 软件东西我懂的都是皮毛, 看来和它有缘无分拉,
和硬件看来还有点尘缘未了啊。
11 月 1 号补充:虽然没有面试的机会,但是还是关注了迈瑞的面试情况,
顺便记录了些在浙大 BBS 上看到的浙大牛人的面经:面试官是那天监考的工作人员, 考卷也是他看的。 好像他是根据考试情况来
定面试内容的。从来开始讲一下他的问题吧:
1.你选择深圳工作,有考虑过深圳离你家近?
2.如果老板给你一个很急的任务,按理来讲要 7 天完成,但是却要你 5 天之内完
成,你会怎么办?
3.你的身边有这么一个老工程师,他可能不如你厉害,但是他脾气还很不好,你
会怎么和他相处?
4.你的老板有一套方案已经确定了,而且马上要实施,而你认为自己的方案也不
错,并且在某点还很有创新,你会怎么办?
5.你对选择做硬件有什么特别的想法?
6.我看你最后一道题答的很详细也很工整,是我想要的结果,但我还是想让你给
我解释一下关键问题的解决思路。 他会给我一张纸,在我画框图的过程中打断我,
顺便问几个技术问题,比如运放做比较器和专门的比较器会有什么不同点等等。
最后他说可能不一定会有二面,但是 11 月 1 号上午会确定是否给 offer。
我的感觉是: 在答最后一道自由发挥的题时,大家最好把自己最熟悉的项目
写上,并且写清楚,这样会给人家留下非常好的印象。另外项目如果不是自己做
的,或者解释不清楚的,简历上最好不要提,被他们盯上就不好说了。但是他们
还是很 Nice 的。
四、华为笔试
人家说得不错,要做好一些事情,不但要有目标还需要有充分的准备。虽然
我没有什么明确的目标,但是这次我有了稍稍的准备。自从被迈瑞打击了一下,
我重新认识了自己。回来正经地复习了一下功课。
虽然华为的硬件笔试题目出得很基础,但我也有不少做不好。但总算可以从
迈瑞的失败中稍稍恢复了一点点信心,不管结果怎么样,我终于可以从头到尾做
完,还提前了半个小时交卷。下面稍稍总结一下吧。
对于华为,我感觉浙大的牛人很不屑一顾。BBS 上面关注的人不多,有也
是华为负面的消息。迈瑞笔试那天有四个教室人,华为今天也就一个阶梯教室人。
在笔试之前,华为都给参加笔试的人打了电话,问问情况。我也收了两个,不过
没带手机,没接上。接到电话的人有两个被调整到技术服务类了。不过听说技术
服务类比研发的待遇要好哦。在考场上,什么也不用检查,去了就考,没有通知
到的也可以考,总之是来者不拒。
试卷有 10 道填空题,12 道单选,12 道多选和一道分析题。其中分析题就叫
写出 2-4 译码器的真值表,是不是比期末考试还简单呢,20 分哦。填空题第一
道就是一道运放题目,给一些已知条件求运放的输出电阻,出来听大家讨论,好
像我作错了。第二道又不会,问 2DPSK 是什么键控,是通信方面的内容,在百
度搜了一下,原来二相差分移相键控。下面有什么是误码率啊,什么 PCM 一次
群,8086 的寄存器是几位,给你一个 128K 的静态 RAM 和起始地址,问你最后
一个字节的地址,还有 VHDL 和数字逻辑等等。有一道题我真写不下东西,问
组合逻辑输出用做时钟容易产生什么。在单选题目考还是那些基础的东西,有问
IBM-PC 和兼容机的 I/O 端口空间,PCM32 一次群一个复帧的时间,还有是问码
元长 0.1us,2.5 秒产生一个误码,其误码率是多少,不会就蒙吧。还问到 RAM
和 ROM 的区别,静态 RAM 和动态 RAM 的存储单元结构等等。多选比较变态
点。第一题问下面的逻辑门必须上来电阻的是:OC 门、OE 门、OD 门、以上都要。第二题是问你下面是可编程逻辑器的是:ASIC、PAL、GAL、FPGA、CPLD。
第三题是 RISC 和 CSIC 的区别。第四题是总线的功能,我不知道驱动是不是总
线的功能,所以没选。第五题有点难,问下面避免竞争冒险的是:采用同步时序
电路,采用异步时序电路,修改状态转移表,增加延时逻辑。第六是 ROM 和
RAM 的区别,下面是 8051 的 P3 脚复用功能,接着是检波器的组成,还有常见
的滤波器。第 10 题不会:问 8KHz 和 10KHz 的正弦波经过混频器之后,能产生
下面那些频率的信号:-2K、2K、18K、1K。11 题考 8051 的中断,最后一道不
容易,问下面对负反馈那里两个是对的。
从题目的难度和广度上看,比迈瑞的简单,但是没有准备过的人也很难做出
来的哦,范围广,重基础,关键还有可恶的多选选择。总的来说,我对自己的表
现比较满意。没有迈瑞的那么狼狈。但是,估计没有下文了。我想这份题目做得
好的人大大的是啊。听上午接到电话的人说,华为搞硬件的主要是 3 个方面:
DSP 和算法、逻辑电路、ASIC。唉,这三个我没有一个会,更不用说懂。就算
有幸进到一面,也会被刷的,我想主要还是专业不太对有点影响。未来的事情就
等它发生了再说吧。好好准备眼前的事情才是正道。
五、华为一面
华为的硬件笔试考完之后感觉不错, 果然得到了一面的机会。不过我们学校
去参加笔试的都可以去参加面试。不过听说华为这次做硬件的只招收 DSP 和逻
辑两个方面,我一听就觉得自己就此终止华为的征程了, 看看大公司的面试也是
长长经验吧。我的面试时间被安排在 6 号的 9 点,搞到那天 6 点 45 就得起来从
下沙赶到黄龙那边的一个酒店,极度的痛苦。
不知道怎么搞的,和我一起来的几个 9 点 20 的都面试完了还没有轮到我们。
后来问问才知道我被安排到 DSP 组里面去了,后来赶紧叫他们改为逻辑。大概
等到 11 点,终于到我了。不过当我走到面世官的前面,他却说要上洗手间,叫
我等几分中,看来真是出师不利啊。
面试官很和蔼客气,大家 say hello 之后,我紧张的心情松了不少。然后他开
始瞄我的简历,我估算了一下,不超过 3 秒钟。还好我做的是一页简历。他看到
我后面有两个项目的实物图, 就指着我在 04 年机械设计大赛的获奖作品问:
“这
个好像是什么车?” 我说这个是我在省里面竞赛的一个作品, 主要用一个多单片
机系统控制直流电机和舵机完成相应的功能。不过他好像不感兴趣,然后就问:
“我看你的简历好像做 DSP 和逻辑的比较少嘛”(其实我根本就没有做过) 。我
赶紧说: “是的,我们研究生虽然有相关的课程,但是我们学到只要是一些入门
的基础, 离实际的应用还很远,我在本科的时候主要是一些基础知识的系统学习,
在研究生阶段主要是跟老师做做项目,其实我现在的技能主要和我做的项目相
关,在以前的基础上的其中一两个方面进行比较深入的研究。 ”面试官看了看的
简历说: “我看你做单片机的项目比较多嘛,我们也有做单板机软件,也有用一
些小型的 CPU 和 AD 转换、DA 转换的一些东西,你愿不愿意做呢?”我想 DSP
和逻辑肯定挂了,这个还有一线生机,赶紧说:
“OK,没有问题,其实我的毕业
设计就说一个单片机的数据采集和处理系统,我把实物带来了,你要不要看一
下?”他点头示意可以。我心里一阵高兴,终于可以使出我的武器了。
下面的面试内容的完全按照我事先预料的方向进行了。 首先我详细的介绍我
带来的系统,从原理到框图,从性能到关键点说了一通。他听完,问我: “这个
系统是你设计的吗?” 对于这个问题我觉得还是老实做答好,不然会死得很惨的。我说不是,我参加这个项目的时候,这个系统已经设计好了,我做的工作就是对
老的版本进行测试,改善,从硬件和软件两个角度去进行性能和稳定性的提高。
他说:
“那好,我就问你几个问题吧?”首先问我上面一个三极管是干什么用的,
我说那其实不是三极管,是一个稳压器 79L05,产生一个-5V 的电压给 AD。然
后他问我上面两个二极管是干什么用的,我说那是起保护作用, 主要是限制电流
反流。他一听很奇怪,他说二极管好像没有限流作用吧,我觉得他可能听错了,
就补充了二极管的单向导通性, 圆了一下场。接着他叫我将系统上面的有源滤波
画出来,完了,这个系统我就那个地方没有弄懂。怎么办呢?只有画吧,凭着记
忆画了一个二阶的有源滤波电路,跟他说我其实忘记了,大概说这样吧。他说那
你讲讲这个滤波器的工作原理吧,我连画都画不出来,原理更讲不清了。我就跟
他说:
“其实二阶的滤波器和一阶滤波器的推导大致原理一样的,我画个一阶的
来解析一下吧” 。然后就画画讲讲,其实我还讲的比较清楚的拉。他问了最后一
个问题,如果你的那个传感器的线比较长,会对你的系统有什么影响,其实我也
是按照大致的方向去答的拉,我说这样就会导致信号的衰减和干扰的增大。 他稍
稍停了一下,问我喜欢做偏硬一点的还是偏软一点的。我说相对来说,我平时对
偏软一点的做的事情比较多。他说: “那我就给你定底软的岗位吧,我现在要考
考你;两道 C 语言的题目。
”然后取了一叠试卷,边找边说给我找两个简单点的
题目。
第一个:写一个宏名为 MIN 的宏,输入两个参数,求最小的那个?晕倒!
我见了很多次,但是为什么偏偏在那个时候忘记呢?但是总不能说不会吧,人家
都说给我找简单的了。只有硬着头皮写拉。我的答案是:
#define MIN (A,B) ?(A>=B)B:A
他看了我的答案,马上指出我的几个错误,应该是:
#define MIN (A,B) (A>=B)?(B):(A)
第二个是读程序写结果,在一个 mian()函数里面循环 3 次调用一个有静态变
量的函数,输出一个和的结果。这个我最熟悉的了,三两下就把结果和过程都写
出来了。
这时,面试也差不多要结束了。面试官问我工作地点的问题。我说我是广东
人,希望在深圳,他说这个没有问题。然后我再一个确认我的工作内容,他说主
要是底软吧,到时候部门之间再调配一下,他看了看我的简历,发现我有 ARM
和 LINUX 的经验,他说其实他们也会做相关的东西,例如 VxWorks 等。
这时,面试官对我说,他对我的能力比较满意,我心里一阵狂喜,不知道是
骄傲还是高兴。他主动站起来和我握手,说叫我等秘书的通知,下一轮面试通知
会在这两天发出。这时我都不知道自己在做什么了,收拾了下我的东西,临走前
我主动和面试官再次握了握手,感谢他的面试与指导。
六、华为二面
没想到华为的工作效率那么快, 本来还以为要到 8 号才有二面的通知, 所以
6 号晚上玩了一把,到 1 点才睡觉。当我睡得正香的时候,来了两个短信,心里
一阵狂怒,凌晨两点半什么人那么无聊发短信啊。不过一看原来是华为通知 7
好早上 9 点半面试,果然和大家说的一样,集体群殴 PK,不管它了,继续睡觉。
本来想睡到 7 点起来的,不过 6 点 20 分左右,又来了短信,还是华为通知面试
的,他们不会加班到通宵吧。
我们学校去参加研发一面的有 4 个人, 其中有 3 个都进了二面。 到了指定的酒店后,先是填表,还真是详细,什么都得填。本来安排是 9 点 30 的面试,后
来拖到了 10 点 20 左右。之前,我们组的 12 个人都到得差不多了,大家赶紧先
认识一下,到时候 PK 的时候也比较熟悉嘛。
时间到了,我们在一个 MM 的带领下进了房间,三个桌子排成三角型,中
间一牌是面试官 4 男 1 女。两外两个是 AB 两组,反正大家随便坐,12 个人分
成两组 PK。首先是每个人用一张纸折一个铭牌,将自己的姓名和应聘岗位写在
上面。然后面试官开始叫我们自我介绍,要说得让面试官和大家对你留下深刻的
影响,说说你的特点和以后的职业规划。我发现浙大的人理想很大哦,职业规划
都是要做什么技术管理结合的职业经理人。我都忘记了我是怎么样介绍我的, 好
像说了说我一些竞赛获奖,说了说我的业余爱好,喜欢踢足球拉,还有就是我觉
得我的硬件基础比较扎实,在华为里面能发挥所长,体现价值,华为是一个大企
业,我在里面也能得到锻炼和成长。不知道这样说有没有问题?
接着开始一个活动,在 10 分钟里面,每组按照发的题目将里面属于白领最
忧虑的事情进行排序,然后由组里面的一个人进行陈述理由,然后其他人可以进
行补充。活动刚开始我提了一个意见,但是有一个人的意见比我的更好,那就按
照他的意见去做吧,我顺势将他推举为我们组的 leader。在 10 分钟里面,HR 们
过来看大家的表现,然后打分,反正我是没有怎么去排列,我只是协调一下大家
的动作啊, 看看时间啊。 很快时间到了, 他们组先进行了陈述,在陈述的过程中,
面试官会打断陈述,叫另外有个人补充表述。我们这组也是。在这个表述中,我
基本上没有什么话,算是话最少的了。
两个组的排列顺序很不一样,这时候面试官说,你们两个组分别陈述理由,
让对方同意你的观点。然后,两个组的人就纷纷展现自己,在这个过程中,我几
乎一言不发,看来犯了群殴的大忌了。最后,面试官叫没有发过言的同学起来说
两句,我是最后一个起来发言的,我就总结性的说了两点,然后就休息 5 分钟。
其实休息 5 分钟是让我们两个组在外面交流一下,统一一下观点。我知道他
的意思, 出来后我问两个组是不是应该统一一下观点啊, 好像他们也没有退步的
感觉,那就算了吧。
很快有进去了,首先面试官叫对方组的一个人起来,说说他的看法,他说同
意了我们组的一个观点但是也有不同的地方。他说完之后,面试官看着我说,你
们好像在外面统一了一下观点,你说说将 B 组的 12 点排在前面,你认不认同。
我突然晕了,这怎么回答呢,答认同嘛,不知道会不会被我们组认说,说不认同
嘛,那面试官明说说我们统一观点,而且 B 组的人也妥协了。那我只有用了找
迂回战术,顺着 B 组刚刚的内容说了些总结性的东西,既不认同也不否认认同。
面试官看我答非所问,又将问题问了一遍,我又将刚才的话说了一边。晕倒,这
时那面官来了句其实我只是问你认不认同,这时候我发现我们组的 leader 在我的
纸上写了认同两个字,我赶紧说认同认同,这才能坐下啊。
接着就是 PK 时段,想不到我是我们组唯一参与的。B 组也有一个人,面试
官说,给你一个机会你把你的特点和长处说出来,让我们觉得你应该加入华为。
对方那人说啊说,面试官还让他举了一个案例。真想不到会轮到我要参与 PK,
是不是因为我话太少,不够积极呢,还是什么......面试官看我有点紧张,就对我
说,你看我现在给了你这么好的一个机会,你要把你的特点和长处说出来,其他
人我都没有给机会啊。不知道是不是安慰我的话。然后我就慢条斯理的说,我自
己性格比较随和,喜欢跟别人交流,我觉得在交流的过程中会得到很大的提高,
我的基础知识比较扎实,在项目的实践过程中,发现基础技能很重要,很多高端的问题都可以用基础的知识来解决。说我本科是学硬件的,研究生学的是软件,
在实践的过程中发现现在不管是硬件开始还是软件开始都是一个协同的过程,不
能机械的拆分两者, 说我考虑问题会从系统的角度去分析,个体不一定是最好的,
但是可能对系统的贡献是最大的。最后我总结说,我的优点是我为人随和,有独
立分析问题和解决问题的能力,自我适应能力和学习能力比较强,在知识结构上
面,软硬件结合,实际项目经验较多。面试官接着问我平时爱好干什么啊,我就
说我喜欢体育运功,特别喜欢踢足球。他居然问我踢那个位置,不知道他是不是
也踢足球的,我是中场。他又问我平时都和什么人踢啊,是不是和同学踢,我说
不一定,有时候和同学踢,有时候到了球场上,碰到谁就和谁踢,还说我参加过
一个大型的足球比赛。
就这样传说中的华为群殴结束了,虽然没有网上说得那么恐怖,但是也领我
感到有点不爽,不知道是不是我被问的缘故。后面还有 10 分钟的提问时间,有
人问了华为集体辞职和加班的问题, 还有下面的一些安排。这时我才知道下面还
有一个单对单的综合面试和综合素质测试、性格测试和英语测试。
长路漫漫啊......不知道还能不能收到三面的通知呢?等等吧......
七、智光面试
非常感谢智光电气给我面试的机会拉。由于 18 号中午学校要进行毕业生的
图像数据采集,我没有办法参加智光电气的笔试,虽然在宣讲会那天和相关的人
员打了招呼,但是那天一直到下午三点多还没有收到任何通知,在浙大 88 上看
到已经有人开始面试了,感觉这次是不是又没戏了呢?干脆回去寝室睡觉算了。
这时居然接到了智光电气的电话,说明天什么时候来杭州百脑汇 8 楼面试......
没有参加笔试和一面,直接参加 19 号的面试,这样的待遇我还是头一次,
很有受尊重的感觉。有机会就不能错过,剩下的时间我就开始临时抱佛脚,听说
很有用,不过面试的时候我都没有用上,因为我的面试估计也就 10 几分钟吧。
之前我等了大概半个小时。
面试我的是一个博士, 还有另外三个人。主要就是根据简历上的东西随便问
问你,但是每个技术都问得很到点子上,但是我也答得很到点上, 而且还很老实,
很多东西都直接说不是我设计或者不是我一个人做的, 或许这样他们就不再往下
问了。现在的硕士大家都知道什么水平的拉......总不能说自己是什么大牛,估计
我是说了肯定逃不过他们的法眼。这次我仍然带了我的毕业课题做的板子过去,
不过他们就随便看了看,也没说什么,我一点发挥的机会都没有......是不是他们
看不上呢?他们问为什么用华邦的单片机做呢?我说便宜啊。 就这样。 另外还问
我有没有做过电机方面的东西, 那我就把以前机械设计竞赛和指导电子设计竞赛
的一些东西说了说,大概就五六句话吧。后来有个人问我做的一个数据汇集机用
什么进行电话网通信的,我说是 MODEM,本来以为可以大说一顿的拉,那个工
程师说可以了,知道了。那我也没什么说的了。基本上聊了一些基本问题面试也
就结束。
接下来就谈待遇了,那个主面的博士问我期望多少钱,经过多次的打击,我
也不好意思说了,就说我没有很高的要求,中等就可以了。他叫我尽管说。我说
5K 到 6K 吧。他说 5K 应该没什么问题的。估计也就这个身价了。后来聊了一些
工作内容和时间的问题,基本都比较合意吧。然后就叫我准备三方了。我说两天
内答复。找工作实在太累太耗时间和精力了,其实也没有什么可以选择的了,就
这样......回去再想想,卖了吧。八、理邦面试
自从上次在智光面试完之后,也没有什么合适的单位到来。在智光面试完,
我正准备签三方的时候,他们的 HR 告诉我,要等广州总部的总工电话面试,但
是快两个礼拜了都没有音讯, 估计我是被他们放弃了。正好 1 号深圳理邦来浙大
宣讲,就去碰碰运气吧。
那天宣讲完马上开始笔试, 还好之前抱了下佛脚。 原本我应聘的是嵌入式软
件工程师职位,需要考一份软件题,不过一想到软件的算法,心里有点慌慌,要
了份硬件的题目来做。题目不多,八九道简答题,主要涉及晶体管、运放、滤波、
触发器、AD、通信、单片机等一些很基础的东西。我已经是身经百考的人了,
每个公司的硬件题目都差不多的,大部分做起来没有什么问题,除了一个压控电
流源和一道场效应管的题目没做,其他的问题不是很大,估计有下文,果然晚上
接到了面试的电话。
理邦公司给你第一感觉很实在,很规范化,而且很守时。面试安排在 9 点
20,我怕迟到早点到了, 说 20 就是 20,我在面试的时候发现他们原来是有表的,
难怪时间那么准,一次面试,经历了三个面试官的车轮战,对于我来说,还是头
一次。
第一战:技术面试
我原来是他们通知的第二个来面试的人。面试的时候,和他有好几米的距离,
感觉有点紧张。 上来第一个问题是你喜欢做什么样的工作,然后开始按照你的简
历上面的所做的项目来问,我都忘了我怎么回答的了,总之就是不停的说。我第
一次感觉到我的简历没有被浪费, 他们用黄色的荧光笔在上面画了不少东西, 看
来我还是有一点东西能让他们感兴趣的。 它对我应聘嵌入式软件工程师去考硬件
题目有点奇怪,那也没什么好解释的,就觉得自己对硬件更有把握一点。这时又
问了一些 linux 和 ucos 方面的东西等等,最后问我技术上面有什么问题需要问的。
这个我还真的没有怎么备,不问感觉好像对公司和个人不关心的,我问他们像我
这种非生物医疗专业的人进去做会不会很困难。 他说没关系,我看你的计算机学
得很不错,呵呵....这句话我搞得我很不好意思。也就是十几分钟,就结束了,
要走的时候,他说我考的是硬件题,技术总监要面试我硬件方面,面就面罗。
第二战:技术总监
技术总监给你感觉和蔼而威严。 他看了看我的成绩单, 好像更关心的是我本
科的成绩,他说你本科是机械自动化的,那你觉得你和电子、计算机专业的学生
竞争有什么优势吗?说真的,在专业技术上面没有任何的优势,我主要围绕着软
硬件结合和项目经验比较丰富这两方面来讲, 好像说得过去了。 接着他问了我单
片机方面的一些东西,好像他们对 UCOS 这个东西比较感兴趣,问我 UCOS 移
植到 MSP430 上面行不行,我说没什么大的问题,然后说了说这个移植的过程。
这个过程中,我感觉我一直在不停的说, 嘴都干了,都不知道我那来那么东西说。
在他问我为什么要在 6 月份毕业的时候,一个女的 HR 进来了,正好,技术总监
叫我跟她出去了。
第三战:面对女 HR
也许这次是我第一次真正的面对 HR,感觉很不自然,而且问题回答的很糟
糕。在整个过程中都非常的严肃,我不知道其他公司的 HR 面试是不是也这样。
在面试的时候,我看到她在一张写着资格审查的表上写了我回答的问题,她
问的问题我基本上都没有什么准备过,总之,问什么就答什么,但是我犯了个错误,有些问题不需要答得太多,说多了就会有问题...
首先问我的职业规划是什么样的,我还真没有考虑过,经过上次华为二面的
教训,我大概把 3-5 年的打算说了说,就一句话,我这段时间想在一个行业里
面做研发,在技术上面多点积累,五年后可能做做技术管理方面的东西。然后问
你要找什么样的公司?工作地点在那里?有没有女朋友?平时喜欢干什么?性
格是偏内向还是偏外向?其实这个我自己都不是很清楚, 应该是有点内向吧。 问
我身边都是些什么朋友?这个问题我答得比较糟糕,我也不想多说拉。 接着问你
父母对你的最大影响是什么啊?对加班的看法?你最艰难的时候是什么时候,这
个地方我又说多了,唉.....还问了毕业时间和实习的一些情况,最后问我有没有
offer,我还真的是没有啊,问我以前有没有 offer,我说智光电气给我了口头的
offer,她好像很关心,把这个公司和我应聘的岗位都写下了,问我他们的待遇是
多少,她顺便问我期望薪资多少,我想他们也不会给太多,说了个 5K 到 6K,
估计最后成的话也就 5K 吧。最后她例行的问我有没有什么问题要问的,我之前
还真没有考虑过哦,问了她在公司里面三年这个发展过程怎么样。
1 号上午理邦一面回来感觉不是很好,但是晚上还是收到了二面的通知。在
宣讲会的时候,他们说是要小组面试,我心里想一面的时候,技术专家面了,技
术总监也见了,HR 也谈了,二面面什么呢,小组面试会不会是跟华为他们一样
的呢?心里没有什么底,也不知道怎么准备,干脆就不准备了。
冬天早起的确是一件很艰难的事情,好不容易才爬起来,九点钟面试,我八
点五十五才感到面试地点。 当我进去面试的房间才知道他们的小组面试是什么回
事,原来所谓的小组,是他们小组,面试我一个人,昨天面试的 3 个人一起来面
试我,大概 30 分钟吧。原来还是问技术方面的问题,但是问的很深入,有很多
问题我知道也做过,但是答的不完整,有些问题他们继续深入问,我只能说不知
道。他们完全按照我简历上面写的项目和技能来进行考查,所以说没有做过,甚
至没有什么把握的东西,最好少出现在简历上面,一旦有严格考查的公司面试,
一下就暴露出来了,而且还觉得你有吹嘘的嫌疑。
面试一开始, 公司技术总监就拿着我的本科成绩单和笔试题目说,我是机电
毕业的学生,但是从笔试来看,我的基础不是很好,这个怎么办好呢?问我准备
以后怎么样去补救。 其实我觉得这份题目做的还不错的拉,我看他在那道压控二
极点高通滤波器上面打了一个大叉叉,我本来还觉得这道题目会做对的呢?然后
他问我一些做“月球车”比赛的事情,我回答得应该不错,他说我是这个团队的
军师了,这我科万万不能接受啊,赶紧把队友的贡献说了一通,强调他们的重要
作用,这个团队里面少了谁也不行。接着问我一些单片机相关的项目,这个我都
答得没有什么问题。然后是一个应该是偏软件一点的技术专家问我。 首先就我用
VC 做的一个项目问我 windows 消息的机制是怎么样实现,这个问题其实我答得
不是很好,我就项目上面基于消息机制的异步网络传输说了一些 windows 消息
机制的一些东西, 他接着我说的问我知不知道将关联消息和消息响应函数的那个
宏是怎么样实现的,有没有看过代码,我只能说没有看过,但是我说我知道它的
原理,是用一个静态的函数表将消息和消息响应函数关联在一起的, 他又顺着问
题往下问我知不知道这个函数表叫什么,我又只能说不知道了。下面他看我上面
写着有 linux 下 C/C++开发的经验,就开始从这里问我了。看我上面写着做过字
符设备的驱动, 其实我只是做做实验看看代码而已,我就把字符设备驱动的框架
说了一说, 他又接着我的回答, 问我知不知道操作系统怎么样找到设备相应的处
理函数的,我也没怎么样想,就直接说不知道了,但是我说我觉得他们应该是怎么样的,我想应该回答得到点上面了。接着他问我有没有做过 linux 上面的应用
开发,我还是老老实实的告诉他吧,没有做过。他好像对我在简历上面的不老实
有点不满。然后他继续问我相关于嵌入式和 linux 方面的东西,比如说移植啊,
bootloader 啊,会不会做 randisk 啊等等,大部分我只能 say no 了,但是我也不是
完全举手投降, 把相关的知识点答了一些, 可能这也为我前面的不足做了一下弥
补吧。最后是 HR 发问,还是一些常规但是不好答的问题:你觉得什么是成功?
你觉得人生的意义是什么?你觉得自己有什么缺点?你为什么要选择理邦?你
觉得到了理邦公司你能做些什么样的贡献?如果现在给你 offer 你会不会签?等
等...我觉得这些问题的回答非常关键, 可能前面你都答的不错,但是这问题回答
不好,也会被 out 的。我觉得今天我这些问题答的还是可以的,虽然不是很好,
总之这些问题怎么回答还是见仁见智的了。最后一个环节是例行的问我有没有什
么要问的,我其实也没什么问的了,但是不问不是很好,就问了一些关于实习的
事情。面试结果要到下午才能知道。
想不到他们效率那么的快,在中午我正在食堂打饭的时候, 他们的电话来了。
虽然有点吵,但是还要赶紧接拉。HR 先把面试结论告诉我,没怎么听清,大概
是说我知识面比较宽,但是深度不够,基础不是很扎实等等等等,但是作为一个
嵌入式软件工程师来说,还是可以培养的,下午可以来签约了,然后是待遇的情
况,说了一通时候,告诉我要带什么什么。
还考虑什么呢,下午赶紧把需要的东西带齐,奔赴浙大签约了。签约只是一
个 5 分钟的过程,他们把资料收好,给我出了张公司的接收函,再给我一张联系
方式,整个签约就结束了,巨快。我就这样卖出去了,尽管有很大的遗憾,但是
最后我选择了一个高校,跟理邦办了违约手续。
九、经验总结
1、要有备而来,尽量将面试官引导到你最擅长的地方。其实他们也希望这
样的吧,否则他很难发现你的能力和特长,而他不知道你的长处,就只有按照他
的思路来考你,对你乱开枪,这样大家都没有得到想要的结果。
2、诚实最重要,懂就懂,不会就不会,东西不是你做就不要乱认。面试你
的都是这一行的资深工程师,要忽悠他们可没那么容易。
3、对于不会回答的题目,不一定要给出准确的答案,只要往正确地将大致的
思路说清楚就可以了,关键是你把你思考的过程告诉面试官。
4、要有自信心,当被问到确实不会的问题是,可以问问面试官,他们会给你
一些提示或者思路,你或许能做出来呢?
5、平时要主要积累和准备,不然当面试机会来临的时候就手忙脚乱的拉,
不过有时候临时抱佛脚也挺有用的,总之,没有准备很难有好发挥。
6、投简历要有目的性,瞄准一家之后,做好各方面的情报工作,在网上收
集试题、面经等等。再投一些同类的公司,他们只是您的热身对手,重在参与,
发现不足,锻炼心理,演练战术。
7、笔试不可怕,笔过两会就经验丰富了,考什么你心里很自然会清楚的。
硬件的当然是数模电基础、单片机接口和 C 语言拉。嵌入式方面少不了操作系
统、网络原理、驱动等一些内容,但都是基础,比期末考试还要容易呢。
8、求职是一个复杂的过程,职场如战场。您完全可以把它看作一场战斗,
优胜劣汰,除了有足够的枪支弹药,还需要有战略战术的指导。
祝大家求职顺利,个个早日找到理想的工作岗位。



一份基础的嵌入式Linux工程师笔试题

北京顶嵌嵌入式培训机构   2009-03-30 09:52:55 作者:NATE 来源:顶嵌特约记者 文字大小:[大][中][小]

一、 填空题：
1． 一些Linux命令,显示文件,拷贝,删除


2． do……while和while……do有什么区别？


3． Linux系统下.ko文件是什么文件？.so文件是什么文件？


4． 二维数组AA [ 3 ][ 7 ]的另外一种表示方法：


5． 请写出下列代码的输出内容
#include “stdio.h”
  main()
  {
   int a,b,c,d;
   a=10;
   b=a++;
   c=++a;
   d=10*a++;
   printf("b，c，d：%d，%d，%d"，b，c，d）;
   return 0;
  } 
    

二、 编程题：
1． 写出两个排序算法，并说明哪个好？
2． 打开一个文件，并读取从第100字节开始的50字节数据。
3． 编写一个函数，输入一个的整型数字，可以选择按照8/10/16进制输出字符串。
4． 如果有一个简单的helloworld项目目录如下：
# tree helloworld
helloworld
|– file2.h
|– file1.cpp
|– file2.cpp
请编写一个Makefile文件。
三、 简答题：
ARM-linux启动分几部分，简述流程：
 
嵌入式工程师笔试题目汇总 
分类： 嵌入式Linux面试题 2011-10-19 19:45 57人阅读 评论(0) 收藏 举报 
C语言测试是招聘嵌入式系统程序员过程中必须而且有效的方法。这些年，我既参加也组织了许多这种测试，在这过程中我意识到这些测试能为面试者和被面试者提供许多有用信息，此外，撇开面试的压力不谈，这种测试也是相当有趣的。
        从被面试者的角度来讲，你能了解许多关于出题者或监考者的情况。这个测试只是出题者为显示其对ANSI标准细节的知识而不是技术技巧而设计吗？这是个愚蠢的问题吗？如要你答出某个字符的ASCII值。这些问题着重考察你的系统调用和内存分配策略方面的能力吗？这标志着出题者也许花时间在微机上而不是在嵌入式系统上。如果上述任何问题的答案是"是"的话，那么我知道我得认真考虑我是否应该去做这份工作。
        从面试者的角度来讲，一个测试也许能从多方面揭示应试者的素质：最基本的，你能了解应试者C语言的水平。不管怎么样，看一下这人如何回答他不会的问题也是满有趣。应试者是以好的直觉做出明智的选择，还是只是瞎蒙呢？当应试者在某个问题上卡住时是找借口呢，还是表现出对问题的真正的好奇心，把这看成学习的机会呢？我发现这些信息与他们的测试成绩一样有用。
        有了这些想法，我决定出一些真正针对嵌入式系统的考题，希望这些令人头痛的考题能给正在找工作的人一点帮助。这些问题都是我这些年实际碰到的。其中有些题很难，但它们应该都能给你一点启迪。
        这个测试适于不同水平的应试者，大多数初级水平的应试者的成绩会很差，经验丰富的程序员应该有很好的成绩。为了让你能自己决定某些问题的偏好，每个问题没有分配分数，如果选择这些考题为你所用，请自行按你的意思分配分数。

预处理器（Preprocessor）

1 . 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）
         #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在这想看到几件事情：
1) #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
2)懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
3) 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
4) 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。

2 . 写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。
        #define MIN(A,B) （（A） <= (B) ? (A) : (B)) 
这个测试是为下面的目的而设的：
1) 标识#define在宏中应用的基本知识。这是很重要的。因为在 嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
2)三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
3) 懂得在宏中小心地把参数用括号括起来
4) 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？
        least = MIN(*p++, b);

3. 预处理器标识#error的目的是什么？
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。


死循环（Infinite loops）

4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
这个问题用几个解决方案。我首选的方案是：
1. while(1)
2. {
3. 
4. }



一些程序员更喜欢如下方案：
1. for(;;)
2. {
3. 
4. }



这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是："我被教着这样做，但从没有想到过为什么。"这会给我留下一个坏印象。

第三个方案是用 goto
1. Loop:
2. ...
3. goto Loop;


应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。


数据声明（Data declarations） 

5. 用变量a给出下面的定义
a) 一个整型数（An integer） 
b)一个指向整型数的指针（ A pointer to an integer） 
c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r 
d)一个有10个整型数的数组（ An array of 10 integers） 
e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers） 
f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers） 
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer） 
h)一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers tofunctions that take an integer argument and return an integer ）

答案是： 
1. a) int a; // An integer
2. b) int *a; // A pointer to an integer
3. c) int **a; // A pointer to a pointer to an integer
4. d) int a[10]; // An array of 10 integers
5. e) int *a[10]; // An array of 10 pointers to integers
6. f) int (*a)[10]; // A pointer to an array of 10 integers
7. g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer
8. h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer



人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？

Static 

6. 关键字static的作用是什么？
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。

大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。


Const 

7．关键字const有什么含意？
我只要一听到被面试者说："const意味着常数"，我就知道我正在和一个业余者打交道。去年DanSaks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded SystemsProgramming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着"只读"就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）
如果应试者能正确回答这个问题，我将问他一个附加的问题：
下面的声明都是什么意思？
1. const int a;
2. int const a;
3. const int *a;
4. int * const a;
5. int const * a const;



/******/
前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
1) 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
2) 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
3) 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。


Volatile 

8. 关键字volatile有什么含意?并给出三个不同的例子。
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
1) 并行设备的硬件寄存器（如：状态寄存器）
2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3) 多线程应用中被几个任务共享的变量

回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。
假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
1)一个参数既可以是const还可以是volatile吗？解释为什么。
2); 一个指针可以是volatile 吗？解释为什么。
3); 下面的函数有什么错误：
1. int square(volatile int *ptr)
2. {
3.         return *ptr * *ptr;
4. }



下面是答案：
1)是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
2); 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
3) 这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
1. int square(volatile int *ptr)
2. {
3.     int a,b;
4.     a = *ptr;
5.     b = *ptr;
6.     return a * b;
7. }


由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
1. long square(volatile int *ptr)
2. {
3.     int a;
4.     a = *ptr;
5.     return a * a;
6. }



位操作（Bit manipulation） 

9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
对这个问题有三种基本的反应
1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
2) 用bit fields。Bitfields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bitfields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：
1. #define BIT3 (0x1 << 3)
2. static int a;
3. 
4. void set_bit3(void)
5. {
6.     a |= BIT3;
7. }
8. void clear_bit3(void)
9. {
10.     a &= ~BIT3;
11. }



一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。


访问固定的内存位置（Accessing fixed memory locations） 

10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：
1.     int *ptr;
2.     ptr = (int *)0x67a9;
3.     *ptr = 0xaa55;



A more obscure approach is: 
一个较晦涩的方法是：
1.     *(int * const)(0x67a9) = 0xaa55;



即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。

中断（Interrupts） 

11.中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字__interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。
1. __interrupt double compute_area (double radius)
2. {
3.     double area = PI * radius * radius;
4.     printf("/nArea = %f", area);
5.     return area;
6. }



这个函数有太多的错误了，以至让人不知从何说起了：
1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。
2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。


代码例子（Code examples）

12 . 下面的代码输出是什么，为什么？
1. void foo(void)
2. {
3.     unsigned int a = 6;
4.     int b = -20;
5.     (a+b > 6) ? puts("> 6") : puts("<= 6");
6. }


这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是">6"。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。

13. 评价下面的代码片断：
1. unsigned int zero = 0;
2. unsigned int compzero = 0xFFFF;
3. /*1's complement of zero */



对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：

unsigned int compzero = ~0;

这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。
到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧...


动态内存分配（Dynamic memory allocation） 

14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？
这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J.Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：
下面的代码片段的输出是什么，为什么？
1. char *ptr;
2. if ((ptr = (char *)malloc(0)) == NULL)
3.     puts("Got a null pointer");
4. else
5.     puts("Got a valid pointer");



这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是"Got a validpointer"。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。

Typedef 

15 Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：
1. #define dPS struct s *
2. typedef struct s * tPS;



以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：
1. dPS p1,p2;
2. tPS p3,p4;



第一个扩展为
1. struct s * p1, p2;


.
上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。



晦涩的语法

16 . C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？
1. int a = 5, b = 7, c;
2. c = a+++b;



这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：
1. c = a++ + b;



因此, 这段代码持行后a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。


好了，伙计们，你现在已经做完所有的测试了。这就是我出的C语言测试题，我怀着愉快的心情写完它，希望你以同样的心情读完它。如果是认为这是一个好的测试，那么尽量都用到你的找工作的过程中去吧。天知道也许过个一两年，我就不做现在的工作，也需要找一个。


嵌入式开发工程师受亲睐以及面试技巧
[前言]
学员问:"老师,你帮我分析一下,这几个公司,我该去哪个好
呢?".
在每一段 linux 培训时期结束后,经常都会遇到这样的问题.那么到
底什么样的企业最适合自己?
如何在众多选择之中,选出一个最合适的职位呢?
[分析]
在分析原因之前,我们首先来看下用人单位.
那么,用人单位喜欢什么样的人呢?
不同类型的企业,对人员素质要求素质不同,但大多数企业,无
外乎于以下几种::
1) 知识与技能
2) 能力
3) 经验
4) 项目素质
5) 潜力
可以说,只要在这几个方面具备了优势,你就能成为企业抢手的
人才,你就可以在几个企业所提供的职位中随意挑选!
[知识与技能]
对于 linux 培训机构而言,传递给学员的知识与技能是重要的,但这不是最重要的.为什么呢?
1, 知识和技能只是最低的要求.
2, 在当前的网络时代,知识的获取是相对容易的.,你可以
从网络上查找很多嵌入式资料,但是并不一定能步入岗位。但在亚嵌
更注重学员做到在这些知识之游刃有余,工作后,就能巧妙而高质量
的完成企业所交给的项目任务.。
[能力和经验】
在面试中,很多企业都狠重视能力和经验。那么,能力和经验从
何而来?
可以毫无悬念的说,从项目而来!
面试官总爱说这么一句话,"讲讲你之前都做过哪些实际的东西".
为什么面试官喜欢问你实际的项目呢?这是因为实际的项目
是要最终给用户使用的,既然给用户使用,那就要考虑除了功能之外
的其它很多因素.试想,如果你的平板电脑 1 分钟才能对用户的输入
做出响应,这样的平板电脑卖给你,你要么? 这就属于性能因素,除了
性能因素之外,还有很多非功能性因素.这些因素才是开发一个项目
的核心.正常功能的实现,稍微懂点编程的人,给点压力勉勉强强都能
实现,对非功能性因素的实现能力,就完全不那么简单了,这才是企业
要求应聘人员具备项目经验的真正原因所在!
[项目素质]
项目素质好的人,一眼就可以看出是能力强而且训练有素的专业
人员,项目素质差的人,一看就是刚入门或者"业余选手".这两种人,企业喜欢哪种人呢?
毋庸置疑,是第一种,具备良好项目素质的人!
因此,专业的 linux 培训,还应该培养学员的项目素质,这样,培
养出来的学员就非常受企业欢迎!
文章转载自亚嵌嵌入式培训:
http://www.akaedu.org/page/newsdetail-2014.html

嵌入式软件工程师笔试题 
//嵌入式软件工程师笔试题(B卷)
//1*****************************************
#define pi 3.14
#define Area(R) pi*R*R
main()
{
 int r1=5,r2=2;
 double s=0;
 s=Area(r1-r2);
 printf("The area is %f",s);
}
//求结果
//2*********************************************
//函数 int compare(int a,int b),定义为该函数的函数指针P:为_______________
//3*********************************************
#include<stdio.h>
void sub(char*s,int num)
{
 int i ,j=num;
 char t;
 while(j-->1)
 {
   for(i=0;i<j;i++)
   {
     if(s[i]<s[i+1])
     {
       t=s[i];
       s[i]=s[i+1];
       s[i+1]=t;
     }
   }
 }
}
main()
{
 char*s="CEAeded";
 sub(s,6);
 printf("%s\n",s)
}
//求结果
//4**********************************************
//交换两个变量的值,不使用第三个变量,即a=3,b=5交换
//后b=3,a=5
     unsigned char a=3,b=5;
     
     
//5**************************************************
#define N 100
void GetMemory1(char*p)
{
 p=(char*)malloc(sizeof(char)*N);
 strcpy(p,"Have a good day!");
}
char*GetMemory2(void)
{
 char p[]="Have a good day!";
 return p;
}
void main(void)
{
 char*str1=NULL,*str2=NULL;
 GetMemory1(str1);
 GetMemory2(str2);
 printf("\nstr1:%s",str1);
 printf("\nstr2:%s",str2);
 
//6******************************************************
//构造N个结点的单链表返回链表头指针,要求链表中各结点顺序
//与结点数据输入顺序相反,例如输入1,2,3,4,5,形成的链表为
//head->5 4 3 2 1 ,补充程序
#define N 10
typedef struct Node
{
 int data;
 struct Node*next;
}NODE;
int Get_Data(int i);//定义省略
Node*Create_u()
{
 int i;
 NODE*p,*Head=NULL;
 for(i=0;i<N;i++)
 {
  VP=New NODE;
  P->Data=Get_Data(i);
  ________________;
  ________________;
 }
 return Head;
}
//7**********************************************
//N个结点链表,每个结点中存放一个字符,判断链表存放的字符是否
//中心对称,即a b c c b a或a b c b a,补充程序
typedef struct Node
{
 int data;
 struct Node*next;
}NODE;
bool Is_symmeic(NODE*head,*int n)
{
 char D[N];
 int i,d;
 __________;
 for(i=0;i<d;i++)
 {
  D[i]=head->data;
  head=head->next;
 }
 if(__________)
 {
  head=head->next;
 }
 while(head)
 {
  _______________;
  if(D[i]!=head->data)
  {
   return false;
  }
  head=head->next;
 }
 return true;
}
//8*************************************
//str中只含有大写和小写字母函数change_move(char*str)将字符串中大写改成*并
//移到前面小写后返回*的个数
//如AabBdcYY改为*****abd,返回5
int chang_move(char*str)
{
 int len,i,curstr=-1;
 len=strlen(str);
 for(i=len-1;i>=0;i--)
 {
  if(str[i]>='A'&&str[i]<='Z')
   {
    str[i]='*';
    if(cursor==-1)
    {
     cursor=i;
    }
    else if(cursor>i)
    {
     _____________;
     str[i]='*';
     _____________;
     
    }
 }
 return____________;
}
//9***********************************************
//求两个字符串的第一个公共子串,并返回该子串
//如:"a b c d e f g e h i" "a a c d e f * * g e h i"
//第一个为"c d e f";不许用strcmp()
char*Maxf(char*str1,char*str2)
{
}

//10
//完成计算一个字节中1的个数的函数，要求最少用2种方法实现。



一、ANSI C/C++方面的知识
一.1、简答题。下面的题目必须全部答对才给分(20分)：
1、 如何在C中初始化一个字符数组。
2、 如何在C中为一个数组分配空间。
3、 如何初始化一个指针数组。
4、 如何定义一个有10个元素的整数型指针数组。
5、 s[10]的另外一种表达方式是什么。
6、 GCC3.2.2版本中支持哪几种编程语言。
7、 要使用CHAR_BIT需要包含哪个头文件。
8、 对(-1.2345)取整是多少？
9、 如何让局部变量具有全局生命期。
10、C中的常量字符串应在何时定义？
11、如何在两个.c文件中引用对方的变量。
12、使用malloc之前需要做什么准备工作。
13、realloc函数在使用上要注意什么问题。
14、strtok函数在使用上要注意什么问题。
15、gets函数在使用上要注意什么问题。
16、C语言的词法分析在长度规则方面采用的是什么策略？
17、a+++++b所表示的是什么意思？有什么问题？
18、如何定义Bool变量的TRUE和FALSE的值。
19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。
一.2、问答题。
1、———————————————————–
“匈牙利命名法”有什么优缺点？(2分)
2、———————————————————–
下面x, y, *p的值是多少，有什么问题？(2分)
int x, y, z = 2;
int *p=&z;
x=sizeof*p;
y=x/*p; /* x=?, *p=?, y=?, 有什么问题？*/
3、———————————————————–
下面的语句是什么意思？如何声明或定义才使它们更易懂？(10分)
int (*foo())();
int (*foo())[];
int (*foo[])();
(*(void(*)())0)();
void (*signal(int,void(*)(int)))(int);
4、———————————————————–
本题(2分)。一般使用malloc时，需要进行强制类型转换，如：
char *s; s = (char *)malloc(31);
下面中???该如何填写，才可以正确执行强制类型转换？
int (*monthp)[31]; monthp = (???)malloc(31);
5、———————————————————–
关于C语言运算符优先级的记忆技巧是什么？(2分)
/* 下面r的值是多少 */
int hi, low, r;
hi=7;low=3;
r=hi<<4+low;
6、———————————————————–
指针和数组的区别是什么？用一个简单的声明把它们区分开。(2分)
指针和数组的声明在什么情况下是相同的？(2分)
7、———————————————————–
C语言的左值(lvalue)和右值(rvalue)的含义是什么？(2分)
8、———————————————————–
为什么C语言可以实现printf(char *format, …)这样可变参数的调用形式？这样有什
么缺点？(2分)
9、———————————————————–
说明C语言中术语”声明”"定义”"原型”的含义？(2分)
10、———————————————————–
举一个例子，说明使用assert和防错代码的区别。(5分)
11、———————————————————–
对语句 if else 与操作符 ? : 使用场合的比较。(2分)
12、———————————————————–
编写一个函数，输入一个的整型数字，可以选择按照8/10/16进制输出字符串。
注意边界值。(5分)
13、———————————————————–
本题(2分)。下面是一个16×16的黑白图标：
static unsigned short stopwatch[] = {
0×07c6,
0×1ff7,
0×383b,
0×600c,
0×600c,
0xc006,
0xc006,
0xdf06,
0xc106,
0xc106,
0×610c,
0×610c,
0×3838,
0×1ff0,
0×07c0,
0×0000,
};
如何修改声明，可以使之在源代码中形象地表现出图形的模样。
14、———————————————————–
说出可以使用calendar[11][30]变量的四种类型定义。(5分)
如：int calendar[12][31]; /* 二维数组 */
15、———————————————————–
使用strcmp，当字符串相同时会返回’\0′。但’\0′一般作为逻辑假，
因此下面的语句不容易理解:
if (!strcmp(s, “string”)) return EQUATION;
如何经过简单修改，使之更易懂？(2分)
16、———————————————————–
编写一个自己的完全C语言版本的memset函数，并且评价这个实现的性能和可移植性。(5
分)
17、———————————————————–
在树和图这些数据结构中，通常使用指针来组织数据。如果我们要把这些数据保存到文
件
中，指针是没有意义的。我们该如何解决这个问题。(2分)
18、———————————————————–
用2种不同的方法计算long变量的”1″bit的个数。(2分)
19、———————————————————–
任意给出一个C的基本数据类型，如何编码判断这个数据类型是有符号还是无符号的？(2
分)
不得上机实验，写出下面代码的输出。解释这个行为是标准定义的，还是依赖实现的。(
2分)
int i;
for (i = 0; i < 10; i++) {
int j = i;
printf (”%d\n”, j);
}
20、———————————————————–
列出5种以上你所看过的C编程的书籍，并写简要书评。(5分)
对C的评价。如果要你改造一把菜刀，使之更加安全，你是否会使用这样的菜刀，为什么
？(5分)
一.3、分析题。
本题(各5分)。假设下面代码中的变量都是合法变量，调用外部的函数都是正确的。回答
几个问题：
这些代码意图要干什么？
是否有问题？
如果有问题，该如何修改，或者如何避免类似错误发生？
如果没有问题，如果代码有输出，输出是什么？
1、———————————————————–
int isvowel (char c)
{
return c==’a''''''''||c==’e''''''''||c==’i''''''''||c==’o''''''''||c==’u''''
}
2、———————————————————–
while (c==’\t’||c=’ ‘||c==’\n’)
c=getc(f);
3、———————————————————–
/* 当x=2, y=3, z=? */
if (x==0)
if (y==0)
z=-1;
else
z=x+y;
4、———————————————————–
/* 处理网络事件 */
void process_network_code(int x, int y)
{
/* 选择modes_pointer资源 */
switch (line) {
case THING1:
/* 处理异常1#, 使用老的modes_pointer资源 */
doit1();
break;
case THING2:
/* 处理异常2#, 需要重新启动服务 */
if (x == STUFF) {
/* 重新申请modes_pointer资源，没有初始化 */
do_first_stuff();
/* 在这种条件下，有些资源不用重新申请 */
if (y == OTHER_STUFF)
break;
/* 申请剩下的资源，并初始化 */
do_later_stuff();
}
/* 初始化modes_pointer资源 */
initialize_modes_pointer();
break;
default:
/* 处理普通事件, 使用老的modes_pointer资源 */
processing();
}
/* 使用modes_pointer资源，处理事件 */
use_modes_pointer();
}
5、———————————————————–
int is_gb2312_char(char c1, char c2)
{
if (c1 >= 0xa1 && c2 >= 0xa1)
return 1;
else
return 0;
}
6、———————————————————–
下面x, y的值是多少，有什么问题？
int x = 10, y = 3;
x ^= y;
y ^= x;
x ^= y;
/* x=?, y = ? */
7、———————————————————–
int days[]={31,28,31,30,31,30,31,31,30,31,30,31,};
int calendar[12][31];
int (*monthp)[31];
int *dayp;
int i;
memset(calendar, 0, sizeof(calendar));
i = 0;
for (monthp = calendar; monthp < &calendar[12]; monthp++) {
for (dayp = *monthp; dayp < &(*monthp)[31]; dayp++) {
if (dayp - *monthp < days[calendar - monthp]) {
*dayp = i++ % 7 + 1;
}
}
}
8、———————————————————–
void printnum(long n)
{
if (n < 0) {
putchar(’-'''''''');
n = -n;
}
if (n >= 10) {
printnum(n/10);
}
putchar (”0123456789″[n%10]);
}
9、———————————————————–
void * memchr(void *pv, unsigned char ch, size_t size)
{
unsigned char *pch = (unsigned char *) pv;
unsigned char *pchEnd = pch + size;
while (pch < pchEnd) {
if (*pch == ch)
return (pch);
pch++;
}
return NULL;
}
10、———————————————————–
void * memchr(void *pv, unsigned char ch, size_t size)
{
unsigned char *pch = (unsigned char *) pv;
unsigned char *pchPlant = pch + size;
unsigned char chSave = *pchPlant;
*pchPlant = ch;
while (pch != ch) {
pch++;
}
*pchPlant = chSave;
return ((pch == pchPlant) ? NULL : pch);
}
11、———————————————————–
void UnsToStr(unsigned short int u, char *str)
{
char *pch;
assert(u <= 65535);
pch = &str[5];
*pch = ‘\0′;
do {
*–pch = u % 10 + ‘0′;
} while ((u / 10) > 0);
strcpy(str, pch);
}
12、———————————————————–
void *memmove(void *pvTo, void pvFrom, size_t size)
{
char *pbTo = (char *)pvTo;
char *pbFrom = (char *)pvFrom;
((pbTo < pbFrom) ? tailmove : headmove) (pbTo, pbFrom, size);
return (pvTo);
}
13、———————————————————–
void *memcpy(void *pvTo, void pvFrom, size_t size)
{
char *pbTo = (char *)pvTo;
char *pbFrom = (char *)pvFrom;
while (size– > 0);
*pbTo++ = *pbFrom++;
return (pvTo);
}
14、———————————————————–
#include 
int main(int argc, char *argv[])
{
char s[]=”0123456789″;
int i = 0;
do {
printf (”%c”, i++[s]);
} while(s?1:printf(”\n”)-1);
return 0;
}
15、———————————————————–
int fibonacci(int x)
{
if (x == 1 || x == 2)
return 1;
return fibonacci(x - 2) + fibonacci(x - 1);
}
16、———————————————————–
这里有一个程序cdecl.c。写出它的工作流程。写出它的使用方法。
给出一个典型输入用例，记录下它的输出。
一.4、综合编程题。
要求：
1、完成需求，程序运行正确。
2、工作原理文档，使用文档完整。
3、代码规整优美。注释得当。
4、运行速度足够快。
5、用工具分析出是哪些代码或函数造成速度瓶颈。
1、———————————————————–
编写一个排序程序。被排序的文件有8MB大小，一行一个随机整数(ASCII格式)。要求对
这些整数进行
排序，并计算平均值，打印出排序所需的时间。(20分)
2、———————————————————–
用dummy header技巧实现一个链表DEMO。要求具有create, insert, delete, search功
能。
编写一个应用程序，使用上面的函数。使用dummy header技巧有什么优点。(20分)
3、———————————————————–
用heapsort算法实现优先队列。要求具有create, insert, delete功能。
编写一个应用程序，使用上面的函数。使用heapsort算法有什么优点。(20分)
用trie(一种多叉树)实现一个字典。要求具有create, insert, delete, search功能。
编写一个应用程序，使用上面的函数。使用trie树有什么优点。(20分)
二、POSIX方面的知识。
二.1、简答题。下面的题目必须全部答对才给分：(5分)
1、在UNIX环境中，编译流程是什么？
2、ABI，ELF的英文全称是什么
3、一般UNIX的程序有多少段，举一个实际的例子说明。
4、如何在kernel二进制代码中找一个字符串。
5、段地址F000:FFF0转换为线形地址的值是多少(16进制表达)。
6、在一个UNIX文件系统中，文件的唯一性标志是什么？
二.2、问答题。
1、———————————————————–
写一些代码。如何用文件实现信号灯？要求如果程序崩溃了，这个文件也将自动被删除
。
为什么可以这样实现信号灯？(5分)
传统的signal函数信号处理为什么是不可靠的，信号和系统调用有何关系？(5分)
在图形库系统中往往提供timer的功能，除了使用ALARM信号外，你还可以使用什么系统
调用来实现timer？(5分)
2、———————————————————–
写一些代码，演示如何正确使用write系统调用。注意看好手册再回答。(2分)
如果一个文件以rw模式打开，在进行read/write操作转换时，需要进行什么操作。(2分)
3、———————————————————–
解释终端结构termios.c_cc的MIN/TIME数值变化的带来read/write的特性。(5分)
如何理解终端、控制终端、虚拟终端、控制台、tty等类同的概念？(5分)
4、———————————————————–
解释计算机中Copy-On-Write的概念。(2分)
调用fork之后，子进程没有继承父进程的属性有哪些？(5分)
解释为什么每个程序在装入执行之后，总是已经预先打开了stdout、stdin、stderr？(2
分)
在fork之前，父进程打开了一个文件。在fork之后，如果子进程移动了文件指针，
父进程的文件指针有什么变化；如果子进程关闭了文件，父进程有什么变化？为什么会
这样？(5分)
标准输入、输出和错误输出分别是什么类型的缓冲，这些缓冲在用户空间还是在核心空
间？
怎样关闭他们的缓冲？如果父进程关闭了缓冲，在fork之后建立的子进程是否也关闭了
缓冲？(5分)
vfork和fork相比，有什么特色？(2分)
system函数是否等同于fork+exec？(2分)
wait系统调用有多少种条件可以退出？(2分)
5、———————————————————–
系统调用和库函数调用有什么区别。(2分)
在linux2.4.x上的glibc和newlib(一种嵌入式C库)的系统调用有什么不同？(2分)
在linux2.4.x上，对系统调用execve如果调用成功，它返回的值是多少。(2分)
6、———————————————————–
列出你所知道的2个内存跟踪库。(2分)
设计一个内存跟踪方案，为什么选择这个方案(5分)
二.3、综合编程题。
要求：
1、完成需求，程序运行正确。
2、工作原理文档，使用文档完整。
3、代码规整优美。注释得当。
4、运行速度足够快。
1、———————————————————–
这里有一个8MB的文件，编写一个copy程序，拷贝这个文件，并计算所需时间。用工具分
析
出是哪些代码或函数造成速度瓶颈。
提示：如果只是使用read/write调用，不是一个好的实现。(20分)
2、———————————————————–
Linux系统中，什么时候会出现类似Y2K的问题。写一个程序证明。(20分)
3、———————————————————–
编写一个程序，测试系统最小的睡眠时间间隔。(20分)
4、———————————————————–
编写一个pipe程序，测试有N个管道，size大小的buffer情况下，pipe的传输性能是多少
？(20分)
5、———————————————————–
在ext2文件系统上，单个文件最大可以达到多少？
写一个程序获得这方面的限制。(20分)
三、Linux编程基本使用知识。
三.1、命令和shell
1）编写一个脚本，统计一个目录下面所有C代码的行数。(2分)
2）编写一个sed脚本，去除HTML文件中的HTML标记。(2分)
3）编写一个脚本获得当前系统eth0的IP地址。(2分)
4）编写一个脚本以交互的方式，进行DNS的设定。(2分)
5）使用ls命令编写一个脚本，实现ls -R，递归列出当前目录下的所有目录、文件。(2
分)
6）———————————————————–
在一个目录下，找soft-link files，用下面的命令，原理是可行的，但无法操作，
该如何解决？要2种方法。(2分)
ls -l | grep ->
7）———————————————————–
如何把标准错误输出，重定向到标准输出上。(2分)
8）———————————————————–
我们的系统中的软件包是使用RPM管理的。要求下面的问题写出shell命令和运行结果。(
5分)
如何知道系统中安装了几个软件包。
如何知道系统中安装了哪几类(group)软件包。
如何知道kernel软件包的简述。
如何知道kernel软件包的Changelog。
如何知道kernel软件包有几个文件。
如何知道kernel软件包安装后有多大。
三.2、编辑工具的使用。(各2分)
1）如何使用vi进行块拷贝、粘贴、删除的操作
2）如何设置Tab的长度，以及自动缩进的长度
3）如何使用tag进行代码阅读
4）如何在1～10行，有确认的进把所有的RedHat改为RedFlag
5）在SourceNavigator中，如何跳到一个变量的声明处？如何得知光标当前的位置在那
个函数体内？
三.3、编译器与调试器。(各2分)
1）如何使用gcc得到宏展开的中间代码
2）如何通过gcc在命令行中传入宏定义
3）在那一级优化的情况下，内联函数才真正的内联到代码中
4）gdb的watch命令如何使用，有何缺点
5）gdb中使用什么命令可以显式调用的栈帧，如何查看某个栈帧上的局部变量
6）如何使用gdb调试多进程
7）如何使能/禁止core dump？
三.4、库。(各2分)
1）如何知道XSetIMValues这个符号在那个X的库文件中
2）如何读取C++的符号名，更具可读性
3）请解释动态库的soname概念
4）解释在链接时rpath选项的含义
三.5、Makefile。(10分)
如果有一个简单的Test项目目录如下：
# tree Test
Test
|– common.h
|– main.cpp
|– test.cpp
`– test.h
1）使用wildcard、patsubst函数编写一个C++项目的Makefile文件
2）使用automake、autoconfig编写一个支持configure选项的configure.in脚本
三.6、CVS。(10分)
1）如果一个CVS项目中，甲添加了一个子目录模块，那么乙在update时是否会自动检
出这个新添加的子模块？如果不能，那么你有什么好的解决方案？
2）如何在一个CVS项目中添加一个二进制文件，这个二进制文件可以进行增量的版本管
理吗？
3）如何检出标记（tag）为milestone-1的版本，如何创建以milestone-1为基础的分支
milestone-1-b1，并如何把分支的修改合并到milestone-1的主分支上
三.7、Linux/GNU编程基本知识
1、———————————————————–
Linux2.4.x有多少种类型的设备文件？分别写出来。(2分)
2、———————————————————–
glibc动态库的搜寻次序是什么？(2分)
glibc 2.1.x 与 2.2.x的动态库的搜寻次序有什么不同？为什么会采用现在的方案？(2
分)
三.3、综合编程题。
要求：
1、完成需求，程序运行正确。
2、工作原理文档，使用文档完整。
3、代码规整优美。注释得当。
4、运行速度足够快。
1、———————————————————–
本题(20分)。写一个程序，有三个功能：
a)取得CMOS中的当前时间，按照YY:MM:DD:HH:MM:SS格式输出。
b)取得物理内存的大小，格式化输出。
c)取得从物理段地址F000:FFF0起，16个字节的值，每字节按照16进制格式输出。
2、———————————————————–
本题(20分)。对串口编程，编写一对类似ping的程序，作用在串口上，了解serial的联
通情况。
定义协议
要求：
定义一个联通和响应协议。至少具有：发送、回复、超时三种状态。除超时状态外，所
有
状态的数据必须经过校验才可使用。
ping_serial_client
要求：
1,发送数据包；
2,等待回复数据包，直到超时；
3,如果有回复数据包，对数据包进行校验；
4,计算校验通过的数据包之间的时间差；
5,重复直到用户退出；
6,统计丢包率，时间。
界面：
bash# ping_serial_client /dev/ttyS0 baud_value
??bytes from ttyS0, time=??ms
……
^C
— ttyS0 ping statistics —
?? packets transmitted, ?? received, ??% loss
time ??ms, min/avg/max = ??/??/?? ms
ping_serial_server
要求：
1,等待对方的发送数据包；
2,对发送数据包进行校验；
3,校验通过则回复数据包；
4,重复直到用户退出；
界面：
bash# ping_serial_server /dev/ttyS0 baud_value
3、———————————————————–
编写一对socket程序，要求类似于network echo procotol。
Client每隔1秒把自己的IP地址轮流循环发送给一个Server.
Server接到IP后，在屏幕上打印对方IP；然后把自己的IP发送回去。
Client收到回复后，在屏幕上打印对方IP。
程序一直运行，直到用户退出。各自分类统计接收到的各IP的数据包的个数。
注意：Client可以向多个Server发送请求，Server也可以接收多个Client请求。
注意：输出信息的美观，和对错误的处理。
———————————————————–
四、C++题目。
———————————————————–
1。给定下面的代码:
class Graph{
public:
Graph() { s_gCount++; }
virtual ~Graph() { s_gCount–;}
virtual int drawOut() = 0;
static int getTotalCount() { return s_gCount; }
protected:
int m_x;
int m_y;
static int s_gCount;
};
回答下列问题：(各5分)
1）这个类能否生成实例，为什么？
2）上述代码中有什么错误？
3）如果有一个Rectangle类公共继承该类，那么s_gCount对Rectangle的成员属性是什么
？
4）对Graph及其子类的计数是否有效，如果无效应该采取什么措施？
5）请画出该类的内存布局结构示意图
———————————————————–
2。给定下面的代码:
class A
{
int a;
};
class AA : public A
{
int aa;
};
class X : public virtual A
{
int x;
};
class Y : public virtual A
{
int y;
};
class Z : public X, public Y {
int z;
};
回答下列问题：(各5分)
1）请画出上述5个类的UML类图
2）请画出A、AA、X、Z的内存布局结构示意图
———————————————————–
3。给定下面代码:
#include 
#include 
typedef struct _AAA
{
int a;
}AAA, *PAAA;
class CAAA
{
public:
CAAA() { m_a.a = 0; }
CAAA(CAAA& in) { printf(”CAAA(CAAA& in)\n”); }
CAAA(AAA in) { printf(”CAAA(AAA in)\n”); }
CAAA(int in) { printf(”CAAA(int in)\n”); }
private:
AAA m_a;
public:
operator PAAA ()
{
return &m_a;
}
};
void test0(PAAA pa)
{
printf(”test0\n”);
}
void test1(CAAA ca)
{
printf(”test1\n”);
}
void test2(CAAA ca)
{
printf (”test2\n”);
}
void main(void)
{
CAAA a;
test0 (a);
AAA b;
test1 (b);
int i=0;
test2 (i);
}
请回答下列问题：(各5分)
1）找出程序中的错误
2）test0函数声明传入的参数为PAAA类型，而在main函数中，实际传入的是CAAA类型，
这是否是一个错误？如果不是，请解释原因。
4。回答下列问题：
1）C++中的struct和class类型有什么区别？(2分)
2）假定一个class名为Test，具有构造函数、拷贝构造函数、operator =，那么
Test a;
Test b=a;
分别执行的是哪一个函数？(2分)
3）C++程序进行链接时是否必须链接stdc++函数库，如果不必须情况下不需要，什么情
况下需要？(2分)
4）你所熟悉的关于C++的中英文经典书籍都有哪些，它们分别都侧重于什么方面？(5分)
五、QT编程。任选2题完成。(各20分)
要求：按照综合编程题目的要求编写代码和文档。
1.编写一个简单的clock控件, 要求从QWidget继承, 有一个指针和表盘,指针每12秒转一
圈,
并且可以用鼠标左键,起动和停止指针的转动.
2.给定一个designer生成的UI文件, 读取指定名字控件的几何信息,计算出该控件的面积
大小.
(用Dom和SAX都可)
3.设计一个程序, 建立个人信息库,包括:姓名,年龄,性别,住址.建立完之后可以查处特
定人
的信息,用designer设计你的界面, 不要求把信息库存在硬盘上.
4.把第三题变成国际化程序, 要求两种语言中文和英文.需要用qt-linquist等工具.
5. 用QSocket实现两台不同机器间的收发, 收发要求用户动态输入.
提示：以上各题需在qt3.0以上实现,推荐用qt-3.1.1,不限止qt-embedded或qt-desktop.
六、MiniGUI编程
要求：按照综合编程题目的要求编写代码和文档。
1.裁剪MiniGUI字体库,使它仅支持英文和繁体中文。(10分)
2.描述MiniGUI/MPP的消息机制(20分)
3.使用MPP和MySql,编写一使用在商场POS机上的应用,要求如下:(50分)
1)收银员帐户管理:每台POS机供若干个收银员和一个系统管理员使用.收银员凭密码
登录POS机,密码可修改.收银员只能查看自己的销售数据,
但不能删除.系统管理员可以增加删减收银员帐户,查询销售记录.
2)收款管理:计算顾客购买商品总金额;计算找零
3)顾客会员管理:根据顾客ID,判断会员等级及相应打折级别.
4)屏幕锁定功能:特定按健触发屏幕锁定,输入密码后解锁
七、Kernel & Driver
内核基础试题
1. 简答题。(各10分)
1.1 Spin Lock 相对于信号量的特点；在UP/MP/SMP这些不同环境下，Spin Lock的不同
实现方法。
1.2 简要说明e2compr压缩文件系统的压缩策略；经其处理后，上层文件系统（EXT2/3
等）是否会受到影响。
1.3 比较linux操作系统内核态和用户态的抢占性，及两者之间存在差异的原因。
1.4 linux2.2支持的最大进程数是多少，演进至2.4后，这一制约是如何克服的。
1.5 列举中断屏蔽的类型，并简单比较。
1.6 列举linux所要处理的定时/计数器（实际的外围硬件设备，不是指软件定时器），
及其用途。
2. 问答题。(各20分)
2.1 穷举在用户态空间，内核消息的获取方式、差异、以及差异的原因。
2.2 解释linux进程调度中的epoch概念，该机制的目的。
2.3 描述一个硬件中断信号发生，到为其注册的中断服务例程开始执行，之间所经过的
内核处理过程。并进一步分析，制约linux中断响应时间的因素存在于哪些方面。
2.4 比较底半机制（BH）和Tasklet的特点，及运行方面的差异。
2.5 说明引导过程中initrd.img和linuxrc作用，给出制作initrd.img的伪代码形式的
流程。
2.6 在VFS层中如何区分设备文件和正规文件?
2.7 内核有几种方式访问硬件设备?
2.8 内核如何访问iomem?请举例说明。
3. 分析题。
3.1 系统时间设置问题。(10分)
同样采用date命令，目的在于修改系统时间，在不同的系统上却有不同的现象：
假定初始时间（T1）为 03月01日16：00 2003年，期望的修改后时间（T2）为 12
月31日00：00 2002年，
<1> 在EDK系统中，执行命令 #date 123100002002，系统时间立即会变为T2；
但系统重新启动之后，系统时间仍恢复为T1的时间区间： 03月01日16：02
2003年，修改并未保留下来。
<2> 在RedHat7.2/8.0中，重复上述设置，系统重新启动之后，时间设置得到了保
留，系统运行于T2的时间区间：12月31日00：02 2002年。
请分析<1> 中所表现出的现象是由于什么原因造成的；
3.2 在大家相关于串口的工作中，可能会遇到这样的问题：(20分)
串口在发送数据时，不是连续且迅速地发送，而是以一个固定的节拍（10秒），且
每次只发送等长度的一段数据，请列举可能造成这一问题的所有原因；
3.3 Oops分析。(50分)
以下是一段经过符号解析过的Oops信息，我们知道造成这个Oops的直接原因在于对
于
内核函数__wake_up的调用过程之中出现了问题；基于上述判断，请基于已经给出
的__wake_up相关源码和反汇编码，大致分析问题出现在哪个源码行，并给出分析结论；
———————————————————–
ksymoops信息：
ksymoops 2.4.4 on i686 2.2.19-rthal3. Options used
-v /usr/src/linux-2.2.19/vmlinux (specified)
-k /proc/ksyms (specified)
-l /proc/modules (specified)
-o /lib/modules/2.2.19-rthal3/ (default)
-m /usr/src/linux-2.2.19/System.map (specified)
current->tss.cr3 = 07d29000, %cr3 = 07d29000
*pde = 00000000
Oops: 0000
CPU: 0
EIP: 0010:[]
Using defaults from ksymoops -t elf32-i386 -a i386
eax: 00000014 ebx: c0eabf74 ecx: 00000013 edx: 00000021
esi: 00000000 edi: 00000020 ebp: c0eabf6c esp: c0eabf60
ds: 0018 es: 0018 ss: 0018
Process in.identd (pid: 828, process nr: 6, stackpage=c0eab000)
Stack: 00000000 c807ca04 00000021 c0eabf74 c807be21 c0eabfb0 c807bf74
c807c940
00000000 00000000 00000000 c803fb60 c807e000 00000e20 2b124c28
0000027c
0010a000 c807c900 00000000 0000f944 bffff944 c803d2ec 00000000
00000000
Call Trace: [] [] [] []
[] []
[] [] []
Code: 8b 02 85 45 fc 74 1b 85 ff 74 10 83 7a 44 00 74 0a 85 f6 75
>>EIP; c01110c1 <__wake_up+2d/6c> <=====
Trace; c807ca04 <[rt_das]timeout+c4/c8>
Trace; c807be21 <[rt_das]read_timeout+25/28>
Trace; c807bf74 <[rt_das]pulse_isr+150/19c>
Trace; c807c940 <[rt_das]timeout+0/c8>
Trace; c803fb60 <[rtai]global_irq_handler+0/80>
Trace; c807e000 <.bss.end+14a1/????>
Trace; c807c900 <[rt_das]board+0/28>
Trace; c803d2ec <[rtai]dispatch_global_irq+28/90>
Trace; c803c0a0 <[rtai]GLOBAL0_interrupt+18/34>
Code; c01110c1 <__wake_up+2d/6c>
00000000 <_EIP>:
Code; c01110c1 <__wake_up+2d/6c> <=====
0: 8b 02 movl (%edx),%eax <=====
Code; c01110c3 <__wake_up+2f/6c>
2: 85 45 fc testl %eax,0xfffffffc(%ebp)
Code; c01110c6 <__wake_up+32/6c>
5: 74 1b je 22 <_EIP+0×22> c01110e3
<__wake_up+4f/6c>
Code; c01110c8 <__wake_up+34/6c>
7: 85 ff testl %edi,%edi
Code; c01110ca <__wake_up+36/6c>
9: 74 10 je 1b <_EIP+0×1b> c01110dc
<__wake_up+48/6c>
Code; c01110cc <__wake_up+38/6c>
b: 83 7a 44 00 cmpl $0×0,0×44(%edx)
Code; c01110d0 <__wake_up+3c/6c>
f: 74 0a je 1b <_EIP+0×1b> c01110dc
<__wake_up+48/6c>
Code; c01110d2 <__wake_up+3e/6c>
11: 85 f6 testl %esi,%esi
Code; c01110d4 <__wake_up+40/6c>
13: 75 00 jne 15 <_EIP+0×15> c01110d6
<__wake_up+42/6c>
Unable to handle kernel paging request at virtual address 66fe4603
current->tss.cr3 = 00e94000, %cr3 = 00e94000
*pde = 00000000
Oops: 0000
CPU: 0
EIP: 0010:[]
EFLAGS: 00010a83
Warning (Oops_read): Code line not seen, dumping what data is available
>>EIP; c01113e6  <=====
1 warning issued. Results may not be reliable.
<附录>
1. __wake_up的源码：
void __wake_up(struct wait_queue **q, unsigned int mode)
{
struct task_struct *p, *best_exclusive;
struct wait_queue *head, *next;
unsigned int do_exclusive;
if (!q)
goto out;
/*
* this is safe to be done before the check because it
* means no deference, just pointer operations.
*/
head = WAIT_QUEUE_HEAD(q);
read_lock(&waitqueue_lock);
next = *q;
if (!next)
goto out_unlock;
best_exclusive = 0;
do_exclusive = mode & TASK_EXCLUSIVE;
while (next != head) {
p = next->task;
next = next->next;
if (p->state & mode) {
if (do_exclusive && p->task_exclusive) {
if (best_exclusive == NULL)
best_exclusive = p;
}
else {
wake_up_process(p);
}
}
}
if (best_exclusive)
wake_up_process(best_exclusive);
out_unlock:
read_unlock(&waitqueue_lock);
out:
return;
}
2. __wake_up的反汇编码：
c0111094 <__wake_up>:
c0111094: 55 pushl %ebp
c0111095: 89 e5 movl %esp,%ebp
c0111097: 83 ec 08 subl $0×8,%esp
c011109a: 57 pushl %edi
c011109b: 56 pushl %esi
c011109c: 53 pushl %ebx
c011109d: 89 55 fc movl %edx,0xfffffffc(%ebp)
c01110a0: 85 c0 testl %eax,%eax
c01110a2: 74 50 je c01110f4 <__wake_up+0×60>
c01110a4: 8d 48 fc leal 0xfffffffc(%eax),%ecx
c01110a7: 89 4d f8 movl %ecx,0xfffffff8(%ebp)
c01110aa: 8b 18 movl (%eax),%ebx
c01110ac: 85 db testl %ebx,%ebx
c01110ae: 74 44 je c01110f4 <__wake_up+0×60>
c01110b0: 31 f6 xorl %esi,%esi
c01110b2: 89 d7 movl %edx,%edi
c01110b4: 83 e7 20 andl $0×20,%edi
c01110b7: 39 cb cmpl %ecx,%ebx
c01110b9: 74 2d je c01110e8 <__wake_up+0×54>
c01110bb: 90 nop
c01110bc: 8b 13 movl (%ebx),%edx
c01110be: 8b 5b 04 movl 0×4(%ebx),%ebx
c01110c1: 8b 02 movl (%edx),%eax
c01110c3: 85 45 fc testl %eax,0xfffffffc(%ebp)
c01110c6: 74 1b je c01110e3 <__wake_up+0×4f>
c01110c8: 85 ff testl %edi,%edi
c01110ca: 74 10 je c01110dc <__wake_up+0×48>
c01110cc: 83 7a 44 00 cmpl $0×0,0×44(%edx)
c01110d0: 74 0a je c01110dc <__wake_up+0×48>
c01110d2: 85 f6 testl %esi,%esi
c01110d4: 75 0d jne c01110e3 <__wake_up+0×4f>
c01110d6: 89 d6 movl %edx,%esi
c01110d8: eb 09 jmp c01110e3 <__wake_up+0×4f>
c01110da: 89 f6 movl %esi,%esi
c01110dc: 89 d0 movl %edx,%eax
c01110de: e8 2d f9 ff ff call c0110a10 
c01110e3: 3b 5d f8 cmpl 0xfffffff8(%ebp),%ebx
c01110e6: 75 d4 jne c01110bc <__wake_up+0×28>
c01110e8: 85 f6 testl %esi,%esi
c01110ea: 74 08 je c01110f4 <__wake_up+0×60>
c01110ec: 89 f0 movl %esi,%eax
c01110ee: e8 1d f9 ff ff call c0110a10 
c01110f3: 90 nop
c01110f4: 8d 65 ec leal 0xffffffec(%ebp),%esp
c01110f7: 5b popl %ebx
c01110f8: 5e popl %esi
c01110f9: 5f popl %edi
c01110fa: 89 ec movl %ebp,%esp
c01110fc: 5d popl %ebp
c01110fd: c3 ret
c01110fe: 89 f6 movl %esi,%esi
———————————————————–
内核驱动题
以下设计应该包括设计文档,实现策略说明,代码包,测试用例,使用说明.
要求：按照综合编程题目的要求编写代码和文档。
参考资料: 第二版.
1.设计并实现一个软件watchdog设备，以监视系统运行情况.(50分)
说明:watchdog设备用于监测系统运行状态,正常运行的系统定期写watchdog以使其
不会超时,一旦超时,意味系统已挂起;watchdog应该重启系统. 现在的软件watchdog
不重启系统,只用于监视应用程序的运行.
2.设计并实现一个简化的、容量可以变化的内存FIFO设备.(50分)
八、用中文Linux办公。
要求本考卷完全在Linux完成，并要求进行版面的格式化或美化。如果只提交TEXT版本，
本题不得分。(各10分)
本题要求是：
1、提交进行版面的格式化或美化的PDF版本。为方便修改和评分，还须提交一个lyx或te
x版本。
2、PDF内嵌的中文字体使用的是红旗桌面版4.0所携带的新版宋体。
九、娱乐。(没有分数)
不会娱乐的程序员不是好的程序员。本部分没有分数，但是聪明的人在这里是不会留下
空白的。
1、运行RedHat 7.3上面的推箱子游戏。用方向-数字的方式(如左3，右4)记录下通过第
一关
的过程，同时记录下过关的时间。看谁的步数少，时间短。
2、运行emacs + doctor游戏。摘录下10句以上的对话，看谁的对话最精彩，同时也看谁
的心理最变态。


1.简述嵌入式系统的定义
以应用为中心,计算机技术为基础,软硬件可剪裁,适应应用系统对功能,成本,体积,可
靠性,功耗严格要求的计算机系统。
2.嵌入式系统的三个基本要素:嵌入性,专用性,计算机系统?
3.嵌入式系统包括:
硬件层(处理器,存储器,输入输出接口),
中间层(板级支持包 BSP,驱动)
,
系统软件层(操作系统,其他系统)
,
应用软件层(自制软件,其他软件)
4.RTOS:实时操作系统是保证在一定时间限制内完成特定功能的操作系统(软实时:要求平
均响应时间要小于某一个值,
硬实时:要求最坏响应时间要小于某一个值)。
5.哈佛结构的主要特点事将程序和数据存储在不同的存储空间中,即程序存储器和数据存储
器是两个相互独立的存储器,每个存储器独立编址、独立访问。
6.通常通过缩短中断响应时间,缩短进程上下文切换时间,缩短实时进程调度时间等手段来
提高 linux 系统的实时性。
7.嵌入式操作系统(Embedded Operating System,简称:EOS)是指用于嵌入式系统的操作
系统。
8.简述 linux 应用于嵌入式操作系统的优缺点:
源代码开放;linux 是可以定制的;和多数 unix 兼容,应用程序的开发和移植相当容易。
linux 并非专门为实时性应用而设计的,因此如果想在实时性要求较高的嵌入式系统中运行
linux,就必须为之添加时事软件模块。
9.嵌入式 linux 系统的组成部分:Bootloader,Kernel,RootFileSystem,UserApp。
10.linux 下库文件分为两大类,分别是动态链接库(以.so 结尾)和静态链接库(以.a 结尾)
。
11.ARM 体系结构定义了 7 种处理器模式,包括用户,快中断,中断,管理,终止,未定义
和系统。两种处理器工作状态:ARM 状态和 Thumb 状态。
12.Bootloader(引导加载程序)是系统加电后运行的第一段软件代码。bootloader 的作用是启
动加载,即完成系统的启动和加载操作系统并运行。大多数 bootloader 包含两种不同的操作
模式:启动加载模式和下载更新模式.
13.bootloader 分为 Stage1(汇编阶段)和 Stage2(C 语言阶段)。
14.linux 内核主要有 5 个子系统组成:进程调度,内存管理,虚拟文件系统,网络接口,进
程间通信。
15.日志文件系统是在传统的文件系统的基础上,加入文件系统更改的日志记录,从而在系
统发生断电或其他系统故障时能保障整体数据的完整性。它的设计思想是:跟踪记录文件系
统的变化,并将变化内容记录到日志中。
16.linux 下的文件系统主要分为三大块:一是上层的文件系统的调用,二是虚拟文件系统 VFS,
三是挂载到 VFS 中的各种实际文件系统。
17.进程是一个具有一定独立功能的程序的一次运行活动。
18.进程互斥是指当有若干进程都要使用某一共享资源时,任何时刻最多允许一个进程使用,
其他要使用该资源的进程必须等待,直到占用该资源者释放了该资源为止。
19.操作系统中将一次只允许一个进程访问的资源称为临界资源。
20.进程中访问临界资源的那段程序代码称为临界区。为实现对临界资源的互斥访问,应保
证诸进程互斥地进入各自的临界区。
21.进程同步:一组并发进程按一定的顺序执行的过程称为进程间的同步。具有同步关系的一组并发进程称
为合作进程,合作进程间互相发送的信号称为消息或事件。
22.进程调度:按一定算法,从一组待运行的进程中选出一个来占有 CPU 运行。调度方式:
抢占式和非抢占式。
23.调度算法:先来先服务调度算法;短进程优先调度算法;高优先级优先调度算法;时间
片轮转法。
24.死锁:多个进程因竞争资源而形成一种僵局,若无外力作用,这些进程都将永远不能再
向前推进。
25.在 pid=fork()之前,只有一个进程在执行,但在这条语句执行之后,就变成两个进程在执
行了,这两个进程的共享代码段,将要执行的下一条语句都是 if(pid==0)。两个进程中,原
来就存在的那个进程被称作“父进程”,新出现的那个进程被称作“子进程”,父子进程的区
别在于进程标识符(PID)不同。子进程的数据空间、堆栈空间都会从父进程得到一个拷贝,
而不是共享。在子进程中对 count 进行加 1 的操作,并没有影响到父进程中的 count 值,父
进程中的 count 值仍然为 0。
26.fork 与 vfork 区别:
1. fork:子进程拷贝父进程的数据段 vfork:子进程与父进程共享数据段
2. fork:父、子进程的执行次序不确定 vfork:子进程先运行,父进程后运行
27.进程间需要通信的目的:数据传输(一个进程需要将它的数据发送给另一个进程。),资
源共享(多个进程之间共享同样的资源。),通知事件(一个进程需要向另一个或一组进程发
送消息,通知它们发生了某种事件。
),进程控制(有些进程希望完全控制另一个进程的执行
(如 Debug 进程)
,此时控制进程希望能够拦截另一个进程的所有操作,并能够及时知道它
的状态改变。
)
。
28.POSIX 表示可移植操作系统接口。
29.Linux 使用的进程间通信方式包括:
管道(pipe)和有名管道(FIFO)
信号(signal)
消息队列
共享内存
信号量
套接字(socket)
30.管道包括无名管道和有名管道两种,前者用于父进程和子进程间的通信,后者可用于运
行于同一系统中的任意两个进程间的通信。
31.当某信号出现时,将按照下列三种方式中的一种进行处理:忽略此信号;执行用户希望
的动作;执行系统默认动作。
32.发送信号的主要函数有 kill 和 raise。区别:Kill 既可以向自身发送信号,也可以向其他进
程发送信号。与 kill 函数不同的是,raise 函数是向进程自身发送信号。
33.和进程相比,它是一种非常“节俭”的多任务操作方式。在 Linux 系统下,启动一个新的
进程必须分配给它独立的地址空间,建立众多的数据表来维护它的代码段、堆栈段和数据段,
这是一种"昂贵"的多任务工作方式。运行于一个进程中的多个线程,它们之间使用相同的地
址空间,而且线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。线程间有方
便的通信机制。对不同进程来说,它们具有独立的数据空间,要进行数据的传递只能通过进
程间通信的方式进行,这种方式不仅费时,而且很不方便。线程则不然,由于同一进程下的
线程之间共享数据空间,所以一个线程的数据可以直接为其它线程所用,这不仅快捷,而且
方便。34.信号量(又名:信号灯)与其他进程间通信方式不大相同,主要用途是保护临界资源。进程
可以根据它判定是否能够访问某些共享资源。除了用于访问控制外,还可用于进程同步。
35.信号灯强调共享资源,只要共享资源可用,其他进程同样可以修改信号灯的值;互斥锁
更强调进程,占用资源的进程使用完资源后,必须由进程本身来解锁。
36.互斥量 PK 信号量
Mutex 是一把钥匙,一个人拿了就可进入一个房间,出来的时候把钥匙交给队列的第一个。
Semaphore 是一件可以容纳 N 人的房间,如果人不满就可以进去,如果人满了,就要等待有
人出来。
37.如果进程中任何一个线程中调用 exit 或_exit,那么整个进程都会终止。
38.线程和进程最大区别是线程完全共享相同的地址空间,运行在同一地址上。
39.线程同步:
进行多线程编程,因为无法知道哪个线程会在哪个时候对共享资源进行操作,因此让如何保
护共享资源变得复杂,通过下面这些技术的使用,可以解决线程之间对资源的竞争:互斥量
Mutex;信号灯 Semaphore;条件变量 Conditions;
40.TCP/IP 参考模型:应用层,传输层,网络层,网络接口层
OSI 参考模型:应用层,表示层,会话层,传输层,网络层,数据链路层,物理层。
41.IP 协议:IP 主要有以下四个主要功能:数据传送;寻址;路由选择;数据报文的分段。
42.IP 的主要目的是为数据输入/输出网络提供基本算法,为高层协议提供无连接的传送服务。
这意味着在 IP 将数据递交给接收站点以前不在传输站点和接收站点之间建立对话。它只是
封装和传递数据,但不向发送者或接收者报告包的状态,不处理所遇到的故障。
43.TCP 与 UDP 区别:
TCP---传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据
前,必须先在双方之间建立一个 TCP 连接,之后才能传输数据。TCP 提供超时重发,丢弃重
复数据,检验数据,流量控制等功能,保证数据能从一端传到另一端。
UDP---用户数据报协议,是一个简单的面向数据报的运输层协议。UDP 不提供可靠性,它只
是把应用程序传给 IP 层的数据报发送出去,但是并不能保证它们能到达目的地。由于 UDP
在传输数据报前不用在客户和服务器之间建立一个连接,且没有超时重发等机制,故而传输
速度很快.
44. 套 接 字 socket 有 三 种 类 型 : 流 式 套 接 字 ( SOCK_STREAM ) --TCP ; 数 据 报 套 接 字
(SOCK_DGRAM)--UDP;原始套接字。
45.网络字节顺序采用 big endian 排序方式。
46.基于 TCP-服务器
1. 创建一个 socket,用函数 socket()
2. 绑定 IP 地址、端口等信息到 socket 上,用函
数 bind()
3. 设置允许的最大连接数,用函数 listen()
4. 接收客户端上来的连接,用函数 accept()
5. 收发数据,用函数 send()和 recv(),或者 read()和 write()
6. 关闭网络连接
47.基于 TCP-客户端
1. 创建一个 socket,用函数 socket()
2. 设置要连接的对方的 IP 地址和端口等属性
3. 连接服务器,用函数 connect()
4. 收发数据,用函数 send()和 recv(),或者 read()和 write()5. 关闭网络连接
48.基于 UDP-服务器
1. 创建一个 socket,用函数 socket()
2. 绑定 IP 地址、端口等信息到 socket 上,用函数 bind()
3. 循环接收数据,用函数 recvfrom()
4. 关闭网络连接
49.基于 UDP-客户端
1. 创建一个 socket,用函数 socket()
2. 绑定 IP 地址、端口等信息到 socket 上,用函数 bind()
3. 设置对方的 IP 地址和端口等属性
4. 发送数据,用函数 sendto()
5. 关闭网络连接
50.TCP 并发服务器:
并发服务器的思想是每一个客户机的请求并不由服务器直接处理,而是由服务器创建一个子
进程来处理。TCP 并发服务器可以解决 TCP 循环服务器客户机独占服务器的情况。但同时也
带来了问题:为了响应客户的请求,服务器要创建子进程来处理,而创建子进程是一种非常
消耗资源的操作。
51.多路复用 I/O:如果你希望服务器仅仅检查是否有客户在等待连接,有就接受连接,否则
就继续做其他事情,则可以通过使用 select 系统调用来实现。除此之外,select 还可以同时
监视多个套接字。
52.多路复用 I/O
1. 设置要监控的文件
2. 调用 Select 开始监控
3. 判断文件是否发生变化
53.PV 操作及信号量的概念都是由荷兰科学家 E.W.Dijkstra 提出的。信号量 S 是一个整数,S
大于等于零时代表可供并发进程使用的资源实体数,但 S 小于零时则表示正在等待使用共享
资源的进程数。
P 操作申请资源:
(1)S 减 1;
(2)若 S 减 1 后仍大于等于零,则进程继续执行;
(3)若 S 减 1 后小于零,则该进程被阻塞后进入与该信号相对应的队列中,然后转入
进程调度。
V 操作 释放资源:
(1)S 加 1;
(2)若相加结果大于零,则进程继续执行;
(3)若相加结果小于等于零,则从该信号的等待队列中唤醒一个等待进程,然后再返
回原进程继续执行或转入进程调度。
54.线程同步: 1 事件,2 互斥对象,3 信号量,4 临界区
55.从编程的角度看,ARM 微处理器的工作状态一般有两种,并可在两种状态之间切换:
第一种为 ARM 状态,此时处理器执行 32 位的字对齐的 ARM 指令。
第二种为 Thumb 状态,此时处理器执行 16 位的、半字对齐的 Thumb 指令。
56.ARM 微处理器支持 7 种工作模式,分别为:
1、用户模式(Usr)
:用于正常执行程序2、快速中断模式(FIQ):用于高速数据传输
3、外部中断模式(IRQ):用于通常的中断处理
4. 管理模式(svc)
:操作系统使用的保护模式
5. 数据访问终止模式(abt):当数据或指令预取终止时进入该模式,可用于虚拟存储及存储
保护。
6. 系统模式(sys)
:运行具有特权的操作系统任务。
7. 未定义指令中止模式(und)
:当未定义的指令执行时进入该模式,可用于支持硬件
57.ARM 微处理器共有 37 个 32 位寄存器,其中 31 个为通用寄存器,6 个为状态寄存器。但
是这些寄存器不能被同时访问,具体哪些寄存器是可以访问的,取决 ARM 处理器的工作状
态及具体的运行模式。但在任何时候,通用寄存器 R14~R0、程序计数器 PC、一个状态寄
存器都是可访问的。
58.所谓寻址方式就是处理器根据指令中给出的地址信息来寻找物理地址的方式。
59.什么是 Shell?
简单地讲,就是命令解析器,将用户输入的指令转换为相应的机器能够运行的程序。
60.所谓优先级翻转问题(priority inversion)即当一个高优先级任务通过信号量机制访问共享
资源时,该信号量已被一低优先级任务占有,而这个低优先级任务在访问共享资源时可能又
被其它一些中等优先级任务抢先,因此造成高优先级任务被许多具有较低优先级任务阻塞,
实时性难以得到保证。
61.进程和线程的区别:
进程和线程都是由操作系统所体会的程序运行的基本单元,系统利用该基本单元实现系统对
应用的并发性。进程和线程的区别在于:
线程的划分尺度小于进程,使得多线程程序的并发性搞高。另外,进程在执行过程中拥有独
立的内存单元,而多个线程共享内存,从而极大地提高了程序的运行效率。线程在执行过程
中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出
口。但是线程不能够独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制。
从逻辑角度来看,多线程的意义在于一个应用程序中,有多个执行部分可以同时执行。但操
作系统并没有将多个线程看做多个独立的应用,来实现进程的调度和管理以及资源分配。这
就是进程和线程的重要区别。
62.嵌入式系统与一般 PC 系统有何区别?
嵌入式系统专用于特定的应用,而 PC 是通用计算机。
经常在极端的环境下运行。
系统资源比 PC 少的多。
需要专用工具和方法进行开发设计。
63.嵌入式系统构架:
嵌入式微处理器
外围硬件设备
嵌入式操作系统
特定的应用程序
64.TFTP 服务器作为工作于宿主机上的软件,主要提供对目标机的主要映像文件的下载工作。
65.Linux 中文件编程可以使用两种方法:Linux 系统调用;C 语言库函数
66.S3C2440 有 130 个 IO 口,分为 A~J 共 9 组:GPA、GPB、GPC......GPJ,可以通过设置寄存
器来确定某个 IO 口用于输入、输出还是其他特殊功能。
67.GPxCON 用于选择引脚功能,GPxDAT 用于读/写引脚数据;另外,GPxUP 用于确定是否使
用内部上拉电阻。其中 x 为 A、B.....H、J 等。68.GPACON 中每一位对应一个 IO 口(共 23 个)
。当某位为 0 时,相应的 IO 为输出;当某位
被置为 1 时,相应的引脚为地址线或用于地址控制。 PORTB~PORTJ 在寄存器操作方面完全相
同,GPxCON 中每两位控制一根引脚:00 表示输入、01 表示输出、10 表示特殊功能、11 保
留不用。
69.GPxDAT 寄存器用于读/写引脚:当引脚被设为输入时,读此寄存器可知相应引脚电平状
态是高还是低;当引脚被设为输出时,写此寄存器相应的位可令此引脚输出高电平或低电平。
70.GPxUP:某位为 1 时,相应引脚无内部上拉电阻;为 0 时相应的引脚使用内部上拉电阻。
71.CPU 运行过程中,如何知道各类外设发生了某些不预期的事件,比如串口收到数据、按
键按下等?
1.查询方式:程序不断地查询各设备的状态,并做出相应的反应。占用 CPU 资源过高,不适
应多任务的系统。
2.中断方式:当事件发生时,硬件会设置某个寄存器;CPU 再每执行完一个指令时,通过硬件
查看这个寄存器,如果所关注的事件发生了,则中断当前程序流程,跳转到一个固定的地址
处理这个事件,最后返回被中断的程序。
72.中断处理流程:
(1)中断控制器汇集各类外设发出的中断信号,然后告诉 CPU。
(2)CPU 保存当前程序的运行环境,然后调用中断服务程序(ISR)来处理中断。
(3)在 ISR 中通过读取中断控制寄存器、外设的相关寄存器来识别是哪个中断,并进行相
应的处理。
(4)清除中断:通过读写相关中断控制寄存器和外设相关寄存器来实现。
(5)最后恢复被中断程序的环境,继续执行。
73.Linux 由用户空间和内核空间两部分组成。内核空间与用户空间是程序执行的两种不同状
态,通过系统调用和硬件中
断能够完成从用户空间到内核空间的转移。
74.进程管理的重点是创建进程(forkexec),停止进程(kill、exit),并控制它们之间的通信
(signal 或者 POSIX 机制)
。进程管理还包括控制活动进程如何共享 CPU,即进程调度。
75.内存管理的主要作用是控制多个进程安全地共享内存区域。
76.虚拟文件系统(VFS)隐藏各种文件系统的具体细节,为文件操作提供统一的接口。
77.内核模块的版本由其所依赖的内核代码版本所决定, 在加载内核模块时,insmod 程序会
将内核模块版本与当前正在运行的内核版本比较,如果不一致时,就会出现类似下面的错误:
insmod hello.kodisagrees about version of symbol struct_moduleinsmod: error inserting
'hello.ko': -1
Invalid module format
解决方法:
1、使用 modprobe --force-modversion 强行插入
2、确保编译内核模块时,所依赖的内核代码版本等同于当前正在运行的内核。
**可通过 uname –r 察看当前运行的内核版本**
78.物理地址是指出现在 CPU 地址总线上的寻址物理内存的地址信号,是地址变换的最终结
果。逻辑地址是在程序代码经过编译后在汇编程序中使用的地址。
79.虚拟内存:Linux 操作系统采用虚拟内存管理技术,使得每个进程都有独立的进程地址空
间,利用这种虚拟地址不但能起到保护操作系统的作用,而且更重要的是用户程序可使用比
实际物理内存更大的地址空间。Linux 将虚拟地址空间划分为两个部分——用户空间与内核
空间。用户进程通常情况下只能访问用户空间的虚拟地址,不能访问内核空间。例外情况是用户进程通过系统调用访问内核空间。
80.程序是存放在磁盘上的一系列代码和数据的可执行映像,是一个静止的实体。
进程是一个执行中的程序。它是动态的实体。
81.僵死进程:表示进程的执行被终止,但是父进程还没有发布 waitpid()系统调用来收集有
关死亡的进程的信息。
82.僵死撤销状态:表示进程的最终状态。父进程已经使用 wait4()或 waitpid()系统调用来收
集了信息,因此进程将由系统删除。
83.在 Linux 中用 current 指针指向当前正在运行的进程的 task_struct。
84.进程销毁可以通过几个事件驱动— 通过正常的进程结束、通过信号或是通过对 exit 函数
的调用。不管进程如何退出,进程的结束都要借助对内核函数 do_exit 的调用。
85.什么是调度?
从就绪的进程中选出最适合的一个来执行。
86.调度的发生有两种方式:
1、主动式:在内核中直接调用 schedule()。当进程需要等待资源等而暂时停止运行时,会把
状态置于挂起(睡眠)
,并主动请求调度,让出 CPU。
2、被动式(抢占)
:用户抢占(Linux2.4、Linux2.6)内核抢占(Linux2.6)
87.在不支持内核抢占的系统中,进程/线程一旦运行于内核空间,就可以一直执行,直到它
主动放弃或时间片耗尽为止。这样一些非常紧急的进程或线程将长时间得不到运行。
在支持内核抢占的系统中,更高优先级的进程/线程可以抢占正在内核空间运行的低优先级
进程/线程。
88.调度步骤
Schedule 函数工作流程如下:
1). 清理当前运行中的进程; 2). 选择下一个要运行的进程;
(pick_next_task 分析)3). 设置新
进程的运行环境;
4). 进程上下文切换。
89.系统调用:Linux 内核中设置了一组用于实现各种系统功能的子程序,称为系统调用。用
户可以通过系统调用命令在自己的应用程序中调用它们。
90.系统调用和普通的函数调用非常相似,区别仅仅在于,系统调用由操作系统内核实现,
运行于内核态;而普通的函数调用由函数库或用户自己提供,运行于用户态。
91.系统调用工作原理:一般情况下,用户进程是不能访问内核的。它既不能访问内核所在
的内存空间,也不能调用内核中的函数。系统调用是一个例外。其原理是进程先用适当的值
填充寄存器,然后调用一个特殊的指令,这个指令会让用户程序跳转到一个事先定义好的内
核中的一个位置:
在 Intel CPU 中,这个指令由中断 0x80 实现。
在 ARM 中,这个指令是 SWI。
92.根文件系统是 Linux 启动时使用的第一个文件系统。没有根文件系统,Linux 将无法正常
启动。
93.在嵌入式系统中,通常没有像 BIOS 那样的固件程序,因此整个系统的加载启动任务就完
全由 BootLoader 来完。BootLoader 就是在操作系统运行之前运行的一段小程序。通过这段
小程序,可以初始化硬件设备,从而将系统的软硬件环境带到一个合适的状态,以便为最终
调用操作系统做好准备。
94.BootLoader 大多采用两阶段,即启动过程可以分为 stage 1 和 stage2:stage1 完成初始化
硬件,为 stage2 准备内存空间,并将 stage2 复制到内存中,设置堆栈,然后跳转到 stage2。
stage2 初始化本阶段要使用到的硬件设备,将内核映像和根文件系统映像从 flash 上读到RAM 中,调用内核。
95.驱动程序:使硬件工作的软件
96.字符设备是一种按字节来访问的设备,字符驱动则负责驱动字符设备,这样的驱动通常
实现 open, close,read 和 write 系统调用。
97.Linux 用户程序通过设备文件(又名:设备节点)来使用驱动程序操作字符设备和块设备。
98.主设备号用来反映设备类型,次设备号用来区分同类型的设备。
99.信号量可能允许有多个持有者,而自旋锁在任何时候只能允许一个持有者。当然也有信
号量叫互斥信号量(只能一个持有者),允许有多个持有者的信号量叫计数信号量。
100.信号量适合于保持时间较长的情况;而自旋锁适合于保持时间非常短的情况,在实际应
用中自旋锁控制的代码只有几行,而持有自旋锁的时间也一般不会超过两次上下文切换的时
间,因为线程一旦要进行切换,就至少花费切出切入两次,自旋锁的占用时间如果远远长于
两次上下文切换,我们就应该选择信号量。
101.内存映射函数 mmap, 负责把文件内容映射到进程的虚拟内存空间, 通过对这段内存的
读取和修改,来实现对文件的读取和修改,而不需要再调用 read,write 等操作。
102.寄存器和 RAM 的主要不同在于寄存器操作有副作用(side effect 或边际效果):读取某
个地址时可能导致该地址内容发生变化,比如很多设备的中断状态寄存器只要一读取,便自
动清零。
103.IO 端口:当一个寄存器或内存位于 IO 空间时,称其为 IO 端口。
IO 内存:当一个寄存器或内存位于内存空间时,称其为 IO 内存。
104.在 Linux 系统中,存在一类字符设备,它们共享一个主设备号(10),但次设备号不同,
我们称这类设备为混杂设备(miscdevice)。所有的混杂设备形成一个链表,对设备访问时内
核根据次设备号查找到相应的 miscdevice 设备。
105.Linux2.6 内核引入了 sysfs 文件系统。 sysfs 被看成是与 proc 同类别的文件系统。 sysfs 把
连接在系统上的设备和总线组织成分级的文件,使其从用户空间可以访问到。
106.Kobject 实现了基本的面向对象管理机制,是构成 Linux2.6 设备模型的核心结构。它与
sysfs 文件系统紧密相连,
在内核中注册的每个 kobject 对象对应 sysfs 文件系统中的一个目录。
107.kset 是具有相同类型的 kobject 的集合,在 sysfs 中体现成一个目录。
108.为什么需要中断?
1.外设的处理速度一般慢于 CPU
2.CPU 不能一直等待外部事件
所以设备必须有一种方法来通知 CPU 它的工作进度,这种方法就是中断。
109.共享中断就是将不同的设备挂到同一个中断信号线上。
110.异步通信以一个字符为传输单位,通信中两个字符间的时间间隔是不固定的,然而同一
个字符中的两个相邻位之间的时间间隔是固定的。
111.当前常用的驱动调试技术可分为:打印调试;调试器调试;查询调试
112.并发:多个执行单元同时被执行。
竞态:并发的执行单元对共享资源(硬件资源和软件上的全局变量等)的访问导致的竞争状
态
113.处理并发的常用技术是加锁或者互斥,即确保在任何时间只有一个执行单元可以操作共
享资源。
114.自旋锁最多只能被一个可执行单元持有。自旋锁不会引起调用者睡眠,如果一个执行线
程试图获得一个已经被持有的自旋锁,那么线程就会一直进行忙循环,一直等待下去,在那
里看是否该自旋锁的保持者已经释放了锁,“自旋”就是这个意思。C++
1.重载:一个函数名多用
2.引用:为一个变量起别名
3.内置(inline)函数:不执行调用,而是在编译时直接把代码接入到调用点处,节省运行时
间,但增加了目标程序长度。
4.多态性:由继承产生的的派生类,基对象对于同一消息,会做出不同的反应。
5.struct 定义类和 class 定义类的区别:前者默认 public,后者默认 private
6.构造函数:用来处理对象的初始化,名字必须与类名同名,不具有任何类型,不返回任何
值。在建立类对象时会自动调用构造函数。
7.虚基类:在继承间接共同基类时只保留一份成员。
8.虚函数:在基类声明函数是虚拟的,并不是实际存在德尔函数,然后在派生类中才正式定
义此函数。
9.纯虚函数有以下特点:纯虚函数仅仅是用来为基类的派生类中的函数保留位置;纯虚函数
在基类中没有定义,它们被初始化为 0;当虚函数变成纯虚函数时,任何派生类都必须给出
它自己的定义。否则编译出错。
10.函数模板:建立一个通用的函数,其函数类型和形参类型不具体指定,用一个虚拟的类
型来代替
11.面向对象程序设计有四个主要特点:抽象,封装,继承和多态性。
12.静态成员函数与非静态成员函数的区别:前者没有 this 指针,后者有 this 指针。
静态成员函数只要用来访问静态数据成员,而不访问非静态成员。
13.转换构造函数:讲一个其他类型的数据转换成一个类的对象,只有一个形参。
14.类型转换函数:
将一个类的对象转换成另一个类型的数据,只能作为成员函数。有 operator
关键字,无形参。C
1.static 修饰的局部变量存储在程序静态区
static 的另一个意义是文件作用域标示符
―static 修饰的全局变量作用域只是声明的文件中
―static 修饰的函数作用域只是声明的文件中
2.register 关键字指明将变量存储于寄存器中
register 只是请求寄存器变量,但不一定请求成功
3.auto 变量存储在程序的栈中,默认属性
static 变量存储在程序静态区中
register 变量请求存储于 CPU 寄存器中
4. void 指针的意义
C 语言规定只有相同类型的指针才可以相互赋值
void*指针作为左值用于“接收”任意类型的指针
void*指针作为右值赋值给其它指针时需要强制类型转换
5. extern 用于声明外部定义的变量和函数
extern 用于“告诉”编译器用 C 方式编译
6.sizeof 是编译器的内置指示符,不是函数
sizeof 用于“计算”相应实体所占的内存大小
sizeof 的值在编译期就已经确定
7.在 C 语言中 const 修饰的变量是只读的,其本质还是变量
const 修饰的变量会在内存占用空间
本质上 const 只对编译器有用,在运行时无用
const 修饰函数参数表示在函数体内不希望改变参数的值
const 修饰函数返回值表示返回值不可改变,多用于返回指针的情形
8.volatile 用于告诉编译器必须每次去内存中取变量值
volatile 主要修饰可能被多个线程访问的变量
volatile 也可以修饰可能被未知因数更改的变量
9.typedef 用于给一个已经存在的数据类型重命名
typedef 并没有产生新的类型
typedef 重定义的类型不能进行 unsigned 和 signed 扩展
10.柔性数组即数组大小待定的数组
C 语言中结构体的最后一个元素可以是大小未知的数组
C 语言中可以由结构体产生柔性数组
11.注释规则小结
编译器会在编译过程删除注释,但不是简单的删除而是用空格代替
编译器认为双引号括起来内容都是字符串,双斜杠也不例外
“/*......*/”型注释不能被嵌套
12.‘a’表示字符常量在内存中占 1 个字节
’a’+1 表示’a’的 ASCII 码加 1,结果为‘b’
“a”表示字符串常量,在内存中占 2 个字节
“a”+1 表示指针运算,结果指向“a”结束符’\0’
13.预编译
处理所有的注释,以空格代替
将所有的#define 删除,并且展开所有的宏定义处理条件编译指令#if, #ifdef, #elif, #else, #endif
处理#include,展开被包含的文件
保留编译器需要使用的#pragma 指令
14.##运算符用于在预编译期粘连两个符号
15.#运算符用于在预编译期将宏参数转换为字符串
QT4
helloqt 程序:
#include <QApplication>
#include <QPushButton>
int main(int argc, char *argv[])
{
QApplication app(argc,argv);
QPushButton pushButton( QObject::tr("Hello Qt !") );
pushButton.show();
QObject::connect(&pushButton,SIGNAL(clicked()),&app,SLOT(quit()));
return app.exec();
}
1.qmake -project
2.qmake helloqt.pro
3.make
4.helloqt.exe
列举了 QDialog 子类的用途。
QDialog 子类说明
子类名用途
QAbstractPrintDialog 提供打印机配置对话框的基本实现对话框
QColorDialog
提供指定窗体颜色的对话框
QErrorMessage
提供“错误提示”对话框
QFileDialog
提供选择文件或目录的对话框
QFontDialog
提供指定窗体的文字字体对话框QInputDialog
提供标准输入对话框,可以方便的输入各种值
QMessageBox
提供一个模态对话框用于提示用户信息或要求用户回答问题
QPageSetupDialog 提供一个用于打印机页面设置的对话框
QPrintPreviewDialog
提供一个预览和调整打印机页面布局的对话框
QProgressDialog 提供一个长进程操作的进度回馈对话框
QWizard
提供一个“向导程序”的框架
对话框:
/............................................................extensionDlg.pro............................................................./
TEMPLATE = app #表示程序的类型是 app。
TARGET =
#TARGET 指定可执行文件或库的基本文件名,其中不包含任何的扩展、
前缀或版本号,默认的就是当前的目录名。
DEPENDPATH += .
INCLUDEPATH += . #INCLUDEPATH 指定 C++编译器搜索全局头文件的路径。
# Input
HEADERS += extensionDlg.h #HEADERS 指定工程的 C++头文件(.h)。多个头文件的情况
下,用空格隔开。
SOURCES += extensionDlg.cpp main.cpp #SOURCES 指定工程的 C++实现文件(.cpp),多个
头文件的情况下,用空格隔开。
/..................................................................extensionDlg.h.............................................................../
#ifndef EXTENSIONDLG_H
#define EXTENSIONDLG_H
#include <QtGui> //引入 QtGui 模块的头文件
class ExtensionDlg : public QDialog //声明我们的自定义对话框类 ExtensionDlg 单公有继
承自 QDialog。
{
Q_OBJECT //加入 Q_OBJECT 宏,程序中用到诸如信号/槽等 Qt 核心机制的时候,都要
加入这个宏。
public:
//声明了构造函数和初始化基础信息和扩展信息的函数。
ExtensionDlg();
void initBasicInfo();
void initDetailInfo();
public slots: //声明公有槽 slot2Extension(),它在用户点击【Detail】按钮时被触发。
void slot2Extension();
private:
//声明两个私有成员变量 baseWidget 和 detailWidget,它们都是 QWidget 的实
例,分别代表伸缩前后的对话框窗体。
QWidget *baseWidget;QWidget *detailWidget;
};
#endif // EXTENSIONDLG_H
/..............................................................................extensionDlg.cpp......................................................./
#include "extensionDlg.h"
ExtensionDlg::ExtensionDlg()
{
//构造函数中的内容。
setWindowTitle(tr("Extension Dialog")); //设置应用程序的标题。
initBasicInfo();
//调用 initBasicInfo()函数,初始化基本信息窗体。
initDetailInfo(); //调用 initDetailInfo()函数,初始化扩展信息窗体。
QVBoxLayout *layout = new QVBoxLayout;
//定义一个垂直布局类实体 layout。
layout->addWidget(baseWidget);
//分别将 baseWidget 和 detailWidget 加入到布局中。
layout->addWidget(detailWidget);
layout->setSizeConstraint(QLayout::SetFixedSize);/*setSizeConstraint()函数用于设置窗体的缩
放模式,其默认取值是 QLayout::SetDefaultConstraint。这里取参数值为 Qlayout::SetFixedSize
是为了使窗体的大小固定,不可经过鼠标拖动而改变大小;如果不这样设置,当用户再次点
击【Detail】按钮时,对话框将不能恢复到初始状态。*/
layout->setSpacing(6); //setSpacing()函数用于设置位于布局之中的窗口部件之间的间隔大
小。
setLayout(layout); //将刚刚设置好的布局应用加载到窗体上。
}
void ExtensionDlg::initBasicInfo()
{
//initBasicInfo()函数体的内容。
baseWidget = new QWidget; //实例化 baseWiaget,注意 baseWidget 是全局变量。
QLabel *nameLabel = new QLabel(tr("Name")); //依次定义窗体中的部件,注意在输入字符
时,前面都加上了 tr()函数。
QLineEdit *nameEdit = new QLineEdit;
QLabel *sexLabel = new QLabel(tr("Sex"));
QComboBox *sexComboBox = new QComboBox;
sexComboBox->addItem(tr("male"));
sexComboBox->addItem(tr("female"));
QPushButton *okButton = new QPushButton(tr("OK"));
QPushButton *detailButton = new QPushButton(tr("Detail"));
connect(detailButton,SIGNAL(clicked()),this,SLOT(slot2Extension())); /*使用信号/槽机制连接
了 detailButton 的单击信
号和窗口类 ExtensionDlg 的 slot2Extension()函数,这就使得整个对话框变得可伸缩。*/
QDialogButtonBox *btnBox = new QDialogButtonBox(Qt::Horizontal);
/* 示 范 了
QDialogButtonBox 类的用法,它用于创建一个
符合当前窗口部件样式的一组按钮,并且它们被排列在某种布局之中。在 Qt Designer 中,
最为常见的用法是从窗口部件盒里面把默认的那个 QDialogButtonBox
窗口部件拖到界面上来,不过显然这并不如使用代码来得方便。Qt::Horizontal 实参表示创
建水平方向的按钮组合*/btnBox->addButton(okButton,QDialogButtonBox::ActionRole); /*把两个按钮加入到这个组合
之中。其中的 QDialogButtonBox::ActionRole
参数表示创建的按钮具有实际的功能,单击它可以引起对话框的某种变化。该参数可以有很
多不同的值,使得这些按钮具有不同的功能,它们都被包含在
QDialogButtonBox::ButtonRole 这个枚举值之中。*/
btnBox->addButton(detailButton,QDialogButtonBox::ActionRole);
QFormLayout *formLayout = new QFormLayout; /*设置表单布局的常用方法,表单布局常用
于窗体界面元素可以整齐的分成两列的情况。 addRow()方法用于向布局中加入整行的界面元
素。*/
formLayout->addRow(nameLabel,nameEdit);
formLayout->addRow(sexLabel,sexComboBox);
QVBoxLayout *vboxLayout = new QVBoxLayout; //定义窗体的顶级布局,并将其两个元素
formLayout 和 btnBox 依次加入其中。
vboxLayout->addLayout(formLayout);
vboxLayout->addWidget(btnBox);
baseWidget->setLayout(vboxLayout);
}
void ExtensionDlg::initDetailInfo() //定义 initDetailInfo()函数。
{
/*其实现过程与 initBasicInfo()函数大同小异。只是由于对 detailWidget 调用了 hide()函数,
才使得程序初始时,显示的是基本信息,而将扩展信息隐藏了起来。hide()函数用于将窗口
隐藏起来,它是 Qt 默认的槽函数之一,其原型如下:void QWidget::hide () [slot]
它的作用等同于调用 setVisible(false)函数。*/
detailWidget = new QWidget;
QLabel *ageLabel = new QLabel(tr("Age"));
QLineEdit *ageEdit = new QLineEdit;
ageEdit->setText(tr("25"));
QLabel *deptLabel = new QLabel(tr("Department"));
QComboBox *deptComboBox = new QComboBox;
deptComboBox->addItem(tr("department 1"));
deptComboBox->addItem(tr("department 2"));
deptComboBox->addItem(tr("department 3"));
deptComboBox->addItem(tr("department 4"));
QLabel *addressLabel = new QLabel(tr("address"));
QLineEdit *addressEdit = new QLineEdit;
QFormLayout *formLayout = new QFormLayout;
formLayout->addRow(ageLabel,ageEdit);
formLayout->addRow(deptLabel,deptComboBox);
formLayout->addRow(addressLabel,addressEdit);
detailWidget->setLayout(formLayout);
detailWidget->hide();
}
void ExtensionDlg::slot2Extension() //定义了 slot2Extension()函数
{/*它是我们自定义的槽函数,在点击【Detail】按钮时,将被触发。它的内容很简单,
就是判断扩展窗口是否被隐藏,如果被隐藏,就显示它;否则就隐藏它。
isHidden()函数用于判断窗体的显示窗体的显隐状态。*/
if (detailWidget->isHidden())
{
detailWidget->show();
}
else
{
detailWidget->hide();
}
}
/.........................................................................main.cpp.................................................................../
#include <QApplication>
#include "extensionDlg.h"
int main(int argc, char * argv[])
{
QApplication app(argc,argv);
ExtensionDlg exDlg;
exDlg.show();
return app.exec();
}

嵌入式系统求职回忆录
来源:blog.mcuol.com 作者:欧浩源 时间:08-11-08 21:10:18 点击数： 我要投稿 
　　嵌入式系统求职回忆录
一、引言 
 
一年前的这个时候，我开始了人生的真正求职历程。在这个过程中，有幸参加过广嵌、迈瑞、华为、智光、周立功、理邦等几个比较大笔试和面试。虽然大部分都失败了，但是我觉得正是这一次次的失败认我真正认识自己的不足，积累经验，成长进步，为最后的成功打下坚实的基础。求职是一个展现个人综合实力的过程，除了需要专业技能之外，还需要有一定的策略。同时这也是一个逐步提高和适应的过程。就像一支球队参加真正比赛之前都要经过系列的热身赛，熟悉对手的同时也在发现自己的不足。那时候我经看看别人的面经，现在我觉得把自己的体会跟大家分享也是一件很愉快的事情。特别在这个找工作的高潮时刻，也希望我以前总结的求职经历能给大家一点借鉴和帮助哦…… 
  
二、广嵌面试 
     这是我人生的第一次正式面试，挺紧张的。广嵌在广州科学城那边，有点偏了，人比较少。首先是做题，没有什么时间限制，做完就交。题目不多，8道好像，全是问答和编程题，没得蒙。主要考了C语音、数据结构、操作系统、编译原理、内存分配和链表的一些东西。虽然是很基础的东西，但是平时不注意不一定做得出来。题目做完了，HR拿去给技术总监看，过了一会来告诉我，技术总监对我的答题较满意，叫我去会议室进行面试。技术总监来是一个比较年轻的工程师，谈吐之间感觉巨牛。我首先介绍了项目的情况，可能是第一次吧，讲的比较细，他听了一会感觉出我实际做了点东西，懒得听我说，直接叫我停止，开始问了我几个问题。看起来不是什么技术难题，但却不好答。我印象比较深刻的是下面三个题目： 
 
1、在学校实验室中编程做项目和实际编程做项目有什么不同，需要注意什么？  
 
2、如果在公司中碰到了行政问题和技术难题应该怎么样处理？  
 
3、你的职业规划或者是你未来几年打算怎么样？  
 
    这些的回答见仁见智。我没想到他会问这些问题，开始愣了几秒中，脑子一下转不过来。不过我对自己的回答比较满意，可能技术总监也认同我的回答。接着他问我做TCP/IP方面的东西怎么样。我说没有怎么样做过网络底层的东西，主要做的应用层上面的套接字编程。然后他问我在windows和linux的驱动层和应用层做过什么东西，我就讲相关的项目和工作稍稍说了一说。然后他给我介绍了进来公司要做的一些工作，主要是做TCP/IP应用层的测试验证工作。后面也没什么问了。他出去后，HR进来和我谈了谈公司的具体情况和福利方面的东西。大概三个小时，我的第一次面试就这样结束了。 
  
三、迈瑞笔试 
收到迈瑞的笔试其实不是很意外，但是比较突然，没有想到当天宣讲完第二天下午就开始笔试，一点准备的机会都没有，去开开眼界吧。迈瑞通知我去考软件工程师，但我C++其实不怎么懂，肯定得交白卷。还好可以和来霸王面的人一起进了硬件工程师的考场。进去后我又要了系统研究工程师的题目，觉得系统的东西具体不是很清楚，思路说说还是可以的。然而，这次考试实在对自己的打击太大了，总算看清楚自己的真是水平了。  
 
     在硬件的题目中，考试范围很广，模电，数电，CPLD，操作系统，算法，智力，设计等都涉及到。对打击自己的是，明明看着知道怎么做，但是忘记相关的公式概念，没法下笔，更伤心的是会做的粗心做错了，唉...无药可救了。  
 
    	第1题是单位的换算，我居然把1Gbyte=1000Mbyte,出来想想才知道错了，应该是1024。 第2题是一个模电的题目，考查共射三极管的电容对上限截止频率和下限截止频率影响，包括耦合电容，极间电容和布线电容。第3题是问什么是摩尔定律，摩尔定律对硬件开发有什么影响？我一个字也写不下来。第4题又是一道伤心的题目，这是我唯一一道有点把握的题目，给了两个运放，要求写出名称和表达式，一个是差动比例放大器，一个积分电路，但是由于粗心，将差动比例放大器推导推错了。接下来的题目是什么呢......第5题做不出来，题目是说电容在高频的时候可以等效成一个电感、一个电容和一个电阻的串连，问实际中在什么频率时候使用做合适。第6题是数电的题目，什么是冒险与竞争，怎么样去消除冒险与竞争。数电的最基本题目，我又空白，你说这样的题目我都做不出来，在简历上吹你熟悉模电和数电还有人会相信吗？下面一题是英语翻译题目，给一个PCI的读时序，让你翻译将上面的英文翻译成中文。接着是一个智力题目：一个人从A城市下班后乘火车到火车站，他的妻子从家里骑车刚好到车站接他回家，一天，他坐了早班火车，5：30就到了火车站，然后走路回家，他的妻子在半路上接了他，回到家里发现比平时早了10分钟，问他坐了多少时间的路？这题我又挂了。后面是选做题，3选1。一道模电，给了运放、二极管，一个AD前端信号调理电路，要找出其中的错误。唉，又没头绪，估计是二极管钳位，写了几个字。另外一个是要用CPLD语言描述出JK触发器，再用JK触发器和与、非门搭出D触发器。这题我又放弃了。最后一个是操作系统的题目，关于PCI总线的三个读取方式的，只能放弃了。后面还有哦，一个二叉树遍历的程序补充，呵呵，这是数据结构最基本最简单的题目，我又缴械了。应该是最后一题了，说说你的一个成功的项目或者课程设计，画出结构框图，说出工作原理，碰到了什么难题怎么样解决。这个当然谁到会写拉，不就吹牛嘛。  
再看看系统工程师的题目，分三个部分。第一部分有四个可选题目，和公司的四条产品线密切相关，第一个是描述心电信号的特点和测量方法。第二个是描述人体生理信号的特点与测量方法。第三个是说说数字滤波器的特征和实现，最后一个是说说光谱吸收装置的原理好像。本来觉得第三个很眼熟，但是又不知道怎么下笔，算了，反正都不会，选了第一到吹了一通。第二题是编程题，一个是补充汉诺塔的程序，还有一部分是计算冒泡法的比较次数和用顺序法找一个最大值的平均次数。下面一道题目是设计题目，设计一个数码相机，从市场需求、功能设计、质量方面、可行性和市场风险去设计。还好这个可以写点东西，不然正的是交白卷了。最后是一个4选1的题目，考查的是精度方面的东西。第一个是说说游标卡尺的精度影响因素，第二个是分析数控机床的精度影响因素，第三个是分析光强测量装置的精度影响因素。第四个忘记了。我选了数控机床那个东西写了几个字。 
 
     虽然是深深收到了打击，但是也真正的看到了自己的水平。 学了那么多年，最基本的东西都没有掌握，正是惭愧啊。看来是时候开始好好找找自己的方向了，明确一个目标就去复习复习吧。软件东西我懂的都是皮毛，看来和它有缘无分拉，和硬件看来还有点尘缘未了啊。 
 
11月1号补充：虽然没有面试的机会，但是还是关注了迈瑞的面试情况，顺便记录了些在浙大BBS上看到的浙大牛人的面经： 
面试官是那天监考的工作人员，考卷也是他看的。好像他是根据考试情况来定面试内容的。从来开始讲一下他的问题吧： 
1.你选择深圳工作，有考虑过深圳离你家近？ 
 
2.如果老板给你一个很急的任务，按理来讲要7天完成，但是却要你5天之内完成，你会怎么办？ 
 
3.你的身边有这么一个老工程师，他可能不如你厉害，但是他脾气还很不好，你会怎么和他相处？ 
 
4.你的老板有一套方案已经确定了，而且马上要实施，而你认为自己的方案也不错，并且在某点还很有创新，你会怎么办？ 
 
5.你对选择做硬件有什么特别的想法？ 
 
6.我看你最后一道题答的很详细也很工整，是我想要的结果，但我还是想让你给我解释一下关键问题的解决思路。他会给我一张纸，在我画框图的过程中打断我，顺便问几个技术问题，比如运放做比较器和专门的比较器会有什么不同点等等。 
 
最后他说可能不一定会有二面，但是11月1号上午会确定是否给offer。 
 
我的感觉是：在答最后一道自由发挥的题时，大家最好把自己最熟悉的项目写上，并且写清楚，这样会给人家留下非常好的印象。另外项目如果不是自己做的，或者解释不清楚的，简历上最好不要提，被他们盯上就不好说了。但是他们还是很Nice的。 
  
四、华为笔试 
 
人家说得不错，要做好一些事情，不但要有目标还需要有充分的准备。虽然我没有什么明确的目标，但是这次我有了稍稍的准备。自从被迈瑞打击了一下，我重新认识了自己。回来正经地复习了一下功课。 
 
     虽然华为的硬件笔试题目出得很基础，但我也有不少做不好。但总算可以从迈瑞的失败中稍稍恢复了一点点信心，不管结果怎么样，我终于可以从头到尾做完，还提前了半个小时交卷。下面稍稍总结一下吧。 
 
     对于华为，我感觉浙大的牛人很不屑一顾。BBS上面关注的人不多，有也是华为负面的消息。迈瑞笔试那天有四个教室人，华为今天也就一个阶梯教室人。在笔试之前，华为都给参加笔试的人打了电话，问问情况。我也收了两个，不过没带手机，没接上。接到电话的人有两个被调整到技术服务类了。不过听说技术服务类比研发的待遇要好哦。在考场上，什么也不用检查，去了就考，没有通知到的也可以考，总之是来者不拒。 
试卷有10道填空题，12道单选，12道多选和一道分析题。其中分析题就叫写出2－4译码器的真值表，是不是比期末考试还简单呢，20分哦。填空题第一道就是一道运放题目，给一些已知条件求运放的输出电阻，出来听大家讨论，好像我作错了。第二道又不会，问2DPSK是什么键控，是通信方面的内容，在百度搜了一下，原来二相差分移相键控。下面有什么是误码率啊，什么PCM一次群，8086的寄存器是几位，给你一个128K的静态RAM和起始地址，问你最后一个字节的地址，还有VHDL和数字逻辑等等。有一道题我真写不下东西，问组合逻辑输出用做时钟容易产生什么。在单选题目考还是那些基础的东西，有问IBM-PC和兼容机的I/O端口空间，PCM32一次群一个复帧的时间，还有是问码元长0.1us，2.5秒产生一个误码，其误码率是多少，不会就蒙吧。还问到RAM和ROM的区别，静态RAM和动态RAM的存储单元结构等等。多选比较变态点。第一题问下面的逻辑门必须上来电阻的是：OC门、OE门、OD门、以上都要。第二题是问你下面是可编程逻辑器的是：ASIC、PAL、GAL、FPGA、CPLD。第三题是RISC和CSIC的区别。第四题是总线的功能，我不知道驱动是不是总线的功能，所以没选。第五题有点难，问下面避免竞争冒险的是：采用同步时序电路，采用异步时序电路，修改状态转移表，增加延时逻辑。第六是ROM和RAM的区别，下面是8051的P3脚复用功能，接着是检波器的组成，还有常见的滤波器。第10题不会：问8KHz和10KHz的正弦波经过混频器之后，能产生下面那些频率的信号：－2K、2K、18K、1K。11题考8051的中断，最后一道不容易，问下面对负反馈那里两个是对的。 
 
    从题目的难度和广度上看，比迈瑞的简单，但是没有准备过的人也很难做出来的哦，范围广，重基础，关键还有可恶的多选选择。总的来说，我对自己的表现比较满意。没有迈瑞的那么狼狈。但是，估计没有下文了。我想这份题目做得好的人大大的是啊。听上午接到电话的人说，华为搞硬件的主要是3个方面：DSP和算法、逻辑电路、ASIC。唉，这三个我没有一个会，更不用说懂。就算有幸进到一面，也会被刷的，我想主要还是专业不太对有点影响。未来的事情就等它发生了再说吧。好好准备眼前的事情才是正道。 
  
五、华为一面 
华为的硬件笔试考完之后感觉不错，果然得到了一面的机会。不过我们学校去参加笔试的都可以去参加面试。不过听说华为这次做硬件的只招收DSP和逻辑两个方面，我一听就觉得自己就此终止华为的征程了，看看大公司的面试也是长长经验吧。我的面试时间被安排在6号的9点，搞到那天6点45就得起来从下沙赶到黄龙那边的一个酒店，极度的痛苦。  
 
    不知道怎么搞的，和我一起来的几个9点20的都面试完了还没有轮到我们。后来问问才知道我被安排到DSP组里面去了，后来赶紧叫他们改为逻辑。大概等到11点，终于到我了。不过当我走到面世官的前面，他却说要上洗手间，叫我等几分中，看来真是出师不利啊。  
 
    面试官很和蔼客气，大家say hello之后，我紧张的心情松了不少。然后他开始瞄我的简历，我估算了一下，不超过3秒钟。还好我做的是一页简历。他看到我后面有两个项目的实物图，就指着我在04年机械设计大赛的获奖作品问：“这个好像是什么车？”我说这个是我在省里面竞赛的一个作品，主要用一个多单片机系统控制直流电机和舵机完成相应的功能。不过他好像不感兴趣，然后就问：“我看你的简历好像做DSP和逻辑的比较少嘛”（其实我根本就没有做过）。我赶紧说：“是的，我们研究生虽然有相关的课程，但是我们学到只要是一些入门的基础，离实际的应用还很远，我在本科的时候主要是一些基础知识的系统学习，在研究生阶段主要是跟老师做做项目，其实我现在的技能主要和我做的项目相关，在以前的基础上的其中一两个方面进行比较深入的研究。”面试官看了看的简历说：“我看你做单片机的项目比较多嘛，我们也有做单板机软件，也有用一些小型的CPU和AD转换、DA转换的一些东西，你愿不愿意做呢？”我想DSP和逻辑肯定挂了，这个还有一线生机，赶紧说：“OK，没有问题，其实我的毕业设计就说一个单片机的数据采集和处理系统，我把实物带来了，你要不要看一下？”他点头示意可以。我心里一阵高兴，终于可以使出我的武器了。 
下面的面试内容的完全按照我事先预料的方向进行了。首先我详细的介绍我带来的系统，从原理到框图，从性能到关键点说了一通。他听完，问我：“这个系统是你设计的吗？”对于这个问题我觉得还是老实做答好，不然会死得很惨的。我说不是，我参加这个项目的时候，这个系统已经设计好了，我做的工作就是对老的版本进行测试，改善，从硬件和软件两个角度去进行性能和稳定性的提高。他说：“那好，我就问你几个问题吧？”首先问我上面一个三极管是干什么用的，我说那其实不是三极管，是一个稳压器79L05，产生一个－5V的电压给AD。然后他问我上面两个二极管是干什么用的，我说那是起保护作用，主要是限制电流反流。他一听很奇怪，他说二极管好像没有限流作用吧，我觉得他可能听错了，就补充了二极管的单向导通性，圆了一下场。接着他叫我将系统上面的有源滤波画出来，完了，这个系统我就那个地方没有弄懂。怎么办呢？只有画吧，凭着记忆画了一个二阶的有源滤波电路，跟他说我其实忘记了，大概说这样吧。他说那你讲讲这个滤波器的工作原理吧，我连画都画不出来，原理更讲不清了。我就跟他说：“其实二阶的滤波器和一阶滤波器的推导大致原理一样的，我画个一阶的来解析一下吧”。然后就画画讲讲，其实我还讲的比较清楚的拉。他问了最后一个问题，如果你的那个传感器的线比较长，会对你的系统有什么影响，其实我也是按照大致的方向去答的拉，我说这样就会导致信号的衰减和干扰的增大。他稍稍停了一下，问我喜欢做偏硬一点的还是偏软一点的。我说相对来说，我平时对偏软一点的做的事情比较多。他说：“那我就给你定底软的岗位吧，我现在要考考你；两道C语言的题目。”然后取了一叠试卷，边找边说给我找两个简单点的题目。  
 
    第一个：写一个宏名为MIN的宏，输入两个参数，求最小的那个？晕倒！我见了很多次，但是为什么偏偏在那个时候忘记呢？但是总不能说不会吧，人家都说给我找简单的了。只有硬着头皮写拉。我的答案是：
  
＃define  MIN (A,B)  ？（A>=B）B:A  
 
他看了我的答案，马上指出我的几个错误，应该是：  
 
＃define  MIN (A,B)  （A>=B）？（B）:（A）  
 
    第二个是读程序写结果，在一个mian()函数里面循环3次调用一个有静态变量的函数，输出一个和的结果。这个我最熟悉的了，三两下就把结果和过程都写出来了。  
 
    这时，面试也差不多要结束了。面试官问我工作地点的问题。我说我是广东人，希望在深圳，他说这个没有问题。然后我再一个确认我的工作内容，他说主要是底软吧，到时候部门之间再调配一下，他看了看我的简历，发现我有ARM和LINUX的经验，他说其实他们也会做相关的东西，例如VxWorks等。  
 
    这时，面试官对我说，他对我的能力比较满意，我心里一阵狂喜，不知道是骄傲还是高兴。他主动站起来和我握手，说叫我等秘书的通知，下一轮面试通知会在这两天发出。这时我都不知道自己在做什么了，收拾了下我的东西，临走前我主动和面试官再次握了握手，感谢他的面试与指导。  
  
六、华为二面 
没想到华为的工作效率那么快，本来还以为要到8号才有二面的通知，所以6号晚上玩了一把，到1点才睡觉。当我睡得正香的时候，来了两个短信，心里一阵狂怒，凌晨两点半什么人那么无聊发短信啊。不过一看原来是华为通知7好早上9点半面试，果然和大家说的一样，集体群殴PK，不管它了，继续睡觉。本来想睡到7点起来的，不过6点20分左右，又来了短信，还是华为通知面试的，他们不会加班到通宵吧。 
我们学校去参加研发一面的有4个人，其中有3个都进了二面。到了指定的酒店后，先是填表，还真是详细，什么都得填。本来安排是9点30的面试，后来拖到了10点20左右。之前，我们组的12个人都到得差不多了，大家赶紧先认识一下，到时候PK的时候也比较熟悉嘛。 
 
    时间到了，我们在一个MM的带领下进了房间，三个桌子排成三角型，中间一牌是面试官4男1女。两外两个是AB两组，反正大家随便坐，12个人分成两组PK。首先是每个人用一张纸折一个铭牌，将自己的姓名和应聘岗位写在上面。然后面试官开始叫我们自我介绍，要说得让面试官和大家对你留下深刻的影响，说说你的特点和以后的职业规划。我发现浙大的人理想很大哦，职业规划都是要做什么技术管理结合的职业经理人。我都忘记了我是怎么样介绍我的，好像说了说我一些竞赛获奖，说了说我的业余爱好，喜欢踢足球拉，还有就是我觉得我的硬件基础比较扎实，在华为里面能发挥所长，体现价值，华为是一个大企业，我在里面也能得到锻炼和成长。不知道这样说有没有问题？ 
 
    接着开始一个活动，在10分钟里面，每组按照发的题目将里面属于白领最忧虑的事情进行排序，然后由组里面的一个人进行陈述理由，然后其他人可以进行补充。活动刚开始我提了一个意见，但是有一个人的意见比我的更好，那就按照他的意见去做吧，我顺势将他推举为我们组的leader。在10分钟里面，HR们过来看大家的表现，然后打分，反正我是没有怎么去排列，我只是协调一下大家的动作啊，看看时间啊。很快时间到了，他们组先进行了陈述，在陈述的过程中，面试官会打断陈述，叫另外有个人补充表述。我们这组也是。在这个表述中，我基本上没有什么话，算是话最少的了。 
    两个组的排列顺序很不一样，这时候面试官说，你们两个组分别陈述理由，让对方同意你的观点。然后，两个组的人就纷纷展现自己，在这个过程中，我几乎一言不发，看来犯了群殴的大忌了。最后，面试官叫没有发过言的同学起来说两句，我是最后一个起来发言的，我就总结性的说了两点，然后就休息5分钟。 
 
   其实休息5分钟是让我们两个组在外面交流一下，统一一下观点。我知道他的意思，出来后我问两个组是不是应该统一一下观点啊，好像他们也没有退步的感觉，那就算了吧。 
 
     很快有进去了，首先面试官叫对方组的一个人起来，说说他的看法，他说同意了我们组的一个观点但是也有不同的地方。他说完之后，面试官看着我说，你们好像在外面统一了一下观点，你说说将B组的12点排在前面，你认不认同。我突然晕了，这怎么回答呢，答认同嘛，不知道会不会被我们组认说，说不认同嘛，那面试官明说说我们统一观点，而且B组的人也妥协了。那我只有用了找迂回战术，顺着B组刚刚的内容说了些总结性的东西，既不认同也不否认认同。面试官看我答非所问，又将问题问了一遍，我又将刚才的话说了一边。晕倒，这时那面官来了句其实我只是问你认不认同，这时候我发现我们组的leader在我的纸上写了认同两个字，我赶紧说认同认同，这才能坐下啊。 
 
    接着就是PK时段，想不到我是我们组唯一参与的。B组也有一个人，面试官说，给你一个机会你把你的特点和长处说出来，让我们觉得你应该加入华为。对方那人说啊说，面试官还让他举了一个案例。真想不到会轮到我要参与PK，是不是因为我话太少，不够积极呢，还是什么......面试官看我有点紧张，就对我说，你看我现在给了你这么好的一个机会，你要把你的特点和长处说出来，其他人我都没有给机会啊。不知道是不是安慰我的话。然后我就慢条斯理的说，我自己性格比较随和，喜欢跟别人交流，我觉得在交流的过程中会得到很大的提高，我的基础知识比较扎实，在项目的实践过程中，发现基础技能很重要，很多高端的问题都可以用基础的知识来解决。说我本科是学硬件的，研究生学的是软件，在实践的过程中发现现在不管是硬件开始还是软件开始都是一个协同的过程，不能机械的拆分两者，说我考虑问题会从系统的角度去分析，个体不一定是最好的，但是可能对系统的贡献是最大的。最后我总结说，我的优点是我为人随和，有独立分析问题和解决问题的能力，自我适应能力和学习能力比较强，在知识结构上面，软硬件结合，实际项目经验较多。面试官接着问我平时爱好干什么啊，我就说我喜欢体育运功，特别喜欢踢足球。他居然问我踢那个位置，不知道他是不是也踢足球的，我是中场。他又问我平时都和什么人踢啊，是不是和同学踢，我说不一定，有时候和同学踢，有时候到了球场上，碰到谁就和谁踢，还说我参加过一个大型的足球比赛。
就这样传说中的华为群殴结束了，虽然没有网上说得那么恐怖，但是也领我感到有点不爽，不知道是不是我被问的缘故。后面还有10分钟的提问时间，有人问了华为集体辞职和加班的问题，还有下面的一些安排。这时我才知道下面还有一个单对单的综合面试和综合素质测试、性格测试和英语测试。 
 
    长路漫漫啊......不知道还能不能收到三面的通知呢？等等吧...... 
  
七、智光面试 
 
非常感谢智光电气给我面试的机会拉。由于18号中午学校要进行毕业生的图像数据采集，我没有办法参加智光电气的笔试，虽然在宣讲会那天和相关的人员打了招呼，但是那天一直到下午三点多还没有收到任何通知，在浙大88上看到已经有人开始面试了，感觉这次是不是又没戏了呢？干脆回去寝室睡觉算了。这时居然接到了智光电气的电话，说明天什么时候来杭州百脑汇8楼面试......  
 
    没有参加笔试和一面，直接参加19号的面试，这样的待遇我还是头一次，很有受尊重的感觉。有机会就不能错过，剩下的时间我就开始临时抱佛脚，听说很有用，不过面试的时候我都没有用上，因为我的面试估计也就10几分钟吧。之前我等了大概半个小时。  
 
      面试我的是一个博士，还有另外三个人。主要就是根据简历上的东西随便问问你，但是每个技术都问得很到点子上，但是我也答得很到点上，而且还很老实，很多东西都直接说不是我设计或者不是我一个人做的，或许这样他们就不再往下问了。现在的硕士大家都知道什么水平的拉......总不能说自己是什么大牛，估计我是说了肯定逃不过他们的法眼。这次我仍然带了我的毕业课题做的板子过去，不过他们就随便看了看，也没说什么，我一点发挥的机会都没有......是不是他们看不上呢？他们问为什么用华邦的单片机做呢？我说便宜啊。就这样。另外还问我有没有做过电机方面的东西，那我就把以前机械设计竞赛和指导电子设计竞赛的一些东西说了说，大概就五六句话吧。后来有个人问我做的一个数据汇集机用什么进行电话网通信的，我说是MODEM，本来以为可以大说一顿的拉，那个工程师说可以了，知道了。那我也没什么说的了。基本上聊了一些基本问题面试也就结束。 
 
    接下来就谈待遇了，那个主面的博士问我期望多少钱，经过多次的打击，我也不好意思说了，就说我没有很高的要求，中等就可以了。他叫我尽管说。我说5K到6K吧。他说5K应该没什么问题的。估计也就这个身价了。后来聊了一些工作内容和时间的问题，基本都比较合意吧。然后就叫我准备三方了。我说两天内答复。找工作实在太累太耗时间和精力了，其实也没有什么可以选择的了，就这样......回去再想想，卖了吧。 
  
八、理邦面试 
 
自从上次在智光面试完之后，也没有什么合适的单位到来。在智光面试完，我正准备签三方的时候，他们的HR告诉我，要等广州总部的总工电话面试，但是快两个礼拜了都没有音讯，估计我是被他们放弃了。正好1号深圳理邦来浙大宣讲，就去碰碰运气吧。 
 
    那天宣讲完马上开始笔试，还好之前抱了下佛脚。原本我应聘的是嵌入式软件工程师职位，需要考一份软件题，不过一想到软件的算法，心里有点慌慌，要了份硬件的题目来做。题目不多，八九道简答题，主要涉及晶体管、运放、滤波、触发器、AD、通信、单片机等一些很基础的东西。我已经是身经百考的人了，每个公司的硬件题目都差不多的，大部分做起来没有什么问题，除了一个压控电流源和一道场效应管的题目没做，其他的问题不是很大，估计有下文，果然晚上接到了面试的电话。 
理邦公司给你第一感觉很实在，很规范化，而且很守时。面试安排在9点20，我怕迟到早点到了，说20就是20，我在面试的时候发现他们原来是有表的，难怪时间那么准，一次面试，经历了三个面试官的车轮战，对于我来说，还是头一次。 
第一战：技术面试 
 
    我原来是他们通知的第二个来面试的人。面试的时候，和他有好几米的距离，感觉有点紧张。上来第一个问题是你喜欢做什么样的工作，然后开始按照你的简历上面的所做的项目来问，我都忘了我怎么回答的了，总之就是不停的说。我第一次感觉到我的简历没有被浪费，他们用黄色的荧光笔在上面画了不少东西，看来我还是有一点东西能让他们感兴趣的。它对我应聘嵌入式软件工程师去考硬件题目有点奇怪，那也没什么好解释的，就觉得自己对硬件更有把握一点。这时又问了一些linux和ucos方面的东西等等，最后问我技术上面有什么问题需要问的。这个我还真的没有怎么备，不问感觉好像对公司和个人不关心的，我问他们像我这种非生物医疗专业的人进去做会不会很困难。他说没关系，我看你的计算机学得很不错，呵呵….这句话我搞得我很不好意思。也就是十几分钟，就结束了，要走的时候，他说我考的是硬件题，技术总监要面试我硬件方面，面就面罗。 
 
第二战：技术总监 
 
    技术总监给你感觉和蔼而威严。他看了看我的成绩单，好像更关心的是我本科的成绩，他说你本科是机械自动化的，那你觉得你和电子、计算机专业的学生竞争有什么优势吗？说真的，在专业技术上面没有任何的优势，我主要围绕着软硬件结合和项目经验比较丰富这两方面来讲，好像说得过去了。接着他问了我单片机方面的一些东西，好像他们对UCOS这个东西比较感兴趣，问我UCOS移植到MSP430上面行不行，我说没什么大的问题，然后说了说这个移植的过程。这个过程中，我感觉我一直在不停的说，嘴都干了，都不知道我那来那么东西说。在他问我为什么要在6月份毕业的时候，一个女的HR进来了，正好，技术总监叫我跟她出去了。 
 
第三战：面对女HR 
 
    也许这次是我第一次真正的面对HR，感觉很不自然，而且问题回答的很糟糕。在整个过程中都非常的严肃，我不知道其他公司的HR面试是不是也这样。 
 
    在面试的时候，我看到她在一张写着资格审查的表上写了我回答的问题，她问的问题我基本上都没有什么准备过，总之，问什么就答什么，但是我犯了个错误，有些问题不需要答得太多，说多了就会有问题… 
 
    首先问我的职业规划是什么样的，我还真没有考虑过，经过上次华为二面的教训，我大概把3－5年的打算说了说，就一句话，我这段时间想在一个行业里面做研发，在技术上面多点积累，五年后可能做做技术管理方面的东西。然后问你要找什么样的公司？工作地点在那里？有没有女朋友？平时喜欢干什么？性格是偏内向还是偏外向？其实这个我自己都不是很清楚，应该是有点内向吧。问我身边都是些什么朋友？这个问题我答得比较糟糕，我也不想多说拉。接着问你父母对你的最大影响是什么啊？对加班的看法？你最艰难的时候是什么时候，这个地方我又说多了，唉…..还问了毕业时间和实习的一些情况，最后问我有没有offer，我还真的是没有啊，问我以前有没有offer，我说智光电气给我了口头的offer，她好像很关心，把这个公司和我应聘的岗位都写下了，问我他们的待遇是多少，她顺便问我期望薪资多少，我想他们也不会给太多，说了个5K到6K，估计最后成的话也就5K吧。最后她例行的问我有没有什么问题要问的，我之前还真没有考虑过哦，问了她在公司里面三年这个发展过程怎么样。 
1号上午理邦一面回来感觉不是很好，但是晚上还是收到了二面的通知。在宣讲会的时候，他们说是要小组面试，我心里想一面的时候，技术专家面了，技术总监也见了，HR也谈了，二面面什么呢，小组面试会不会是跟华为他们一样的呢？心里没有什么底，也不知道怎么准备，干脆就不准备了。 
 
冬天早起的确是一件很艰难的事情，好不容易才爬起来，九点钟面试，我八点五十五才感到面试地点。当我进去面试的房间才知道他们的小组面试是什么回事，原来所谓的小组，是他们小组，面试我一个人，昨天面试的3个人一起来面试我，大概30分钟吧。原来还是问技术方面的问题，但是问的很深入，有很多问题我知道也做过，但是答的不完整，有些问题他们继续深入问，我只能说不知道。他们完全按照我简历上面写的项目和技能来进行考查，所以说没有做过，甚至没有什么把握的东西，最好少出现在简历上面，一旦有严格考查的公司面试，一下就暴露出来了，而且还觉得你有吹嘘的嫌疑。 
 
面试一开始，公司技术总监就拿着我的本科成绩单和笔试题目说，我是机电毕业的学生，但是从笔试来看，我的基础不是很好，这个怎么办好呢？问我准备以后怎么样去补救。其实我觉得这份题目做的还不错的拉，我看他在那道压控二极点高通滤波器上面打了一个大叉叉，我本来还觉得这道题目会做对的呢？然后他问我一些做“月球车”比赛的事情，我回答得应该不错，他说我是这个团队的军师了，这我科万万不能接受啊，赶紧把队友的贡献说了一通，强调他们的重要作用，这个团队里面少了谁也不行。接着问我一些单片机相关的项目，这个我都答得没有什么问题。然后是一个应该是偏软件一点的技术专家问我。首先就我用VC做的一个项目问我windows消息的机制是怎么样实现，这个问题其实我答得不是很好，我就项目上面基于消息机制的异步网络传输说了一些windows消息机制的一些东西，他接着我说的问我知不知道将关联消息和消息响应函数的那个宏是怎么样实现的，有没有看过代码，我只能说没有看过，但是我说我知道它的原理，是用一个静态的函数表将消息和消息响应函数关联在一起的，他又顺着问题往下问我知不知道这个函数表叫什么，我又只能说不知道了。下面他看我上面写着有linux下C/C++开发的经验，就开始从这里问我了。看我上面写着做过字符设备的驱动，其实我只是做做实验看看代码而已，我就把字符设备驱动的框架说了一说，他又接着我的回答，问我知不知道操作系统怎么样找到设备相应的处理函数的，我也没怎么样想，就直接说不知道了，但是我说我觉得他们应该是怎么样的，我想应该回答得到点上面了。接着他问我有没有做过linux上面的应用开发，我还是老老实实的告诉他吧，没有做过。他好像对我在简历上面的不老实有点不满。然后他继续问我相关于嵌入式和linux方面的东西，比如说移植啊，bootloader啊，会不会做randisk啊等等，大部分我只能say no了，但是我也不是完全举手投降，把相关的知识点答了一些，可能这也为我前面的不足做了一下弥补吧。最后是HR发问，还是一些常规但是不好答的问题：你觉得什么是成功？你觉得人生的意义是什么？你觉得自己有什么缺点？你为什么要选择理邦？你觉得到了理邦公司你能做些什么样的贡献？如果现在给你offer你会不会签？等等…我觉得这些问题的回答非常关键，可能前面你都答的不错，但是这问题回答不好，也会被out的。我觉得今天我这些问题答的还是可以的，虽然不是很好，总之这些问题怎么回答还是见仁见智的了。最后一个环节是例行的问我有没有什么要问的，我其实也没什么问的了，但是不问不是很好，就问了一些关于实习的事情。面试结果要到下午才能知道。 
 
想不到他们效率那么的快，在中午我正在食堂打饭的时候，他们的电话来了。虽然有点吵，但是还要赶紧接拉。HR先把面试结论告诉我，没怎么听清，大概是说我知识面比较宽，但是深度不够，基础不是很扎实等等等等，但是作为一个嵌入式软件工程师来说，还是可以培养的，下午可以来签约了，然后是待遇的情况，说了一通时候，告诉我要带什么什么还考虑什么呢，下午赶紧把需要的东西带齐，奔赴浙大签约了。签约只是一个5分钟的过程，他们把资料收好，给我出了张公司的接收函，再给我一张联系方式，整个签约就结束了，巨快。我就这样卖出去了，尽管有很大的遗憾，但是最后我选择了一个高校，跟理邦办了违约手续。 
  
九、经验总结 
 
    1、要有备而来，尽量将面试官引导到你最擅长的地方。其实他们也希望这样的吧，否则他很难发现你的能力和特长，而他不知道你的长处，就只有按照他的思路来考你，对你乱开枪，这样大家都没有得到想要的结果。 
 
    2、诚实最重要，懂就懂，不会就不会，东西不是你做就不要乱认。面试你的都是这一行的资深工程师，要忽悠他们可没那么容易。  
 
   3、对于不会回答的题目，不一定要给出准确的答案，只要往正确地将大致的思路说清楚就可以了，关键是你把你思考的过程告诉面试官。  
 
   4、要有自信心，当被问到确实不会的问题是，可以问问面试官，他们会给你一些提示或者思路，你或许能做出来呢？  
 
    5、平时要主要积累和准备，不然当面试机会来临的时候就手忙脚乱的拉，不过有时候临时抱佛脚也挺有用的，总之，没有准备很难有好发挥。 
 
6、投简历要有目的性，瞄准一家之后，做好各方面的情报工作，在网上收集试题、面经等等。再投一些同类的公司，他们只是您的热身对手，重在参与，发现不足，锻炼心理，演练战术。 
 
7、笔试不可怕，笔过两会就经验丰富了，考什么你心里很自然会清楚的。硬件的当然是数模电基础、单片机接口和C语言拉。嵌入式方面少不了操作系统、网络原理、驱动等一些内容，但都是基础，比期末考试还要容易呢。
 
8、求职是一个复杂的过程，职场如战场。您完全可以把它看作一场战斗，优胜劣汰，除了有足够的枪支弹药，还需要有战略战术的指导。 
 
祝大家求职顺利，个个早日找到理想的工作岗位。



一.1、简答题。下面的题目必须全部答对才给分(20分)：
1、 如何在C中初始化一个字符数组。
2、 如何在C中为一个数组分配空间。
3、 如何初始化一个指针数组。
4、 如何定义一个有10个元素的整数型指针数组。
5、 s[10]的另外一种表达方式是什么。
6、 GCC3.2.2版本中支持哪几种编程语言。
7、 要使用CHAR_BIT需要包含哪个头文件。
8、 对(-1.2345)取整是多少？
9、 如何让局部变量具有全局生命期。
10、C中的常量字符串应在何时定义？
11、如何在两个.c文件中引用对方的变量。
12、使用malloc之前需要做什么准备工作。
13、realloc函数在使用上要注意什么问题。
14、strtok函数在使用上要注意什么问题。
15、gets函数在使用上要注意什么问题。
16、C语言的词法分析在长度规则方面采用的是什么策略？
17、a+++++b所表示的是什么意思？有什么问题？
18、如何定义Bool变量的TRUE和FALSE的值。
19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。    
一.2、问答题。
1、-----------------------------------------------------------    
"匈牙利命名法"有什么优缺点？(2分)   
2、-----------------------------------------------------------    
下面x, y, *p的值是多少，有什么问题？(2分)
int x, y, z = 2; int *p=&z; x=sizeof*p;
y=x/*p; /* x=?, *p=?, y=?, 有什么问题？*/   
3、-----------------------------------------------------------    
下面的语句是什么意思？如何声明或定义才使它们更易懂？(10分)
int (*foo())();
int (*foo())[];
int (*foo[])();
(*(void(*)())0)();
void (*signal(int,void(*)(int)))(int);    
4、-----------------------------------------------------------     本题(2分)。
一般使用malloc时，需要进行强制类型转换，如： char *s; s = (char *)malloc(31);
下面中???该如何填写，才可以正确执行强制类型转换？ int (*monthp)[31]; monthp = (???)malloc(31);    
5、-----------------------------------------------------------    
关于C语言运算符优先级的记忆技巧是什么？(2分) /* 下面r的值是多少 */
int hi, low, r; hi=7;low=3; r=hi<<4+low;    
6、-----------------------------------------------------------    
指针和数组的区别是什么？
用一个简单的声明把它们区分开。(2分)
指针和数组的声明在什么情况下是相同的？(2分)    
7、-----------------------------------------------------------    
C语言的左值(lvalue)和右值(rvalue)的含义是什么？(2分)   
8、-----------------------------------------------------------    
为什么C语言可以实现printf(char *format, ...)这样可变参数的调用形式？这样有什     么缺点？(2分)   
9、-----------------------------------------------------------    
说明C语言中术语"声明""定义""原型"的含义？(2分)    
10、-----------------------------------------------------------    
举一个例子，说明使用assert和防错代码的区别。(5分)    
11、-----------------------------------------------------------    
对语句 if else 与操作符 ? : 使用场合的比较。(2分)    
12、-----------------------------------------------------------    
编写一个函数，输入一个的整型数字，可以选择按照8/10/16进制输出字符串。 注意边界值。(5分)  

13、-----------------------------------------------------------    
本题(2分)。下面是一个16x16的黑白图标：
static unsigned short stopwatch[] = { 0x07c6, 0x1ff7, 0x383b, 0x600c, 0x600c, 0xc006, 0xc006,
0xdf06, 0xc106, 0xc106, 0x610c, 0x610c, 0x3838, 0x1ff0, 0x07c0, 0x0000, };
如何修改声明，可以使之在源代码中形象地表现出图形的模样。    
14、-----------------------------------------------------------
说出可以使用calendar[11][30]变量的四种类型定义。(5分) 如：int calendar[12][31];   /* 二维数组 */  

15、-----------------------------------------------------------
使用strcmp，当字符串相同时会返回'\0'。但'\0'一般作为逻辑假， 因此下面的语句不容易理解:
if (!strcmp(s, "string")) return EQUATION; 如何经过简单修改，使之更易懂？(2分)
  
16、-----------------------------------------------------------
编写一个自己的完全C语言版本的memset函数，并且评价这个实现的性能和可移植性。(5     分)
   
17、-----------------------------------------------------------
在树和图这些数据结构中，通常使用指针来组织数据。如果我们要把这些数据保存到文     件 中，
指针是没有意义的。我们该如何解决这个问题。(2分)    
18、-----------------------------------------------------------
用2种不同的方法计算long变量的"1"bit的个数。(2分)    
19、-----------------------------------------------------------
任意给出一个C的基本数据类型，如何编码判断这个数据类型是有符号还是无符号的？(2     分)
不得上机实验，写出下面代码的输出。解释这个行为是标准定义的，还是依赖实现的。(     2分)
int i; for (i = 0; i < 10; i++) {      int j = i;      printf ("%d\n", j); }
  
20、-----------------------------------------------------------
列出5种以上你所看过的C编程的书籍，并写简要书评。(5分) 对C的评价。如果要你改造一把菜刀，
使之更加安全，你是否会使用这样的菜刀，为什么     ？(5分)
   
一.3、分析题。 本题(各5分)。假设下面代码中的变量都是合法变量，调用外部的函数都是正确的。
回答几个问题:这些代码意图要干什么？ 是否有问题？
如果有问题，该如何修改，或者如何避免类似错误发生?如果没有问题，如果代码有输出，输出是什么？
1、-----------------------------------------------------------    
int isvowel (char c) {      return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'; }    
2、-----------------------------------------------------------    
while (c=='\t'||c=' '||c=='\n')      c=getc(f);    
3、-----------------------------------------------------------    
/* 当x=2, y=3, z=? */ if (x==0)      if (y==0)          z=-1; else      z=x+y;    
4、-----------------------------------------------------------    
/* 处理网络事件 */
void process_network_code(int x, int y)
{      /* 选择modes_pointer资源 */     
switch (line) {         
case THING1:              /* 处理异常1#, 使用老的modes_pointer资源 */            
    doit1();              break;         
case THING2:              /* 处理异常2#, 需要重新启动服务 */             
   if (x == STUFF) {                  /* 重新申请modes_pointer资源，没有初始化 */                 
    do_first_stuff();                  /* 在这种条件下，有些资源不用重新申请 */                
     if (y == OTHER_STUFF)                     
     break;                  /* 申请剩下的资源，并初始化 */                 
     do_later_stuff();            
     }             
    /* 初始化modes_pointer资源 */             
    initialize_modes_pointer();             
    break;         
default:              /* 处理普通事件, 使用老的modes_pointer资源 */             
   processing();     
}      /* 使用modes_pointer资源，处理事件 */     
use_modes_pointer();
}    
5、-----------------------------------------------------------    
int is_gb2312_char(char c1, char c2)
{      if (c1 >= 0xa1 && c2 >= 0xa1)         
return 1;     
else        
return 0;
}   
6、-----------------------------------------------------------    
下面x, y的值是多少，有什么问题？
int x = 10, y = 3;
   x ^= y; y ^= x;
   x ^= y; /* x=?, y = ? */   
7、-----------------------------------------------------------    
int days[]={31,28,31,30,31,30,31,31,30,31,30,31,};
int calendar[12][31]; int (*monthp)[31];
int *dayp; int i;    
memset(calendar, 0, sizeof(calendar));
i = 0;
for (monthp = calendar; monthp < &calendar[12]; monthp++)
{     
for (dayp = *monthp; dayp < &(*monthp)[31]; dayp++)
   {         
    if (dayp - *monthp < days[calendar - monthp])
     {             
      *dayp = i++ % 7 + 1;         
     }     
   }
}    
8、-----------------------------------------------------------    
void printnum(long n)
{     
if (n < 0)
   {         
   putchar('-');         
   n = -n;     
   }        
   if (n >= 10) {          printnum(n/10);      }         putchar ("0123456789"[n%10]); }   
9、-----------------------------------------------------------     void * memchr(void *pv, unsigned char ch, size_t size)
{      unsigned char *pch = (unsigned char *) pv;      unsigned char *pchEnd = pch + size;        
while (pch < pchEnd) {          if (*pch == ch)              return (pch);          pch++;      }         return NULL; }    
10、-----------------------------------------------------------     void * memchr(void *pv, unsigned char ch, size_t size)
{      unsigned char *pch = (unsigned char *) pv;      unsigned char *pchPlant = pch + size;     
unsigned char chSave = *pchPlant;         *pchPlant = ch;      while (pch != ch) {          pch++;      }      *pchPlant = chSave;        
return ((pch == pchPlant) ? NULL : pch); }    
11、-----------------------------------------------------------     void UnsToStr(unsigned short int u, char *str)
{      char *pch;         assert(u <= 65535);      pch = &str[5];      *pch = '\0';     
do {          *--pch = u % 10 + '0';      } while ((u / 10) > 0);         strcpy(str, pch); }    
12、-----------------------------------------------------------     void *memmove(void *pvTo, void pvFrom, size_t size)
{      char *pbTo = (char *)pvTo;      char *pbFrom = (char *)pvFrom;       
((pbTo < pbFrom) ? tailmove : headmove) (pbTo, pbFrom, size);      return (pvTo); }   
13、-----------------------------------------------------------     void *memcpy(void *pvTo, void pvFrom, size_t size)
{      char *pbTo = (char *)pvTo;      char *pbFrom = (char *)pvFrom;         while (size-- > 0);         
*pbTo++ = *pbFrom++;      return (pvTo); }   
14、-----------------------------------------------------------   
#include <stdio.h>    
int main(int argc, char *argv[]) {      char s[]="0123456789";      int i = 0;        
do {          printf ("%c", i++[s]);      } while(s[i]?1:printf("\n")-1);         return 0; }    
15、-----------------------------------------------------------    
int fibonacci(int x) {      if (x == 1 || x == 2)          return 1;      return fibonacci(x - 2) + fibonacci(x - 1); }    
16、-----------------------------------------------------------     这里有一个程序cdecl.c。写出它的工作流程。写出它的使用方法。
给出一个典型输入用例，记录下它的输出。    
一.4、综合编程题。 要求： 1、完成需求，程序运行正确。 2、工作原理文档，使用文档完整。
3、代码规整优美。注释得当。 4、运行速度足够快。 5、用工具分析出是哪些代码或函数造成速度瓶颈。

1、----------------------------------------------------------- 编写一个排序程序。被排序的文件有8MB大小，一行一个随机整数(ASCII格式)。
要求对这些
整数进行 排序，并计算平均值，打印出排序所需的时间。(20分)    
2、----------------------------------------------------------- 用dummy header技巧实现一个链表DEMO。要求具有create, insert, delete, search功    
能。 编写一个应用程序，使用上面的函数。使用dummy header技巧有什么优点。(20分)   
3、----------------------------------------------------------- 用heapsort算法实现优先队列。要求具有create, insert, delete功能。
编写一个应用程序，使用上面的函数。使用heapsort算法有什么优点。(20分)     用trie(一种多叉树)实现一个字典。要求具有create, insert, delete, search功能。    
编写一个应用程序，使用上面的函数。使用trie树有什么优点。(20分)    
二、POSIX方面的知识。
二.1、简答题。下面的题目必须全部答对才给分：(5分)
1、在UNIX环境中，编译流程是什么？
2、ABI，ELF的英文全称是什么
3、一般UNIX的程序有多少段，举一个实际的例子说明。
4、如何在kernel二进制代码中找一个字符串。
5、段地址F000:FFF0转换为线形地址的值是多少(16进制表达)。
6、在一个UNIX文件系统中，文件的唯一性标志是什么？    
二.2、问答题。
1、----------------------------------------------------------- 写一些代码。如何用文件实现信号灯？要求如果程序崩溃了，这个文件也将自动被删除     。
为什么可以这样实现信号灯？(5分) 传统的signal函数信号处理为什么是不可靠的，信号和系统调用有何关系？(5分) 在图形库系统中往往提供timer的功能，
除了使用ALARM信号外，你还可以使用什么系统     调用来实现timer？(5分)
2、----------------------------------------------------------- 写一些代码，演示如何正确使用write系统调用。注意看好手册再回答。(2分)
如果一个文件以rw模式打开，在进行read/write操作转换时，需要进行什么操作。(2分)       
3、----------------------------------------------------------- 解释终端结构termios.c_cc的MIN/TIME数值变化的带来read/write的特性。(5分)
如何理解终端、控制终端、虚拟终端、控制台、tty等类同的概念？(5分)
4、-----------------------------------------------------------     解释计算机中Copy-On-Write的概念。(2分)     调用fork之后，子进程没有继承父进程
的属性有哪些？(5分) 解释为什么每个程序在装入执行之后，总是已经预先打开了stdout、stdin、stderr？(2     分) 在fork之前，父进程打开了一个文件。
在fork之后，
如果子进程移动了文件指针， 父进程的文件指针有什么变化；如果子进程关闭了文件，父进程有什么变化？为什么会     这样？(5分) 标准输入、
输出和错误输出分别是什么
类型的缓冲，这些缓冲在用户空间还是在核心空     间？ 怎样关闭他们的缓冲？如果父进程关闭了缓冲，在fork之后建立的子进程是否也关闭了    
缓冲？(5分) vfork和fork相比，
有什么特色？(2分) system函数是否等同于fork+exec？(2分)     wait系统调用有多少种条件可以退出？(2分)   
5、----------------------------------------------------------- 系统调用和库函数调用有什么区别。(2分) 在linux2.4.x上的glibc和newlib
(一种嵌入式C库)的系统调用有什么不同？(2分) 在linux2.4.x上，对系统调用execve如果调用成功，它返回的值是多少。(2分)    
6、----------------------------------------------------------- 列出你所知道的2个内存跟踪库。(2分) 设计一个内存跟踪方案，为什么选择这个方案(5分)    
二.3、综合编程题。 要求： 1、完成需求，程序运行正确。 2、工作原理文档，使用文档完整。 3、代码规整优美。注释得当。 4、运行速度足够快。    
1、----------------------------------------------------------- 这里有一个8MB的文件，编写一个copy程序，拷贝这个文件，并计算所需时间。用工具分    
析 出是哪些代码或函数造成速度瓶颈。 提示：如果只是使用read/write调用，不是一个好的实现。(20分)   
2、----------------------------------------------------------- Linux系统中，什么时候会出现类似Y2K的问题。写一个程序证明。(20分)    
3、----------------------------------------------------------- 编写一个程序，测试系统最小的睡眠时间间隔。(20分)    
4、----------------------------------------------------------- 编写一个pipe程序，测试有N个管道，size大小的buffer情况下，pipe的传输性能是多少     ？(20分)    
5、----------------------------------------------------------- 在ext2文件系统上，单个文件最大可以达到多少？ 写一个程序获得这方面的限制。(20分)    
三、Linux编程基本使用知识。
三.1、命令和shell
1）编写一个脚本，统计一个目录下面所有C代码的行数。(2分)
2）编写一个sed脚本，去除HTML文件中的HTML标记。(2分)
3）编写一个脚本获得当前系统eth0的IP地址。(2分)
4）编写一个脚本以交互的方式，进行DNS的设定。(2分)
5）使用ls命令编写一个脚本，实现ls -R，递归列出当前目录下的所有目录、文件。(2     分)
6） 在一个目录下，找soft-link files，用下面的命令，原理是可行的，但无法操作，
该如何解决？要2种方法。(2分) ls -l | grep ->    
7） 如何把标准错误输出，重定向到标准输出上。(2分)    
8） 我们的系统中的软件包是使用RPM管理的。要求下面的问题写出shell命令和运行结果。
( 5分) 如何知道系统中安装了几个软件包。 如何知道系统中安装了哪几类(group)软件包。 如何知道kernel软件包的简述。 如何知道kernel软件包
的Changelog。 如何知道kernel软件包有几个文件。 如何知道kernel软件包安装后有多大。    
三.2、编辑工具的使用。(各2分)
1）如何使用vi进行块拷贝、粘贴、删除的操作
2）如何设置Tab的长度，以及自动缩进的长度
3）如何使用tag进行代码阅读
4）如何在1～10行，有确认的进把所有的RedHat改为RedFlag
5）在SourceNavigator中，如何跳到一个变量的声明处？如何得知光标当前的位置在那        个函数体内？    
三.3、编译器与调试器。(各2分)
1）如何使用gcc得到宏展开的中间代码
2）如何通过gcc在命令行中传入宏定义
3）在那一级优化的情况下，内联函数才真正的内联到代码中
4）gdb的watch命令如何使用，有何缺点
5）gdb中使用什么命令可以显式调用的栈帧，如何查看某个栈帧上的局部变量
6）如何使用gdb调试多进程 7）如何使能/禁止core dump？    
三.4、库。(各2分)
1）如何知道XSetIMValues这个符号在那个X的库文件中
2）如何读取C++的符号名，更具可读性
3）请解释动态库的soname概念
4）解释在链接时rpath选项的含义   
三.5、Makefile。(10分) 如果有一个简单的Test项目目录如下： # tree Test Test |-- common.h |-- main.cpp |-- test.cpp `-- test.h    
1）使用wildcard、patsubst函数编写一个C++项目的Makefile文件
2）使用automake、autoconfig编写一个支持configure选项的configure.in脚本    
三.6、CVS。(10分)
1）如果一个CVS项目中，甲添加了一个子目录模块，那么乙在update时是否会自动检     出这个新添加的子模块？如果不能，那么你有什么好的解决方案？
2）如何在一个CVS项目中添加一个二进制文件，这个二进制文件可以进行增量的版本管     理吗？
3）如何检出标记（tag）为milestone-1的版本，如何创建以milestone-1为基础的分支        milestone-1-b1，并如何把分支的修改合并到milestone-1的主分支上    
三.7、Linux/GNU编程基本知识 1、----------------------------------------------------------- Linux2.4.x有多少种类型的设备文件？分别写出来。(2分)    
2、----------------------------------------------------------- glibc动态库的搜寻次序是什么？(2分) glibc 2.1.x 与 2.2.x的动态库的搜寻次序有什么
不同？为什么会采用现在的方案？(2     分)


嵌入式C开发人员的最好的0x10道笔试题_别有洞天
Page 1 of 9
嵌入式C开发人员的最好的0x10道笔试题
2006-11-22 15:53
约定:
1) 下面的测试题中,认为所有必须的头文件都已经正确的包含了
2)数据类型
char 一个字节 1 byte
int 两个字节 2 byte (16位系统,认为整型是2个字节)
long int 四个字节 4 byte
float 四个字节4 byet
double 八个字节 8 byte
long double 十个字节 10 byte
pointer 两个字节 2 byte(注意,16位系统,地址总线只有16位)
第1题: 考查对volatile关键字的认识
#include<setjmp.h>
static jmp_buf buf;
main()
{
volatile int b;
b =3;
if(setjmp(buf)!=0)
{
printf("%d ", b);
exit(0);
}
b=5;
longjmp(buf , 1);
}
请问,这段程序的输出是
(a) 3
(b) 5
(c) 0
(d) 以上均不是
第2题:考查类型转换
main()
{
struct node
{
int a;
int b;
int c;
};
struct node s= { 3, 5,6 };
struct node *pt = &s;
printf("%d" , *(int*)pt);
}
这段程序的输出是:
(a) 3
(b) 5
(c) 6
(d) 7

//----

第4题:考查指针,这道题只适合于那些特别细心且对指针和数组有深入理解的人
main()
{
int a[5] = {1,2,3,4,5};
int *ptr = (int*)(&a+1);
printf("%d %d" , *(a+1), *(ptr-1) );
}
这段程序的输出是:
(a)
(b)
(c)
(d)
2 2
2 1
2 5
以上均不是
第5题:考查多维数组与指针
void foo(int [][3] );
main()
{
int a [3][3]= { { 1,2,3} , { 4,5,6},{7,8,9}};
foo(a);
printf("%d" , a[2][1]);
}
void foo( int b[][3])
{
++ b;
b[1][1] =9;
}
这段程序的输出是:
(a) 8
(b) 9
(c) 7
(d)以上均不对
第6题目:考查逗号表达式
main()
{
int a, b,c, d;
a=3;
b=5;
c=a,b;
d=(a,b);
printf("c=%d" ,c);
printf("d=%d" ,d);
}
这段程序的输出是:
(a)
(b)
(c)
(d)
c=3
c=5
c=3
c=5
d=3
d=3
d=5
d=5
第7题:考查指针数组
main()
{
int a[][3] = { 1,2,3 ,4,5,6};
int (*ptr)[3] =a;
printf("%d %d " ,(*ptr)[1], (*ptr)[2] );
++ptr;
printf("%d %d" ,(*ptr)[1], (*ptr)[2] );
}
这段程序的输出是:
(a)
(b)
(c)
(d)
2 3 5 6
2 3 4 5
4 5 0 0
以上均不对
http://hi.baidu.com/danforn/blog/item/87a05e66833a5e24ab184ced.html
2007-10-21嵌入式C开发人员的最好的0x10道笔试题_别有洞天
Page 3 of 9
第8题:考查函数指针
int *f1(void)
{
int x =10;
return(&x);
}
int *f2(void)
{
int*ptr;
*ptr =10;
return ptr;
}
int *f3(void)
{
int *ptr;
ptr=(int*) malloc(sizeof(int));
return ptr;
}
上面这3个函数哪一个最可能引起指针方面的问题
(a)
(b)
(c)
(d)
只有 f3
只有f1 and f3
只有f1 and f2
f1 , f2 ,f3
第9题:考查自加操作(++)
main()
{
int i=3;
int j;
j = sizeof(++i+ ++i);
printf("i=%d j=%d", i ,j);
}
这段程序的输出是:
(a)
(b)
(c)
(d)
i=4
i=3
i=3
i=3
j=2
j=2
j=4
j=6
第10题:考查形式参数,实际参数,指针和数组
void f1(int *, int);
void f2(int *, int);
void(*p[2]) ( int *, int);
main()
{
int a;
int b;
p[0] = f1;
p[1] = f2;
a=3;
b=5;
p[0](&a , b);
printf("%d\t %d\t" , a ,b);
p[1](&a , b);
printf("%d\t %d\t" , a ,b);
}
void f1( int* p , int q)
{
int tmp;
tmp =*p;
*p = q;
q= tmp;
}
void f2( int* p , int q)
{
int tmp;
tmp =*p;
*p = q;
q= tmp;
}
这段程序的输出是:
(a) 5 5 5 5
(b) 3 5 3 5
(c) 5 3 5 3
http://hi.baidu.com/danforn/blog/item/87a05e66833a5e24ab184ced.html
2007-10-21嵌入式C开发人员的最好的0x10道笔试题_别有洞天
Page 4 of 9
(d) 3 3 3 3
第11题:考查自减操作(--)
void e(int );
main()
{
int a;
a=3;
e(a);
}
void e(int n)
{
if(n>0)
{
e(--n);
printf("%d" , n);
e(--n);
}
}
这段程序的输出是:
(a)
(b)
(c)
(d)
0
0
1
0
1
1
2
2
2
2
0
1
0
1
1
1
第12题:考查typedef类型定义,函数指针
typedef int (*test) ( float * , float*)
test tmp;
tmp 的类型是
(a) 函数的指针,该函数以 两个指向浮点数(float)的指针(pointer)作为参数(arguments)
Pointer to function of having two arguments that is pointer to float
(b) 整型
(c) 函数的指针,该函数以 两个指向浮点数(float)的指针(pointer)作为参数(arguments),并且函数的返回值类型是整型
Pointer to function having two argument that is pointer to float and return int
(d) 以上都不是
第13题:数组与指针的区别与联系
main()
{
char p;
char buf[10] ={ 1,2,3,4,5,6,9,8};
p = (buf+1)[5];
printf("%d" , p);
}
这段程序的输出是:
(a)
(b)
(c)
(d)
5
6
9
以上都不对
第14题: 考查指针数组的指针
Void f(char**);
main()
{
char * argv[] = { "ab" ,"cd" , "ef" ,"gh", "ij" ,"kl" };
f( argv );
}
void f( char **p )
{
char* t;
t= (p+= sizeof(int))[-1];
printf( "%s" , t);
}
这段程序的输出是:
(a) ab
(b) cd
(c) ef
http://hi.baidu.com/danforn/blog/item/87a05e66833a5e24ab184ced.html
2007-10-21嵌入式C开发人员的最好的0x10道笔试题_别有洞天
Page 5 of 9
(d) gh
第15题:此题考查的是C的变长参数,就像标准函数库里printf()那样,这个话题一般国内大学课堂是不会讲到的,不会也情有可原呵呵,
#include<stdarg.h>
int ripple ( int , ...);
main()
{
int num;
num = ripple ( 3, 5,7);
printf( " %d" , num);
}
int ripple (int n, ...)
{
int i , j;
int k;
va_list p;
k= 0;
j = 1;
va_start( p , n);
for (; j<n; ++j)
{
i = va_arg( p , int);
for (; i;
i &=i-1 )
++k;
}
return k;
}
这段程序的输出是:
(a)
(b)
(c)
(d)
7
6
5
3
第16题:考查静态变量的知识
int counter (int i)
{
static int count =0;
count = count +i;
return (count );
}
main()
{
int i , j;
for (i=0; i <=5; i++)
j = counter(i);
}
本程序执行到最后,j的值是:
(a)
(b)
(c)
(d)
10
15
6
7
详细参考答案
第1题:
(b)
volatile字面意思是易于挥发的。这个关键字来描述一个变量时,意味着 给该变量赋值(写入)之后,马上再读取,写入的值与读取的值可能
不一样,所以说它"容易挥发"的。
这是因为这个变量可能一个寄存器,直接与外部设备相连,你写入之后,该寄存器也有可能被外部设备的写操作所改变;或者,该变量被一个
中断程序,或另一个进程
改变了.
volatile 不会被编译器优化影响,在longjump 后,它的值 是后面假定的变量值,b最后的值是5,所以5被打印出来.
setjmp : 设置非局部跳转 /* setjmp.h*/
Stores context information such as register values so that the lomgjmp function can return control to the statement
following the one calling setjmp.Returns 0 when it is initially called.
Lonjjmp: 执行一个非局部跳转 /* setjmp.h*/
http://hi.baidu.com/danforn/blog/item/87a05e66833a5e24ab184ced.html
2007-10-21嵌入式C开发人员的最好的0x10道笔试题_别有洞天
Page 6 of 9
Transfers control to the statement where the call to setjmp (which initialized buf) was made. Execution continues at this
point as if longjmp cannot return the value 0.A nonvolatile automatic variable might be changed by a call to longjmp.When
you use setjmp and longjmp, the only automatic variables guaranteed to remain valid are those declared volatile.
Note: Test program without volatile qualifier (result may very)
更详细介绍,请参阅 C语言的setjmp和longjmp
第2题:
(a)
结构题的成员在内存中的地址是按照他们定义的位置顺序依次增长的。如果一个结构体的指针被看成 它的第一个成员的指针,那么该指针的
确指向第一个成员
第3题: (a)
此题目较难.
这个程序的非递归版本
int what ( int x , int n)
{
int val;
int product;
product =1;
val =x;
while(n>0)
{
if (n%2 == 1)
product = product*val;
/*如果是奇数次幂,
x(val)
要先乘上一次,;
偶数次幂,最后返回时才会到这里
乘以1*/
val = val* val;
n = n/2;
}
return product;
}
/* 用二元复乘策略 */
算法描述
(while n>0)
{
if next most significant binary digit of n( power) is one
then multiply accumulated product by current val ,
reduce n(power) sequence by a factor of two using integer division .
get next val by multiply current value of itself
}
第4题: (c)
a的类型是一个整型数组,它有5个成员
&a的类型是一个整型数组的指针
所以&a + 1指向的地方等同于 a[6]
所以*(a+1) 等同于a[1]
ptr等同 a[6], ptr-1就等同与a[5]
第5题:
(b)
http://hi.baidu.com/danforn/blog/item/87a05e66833a5e24ab184ced.html
2007-10-21嵌入式C开发人员的最好的0x10道笔试题_别有洞天
Page 7 of 9
题目自身就给了足够的提示
b[0][0] = 4
b[1][0] = 7
第6题: (c)
考查逗号表达式,逗号表达式的优先级是很低的,比 赋值(=)的优先级 低. 逗号表达式的值就是最后一个元素的值
逗号表达式的还有一个作用就是分割函数的参数列表..
E1, E2, ..., En
上面这个表示式的左右是,E1, E2,... En的值被分别计算出来,En计算出来的结构赋给整个逗号表达式
c=a,b;
d=(a,b);
第7题:
/ *yields c=a* /
/* d =b */
(a)
ptr是一个数组的指针,该数组有3个int成员
第8题: (c)
f1显然有问题,它返回一个局部变量的指针,局部变量是保存在stack中的,退出函数后,局部变量就销毁了,保留其指针没有意义,因为其
指向的stack空间可能被其他变量覆盖了
f2也有问题, ptr是局部变量,未初始化,它的值是未知的,*ptr不知道指向哪里了,直接给*ptr赋值可能会覆盖重要的系统变量,这就是通
常说的野指针的一种
第9题: (b)
sizeof 操作符给出其操作数需要占用的空间大小,它是在编译时就可确定的,所以其操作数即使是一个表达式,也不需要在运行时进行计
算.( ++i + ++ i )是不会执行的,所以
i 的值还是3
第10题: (a)
很显然选a.
f1交换*p 和 q的值,f1执行完后, *p 和 q的值的确交换了, 但 q的改变不会影响到 b的改变, *p 实际上就是 a
所以执行f1后, a=b=5
这道题考查的知识范围很广,包括typedef自定义类型,函数指针,指针数组
void(*p[ 2 ]) ( int *, int);
定义了一个函数指针的数组p,p有两个指针元素. 元素是函数的指针,函数指针指向的函数是一个带2个参数,返回void的函数,所带的两个
参数是 指向整型的指针,和整型
p[ 0 ] = f1; p[ 1 ] = f2 contain address of function .function name without parenthesis represent address of function Value
and address of variable is passed to function only argument that is effected is a (address is passed). Because of call by
value f1, f2 can not effect b
第11题:
(a)
http://hi.baidu.com/danforn/blog/item/87a05e66833a5e24ab184ced.html
2007-10-21嵌入式C开发人员的最好的0x10道笔试题_别有洞天
Page 8 of 9
考查--操作和递归调用,仔细分析一下就可以了
第12题: (c)
建议不会的看看C专家编程
从左往有,遇到括号停下来,将第一个括号里的东西看成一个整体
第13题:
(c)
考查什么时候数组就是指针.对某些类型T而言,如果一个表达式是 T[]
的指针.所以(buf+1)[5]实际上就是*(buf +6)或者buf[6]
第14题:
(T的数组),
这个表达式的值实际上就是指向该数组的第一个元素
(b)
sizeof(int)的值是2,所以p+=sizeof(int) 指向 argv[2],这点估计大家都没有什么疑问
(p+=sizeof(int))[-1] 指向 argv[1],能理解吗,因为(p+=sizeof(int))[-1]
第15题:
就相当于 (p+=2)[-1] ,也就是(p+2-1)
(c)
在C编译器通常提供了一系列处理可变参数的宏,以屏蔽不同的硬件平台造成的差异,增加程序的可移植性。这些宏包括va_start、 va_arg
和va_end等。
采用ANSI标准形式时,参数个数可变的函数的原型声明是:
type funcname(type para1, type para2, ...)
这种形式至少需要一个普通的形式参数,后面的省略号不表示省略,而是函数原型的一部分。type是函数返回值和形式参数的类型。
不同的编译器,对这个可变长参数的实现不一样 ,gcc4.x中是内置函数.
关于可变长参数,可参阅
http://www.upsdn.net/html/2004-11/26.html
http://www.upsdn.net/html/2004-11/24.html
http://hi.baidu.com/danforn/blog/item/87a05e66833a5e24ab184ced.html
2007-10-21嵌入式C开发人员的最好的0x10道笔试题_别有洞天
Page 9 of 9
程序分析
va_list p; /*定义一个变量 ,保存 函数参数列表 的指针*/
va_start( p , n);
/*用va_start宏 初始化 变量p,
va_start宏的第2个参数n ,
是一个固定的参数,
必须是我们自己定义的变长函数的最后一个入栈的参数
也就是调用的时候参数列表里的第1个参数*/
for (; j<n; ++j)
/* j从1开始,
遍历所有可变参数 */
{
i = va_arg( p , int);
/*va_arg取出当前的参数,
并认为取出的参数是一个整数(int) */
for (; i;
i &=i-1 )
/*判断取出的i是否为0*/
++k;
/* 如果i不为0,
k自加,
i与i-1进行与逻辑运算, 直到i 为0
这是一个技巧,下面会谈到它的功能*/
}
当我们调用ripple函数时,传递给ripple函数的 参数列表的第一个参数n的值是3 .
va_start 初始化 p士气指向第一个未命名的参数(n是有名字的参数) ,也就是 is 5 (第一个).
每次对 va_arg的调用,都将返回一个参数,并且把 p 指向下一个参数.
va_arg 用一个类型名来决定返回的参数是何种类型,以及在 var_arg的内部实现中决定移动多大的距离才到达下一个 参数
(; i; i&=i-1) k++
/* 计算i有多少bit被置1 */
5用二进制表示是 (101) 2
7用二进制表示 (111) 3
所以 k 返回 5(2+3),也即本题应该选c
举个例子,就很好理解了
令
i= 9 = 1001
i-1 = 1000
(i-1) +1 = i
1000
+1
1 001
因为i与i-1的最右边的那位(最低位) 肯定是不同,如果i1,i-1肯定是0,反之亦然.
消除最右边的1位
i & i-1 这个运算,在二相补的数字系统中,将会
第16题: (b)
答案是 (b)
相传高斯小学一年级的时候就会做这类等比数列的题目了.这道题考查的是静态变量的知识,当每次调用完函数之后,静态变量的值不会丢失,
这与栈中的临时局部变量明显不同的地方.
所以,第一次调用counter(0)之后,count =0
第二次调用 counter(1)后 count = 0+1;
第三次调用 counter(2) count = 1+2;
/* count = count +i */
第四次调用 counter(3) count = 3+3;
第五次调用 counter(4) count = 6+4;
第六次调用 counter(5) count = 10+5;
命题人信息 Ashok K. Pathak a member ( Research Staff ) at Bharat Electronics Limited (CRL) , Ghaziabad. He has been
developing embedded application for the past five years .Ashok holds a M.E in computer science and engineering . Ashok
recently completed a book about' "Advanced Test in C and Embedded System Programming" , Published by BPB , ND .
http://hi.baidu.com/danforn/blog/item/87a05e66833a5e24ab184ced.html
2007-10-21

1、将一个字符串逆序 
2、将一个链表逆序 
3、计算一个字节里（byte）里面有多少bit被置1 
4、搜索给定的字节(byte) 
5、在一个字符串中找到可能的最长的子字符串 
6、字符串转换为整数 
7、整数转换为字符串
/*
* 题目：将一个字符串逆序
* 完成时间：2006.9.30深圳极讯网吧
* 版权归刘志强所有
* 描述：写本程序的目的是希望练一下手，希望下午去面试能成功，不希望国庆节之后再去找工作拉！
#include <iostream>
using namespace std;
//#define NULL ((void *)0)
char * mystrrev(char * const dest,const char * const src)
{
if (dest==NULL && src==NULL)
   return NULL;
char *addr = dest;
int val_len = strlen(src);
dest[val_len] = '\0';
int i;
for (i=0; i<val_len; i++)
{
   *(dest+i) = *(src+val_len-i-1);  
}
return addr;
}
main()
{
char *str="asdfa";
char *str1=NULL;
str1 = (char *)malloc(20);
if (str1 == NULL)
   cout<<"malloc failed";
cout<<mystrrev(str1,str);
free(str1);
str1=NULL;//杜绝野指针
}
p=head; 
q=p->next; 
while(q!=NULL) 
{ 
temp=q->next; 
q->next=p; 
p=q; 
q=temp; 
} 
这样增加个辅助的指针就行乐。
ok 通过编译的代码： 
#include <stdio.h> 
#include <ctype.h> 
#include <stdlib.h> 
typedef struct List{ 
int data; 
struct List *next; 
}List; 
List *list_create(void) 
{ 
struct List *head,*tail,*p; 
int e; 
head=(List *)malloc(sizeof(List)); 
tail=head; 
printf("\nList Create,input numbers(end of 0):"); 
scanf("%d",&e); 
while(e){ 
p=(List *)malloc(sizeof(List)); 
p->data=e; 
tail->next=p; 
tail=p; 
scanf("%d",&e);} 

tail->next=NULL; 
return head; 
} 
List *list_reverse(List *head) 
{ 
List *p,*q,*r; 
p=head; 
q=p->next; 
while(q!=NULL) 
{ 
r=q->next; 
q->next=p; 
p=q; 
q=r; 
} 
head->next=NULL; 
head=p; 
return head; 
} 
void main(void) 
{ 
struct List *head,*p; 
int d; 
head=list_create(); 
printf("\n"); 
for(p=head->next;p;p=p->next) 
printf("--%d--",p->data); 
head=list_reverse(head); 
printf("\n"); 
for(p=head;p->next;p=p->next) 
printf("--%d--",p->data); 
}
       编写函数数N个BYTE的数据中有多少位是1。
解：此题按步骤解：先定位到某一个BYTE数据；再计算其中有多少个1。叠加得解。

#incluede<iostream>
#define N 10
//定义BYTE类型别名
#ifndef BYTE
typedef unsigned char BYTE;
#endif
int comb(BYTE b[],int n)
{
int count=0;
int bi,bj;
BYTE cc=1,tt;
//历遍到第bi个BYTE数据
for(bi=0;bi<n;bi++)
{
//计算该BYTE的8个bit中有多少个1
tt=b[bi];
       for(bj=0;bj<8;bj++)
{
         //与1相与或模2结果是否是1？测试当前bit是否为1
         //if(tt%2==1)
       if((tt&cc)==1)
{
            count++;
         }
         //右移一位或除以2，效果相同
//tt=tt>>1;
tt=tt/2;
}
}
return count;
}
//测试
int main()
{
BYTE b[10]={3,3,3,11,1,1,1,1,1,1};
cout<<comb(b,N)<<endl;
return 0;
}
1。编写一个 C 函数，该函数在一个字符串中找到可能的最长的子字符串，且该字符串是由同一字符组成的。
char * search(char *cpSource, char ch)
{
char *cpTemp=NULL, *cpDest=NULL;
int iTemp, iCount=0;
while(*cpSource)
{
if(*cpSource == ch)
{
iTemp = 0;
cpTemp = cpSource;
while(*cpSource == ch) 
++iTemp, ++cpSource;
if(iTemp > iCount) 
iCount = iTemp, cpDest = cpTemp;
if(!*cpSource) 
break;
}
++cpSource;
}
return cpDest;
}
#include <stdio.h>
#include <string.h>
//
// 自定义函数MyAtoI
// 实现整数字符串转换为证书输出
// 程序不检查字符串的正确性,请用户在调用前检查
int MyAtoI(char str[])
{
int i;
int weight = 1; // 权重
int rtn = 0; // 用作返回
for(i = strlen(str) - 1; i >= 0; i--)
{
   rtn += (str[i] - '0')* weight; // 
   weight *= 10; // 增重
}
return rtn;
}
void main()
{
char str[32];
printf("Input a string :");
gets(str);
printf("%d\n", MyAtoI(str));
}
#include<stdio.h>
#include<string.h>
void reverse(char s[]) 
{   //字符串反转 
    int c, i=0, j; 
    for(j=strlen(s)-1;i<j;j--) 
    {    c=s[i]; 
        s[i]=s[j]; 
        s[j]=c; 
        i++; 
    } 
}
void IntegerToString(char s[],int n) 
{    int i=0,sign; 
    if((sign=n)<0)//如果是负数，先转成正数   
        n=-n; 
    do //从个位开始变成字符,直到最高位,最后应该反转 
    {    s[i++]=n%10+'0'; 
    }while((n=n/10)>0); 
    //如果是负数，补上负号 
    if(sign<0) 
        s[i++]='-'; 
    s[i]='\0';//字符串结束 
    reverse(s); 
} 
void main()
{    int m;
    char c[100];
    printf("请输入整数m: ");
    scanf("%d",&m);
    IntegerToString(c,m);
    printf("integer = %d string = %s\n", m, c);
}

嵌入式软件工程师应知道的0x10个基本问题(经典收藏版)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
C语言测试是招聘嵌入式系统程序员过程中必须而且有效的方法。这些年，我既参加也组织了许多这种测试，在这过程中我意识到这些测试能为面试者和被面试者提供许多有用信息，此外，撇开面试的压力不谈，这种测试也是相当有趣的。                                                                                                                                                                                                                                                                                                                                
        从被面试者的角度来讲，你能了解许多关于出题者或监考者的情况。这个测试只是出题者为显示其对ANSI标准细节的知识而不是技术技巧而设计吗？这是个愚蠢的问题吗？如要你答出某个字符的ASCII值。这些问题着重考察你的系统调用和内存分配策略方面的能力吗？这标志着出题者也许花时间在微机上而不是在嵌入式系统上。如果上述任何问题的答案是"是"的话，那么我知道我得认真考虑我是否应该去做这份工作。                                                                                                                                                        
        从面试者的角度来讲，一个测试也许能从多方面揭示应试者的素质：最基本的，你能了解应试者C语言的水平。不管怎么样，看一下这人如何回答他不会的问题也是满有趣。应试者是以好的直觉做出明智的选择，还是只是瞎蒙呢？当应试者在某个问题上卡住时是找借口呢，还是表现出对问题的真正的好奇心，把这看成学习的机会呢？我发现这些信息与他们的测试成绩一样有用。                                                                                                                                                                                            
        有了这些想法，我决定出一些真正针对嵌入式系统的考题，希望这些令人头痛的考题能给正在找工作的人一点帮助。这些问题都是我这些年实际碰到的。其中有些题很难，但它们应该都能给你一点启迪。                                                                                                                                                                                                                                                                                                                                                       
        这个测试适于不同水平的应试者，大多数初级水平的应试者的成绩会很差，经验丰富的程序员应该有很好的成绩。为了让你能自己决定某些问题的偏好，每个问题没有分配分数，如果选择这些考题为你所用，请自行按你的意思分配分数。                                                                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
预处理器（Preprocessor）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
1 . 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
         #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
我在这想看到几件事情：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
1) #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
2)懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。                                                                                                                                                                                                                                                                                                                                                                                                                     
3) 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。                                                                                                                                                                                                                                                                                                                                                                                                                                             
4) 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
2 . 写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
        #define MIN(A,B) （（A） <= (B) ? (A) : (B))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
这个测试是为下面的目的而设的：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
1) 标识#define在宏中应用的基本知识。这是很重要的。因为在  嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。                                                                                                                                                                                                                                                                                                                                         
2)三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。                                                                                                                                                                                                                                                                                                                                                                                                                      
3) 懂得在宏中小心地把参数用括号括起来                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
4) 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
        least = MIN(*p++, b);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
3. 预处理器标识#error的目的是什么？                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
死循环（Infinite loops）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
4. 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
这个问题用几个解决方案。我首选的方案是：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
while(1)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
一些程序员更喜欢如下方案：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
for(;;)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是："我被教着这样做，但从没有想到过为什么。"这会给我留下一个坏印象。                                                                                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
第三个方案是用 goto                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
Loop:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
...                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
goto Loop;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。                                                                                                                                                                                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
数据声明（Data declarations）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
5. 用变量a给出下面的定义                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
a) 一个整型数（An integer）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
b)一个指向整型数的指针（ A pointer to an integer）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
c)一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r                                                                                                                                                                                                                                                                                                                                                                                                                                                    
d)一个有10个整型数的数组（ An array of 10 integers）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
e) 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）                                                                                                                                                                                                                                                                                                                                                                                                                                                       
f) 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）                                                                                                                                                                                                                                                                                                                                                                                               
h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
答案是：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
a) int a; // An integer                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
b) int *a; // A pointer to an integer                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
c) int **a; // A pointer to a pointer to an integer                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
d) int a[10]; // An array of 10 integers                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
e) int *a[10]; // An array of 10 pointers to integers                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
f) int (*a)[10]; // A pointer to an array of 10 integers                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer                                                                                                                                                                                                                                                                                                                                                                                                                                             
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
Static                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
6. 关键字static的作用是什么？                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。                                                                                                                                                                                                                                                                                                                                                                                                                
3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。                                                                                                                                                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
Const                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
7．关键字const有什么含意？                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
我只要一听到被面试者说："const意味着常数"，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着"只读"就可以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）                                                                                                                                 
如果应试者能正确回答这个问题，我将问他一个附加的问题：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
下面的声明都是什么意思？                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
const int a;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
int const a;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
const int *a;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
int * const a;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
int const * a const;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
/******/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
1) 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）                                                                                                                                                                                                                                                                                  
2) 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
3) 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
Volatile                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
8. 关键字volatile有什么含意?并给出三个不同的例子。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：                                                                                                                                                                                                                                                                                                       
1) 并行设备的硬件寄存器（如：状态寄存器）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
3) 多线程应用中被几个任务共享的变量                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。                                                                                                                                                                                                                                                                                                                                  
假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。                                                                                                                                                                                                                                                                                                                                                                                                                     
1)一个参数既可以是const还可以是volatile吗？解释为什么。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
2); 一个指针可以是volatile 吗？解释为什么。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
3); 下面的函数有什么错误：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
int square(volatile int *ptr)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
        return *ptr * *ptr;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
下面是答案：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
1)是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。                                                                                                                                                                                                                                                                                                                                                                                                                                
2); 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。                                                                                                                                                                                                                                                                                                                                                                                                                                                         
3) 这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
int square(volatile int *ptr)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
    int a,b;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
    a = *ptr;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    b = *ptr;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    return a * b;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
long square(volatile int *ptr)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
    int a;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
    a = *ptr;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    return a * a;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
位操作（Bit manipulation）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
9. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。                                                                                                                                                                                                                                                                                                                                                                                    
对这个问题有三种基本的反应                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
2) 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。                                                                                                                                                                                                            
3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：                                                                                                                                                                                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
#define BIT3 (0x1 << 3)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
static int a;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
void set_bit3(void)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
    a |= BIT3;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
void clear_bit3(void)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
    a &= ~BIT3;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
访问固定的内存位置（Accessing fixed memory locations）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
10. 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。                                                                                                                                                                                                                                                                                                                                                                 
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：                                                                                                                                                                                                                                                                                                                                                                                         
    int *ptr;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    ptr = (int *)0x67a9;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
    *ptr = 0xaa55;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
 A more obscure approach is:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
一个较晦涩的方法是：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
    *(int * const)(0x67a9) = 0xaa55;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
中断（Interrupts）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
11. 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。                                                                                                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
__interrupt double compute_area (double radius)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
    double area = PI * radius * radius;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
    printf("\nArea = %f", area);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
    return area;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
这个函数有太多的错误了，以至让人不知从何说起了：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。                                                                                                                                                                                                                                                                                                                                            
4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。                                                                                                                                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
代码例子（Code examples）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
12 . 下面的代码输出是什么，为什么？                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
void foo(void)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
    unsigned int a = 6;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
    int b = -20;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
    (a+b > 6) ? puts("> 6") : puts("<= 6");                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 ">6"。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。                                                                                                                                       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
13. 评价下面的代码片断：                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
unsigned int zero = 0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
unsigned int compzero = 0xFFFF;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
/*1s complement of zero */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
对于一个int型不是16位的处理器为说，上面的代码是不正确的。应编写如下：                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
unsigned int compzero = ~0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。                                                                                                                                                                                                                                                                                                                                                                           
到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如何，你就当是这个娱乐吧...                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
动态内存分配（Dynamic memory allocation）                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
14. 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？                                                                                                                                                                                                                                                                                                                                                                                                     
这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：                                                                                                                                                                                                                                                                               
下面的代码片段的输出是什么，为什么？                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
char *ptr;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
if ((ptr = (char *)malloc(0)) == NULL)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
    puts("Got a null pointer");                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
else                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
    puts("Got a valid pointer");                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是"Got a valid pointer"。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
Typedef                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
15 Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：                                                                                                                                                                                                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
#define dPS struct s *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
typedef struct s * tPS;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？                                                                                                                                                                                                                                                                                                                                                                                                                                             
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
dPS p1,p2;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
tPS p3,p4;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
第一个扩展为                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
struct s * p1, p2;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。                                                                                                                                                                                                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
晦涩的语法                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
16 . C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
int a = 5, b = 7, c;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
c = a+++b;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：                                                                                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
c = a++ + b;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
因此, 这段代码持行后a = 6, b = 7, c = 12。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
好了，伙计们，你现在已经做完所有的测试了。这就是我出的C语言测试题，我怀着愉快的心情写完它，希望你以同样的心情读完它。如果是认为这是一个好的测试，那么尽量都用到你的找工作的过程中去吧。天知道也许过个一两年，我就不做现在的工作，也需要找一个。                                                                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
作者介绍:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
        Nigel Jones 是一个顾问，现在住在Maryland，当他不在水下时，你能在多个范围的嵌入项目中找到他。 他很高兴能收到读者的来信，他的email地址是: NAJones@compuserve.com                                                                                                                                                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
参考文献                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
1) Jones, Nigel, "In Praise of the #error directive," Embedded Systems Programming, September 1999, p. 114.                                                                                                                                                                                                                                                                                                                                                                                                                                      
2) Jones, Nigel, " Efficient C Code for Eight-bit MCUs ," Embedded Systems Programming, November 1998, p. 66.                                                                                                                                                                                                                                                                                                                                                                                                                                    
     
考查嵌入式C开发人员的最好的0x10道题
考查一个初级嵌入式系统开发人员的C基本功，附有答案题目由资深嵌入式系统专家拟定,目的是考查入门级的嵌入式软件开发人员 Gavin Shaw提供详细解答
编者按:非常基本关于C语言的问题,一个信息类(计算机,资讯工程,电子工程, 通信工程)专业的本科毕业生应该达到的水平。题目不难,全部都能快速地答完，当然也需要一定的知识储备。
对于大多数人，我们预期你可能答错 3)   4)  15)题，所以答错3道以内的，我们认为你很棒
答错5道题以内，我们认为你还不错(你还可能答错第9题)
如果你有6道以上的题目不能答对,基本上我们都不好说什么了....
约定:
   1) 下面的测试题中，认为所有必须的头文件都已经正确的包含了
    2)数据类型     
        char 一个字节 1 byte
        int 两个字节 2 byte (16位系统，认为整型是2个字节)
        long int 四个字节 4 byte
        float  四个字节4 byet
        double 八个字节 8 byte
        long double 十个字节 10 byte
        pointer 两个字节 2 byte(注意，16位系统,地址总线只有16位)
第1题: 考查对volatile关键字的认识
#include<setjmp.h>
static jmp_buf  buf;
main()    
{
  volatile  int b;
  b =3;
 if(setjmp(buf)!=0)  
  {
    printf("%d ", b);  
    exit(0);
  }
  b=5;
  longjmp(buf , 1);
}   
请问，这段程序的输出是
(a) 3
(b) 5
(c) 0
(d) 以上均不是
第2题:考查类型转换
main()
{
   struct node 
   {
     int a;
     int b;
     int c;     
   };
   struct node  s= { 3, 5,6 };
   struct node *pt = &s;
   printf("%d" ,  *(int*)pt);

}
这段程序的输出是:
(a) 3
(b) 5
(c) 6
(d) 7

//----

第4题:考查指针,这道题只适合于那些特别细心且对指针和数组有深入理解的人
main() 
{
  int  a[5] = {1,2,3,4,5};
  int *ptr =  (int*)(&a+1);
  printf("%d %d" , *(a+1), *(ptr-1) );
}
这段程序的输出是:
(a) 2 2
(b) 2 1
(c) 2 5
(d) 以上均不是

第5题:考查多维数组与指针
void foo(int [][3] );     
main()
{
  int a [3][3]= { { 1,2,3} , { 4,5,6},{7,8,9}};
  foo(a);
  printf("%d" , a[2][1]);
}
void foo( int b[][3])   
{
  ++ b;
  b[1][1] =9;
}
这段程序的输出是:
(a) 8
(b) 9
(c) 7
(d)以上均不对
第6题目:考查逗号表达式
main()
{
  int a, b,c, d;
  a=3;
  b=5;
  c=a,b;
  d=(a,b);

  printf("c=%d" ,c);
  printf("d=%d" ,d);
}
这段程序的输出是:
(a) c=3 d=3
(b) c=5 d=3
(c) c=3 d=5
(d) c=5 d=5
第7题:考查指针数组
main()
{
  int a[][3] = { 1,2,3 ,4,5,6};
  int (*ptr)[3] =a;
  printf("%d %d "  ,(*ptr)[1], (*ptr)[2] );
  ++ptr;
  printf("%d %d"  ,(*ptr)[1], (*ptr)[2] );
}
这段程序的输出是:
(a) 2 3 5 6
(b) 2 3 4 5
(c) 4 5 0 0
(d) 以上均不对
第8题:考查函数指针
int *f1(void)
{
  int x =10;
  return(&x);
}
int *f2(void)
{
  int*ptr;
  *ptr =10;
  return ptr;
}
int *f3(void)
{
  int *ptr;
  ptr=(int*) malloc(sizeof(int));
  return ptr;
}
上面这3个函数哪一个最可能引起指针方面的问题
(a) 只有 f3
(b) 只有f1 and f3
(c) 只有f1 and f2
(d) f1 , f2 ,f3
第9题:考查自加操作(++)
main()
{
  int i=3;
  int j;
  j = sizeof(++i+ ++i);
  printf("i=%d j=%d", i ,j);
}
这段程序的输出是:
(a) i=4 j=2
(b) i=3 j=2
(c) i=3 j=4
(d) i=3 j=6
第10题:考查形式参数，实际参数，指针和数组
void f1(int *, int); 
void f2(int *, int); 
void(*p[2]) ( int *, int);
main()
{
  int a;
  int b;
  p[0] = f1;
  p[1] = f2;
  a=3;
  b=5;
  p[0](&a , b);
  printf("%d\t %d\t" , a ,b);
  p[1](&a , b);
  printf("%d\t %d\t" , a ,b);
}
void f1( int* p , int q)
{
  int tmp;
  tmp =*p;
  *p = q;
  q= tmp;
}
void f2( int* p , int q)
{
  int tmp;
  tmp =*p;
  *p = q;
  q= tmp;
}  
这段程序的输出是:
(a) 5 5 5 5
(b) 3 5 3 5
(c) 5 3 5 3
(d) 3 3 3 3
第11题:考查自减操作(--)
void e(int );   
main()
{
  int a;
  a=3;
  e(a);
}
void e(int n)
{
  if(n>0)
  {
    e(--n);
    printf("%d" , n);
    e(--n);
  }
}
这段程序的输出是:
(a) 0 1 2 0
(b) 0 1 2 1
(c) 1 2 0 1
(d) 0 2 1 1
第12题:考查typedef类型定义,函数指针
typedef int (*test) ( float * , float*)
test tmp;
 tmp 的类型是
(a) 函数的指针，该函数以 两个指向浮点数(float)的指针(pointer)作为参数(arguments)
      Pointer to function of having two arguments that is pointer to float
(b) 整型
(c) 函数的指针，该函数以 两个指向浮点数(float)的指针(pointer)作为参数(arguments),并且函数的返回值类型是整型
      Pointer to function having two argument that is pointer to float and return int
(d) 以上都不是
第13题:数组与指针的区别与联系
main()
{
  char p;
  char buf[10] ={ 1,2,3,4,5,6,9,8};
  p = (buf+1)[5];
  printf("%d" , p);
}
这段程序的输出是:
(a) 5
(b) 6
(c) 9
(d) 以上都不对
第14题: 考查指针数组的指针
Void f(char**);
main()
{
  char * argv[] = { "ab" ,"cd" , "ef" ,"gh", "ij" ,"kl" };
  f( argv );
}
void f( char **p )
{
  char* t;
  t= (p+= sizeof(int))[-1];
  printf( "%s" , t);
}
这段程序的输出是:
(a) ab
(b) cd
(c) ef
(d) gh
第15题:此题考查的是C的变长参数,就像标准函数库里printf()那样,这个话题一般国内大学课堂是不会讲到的,不会也情有可原呵呵,
#include<stdarg.h>
int ripple ( int , ...);
main()
{
  int num;
  num = ripple ( 3, 5,7);
  printf( " %d" , num);
}
int ripple (int n, ...)
{
  int i , j;
  int k;  
  va_list p;
  k= 0;
  j = 1;
  va_start( p , n);     
  for (; j<n;  ++j) 
  {
    i =  va_arg( p , int);
    for (; i;    i &=i-1  )
      ++k;
  }
  return k;
}
这段程序的输出是:
(a) 7
(b) 6
(c) 5
(d) 3
第16题:考查静态变量的知识
int counter (int i)
{
  static int count =0;
  count = count +i;
  return (count );
}
main()
{
  int i , j;
  for (i=0; i <=5; i++)
    j = counter(i);
}
本程序执行到最后,j的值是:
(a) 10
(b) 15
(c) 6
(d) 7
详细参考答案
第1题:   (b)
volatile字面意思是易于挥发的。这个关键字来描述一个变量时，意味着 给该变量赋值(写入)之后，马上再读取，写入的值与读取的值可能不一样,所以说它"容易挥发"的。
这是因为这个变量可能一个寄存器，直接与外部设备相连，你写入之后，该寄存器也有可能被外部设备的写操作所改变;或者，该变量被一个中断程序，或另一个进程改变了.
volatile 不会被编译器优化影响，在longjump 后,它的值 是后面假定的变量值,b最后的值是5,所以5被打印出来.
setjmp : 设置非局部跳转 /* setjmp.h*/
Stores context information such as register values so that the lomgjmp function can return control to the statement following the one calling setjmp.Returns 0 when it is initially called.
Lonjjmp: 执行一个非局部跳转 /* setjmp.h*/
Transfers control to the statement where the call to setjmp (which initialized buf) was made. Execution continues at this point as if longjmp cannot return the value 0.A nonvolatile automatic variable might be changed by a call to longjmp.When you use setjmp and longjmp, the only automatic variables guaranteed to remain valid are those declared volatile.
Note: Test program without volatile qualifier (result may very)
更详细介绍，请参阅 C语言的setjmp和longjmp

第2题:   (a)
结构题的成员在内存中的地址是按照他们定义的位置顺序依次增长的。如果一个结构体的指针被看成 它的第一个成员的指针,那么该指针的确指向第一个成员
第3题:  (a)
此题目较难.
这个程序的非递归版本 
int  what ( int x , int  n)
{
  int val;
  int product;
  product =1;
  val =x;
  while(n>0)
  {
    if (n%2 == 1)  
      product = product*val;   /*如果是奇数次幂,  x(val)
                                                    要先乘上一次,;   
                                                  偶数次幂,最后返回时才会到这里
                                                    乘以1*/
     val = val* val;                  
     n = n/2; 
  }
   return product;
}
/* 用二元复乘策略 */
算法描述
(while n>0)  
{
  if  next most significant binary digit of  n( power)  is one
  then multiply accumulated product by current val  , 
  reduce n(power)  sequence by a factor of two using integer division .
  get next val by multiply current value of itself                   
}
第4题:  (c)
a的类型是一个整型数组,它有5个成员
&a的类型是一个整型数组的指针
所以&a + 1指向的地方等同于 a[6]

所以*(a+1) 等同于a[1]
ptr等同 a[6], ptr-1就等同与a[5]
第5题:  (b)

题目自身就给了足够的提示
b[0][0]  = 4
b[1][0]  = 7
第6题:  (c)
考查逗号表达式,逗号表达式的优先级是很低的，比 赋值(=)的优先级 低. 逗号表达式的值就是最后一个元素的值
逗号表达式的还有一个作用就是分割函数的参数列表..
E1, E2, ..., En
上面这个表示式的左右是,E1, E2,... En的值被分别计算出来，En计算出来的结构赋给整个逗号表达式 
c=a,b;       / *yields c=a* /
d=(a,b);    /* d =b  */

第7题:  (a)

ptr是一个数组的指针，该数组有3个int成员
第8题:  (c)
f1显然有问题，它返回一个局部变量的指针，局部变量是保存在stack中的,退出函数后，局部变量就销毁了，保留其指针没有意义，因为其指向的stack空间可能被其他变量覆盖了
f2也有问题, ptr是局部变量，未初始化，它的值是未知的，*ptr不知道指向哪里了，直接给*ptr赋值可能会覆盖重要的系统变量，这就是通常说的野指针的一种
第9题:  (b)
sizeof  操作符给出其操作数需要占用的空间大小，它是在编译时就可确定的，所以其操作数即使是一个表达式，也不需要在运行时进行计算.( ++i + ++ i  )是不会执行的，所以
i 的值还是3
第10题:  (a)
很显然选a.
f1交换*p 和 q的值，f1执行完后, *p 和 q的值的确交换了,  但 q的改变不会影响到  b的改变,  *p 实际上就是 a 
所以执行f1后,  a=b=5
这道题考查的知识范围很广,包括typedef自定义类型,函数指针,指针数组
void(*p[ 2 ]) ( int *, int);
定义了一个函数指针的数组p,p有两个指针元素.  元素是函数的指针，函数指针指向的函数是一个带2个参数,返回void的函数，所带的两个参数是 指向整型的指针，和整型
p[ 0 ] = f1; p[ 1 ] = f2 contain address of function .function name without parenthesis represent address of function Value and address of variable is passed to function only argument that is effected is a (address is passed). Because of call by value f1, f2 can not effect b
第11题:  (a)

考查--操作和递归调用,仔细分析一下就可以了
第12题:  (c)
分析函数声明，建议不会的看看《C专家编程》
这里介绍一个简单规则:从左往右，遇到括号停下来，将第一个括号里的东西看成一个整体 
第13题:  (c)
考查什么时候数组就是指针.对某些类型T而言，如果一个表达式是 T[]  (T的数组),  这个表达式的值实际上就是指向该数组的第一个元素的指针.所以(buf+1)[5]实际上就是*(buf +6)或者buf[6]
第14题:  (b)

sizeof(int)的值是2,所以p+=sizeof(int) 指向 argv[2],这点估计大家都没有什么疑问
(p+=sizeof(int))[-1] 指向 argv[1],能理解吗，因为(p+=sizeof(int))[-1]  就相当于 (p+=2)[-1] ,也就是(p+2-1)
第15题:  (c)
在C编译器通常提供了一系列处理可变参数的宏，以屏蔽不同的硬件平台造成的差异，增加程序的可移植性。这些宏包括va_start、 va_arg和va_end等。 
采用ANSI标准形式时，参数个数可变的函数的原型声明是： 
type funcname(type para1, type para2, ...) 
这种形式至少需要一个普通的形式参数，后面的省略号不表示省略，而是函数原型的一部分。type是函数返回值和形式参数的类型。
不同的编译器，对这个可变长参数的实现不一样 ，gcc4.x中是内置函数.
关于可变长参数,可参阅 
http://www.upsdn.net/html/2004-11/26.html
http://www.upsdn.net/html/2004-11/24.html
程序分析
va_list p;  /*定义一个变量 ,保存  函数参数列表 的指针*/
va_start( p , n);     /*用va_start宏 初始化 变量p,   
                          va_start宏的第2个参数n  ,
                          是一个固定的参数,
                          必须是我们自己定义的变长函数的最后一个入栈的参数
                          也就是调用的时候参数列表里的第1个参数*/
for (; j<n;  ++j)     /* j从1开始,   遍历所有可变参数 */
{
    i =  va_arg( p , int);      /*va_arg取出当前的参数,
                                      并认为取出的参数是一个整数(int)  */
    for (; i;    i &=i-1  )      /*判断取出的i是否为0*/
      ++k;                              /* 如果i不为0,   k自加,  
                                    i与i-1进行与逻辑运算, 直到i 为0
                                   这是一个技巧，下面会谈到它的功能*/
}
当我们调用ripple函数时，传递给ripple函数的 参数列表的第一个参数n的值是3 .
va_start 初始化 p士气指向第一个未命名的参数(n是有名字的参数) ,也就是 is 5 (第一个).
每次对 va_arg的调用，都将返回一个参数，并且把 p 指向下一个参数.
va_arg 用一个类型名来决定返回的参数是何种类型,以及在 var_arg的内部实现中决定移动多大的距离才到达下一个 参数
(; i; i&=i-1) k++        /* 计算i有多少bit被置1 */

5用二进制表示是 (101) 2
7用二进制表示 (111) 3
所以 k 返回 5(2+3),也即本题应该选c

举个例子，就很好理解了
令  i= 9 = 1001
     i-1  = 1000        
    (i-1) +1 = i
               1000
                 +1
              1 001
因为i与i-1的最右边的那位(最低位) 肯定是不同，如果i1,i-1肯定是0，反之亦然.     i & i-1 这个运算，在二相补的数字系统中，将会 消除最右边的1位
第16题:  (b)
答案是 (b)
相传高斯小学一年级的时候就会做这类等比数列的题目了.这道题考查的是静态变量的知识,当每次调用完函数之后,静态变量的值不会丢失,这与栈中的临时局部变量明显不同的地方.
所以,第一次调用counter(0)之后,count =0
第二次调用 counter(1)后 count = 0+1;
第三次调用 counter(2) count = 1+2;    /* count = count +i */
第四次调用 counter(3) count = 3+3;
第五次调用 counter(4) count = 6+4;
第六次调用 counter(5) count = 10+5;


华为嵌入式软件笔试题
(1)什么是预编译,何时需要预编译:
答案:
1、总是使用不经常改动的大型代码体。
2、程序由多个模块组成,所有模块都使用一组标准的包含文件和相同的编译选项。在这种
情况下,可以将所有包含文件预编译为一个预编译头。
(2)char * const p
char const * p
const char *p 上述三个有什么区别?
答案:
char * const p; //常量指针,p 的值不可以修改
char const * p;//指向常量的指针,指向的常量值不可以改 const char *p; //和 char const *p
(3)char str1[] = "abc"; char str2[] = "abc"; const char str3[] = "abc"; const char str4[] = "abc";
const char *str5 = "abc"; const char *str6 = "abc"; char *str7 = "abc"; char *str8 = "abc"; cout < <
( str1 == str2 ) < < endl; cout < < ( str3 == str4 ) < < endl; cout < < ( str5 == str6 ) < < endl; cout <
< ( str7 == str8 ) < < endl;
结果是:0 0 1 1 str1,str2,str3,str4 是数组变量,它们有各自的内存空间;而 str5,str6,str7,str8
是指针,它们指向相同的常量区域。
(4)以下代码中的两个 sizeof 用法有问题吗?
[C 易] void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母 { for( size_t i=0;
i <sizeof(str)/sizeof(str[0]); ++i )
if( 'a' <=str[i] && str[i] <='z' )
str[i] -= ('a'-'A' ); }
char str[] = "aBcDe"; cout < < "str 字符长度为: " < < sizeof(str)/sizeof(str[0]) < < endl;
UpperCase( str ); cout < < str < < endl; 答案:函数内的 sizeof 有问题。根据语法,sizeof 如用
于数组,只能测出静态数组的大小,无法检测动态分配的或外部数组大小。函数外的 str 是
一个静态定义的数组,因此其大小为 6,因为还有'\0',函数内的 str 实际只是一个指向字符
串的指针,没有任何额外的与数组相关的信息,因此 sizeof 作用于上只将其当指针看,一个
指针为 4 个字节,因此返回 4。
(5)一个 32 位的机器,该机器的指针是多少位答案:
指针是多少位只要看地址总线的位数就行了。80386 以后的机子都是 32 的数据总线。所以
指针的位数就是 4 个字节了。
6 main()
{
int a[5]={1,2,3,4,5};
int *ptr=(int *)(&a+1);
printf("%d,%d",*(a+1),*(ptr-1));
}
答案:2。5 *(a+1)就是 a[1],*(ptr-1)就是 a[4],执行结果是 2,5 &a+1 不是首地址+1,系统
会认为加一个 a 数组的偏移,是偏移了一个数组的大小(本例是 5 个 int) int *ptr=(int *)(&a+1);
则 ptr 实际是&(a[5]),也就是 a+5 原因如下: &a 是数组指针,其类型为 int (*)[5]; 而指针
加 1 要根据指针类型加上一定的值,不同类型的指针+1 之后增加的大小不同 a 是长度为 5
的 int 数组指针,所以要加 5*sizeof(int) 所以 ptr 实际是 a[5] 但是 prt 与(&a+1)类型是不一
样的(这点很重要) 所以 prt-1 只会减去 sizeof(int*) a,&a 的地址是一样的,但意思不一样,a是数组首地址,也就是 a[0]的地址,&a 是对象(数组)首地址,a+1 是数组下一元素的地
址,即 a[1],&a+1 是下一个对象的地址,即 a[5].
7。请问以下代码有什么问题:
int main() { char a; char *str=&a; strcpy(str,"hello"); printf(str); return 0; }
答案:没有为 str 分配内存空间,将会发生异常问题出在将一个字符串复制进一个字符变量
指针所指地址。虽然可以正确输出结果,但因为越界进行内在读写而导致程序崩溃。
8。char* s="AAA"; printf("%s",s); s[0]='B'; printf("%s",s); 有什么错?
答案:"AAA"是字符串常量。s 是指针,指向这个字符串常量,所以声明 s 的时候就有问题。
cosnt char* s="AAA"; 然后又因为是常量,所以对是 s[0]的赋值操作是不合法的。
9。写一个“标准”宏,这个宏输入两个参数并返回较小的一个。
答案:.#define Min(X, Y) ((X)>(Y)?(Y):(X)) //结尾没有‘;’
10。嵌入式系统中经常要用到无限循环,你怎么用 C 编写死循环。
答案:while(1){}或者 for(;;)
11。关键字 static 的作用是什么?
答案:定义静态变量
12。关键字 const 有什么含意?
答案:表示常量不可以修改的变量。
13。关键字 volatile 有什么含意?并举出三个不同的例子?
答案:提示编译器对象的值可能在编译器未监测到的情况下改变。
14。int (*s[10])(int) 表示的是什么啊?
答案:int (*s[10])(int) 函数指针数组,每个指针指向一个 int func(int param)的函数。
15。有以下表达式: int a=248; b=4;int const c=21;const int *d=&a; int *const e=&b;int const
*f const =&a; 请问下列表达式哪些会被编译器禁止?为什么?
答案:*c=32;d=&b;*d=43;e=34;e=&a;f=0x321f; *c 这是个什么东东,禁止 *d 说了是 const,
禁止 e = &a 说了是 const 禁止 const *f const =&a; 禁止
16 交换两个变量的值,不使用第三个变量。即 a=3,b=5,交换之后 a=5,b=3;
答案:有两种解法, 一种用算术算法, 一种用^(异或) a = a + b; b = a - b; a = a - b; or a = a^b;//
只能对 int,char.. b = a^b; a = a^b; or a ^= b ^= a;
17.c 和 c++中的 struct 有什么不同?
答案:c 和 c++中 struct 的主要区别是 c 中的 struct 不可以含有成员函数,而 c++中的 struct
可以。c++中 struct 和 class 的主要区别在于默认的存取权限不同,struct 默认为 public,而
class 默认为 private
18.#include <stdio.h>
#include <stdlib.h>
void getmemory(char *p)
{
p=(char *) malloc(100);
strcpy(p,"hello world");
}
int main( )
{
char *str=NULL;
getmemory(str);
printf("%s/n",str);
free(str); return 0;
}
答案:程序崩溃,getmemory 中的 malloc 不能返回动态内存, free()对 str 操作很危险
19.char szstr[10]; strcpy(szstr,"0123456789"); 产生什么结果?为什么?
答案: 长度不一样,会造成非法的 OS
20.列举几种进程的同步机制,并比较其优缺点。答案: 原子操作 信号量机制
锁 管程,会合,分布式系统
21.进程之间通信的途径
答案:共享存储系统消息传递系统管道:以文件系统为基础
22.进程死锁的原因
答案:资源竞争及进程推进顺序非法
23.死锁的 4 个必要条件
答案:互斥、请求保持、不可剥夺、环路
24.死锁的处理
答案:鸵鸟策略、预防策略、避免策略、检测与解除死锁
25. 操作系统中进程调度策略有哪几种?
答案:FCFS(先来先服务),优先级,时间片轮转,多级反馈
26.类的静态成员和非静态成员有何区别?
答案:类的静态成员每个类只有一个,非静态成员每个对象一个
27.纯虚函数如何定义?使用时应注意什么?
答案:virtual void f()=0; 是接口,子类必须要实现
28.数组和链表的区别
自旋答案:数组:数据顺序存储,固定大小连表:数据可以随机存储,大小可动态改变
29.ISO 的七层模型是什么?
tcp/udp 是属于哪一层?tcp/udp 有何优缺点?
答案:应用层表示层会话层运输层网络层物理链路层物理层 tcp /udp 属于运输层 TCP 服务
提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。与 TCP 不同,
UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单,
UDP 头包含很少的字节,比 TCP 负载消耗少。 tcp: 提供稳定的传输服务,有流量控制,
缺点是包头大,冗余性不好 udp: 不提供稳定的服务,包头小,开销小
30:(void *)ptr 和 (*(void**))ptr 的结果是否相同?其中 ptr 为同一个指针
答案:.(void *)ptr 和 (*(void**))ptr 值是相同的
31:int main() { int x=3; printf("%d",x); return 1;
} 问函数既然不会被其它函
数调用,为什么要返回 1?
答案:mian 中,c 标准认为 0 表示成功,非 0 表示错误。具体的值是某中具体出错信息
32,要对绝对地址 0x100000 赋值,我们可以用 (unsigned int*)0x100000 = 1234; 那么要是
想让程序跳转到绝对地址是 0x100000 去执行,应该怎么做?
答案:*((void (*)( ))0x100000 ) ( ); 首先要将 0x100000 强制转换成函数指针,即: (void
(*)())0x100000 然后再调用它: *((void (*)())0x100000)(); 用 typedef 可以看得更直观些:
typedef void(*)() voidFuncPtr; *((voidFuncPtr)0x100000)();
33,已知一个数组 table,用一个宏定义,求出数据的元素个数
答案:#define NTBL #define NTBL (sizeof(table)/sizeof(table[0]))
34。线程与进程的区别和联系? 线程是否具有相同的堆栈? dll 是否有独立的堆栈?
答案:进程是死的,只是一些资源的集合,真正的程序执行都是线程来完成的,程序启动的
时候操作系统就帮你创建了一个主线程。每个线程有自己的堆栈。 DLL 中有没有独立的堆
栈,这个问题不好回答,或者说这个问题本身是否有问题。因为 DLL 中的代码是被某些线
程所执行,只有线程拥有堆栈,如果 DLL 中的代码是 EXE 中的线程所调用,那么这个时候
是不是说这个 DLL 没有自己独立的堆栈?如果 DLL 中的代码是由 DLL 自己创建的线程所
执行,那么是不是说 DLL 有独立的堆栈?以上讲的是堆栈,如果对于堆来说,每个 DLL 有
自己的堆,所以如果是从 DLL 中动态分配的内存,最好是从 DLL 中删除,如果你从 DLL
中分配内存,然后在 EXE 中,或者另外一个 DLL 中删除,很有可能导致程序崩溃
35。unsigned short A = 10; printf("~A = %u\n", ~A); char c=128; printf("c=%d\n",c); 输出
多少?并分析过程
答案:第一题,~A =0xfffffff5,int 值 为-11,但输出的是 uint。所以输出 4294967285 第
二题,c=0x10,输出的是 int,最高位为 1,是负数,所以它的值就是 0x00 的补码就是 128,
所以输出-128。这两道题都是在考察二进制向 int 或 uint 转换时的最高位处理。
(二)
1. -1,2,7,28,,126 请问 28 和 126 中间那个数是什么?为什么?
答案:第一题的答案应该是 4^3-1=63 规律是 n^3-1(当 n 为偶数 0,2,4)
n^3+1(当 n 为奇数 1,3,5)
2.用两个栈实现一个队列的功能?要求给出算法和思路!
答案:设 2 个栈为 A,B, 一开始均为空. 入队: 将新元素 push 入栈 A; 出队: (1)判断栈 B 是
否为空; (2)如果不为空,则将栈 A 中所有元素依次 pop 出并 push 到栈 B; (3)将栈 B 的栈
顶元素 pop 出;这样实现的队列入队和出队的平摊复杂度都还是 O(1), 比上面的几种方法要
好。
3.在 c 语言库函数中将一个字符转换成整型的函数是 atol()吗,这个函数的原型是什么?
答案:函数名: atol 功 能: 把字符串转换成长整型数 用 法: long atol(const char *nptr); 程序
例: #include <stdlib.h> #include <stdio.h> int main(void) { long l; char *str = "98765432"; l =
atol(lstr); printf("string = %s integer = %ld\n", str, l); return(0); }
4。对于一个频繁使用的短小函数,在 C 语言中应用什么实现,在 C++中应用什么实现?
答案:c 用宏定义,c++用 inline
5。直接链接两个信令点的一组链路称作什么?
答案:PPP 点到点连接
7。软件测试都有那些种类?
答案:黑盒:针对系统功能的测试
白合:测试函数功能,各函数接口
8。确定模块的功能和模块的接口是在软件设计的那个队段完成的?
答案:概要设计阶段
9。enum string { x1, x2, x3=10, x4,
答案:取值在 0。1。10。11。12 中的一个
x5,
}x;
问 x;
10。unsigned char *p1; unsigned long *p2; p1=(unsigned char *)0x801000; p2=(unsigned
long *)0x810000; 请问 p1+5= ;
p2+5= ;
答案:801005; 810014。不要忘记了这个是 16 进制的数字,p2 要加 20 变为 16 进制就是
14
选择题:
1.Ethternet 链接到 Internet 用到以下那个协议?
A.HDLC;B.ARP;C.UDP;D.TCP;E.ID
2.属于网络层协议的是:
A.TCP;B.IP;C.ICMP;D.X.25
3.Windows 消息调度机制是:
A.指令队列;B.指令堆栈;C.消息队列;D.消息堆栈; 答案:b,a,c
四.找错题:
1.请问下面程序有什么错误?int a[60][250][1000],i,j,k;
for(k=0;k <=1000;k++)
for(j=0;j <250;j++)
for(i=0;i <60;i++)
a[i][j][k]=0;
答案:把循环语句内外换一下
2。以下是求一个数的平方的程序,请找出错误:
#define SQUARE(a) ((a)*(a))
int a=5;
int b;
b=SQUARE(a++);
答案:这个没有问题,s(a++),就是((a++)×(a++))唯一要注意的就是计算后 a
=7 了
3: typedef unsigned char BYTE
int examply_fun(BYTE gt_len; BYTE *gt_code)
{
BYTE *gt_buf;
gt_buf=(BYTE )MALLOC(Max_GT_Length);
......
if(gt_len>Max_GT_Length)
{
return GT_Length_ERROR;
}
.......
}
答案:要释放内存问答题:
1.IP Phone 的原理是什么?
答案:IPV6
2.TCP/IP 通信建立的过程怎样,端口有什么作用?
答案:三次握手,确定是哪个应用程序使用该协议
(三)
1、局部变量能否和全局变量重名?
答案:能,局部会屏蔽全局。要用全局变量,需要使用"::" 局部变量可以与全局变量同名,
在函数内引用这个变量时,会用到同名的局部变量,而不会用到全局变量。对于有些编译器
而言,在同一个函数内可以定义多个同名的局部变量,比如在两个循环体内都定义一个同名
的局部变量,而那个局部变量的作用域就在那个循环体内
2、如何引用一个已经定义过的全局变量?
答案:extern 可以用引用头文件的方式,也可以用 extern 关键字,如果用引用头文件方式来
引用某个在头文件中声明的全局变理,假定你将那个变写错了,那么在编译期间会报错,如
果你用 extern 方式引用时,假定你犯了同样的错误,那么在编译期间不会报错,而在连接期间报错
3、全局变量可不可以定义在可被多个.C 文件包含的头文件中?为什么?
答案:可以,在不同的 C 文件中以 static 形式来声明同名全局变量。可以在不同的 C 文件中
声明同名的全局变量,前提是其中只能有一个 C 文件中对此变量赋初值,此时连接不会出
错
4、语句 for( ;1 ;)有什么问题?它是什么意思?
答案:和 while(1)相同。
5、do......while 和 while......do 有什么区别?
答案:前一个循环一遍再判断,后一个判断以后再循环。
6、请写出下列代码的输出内容#include <stdio.h> main() { int a,b,c,d; a=10; b=a++; c=++a;
d=10*a++; printf("b,c,d:%d,%d,%d",b,c,d); return 0; }
答案:10,12,120 a=10; b=a++;//a=11 b=10 c=++a;//a=12 c=12 d=10*a++;//a=13 d=120
高级题
1、static 全局变量与普通的全局变量有什么区别?static 局部变量和普通局部变量有什么区
别?static 函数与普通函数有什么区别?
答案:全局变量(外部变量)的说明之前再冠以 static 就构成了静态的全局变量。全局变量本
身就是静态存储方式,静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不
同。这两者的区别虽在于非静态全局变量的作用域是整个源程序, 当一个源程序由多个源
文件组成时,非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作
用域, 即只在定义该变量的源文件内有效, 在同一源程序的其它源文件中不能使用它。由
于静态全局变量的作用域局限于一个源文件内,只能为该源文件内的函数公用,因此可以避
免在其它源文件中引起错误。从以上分析可以看出, 把局部变量改变为静态变量后是改变
了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域,
限制了它的使用范围。 static 函数与普通函数作用域不同。仅在本文件。只在当前源文件中
使用的函数应该说明为内部函数(static),内部函数应该在当前源文件中说明和定义。对于可
在当前源文件以外使用的函数,应该在一个头文件中说明,要使用这些函数的源文件要包含
这个头文件 static 全局变量与普通的全局变量有什么区别:static 全局变量只初使化一次,
防止在其他文件单元中被引用; static 局部变量和普通局部变量有什么区别:static 局部变量
只被初始化一次,下一次依据上一次结果值; static 函数与普通函数有什么区别:static 函
数在内存中只有一份,普通函数在每个被调用中维持一份拷贝
2、程序的局部变量存在于()中,全局变量存在于()中,动态申请数据存在于( )中。
答案:栈;静态区;堆
3、设有以下说明和定义: typedef union {long i; int k[5]; char c;} DATE; struct data { int cat;
DATE cow; double dog;} too; DATE max; 则语句 printf("%d",sizeof(too)+sizeof(max));的执行
结果是: ______ 答案: DATE 是一个 union, 变量公用空间. 里面最大的变量类型是 int[5], 占
用 20 个字节. 所以它的大小是 20 data 是一个 struct, 每个变量分开占用空间. 依次为 int4 +
DATE20 + double8 = 32. 所以结果是 20 + 32 = 52. 当然...在某些 16 位编辑器下, int 可能是 2字节,那么结果是 int2 + DATE10 + double8 = 20
4、队列和栈有什么区别?
答案:队列先进先出,栈后进先出÷
6、已知一个单向链表的头,请写出删除其某一个结点的算法,要求,先找到此结点,然后
删除。
答 案 : slnodetype *Delete(slnodetype *Head,int key){} 中 if(Head->number==key)
{ Head=Pointer->next; free(Pointer); break; } Back = Pointer;
Pointer=Pointer->next;
if(Pointer->number==key) {
Back->next=Pointer->next; free(Pointer); break; } void
delete(Node* p) { if(Head = Node) while(p) }
7、请找出下面代码中的所以错误说明:以下代码是把一个字符串倒序,
如“abcd”倒序后变为“dcba”
1、#include"string.h"
2、main()
3、{
4、 char*src="hello,world";
5、 char* dest=NULL;
6、 int len=strlen(src);
7、 dest=(char*)malloc(len);
8、 char* d=dest;
9、 char* s=src[len];
10、 while(len--!=0)
11、 d++=s--;
12、 printf("%s",dest);
13、 return 0;
14、}
答案:还要加上#include <stdio.h> int main(){ char* src = "hello,world"; int len = strlen(src);
char* dest = (char*)malloc((len+1)*sizeof(char)); //要为\0 分配一个空间 char* d = dest; char*
s = &src[len-1]; //指向最后一个字符 while( len-- != 0 ) *d++=*s--; *d = 0; //尾部要加\0
printf("%s\n",dest); free(dest);// 使用完,应当释放空间,以免造成内存汇泄露 return 0; }
华为笔试题(3) 2006-09-29 19:41
一、判断题(对的写 T,错的写 F 并说明原因,每小题 4 分,共 20 分)
1、有数组定义 int a[2][2]={{1},{2,3}};则 a[0][1]的值为 0。( 正确 )
2、 int (*ptr) (),则 ptr 是一维数组的名字。
(错误 int (*ptr) ();定义一个指向函数的指针变量 )
3、指针在任何情况下都可进行>, <,>=, <=,==运算。( 错误 )
4、switch(c) 语句中 c 可以是 int ,long,char ,float ,unsigned int 类型。( 错,不能用实形 )
二、填空题(共 30 分)
1、在 windows 下,写出运行结果,每空 2 分,共 10 分。 char str[ ]= "Hello"; char *p=str;
int n=10; sizeof(str)=(
) sizeof(p)=(
) sizeof(n)=(
) void func(char str[100]){ }sizeof(str)=(
剖析”
) 答案:6,4,4,4, 具体解释请参看我的空间里的“C/C++程序员应聘试题
2、void getmemory(char **p, int num) { *p=(char *) malloc(num);} void test(void) { char
*str=NULL; getmemory(&str,100); strcpy(str,"hello"); printf(str); } 运行 test 函数有什
么结果?(
)10 分 答案:输出 hello,但是发生内存泄漏。
3、设 int arr[]={6,7,8,9,10};
int *ptr=arr;
(
) 10 分答案:8,
*(ptr++)+=123; printf("%d,%d",*ptr,*(++ptr));
8。这道题目的意义不大,因为在不同的编译器里 printf 的参数的方向是不一样的,在 vc6.0
下是从有到左,这里先*(++ptr) 后*pt,于是结果为 8,8
三、编程题(第一小题 20,第二小题 30 分)
1、 不使用库函数,编写函数 int strcmp(char *source, char *dest) 相等返回 0,不等返回-1;
答
案
:
一
、
int
strcmp(char
*source,
char
*dest)
{
assert((source!=NULL)&&(dest!=NULL));
int
i,j;
for(i=0;
source[i]==dest[i];
i++) { if(source[i]=='\0' && dest[i]=='\0') return 0; else return -1; } } 答案:二、 int
strcmp(char *source, char *dest) {
while ( (*source != '\0') && (*source ==
*dest)) { source++; dest++; } return ( (*source) - (*dest) ) ? -1 : 0; }
2、 写一函数 int fun(char *p)判断一字符串是否为回文,是返回 1,不是返回 0,出错返回
-1 答案:一、 int fun(char *p) { if(p==NULL) return -1; else { int length = 0; int i =
0;
int
judge
=
1;
length
=
strlen(p);
for(i=0;
i
<length/2;
i++) {
if(p[i]!=p[length-1-i])
judge = 0;
break; } if(judge == 0)
return
0; else return 1; } } 答案:二、 int fun(char *p){ int len = strlen(p) - 1; char *q = p + len; if
(!p) return -1; while (p < q) { if ((*p++) != (*q--)) return 0; } return 1;}
华为笔试网络题(3) 2006-09-30 12:48
1.在 OSI 7 层模型中,网络层的功能有( )
A.确保数据的传送正确无误 B.确定数据包如何转发与路由 C.在信道上传送比特流 D.纠
错与流控
2.FDDI 使用的是___局域网技术。( )
A.以太网; B.快速以太网; C.令牌环; D.令牌总线。
3.下面那种 LAN 是应用 CSMA/CD 协议的()
A.令牌环 B.FDDI C.ETHERNET D.NOVELL
4.TCP 和 UDP 协议的相似之处是 ( )
A.面向连接的协议 B.面向非连接的协议 C.传输层协议 D.以上均不对
5.应用程序 PING 发出的是___报文.( )
A.TCP 请求报文。 B.TCP 应答报文。 C.ICMP 请求报文。 D.ICMP 应答报文。
6.以下说法错误的是(多) ( )
A.中继器是工作在物理层的设备 B.集线器和以太网交换机工作在数据连路层 C.路由器
是工作在网络层的设备 D.桥能隔离网络层广播
7.当桥接收的分组的目的 MAC 地址在桥的映射表中没有对应的表项时,采取的策略是( )
A.丢掉该分组 B.将该分组分片 C.向其他端口广播该分组 D.以上答案均不对8.LAN Switch 在网络层次模型中的地位( )
A.物理层 B.链路层 C.网络层 D.以上都不是
9.小于___的 TCP/UDP 端口号已保留与现有服务一一对应,此数字以上的端口号可自由分配。
( ) A.199
B.100 C.1024
D.2048
10.当一台主机从一个网络移到另一个网络时,以下说法正确的是 ( )
A.必须改变它的 IP 地址和 MAC 地址 B.必须改变它的 IP 地址,但不需改动 MAC 地址
C.必须改变它的 MAC 地址,但不需改动 IP 地址 D.MAC 地址.IP 地址都不需改动
答案:1.B; 2.C; 3.C; 4.C; 5.C; 6.BD; 7.C; 8.B; 9.C; 10.B.
华为笔试题(4) 2006-09-30 13:00
1. 找错 void test1()
{
char string[10]; char* str1="0123456789";
strcpy(string, str1);
}
答:表面上并且编译都不会错误。但如果 string 数组原意表示的是字符串的话,那这个赋值
就没有达到意图。最好定义为 char string[11],这样最后一个元素可以存储字符串结尾符'\0';
void test2() {
char string[10], str1[10]; for(int I=0; I <10;I++) {
str1[I]
='a'; } strcpy(string, str1); } 答: strcpy 使用错误, strcpy 只有遇到字符串末尾的'\0'才会结束,
而 str1 并没有结尾标志,导致 strcpy 函数越界访问,不妨让 str1[9]='\0',这样就正常了。 void
test3(char* str1) { char string[10]; if(strlen(str1) <=10) { strcpy(string, str1); } } 答:这又
会出现第一道改错题的错误了。strlen(str1)算出来的值是不包含结尾符'\0'的,如果 str1 刚好
为 10 个字符+1 结尾符, string 就得不到结尾符了。
可将 strlen(str1) <=10 改为 strlen(str1) <10。
2. 找错
#define MAX_SRM 256
DSN get_SRM_no()
{
static int SRM_no;
int I;
for(I=0;I<MAX_SRM;I++,SRM_no++)
{
SRM_no %= MAX_SRM;
if(MY_SRM.state==IDLE)
{
break;
}
}
if(I>=MAX_SRM)
return (NULL_SRM);
else
return SRM_no;
}
答:我不知道这段代码的具体功能,但明显有两个错误 1, SRM_no 没有赋初值 2,由于 static的声明,使该函数成为不可重入(即不可预测结果)函数,因为 SRM_no 变量放在程序的
全局存储区中,每次调用的时候还可以保持原来的赋值。这里应该去掉 static 声明。
3. 写出程序运行结果
int sum(int a)
{
auto int c=0;
static int b=3;
c+=1;
b+=2;
return(a+b+c);
}
void main()
{
int I;
int a=2;
for(I=0;I <5;I++)
{
printf("%d,", sum(a));
}
}
答:8,10,12,14,16 该题比较简单。只要注意 b 声明为 static 静态全局变量,其值在下次调用
时是可以保持住原来的赋值的就可以。
4. int func(int a)
{
int b;
switch(a)
{
case 1: b=30;
case 2: b=20;
case 3: b=16;
default: b=0;
}
return b;
}
则 func(1)=?
答:func(1)=0,因为没有 break 语句,switch 中会一直计算到 b=0。这是提醒我们不要忘了
break。呵呵。
5:
int a[3];
a[0]=0;
a[1]=1;
a[2]=2;int *p, *q;
p=a;
q=&a[2];
则 a[q-p]=?
答:a[q-p]=a[2]=2;这题是要告诉我们指针的运算特点
6. 定义 int **a[3][4], 则变量占有的内存空间为:_____
答:此处定义的是指向指针的指针数组,对于 32 位系统,指针占内存空间 4 字节,因此总
空间为 3×4×4=48。
7. 编写一个函数,要求输入年月日时分秒,输出该年月日时分秒的下一秒。如输入 2004 年
12 月 31 日 23 时 59 分 59 秒,则输出 2005 年 1 月 1 日 0 时 0 分 0 秒。
答: /*输入年月日时分秒,输出年月日时分秒的下一秒,输出仍然在原内存空间*/
void NextMinute(int *nYear,int *nMonth,int *nDate,int *nHour,int *nMinute,int *nSecond)
{
int nDays; (*nSecond)++; // 秒加 1 if(*nSecond>=60) // 秒满 60,做出特殊处理,下面时,
日,月等类同
{
*nSecond=0;
(*nMinute)++;
if(*nMinute>=60)
{
*nMinute=0;
(*nHour)++;
if(*nHour>=24)
{
*nHour=0;
(*nDate)++;
switch(*nMonth)
{
case 1:
case 3:
case 5:
case 7:
case 8:
case 10:
case 12:
nDays=31;
break;
case 2:// 判断闰年
if(*nYear%400==0 ¦ ¦*nYear%100!=0&&*nYear%4==0)
{
nDays=29;
}
else{
nDays=28;
}
break;
default:
nDays=30;
break;
}
if(*nDate>nDays)
{
*nDate=1;
(*nMonth)++;
if(*nMonth>12)
{
*nMonth=1;
(*nYear)++;
}
}
}
}
}
} /*示例可运行代码*/
void main()
{
int nYear=2004,nMonth=12,nDate=31,nHour=59,nMinute=59,nSecond=59;
NextMinute(&nYear,&nMonth,&nDate,&nHour,&nMinute,&nSecond);
printf("The result:%d-%d-%d %d:%d:%d",nYear,nMonth,nDate,nHour,nMinute,nSecond);
}
华为硬件笔试题 2006-09-30 13:01
一 选择 13 个题目,没有全部抄下来,涉及的课程有电路,模拟电路,数字电路,信号与系统,微
机原理,网络,数字信号处理 有关于 1.微分电路 2.CISC,RISC 3.数据链路层
二 填空 10 个题目,没有全部抄下来,涉及的课程有电路,模拟电路,数字电路,信号与系统,微
机原理,网络,数字信号处理 有关于
1.TIC6000 DSP 2.二极管 3.RISC 4.IIR
三 简答
1.x(t)的傅立叶变换为 X(jw)=$(w)+$(w-PI)+$(w-5) h(t)=u(t)-u(t-2) 问: (1),x(t)是周期的吗?
(2),x(t)*h(t)是周期的吗? (3),两个非周期的信号卷积后可周期吗? 2.简述分组交换的特点和不
足四 分析设计 1.波形变换题目 从正弦波->方波->锯齿波->方波,设计电路 2.74161 计数器
组成计数电路,分析几进制的 3.用 D 触发器构成 2 分频电路 4.判断 MCS-51 单片机的指令正
确还是错误,并指出错误原因 (1) MUL R0,R1 (2) MOV A,@R7 (3) MOV A,#3000H (4) MOVC
@A+DPTR,A (5) LJMP #1000H () 5.MCS-51 单片机中,采用 12Mhz 时钟,定时器 T0 采用模式
1(16 位 计 数 器 ), 请 问 在 下 面 程 序 中 ,p1.0 的 输 出 频 率 MOV TMOD,#01H SETB TR0
LOOP:MOV TH0,#0B1H MOV TL0,#0E0H LOOP1:JNB TF0,LOOP1 CLR TR0 CPL P1.0
SJMP LOOP华为硬件面试题 2006-09-30 13:02
全都是几本模电数电信号单片机题目
1.用与非门等设计全加法器
2.给出两个门电路让你分析异同
3.名词:sram,ssram,sdram
4.信号与系统:在时域与频域关系
5.信号与系统:和 4 题差不多
6.晶体振荡器,好像是给出振荡频率让你求周期(应该是单片机的,12 分之一周期..
..)
7.串行通信与同步通信异同,特点,比较
8.RS232c 高电平脉冲对应的 TTL 逻辑是?(负逻辑?)
9.延时问题,判错
10.史密斯特电路,求回差电压
11.VCO 是什么,什么参数(压控振荡器?)
12. 用 D 触发器做个二分颦的电路.又问什么是状态图
13. 什么耐奎斯特定律,怎么由模拟信号转为数字信号
14. 用 D 触发器做个 4 进制的计数
15.那种排序方法最快?
一、 研发(软件)
用 C 语言写一个递归算法求 N!;
给一个 C 的函数,关于字符串和数组,找出错误;
防火墙是怎么实现的?
你对哪方面编程熟悉?
硬件: 1、继电器控制电路。 2、SDRAM 是怎么工作的 3、写出逻辑表达式说明 A2A1A0
大于 B2B1B0。 4、常用触发器有几种 5、示波器有几种触发方式,举出三种
华为 3COM 数据通信工程师试题 2006-09-29 18:53
1 H.323 协商答案:12 个包协商,先 H225 然后 H245,需要注意的是面试官可能会问到跟
SIP 的比较
2 ipsec 为什么是三层的。L2tp 为什么是二层的? 答案:IPSec (Internet 协议安全)是一个工
业标准网络安全协议,为 IP 网络通信提供透明的安全服务,保护 TCP/IP 通信免遭窃听和
篡改,可以有效抵御网络攻击,同时保持易用性。IPSec 有两个基本目标:1)保护 IP 数据
包安全;2)为抵御网络攻击提供防护措施。 第三层保护的优点
通常 IPSec 提供的保
护需要对系统做一定的修改。但是 IPSec 在 IP 传输层即第三层的"策略执行"(strategic
implementation)几乎不需要什么额外开销就可以实现为绝大多数应用系统、服务和上层协
议提供较高级别的保护;为现有的应用系统和操作系统配置 IPSec 几乎无须做任何修改,安
全策略可以在 Active Directory 里集中定义也可以在某台主机上进行本地化管理。
IPSec
策略在 ISO 参考模型第三层即网络层上实施的安全保护,其范围几乎涵盖了 TCP/IP 协议簇
中所有 IP 协议和上层协议,如 TCP、UDP、ICMP,Raw(第 255 号协议)、甚至包括在网
络层发送数据的客户自定义协议。在第三层上提供数据安全保护的主要优点就在于:所有使
用 IP 协议进行数据传输的应用系统和服务都可以使用 IPSec,而不必对这些应用系统和服务
本身做任何修改。
运作于第三层以上的其他一些安全机制,如安全套接层 SSL,仅对知
道如何使用 SSL 的应用系统(如 Web 浏览器)提供保护,这极大地限制了 SSL 的应用范围;
而运作于第三层以下的安全机制,如链路层加密,通常只保护了特定链路间的数据传输,而
无法做到在数据路径所经过的所有链路间提供安全保护,这使得链接层加密无法适用于
Internet 或路由 Intranet 方案中的端对端数据保护。 L2TP(第二层隧道协议)通过使用虚
拟专用网 (VPN) 连接和第二层隧道协议 (L2TP),可以通过 Internet 或其他公共网络访问
专用网。L2TP 是一个工业标准 Internet 隧道协议,它和点对点隧道协议 (PPTP) 的功能大
致相同。利用 L2TP 来构建企业的 VPN,一样需要运营商支持,因为 LAC 一般是在传统电话交换网络中部署的,并且一个公司的分支机构以及移动办公的员工在地域上分布很广,所
以需要各地的运营商都具备 LAC 才能够实现企业大范围构建 VPN 网络。当然企业也可以构
建自己的基于 L2TP 的 VPN 网络在 L2TP VPN 中,用户端的感觉就像是利用 PPP 协议直接
接到了企业总部的 PPP 端接设备上一样,其地址分配可以由企业通过 DHCP 来分配,认证
方式可以沿用 PPP 一直沿用的各种认证方式,并且 L2TP 是 IETF 定义的,其 MIB 库也将定
义出来从而可以实现全局的网络管理。
3 ospf 中包的 ttl 值是多少? 答案:1,因为 224.0.0.5/224.0.0.6 是本地链路组播
4 OSPF 为什么要划分区域?答案:RD 用于 BGP 区分 VPN 路由,RT 用于在各 VRF 中导入
或导出路由
5 MPLS VPN 的标签一共有几层。内网的标签放在哪里。答案:如果没有流量工程则是 2 层,
内网标签在隧道标签之后
6 MPLS 中 RD 和 RT 的作用分别是什么?答案:减少 CPU 负载,区域间使用距离矢量算法,
因此其它区域的泛洪不会影响区域的 SPF 运算,这里注意面试官可能会问 OSPF 多区域如
何防止环路。(注意答本质而不是现象,免得面试官追问)
7 RR 防止环路的机制。答案:RR 中通过 ORIGIN ID 和 CLUSTER ID 防止环路,若 RR 收
到带有自己 CLUSTER ID 的路由则丢弃
8 BGP 控制 out-bound 用 local-pre,控制进来的用 med. 答案:正确
9 ospf 是工作在哪个协议上的?答案:IP,OSPF 协议号 89
10 ospf 的 LSA 类型。答案:1,2,3,4,5,6,7,没有什么好说的,注意考官问到第 6
类 LSA,组播再准备多点
11 简述 OSPF 的基本工作机制。答案:这个没什么可以说了,把知道的都说出来就行了
12 ppp 的 lcp 和 ncp 协商过程。答案:LCP 过程协商二层链路相关参数,MTU/PPP 压缩/认
证协议类型等~~~NCP 协商第三层协议,IP 地址,IP 压缩等等,这里记住最好不要说 CDP
13 笔试中还有一道 PSTN 的信令控制有哪三种?答案:这个我只知道随路信令和共路信令,
信工同学提供的答案是:监视\号码\音信号\,知道正确答案的朋友麻烦纠正一下
14sloari 8.0 查看进程的命令是什么?linux 7.3 查看 IP 的命令是什么?答案:不知道华为为
什么问这个,第一个是 PS 吧?第二个是 IFCONFIG /A
15 IP 是 5.32.0.0,掩码 255.224.0.0。请问最大的有效地址是多少。答案:最大主机地址 5。 64。
255。254
17 lx/lh 的有效距离是多少?答案:???
18 IP 包头几个字节?加上数据部分几个字节答案:应该是问 IPV4,一般 20 字节,加上源
路由选择等后最大 60 字节,加上数据部分还是根据链路 MTU 决定
20 CQ 能不能有一种流量 dominate 第二种流量? 答案:CQ 不能有一种流量 DOMINATE 其
它任何流量 21 FTP 下载一个文件完成。有几个 TCP 连接答案:4 个


（一）
1什么是预编译，何时需要预编译： 
答案： 
１、总是使用不经常改动的大型代码体。 
２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。 

2 char * const p      char const * p      const char *p 上述三个有什么区别？ 
答案： 
char * const p; //常量指针，p的值不可以修改 
char const * p；//指向常量的指针，指向的常量值不可以改 const char *p； //和char const *p 

3
char str1[] = "abc"; 
char str2[] = "abc"; 
const char str3[] = "abc"; 
const char str4[] = "abc"; 
const char *str5 = "abc"; 
const char *str6 = "abc"; 
char *str7 = "abc"; 
char *str8 = "abc"; 
cout < < ( str1 == str2 ) < < endl; 
cout < < ( str3 == str4 ) < < endl; 
cout < < ( str5 == str6 ) < < endl; 
out < < ( str7 == str8 ) < < endl; 
结果是：0 0 1 1 
str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。 

4以下代码中的两个sizeof用法有问题吗？ 
[C易] 
void UpperCase( char str[] )           // 将 str 中的小写字母转换成大写字母 
{    for( size_t i=0; i <sizeof(str)/sizeof(str[0]); ++i )        
       if( 'a' <=str[i] && str[i] <='z' )            
            str[i] -= ('a'-'A' ); 
} 
char str[] = "aBcDe";  
cout < < "str字符长度为: " < < sizeof(str)/sizeof(str[0]) < < endl; 
UpperCase( str ); 
cout < < str < < endl; 
答案：函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，因为还有'\0'，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。 

5一个32位的机器,该机器的指针是多少位
答案： 
指针是多少位只要看地址总线的位数就行了。80386以后的机子都是32的数据总线。所以指针的位数就是4个字节了。 

6 main()
{  
int a[5]={1,2,3,4,5};    
int *ptr=(int *)(&a+1);    
printf("%d,%d",*(a+1),*(ptr-1));
} 
答案：2   5
分析：*(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5 。&a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int） int *ptr=(int *)(&a+1); 则ptr实际是&(a[5]),也就是a+5 原因如下： &a是数组指针，其类型为 int (*)[5]; 而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同 a是长度为5的int数组指针，所以要加 5*sizeof(int) 所以ptr实际是a[5] 但是prt与(&a+1)类型是不一样的(这点很重要) 所以prt-1只会减去sizeof(int*)。 a,&a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5]. 

7请问以下代码有什么问题： 
int  main() 
{     char a; 
      char *str=&a; 
      strcpy(str,"hello"); 
      printf(str);
      return 0; 
} 
答案：没有为str分配内存空间，将会发生异常，问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内存读写而导致程序崩溃。 

8
Char  * s="AAA"; 
printf("%s",s); 
s[0]='B'; 
printf("%s",s); 有什么错？
答案："AAA"是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。 cosnt char* s="AAA"; 然后又因为是常量，所以对是s[0]的赋值操作是不合法的。 

9写一个“标准”宏，这个宏输入两个参数并返回较小的一个。
答案：.#define Min(X, Y) ((X)>(Y)?(Y):(X))  //结尾没有‘；’ 

10 嵌入式系统中经常要用到无限循环，你怎么用C编写死循环？
答案：while(1){}或者for(;;) 

11 关键字static的作用是什么？
答案：定义静态变量 或 静态函数

12 关键字const有什么含意？
答案：表示常量不可以修改的变量。 

13 关键字volatile有什么含意？并举出三个不同的例子？
答案：提示编译器对象的值可能在编译器未监测到的情况下改变。
      （1）并行设备的硬件寄存器（如状态寄存器）
      （2）中断函数中会访问到的非自动变量
      （3）多线程应用中被几个任务共享的变量

14  int (*s[10])(int) 表示的是什么啊？
答案：int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。 

15 有以下表达式：
  int a=248，b=4;
  int const c=21;
  const int *d=&a; 
  int *const e=&b;
  int const *f const =&a; 请问下列表达式哪些会被编译器禁止？为什么？
答案：*c=32;  d=&b;  *d=43;  e=34;  e=&a;  f=0x321f;  *c 这是个什么东东，禁止 *d 说了是const， 禁止 e = &a 说了是const 禁止 const *f const =&a; 禁止 

16 交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3; 
答案：有两种解法, 一种用算术算法, 一种用^(异或) 。a = a + b; b = a - b; a = a - b; 
或者  a = a^b;// 只能对int,char.. b = a^b; a = a^b; or a ^= b ^= a; 

17 c和c++中的struct有什么不同？
答案：c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private 

18.
#include <stdio.h>  
#include <stdlib.h>  

void getmemory(char *p) 
{    
p=(char *) malloc(100);    
strcpy(p,"hello world");  
}  
int main( ) 
{    
char *str=NULL;    
getmemory(str);    
printf("%s/n",str);    
free(str);    
return 0;  
}
 答案：程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险 

19 
char szstr[10];  
strcpy(szstr,"0123456789");  
产生什么结果？为什么？
答案：  长度不一样，会造成非法的OS 

20 列举几种进程的同步机制，并比较其优缺点
答案：  原子操作 信号量机制    自旋锁    管程，会合，分布式系统 

21.进程之间通信的途径
答案：共享存储系统消息传递系统管道：以文件系统为基础 

22.进程死锁的原因
答案：资源竞争及进程推进顺序非法 

23.死锁的4个必要条件
答案：互斥、请求保持、不可剥夺、环路 

24.死锁的处理
答案：鸵鸟策略、预防策略、避免策略、检测与解除死锁 

25.  操作系统中进程调度策略有哪几种？
答案：FCFS(先来先服务)，优先级，时间片轮转，多级反馈 

26.类的静态成员和非静态成员有何区别？
答案：类的静态成员每个类只有一个，非静态成员每个对象一个 

27.纯虚函数如何定义？使用时应注意什么？
答案：virtual void f()=0; 是接口，子类必须要实现 

28.数组和链表的区别
答案：数组：数据顺序存储，固定大小连表：数据可以随机存储，大小可动态改变 

29.ISO的七层模型是什么？
tcp/udp是属于哪一层？tcp/udp有何优缺点？
答案：应用层 表示层 会话层 传输层 网络层 链路层 物理层 ；
 tcp /udp属于传输层 ；
 TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。 tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好 udp: 不提供稳定的服务，包头小，开销小  

30：(void *)ptr 和 (*(void**))ptr的结果是否相同？其中ptr为同一个指针
答案：.(void *)ptr 和 (*(void**))ptr值是相同的 

31：
int main()    
{
int x=3; 
printf("%d",x); 
 return 1;      
} 
问函数既然不会被其它函数调用，为什么要返回1？
答案：mian中，c标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息 

32 要对绝对地址0x100000赋值，我们可以用 (unsigned int*)0x100000 = 1234; 那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？
答案：*((void (*)( ))0x100000 ) ( ); 首先要将0x100000强制转换成函数指针,即: (void (*)())0x100000 然后再调用它: *((void (*)())0x100000)(); 用typedef可以看得更直观些: typedef  void(*)()  voidFuncPtr; 
*((voidFuncPtr)0x100000)(); 

33，已知一个数组table，用一个宏定义，求出数据的元素个数
答案:  #define NTBL(table)  (sizeof(table)/sizeof(table[0])) 

34。线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈? 
答案：进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。每个线程有自己的堆栈。 DLL中有没有独立的堆栈，这个问题不好回答，或者说这个问题本身是否有问题。因为DLL中的代码是被某些线程所执行，只有线程拥有堆栈，如果DLL中的代码是EXE中的线程所调用，那么这个时候是不是说这个DLL没有自己独立的堆栈？如果DLL中的代码是由DLL自己创建的线程所执行，那么是不是说DLL有独立的堆栈？以上讲的是堆栈，如果对于堆来说，每个DLL有自己的堆，所以如果是从DLL中动态分配的内存，最好是从DLL中删除，如果你从DLL中分配内存，然后在EXE中，或者另外一个DLL中删除，很有可能导致程序崩溃 

35。
unsigned short A = 10; 
printf("~A = %u\n", ~A); 
char c=128; 
printf("c=%d\n",c); 
输出多少？并分析过程
答案：第一题，～A ＝0xfffffff5,int值 为－11，但输出的是uint。所以输出4294967285 第二题，c＝0x10,输出的是int，最高位为1，是负数，所以它的值就是0x00的补码就是128，所以输出－128。这两道题都是在考察二进制向int或uint转换时的最高位处理。  

（二） 
1. -1,2,7,28,,126请问28和126中间那个数是什么？为什么？
答案：第一题的答案应该是4^3-1=63 规律是n^3-1(当n为偶数0，2，4)      n^3+1(当n为奇数1，3，5) 

2.用两个栈实现一个队列的功能？要求给出算法和思路！
答案：设2个栈为A,B, 一开始均为空. 入队: 将新元素push入栈A; 出队: (1)判断栈B是否为空； (2)如果不为空，则将栈A中所有元素依次pop出并push到栈B； (3)将栈B的栈顶元素pop出；这样实现的队列入队和出队的平摊复杂度都还是O(1), 比上面的几种方法要好。 

3.在c语言库函数中将一个字符转换成整型的函数是atol()吗，这个函数的原型是什么？
答案：函数名: atol 功 能: 把字符串转换成长整型数 用 法: long atol(const char *nptr); 程序例: 
#include <stdlib.h> 
#include <stdio.h> 
int main(void) 
{   long l; 
char *str = "98765432"; 
l = atol(lstr); 
printf("string = %s integer = %ld\n", str, l); 
return(0); 
} 

4。对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现? 
答案：c用宏定义，c++用inline 

5。直接链接两个信令点的一组链路称作什么? 
答案：PPP点到点连接

7。软件测试都有那些种类? 
答案：黑盒：针对系统功能的测试    白合：测试函数功能，各函数接口 

8。确定模块的功能和模块的接口是在软件设计的那个队段完成的? 
答案：概要设计阶段 

9。enum string    
{    
x1,    x2,    x3=10,    x4,    x5,    
}x;    问x；
答案：取值在0。1。10。11。12中的一个 

10。
unsigned char *p1;    
unsigned long *p2;    
p1=(unsigned char *)0x801000;    
p2=(unsigned long *)0x810000;    
请问p1+5=  ;        
     p2+5=  ; 
答案：801005； 810014。不要忘记了这个是16进制的数字，p2要加20变为16进制就是
14 

选择题:  
1.Ethternet链接到Internet用到以下那个协议? 
 A. HDLC;   B. ARP;  C. UDP;  D. TCP;  E. ID  
 答案 D
2.属于网络层协议的是:  
A.TCP;  B.IP;  C.ICMP;  D.X.25  
答案 B
3.Windows消息调度机制是:  
A.指令队列;B.指令堆栈;C.消息队列;D.消息堆栈; 
答案：C

找错题:  
1.请问下面程序有什么错误?    
int a[60][250][1000],i,j,k;    
for(k=0;k <=1000;k++)    
for(j=0;j <250;j++)      
for(i=0;i <60;i++)      
a[i][j][k]=0; 
答案：把循环语句内外换一下 

2。以下是求一个数的平方的程序,请找出错误:    
#define SQUARE(a)  ((a)*(a))   
int a=5;    
int b;    
b=SQUARE(a++); 
答案：这个没有问题，s（a＋＋），就是（（a＋＋）×（a＋＋））唯一要注意的就是计算后a＝7了 

3: typedef unsigned char BYTE
int examply_fun(BYTE gt_len; BYTE *gt_code)
{
BYTE  *gt_buf;     
gt_buf=(BYTE )MALLOC(Max_GT_Length);  
    ......      
if(gt_len>Max_GT_Length)        
{        
return GT_Length_ERROR;     
}       
 .......    
} 
答案：要释放内存问答题: 

1.IP Phone的原理是什么? 
答案：IPV6 

2.TCP/IP通信建立的过程怎样，端口有什么作用？
答案：三次握手，确定是哪个应用程序使用该协议 


（三） 
1、局部变量能否和全局变量重名？
答案：能，局部会屏蔽全局。要用全局变量，需要使用"::" 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内 

2、如何引用一个已经定义过的全局变量？
答案：extern 可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错 

3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？
答案：可以，在不同的C文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错 

4、语句for( ；1 ；)有什么问题？它是什么意思？
答案：和while(1)相同。 

5、do……while和while……do有什么区别？
答案：前一个循环一遍再判断，后一个判断以后再循环。 

6、 请写出下列代码的输出内容
＃include <stdio.h> 
main() 
{ 
int a,b,c,d; 
a=10; 
b=a++;  
c=++a; 
d=10*a++; 
printf("b，c，d：%d，%d，%d"，b，c，d）; 
return 0; 
} 
答案：10，12，120  a=10;  b=a++;//a=11 b=10  c=++a;//a=12 c=12  d=10*a++;//a=13 d=120 


高级题 
1、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
答案：全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。 static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件 static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用; static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值； static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 

2、程序的局部变量存在于（）中，全局变量存在于（）中，动态申请数据存在于（ ）中。
答案：栈；静态区；堆 

3、 设有以下说明和定义： 
typedef union 
{
long i; 
int k[5]; 
char c;
} DATE; 
struct data 
{
     int cat;
     DATE cow; 
     double dog;
} too; 
DATE max; 
则语句 printf("%d",sizeof(too)+sizeof(max));的执行结果是：_20_
答案：DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20 data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32. 所以结果是 20 + 32 = 52. 当然...在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 = 20 


4、队列和栈有什么区别？
答案：队列先进先出，栈后进先出

6、已知一个单向链表的头，请写出删除其某一个结点的算法，要求，先找到此结点，然后删除。
答案：
slnodetype *Delete(slnodetype *Head,int key)
{
if(Head->number==key) 
{ 
    Head=Pointer->next; 
    free(Pointer); 
    break; 
} 
Back = Pointer;        
Pointer=Pointer->next; 
if(Pointer->number==key) 
{            
    Back->next=Pointer->next; 
    free(Pointer); 
    break; 
} 
void delete(Node* p) 
{    
    if(Head = Node)    
    while(p) 
}
｝ 

7、请找出下面代码中的所以错误说明：以下代码是把一个字符串倒序，
如“abcd”倒序后变为“dcba” 
＃include"string.h"
main() 
{ 
    char*src="hello,world"; 
    char* dest=NULL; 
int len=strlen(src); 
dest=(char*)malloc(len); 
    char* d=dest; 
char* s=src[len];
 
while(len--!=0) 
d++=s--; 

printf("%s",dest); 
        
    return 0; 
} 
答案：
＃include <stdio.h> 
int main()
{
 	char* src = "hello,world"; 
int len = strlen(src); 
char* dest = (char*)malloc((len+1)*sizeof(char));  //要为\0分配一个空间 
char* d = dest; 
char* s = &src[len-1];      //指向最后一个字符 

while( len-- != 0 ) 
*d++=*s--; 
*d = 0;               //尾部要加\0
     printf("%s\n",dest); 
free(dest);            // 使用完，应当释放空间，以免造成内存汇泄露 

return 0; 
}   

 华为笔试题（3） 2006-09-29 19:41 
一、判断题（对的写T，错的写F并说明原因，每小题4分，共20分） 
1、有数组定义int a[2][2]={{1},{2,3}};则a[0][1]的值为0。（正确 ） 
2、int (*ptr) (),则ptr是一维数组的名字。（错误  int (*ptr) ();定义一个指向函数的指针变量） 
3、指针在任何情况下都可进行>, <,>=, <=,==运算。（错误） 
4、switch(c) 语句中c可以是int ,long,char ,float ,unsigned int 类型。(错，不能用实形） 

二、填空题（共30分） 
1、在windows下，写出运行结果，每空2分，共10分。 
char str[ ]= ＂Hello＂; 
char *p=str; 
int n=10; 
sizeof(str)=(      )
 sizeof(p)=(      ) 
sizeof(n)=(      ) 
void func(char str[100])
{    } 
sizeof(str)=(    )  
答案：6，4，4，4, 具体解释请参看我的空间里的“C/C++程序员应聘试题剖析” 

2、
void getmemory(char **p,  int num) 
{
 	*p=(char*)malloc(num);
} 
void test(void) 
{  
char *str=NULL;    
getmemory(&str,100);    
strcpy(str,＂hello＂);    
printf(str); 
} 
运行test函数有什么结果？（                                ）10分  答案：输出hello，但是发生内存泄漏。 

3、 设
int arr[]={6,7,8,9,10};      
int *ptr=arr;    
*(ptr++)+=123;     //先算*ptr=*ptr+123; 再 ptr++;所以arr[0]= 129;
printf(＂%d,%d＂,*ptr,*(++ptr));    //按从右到左的顺序
(    )    10分
答案：8， 

8。这道题目的意义不大，因为在不同的编译器里printf的参数的方向是不一样的，在vc6.0下是从右到左，这里先*(++ptr) 后*pt，于是结果为8，8 

三、编程题（第一小题20，第二小题30分） 
1、  不使用库函数，编写函数int strcmp(char  *source, char *dest) 相等返回0，不等返回-1； 
答案：一、 
int strcmp(char  *source, char *dest) 
{  
assert((source!=NULL)&&(dest!=NULL));  
int i,j;  

for(i=0; source[i]==dest[i]; i++)  
{  
if(source[i]=='\0' && dest[i]=='\0')    
return 0;  
else    
    return -1;  
} 
} 
答案：二、 
int strcmp(char *source, char *dest) 
{    
while ( (*source != '\0') && (*source == *dest))    
{ 
source++; 
dest++;    
}    
return ( (*source) - (*dest) ) ? -1 : 0; 
}
 
2、   写一函数int fun(char *p)判断一字符串是否为回文，是返回1，不是返回0，出错返回-1 
答案：一、 
int fun(char *p) 
{  
if(p==NULL)  
return -1;  
else  
{  
int length = 0;  
int i = 0;  
int judge = 1;  
length = strlen(p);  
for(i=0; i <length/2; i++)  
{    
if(p[i]!=p[length-1-i])    
judge = 0;    
break;  
}  
if(judge == 0)    
return 0;  
else    
return 1;  
} 
} 
答案：二、 
int fun(char *p)
{ 
int len = strlen(p) - 1; 
char *q = p + len; 
if (!p) return -1; 
while (p < q) 
{
 if ((*p++) != (*q--)) return 0; 
} 
return 1;
}  

华为笔试网络题（3） 2006-09-30 12:48 
1.在OSI 7 层模型中,网络层的功能有(B ) 
A.确保数据的传送正确无误  B.确定数据包如何转发与路由 C.在信道上传送比特流    D.纠错与流控 
2.FDDI(光纤分布式数据接口) 使用的是___局域网技术。(C ) 
A.以太网;    B.快速以太网;    C.令牌环;    D.令牌总线。 
3.下面那种LAN 是应用CSMA/CD协议的（C) 
A.令牌环    B.FDDI    C.ETHERNET    D.NOVELL 
4.TCP 和UDP 协议的相似之处是 ( C) 
A.面向连接的协议    B.面向非连接的协议    C.传输层协议    D.以上均不对 
5.应用程序PING 发出的是___报文.( C)
 A.TCP 请求报文。    B.TCP 应答报文。    C.ICMP 请求报文。  D.ICMP 应答报文。 
6.以下说法错误的是(多) ( BD) 
A.中继器是工作在物理层的设备    B.集线器和以太网交换机工作在数据连路层 C.路由器是工作在网络层的设备    D.桥能隔离网络层广播 
7.当桥接收的分组的目的MAC地址在桥的映射表中没有对应的表项时,采取的策略是( C) 
A.丢掉该分组  B.将该分组分片    C.向其他端口广播该分组    D.以上答案均不对 
8.LAN Switch 在网络层次模型中的地位( B) 
A.物理层    B.链路层    C.网络层    D.以上都不是 
9.小于___的TCP/UDP端口号已保留与现有服务一一对应,此数字以上的端口号可自由分配。( C) A.199      B.100    C.1024      D.2048 
10.当一台主机从一个网络移到另一个网络时,以下说法正确的是 ( B) 
A.必须改变它的IP 地址和MAC 地址    B.必须改变它的IP 地址,但不需改动MAC 地址 
C.必须改变它的MAC 地址,但不需改动IP 地址    D.MAC 地址.IP 地址都不需改动
答案：1.B; 2.C; 3.C; 4.C; 5.C; 6.BD; 7.C; 8.B; 9.C; 10.B.  

华为笔试题（4） 2006-09-30 13:00 
1. 找错 
void test1() 
{    
char string[10];    
char* str1="0123456789";    
strcpy(string, str1);
} 
答：表面上并且编译都不会错误。但如果string数组原意表示的是字符串的话，那这个赋值就没有达到意图。最好定义为char string[11]，这样最后一个元素可以存储字符串结尾符'\0'; 

void test2() 
{    
char string[10], 
str1[10];  
for(int I=0; I <10;I++)  
{    
str1[I] ='a';  
}  
strcpy(string, str1);
 } 
答：strcpy使用错误，strcpy只有遇到字符串末尾的'\0'才会结束，而str1并没有结尾标志，导致strcpy函数越界访问，不妨让str1[9]='\0'，这样就正常了。 

void test3(char* str1) 
{    
char string[10];    
if(strlen(str1) <=10) 
{    
strcpy(string, str1); 
} 
} 
答：这又会出现第一道改错题的错误了。strlen(str1)算出来的值是不包含结尾符'\0'的，如果str1刚好为10个字符＋1结尾符，string就得不到结尾符了。可将strlen(str1) <=10改为strlen(str1) <10。 

2. 找错 
#define MAX_SRM 256 
DSN get_SRM_no() 
{    
static int SRM_no;    
int I;    
for(I=0;I<MAX_SRM;I++,SRM_no++)
{
SRM_no %= MAX_SRM;    
if(MY_SRM.state==IDLE) 
{      
break;    
}  
}  
if(I>=MAX_SRM)    
return (NULL_SRM);  
else    
return SRM_no;
} 
答：我不知道这段代码的具体功能，但明显有两个错误 1，SRM_no没有赋初值   2，由于static的声明，使该函数成为不可重入（即不可预测结果）函数，因为SRM_no变量放在程序的全局存储区中，每次调用的时候还可以保持原来的赋值。这里应该去掉static声明。 

3. 写出程序运行结果 
int sum(int a) 
{    
auto int c=0;    
static int b=3;  
c+=1;  
b+=2;  
return(a+b+c); 
}  
void main() 
{    
int I;  
int a=2;  
for(I=0;I <5;I++)  
{    
printf("%d,", sum(a));  
} 
} 
答：8,10,12,14,16 该题比较简单。只要注意b声明为static静态全局变量，其值在下次调用时是可以保持住原来的赋值的就可以。 

4. int func(int a)
{   
int b;    
switch(a)    
{        
case 1: b=30;        
case 2: b=20;        
case 3: b=16;        
default: b=0;    
}    
return b; 
} 
则func(1)=? 
答：func(1)=0，因为没有break语句，switch中会一直计算到b=0。这是提醒我们不要忘了break。呵呵。 
5:  
int a[3]; 
a[0]=0; 
a[1]=1;
a[2]=2;  
int *p, *q;  
p=a;  
q=&a[2]; 
则a[q-p]=? 
答：a[q-p]=a[2]=2;这题是要告诉我们指针的运算特点 

6. 定义 int **a[3][4], 则变量占有的内存空间为：_____ 
答：此处定义的是指向指针的指针数组，对于32位系统，指针占内存空间4字节，因此总空间为3×4×4＝48。 
7. 编写一个函数，要求输入年月日时分秒，输出该年月日时分秒的下一秒。如输入2004年12月31日23时59分59秒，则输出2005年1月1日0时0分0秒。 
答： /*输入年月日时分秒，输出年月日时分秒的下一秒，输出仍然在原内存空间*/ 
void NextMinute(int *nYear,int *nMonth,int *nDate,int *nHour,int *nMinute,int *nSecond)
{  
int nDays;  (*nSecond)++;  // 秒加1  if(*nSecond>=60)  // 秒满60，做出特殊处理，下面时，日，月等类同  
{    
*nSecond=0;    
(*nMinute)++;    
if(*nMinute>=60)    
{      
*nMinute=0;     
 (*nHour)++;      
if(*nHour>=24)      
{        
*nHour=0;       
(*nDate)++;        
switch(*nMonth)        
{          
case 1:          
case 3:          
case 5:          
case 7:          
case 8:          
case 10:          
case 12:            
nDays=31;          
break;          
case 2:// 判断闰年            
if(*nYear%400==0 ¦ ¦*nYear%100!=0&&*nYear%4==0)            
{            
nDays=29;            
} 
else            
{            
nDays=28;            
}          
break;          
default:            
nDays=30;          
break;        
}        
if(*nDate>nDays)        
{          
*nDate=1;          
(*nMonth)++;          
if(*nMonth>12)          
{          
*nMonth=1;          
(*nYear)++;          
}        
}      
}    
}  
} 
} /*示例可运行代码*/ 
void main() 
{  
int nYear=2004,nMonth=12,nDate=31,nHour=59,nMinute=59,nSecond=59;  
NextMinute(&nYear,&nMonth,&nDate,&nHour,&nMinute,&nSecond);  
printf("The result:%d-%d-%d %d:%d:%d",nYear,nMonth,nDate,nHour,nMinute,nSecond); 
}    
华为硬件笔试题 2006-09-30 13:01 
一 选择 13个题目,没有全部抄下来,涉及的课程有电路,模拟电路,数字电路,信号与系统,微机原理,网络,数字信号处理 有关于 1.微分电路 2.CISC,RISC 3.数据链路层 
二 填空 10个题目,没有全部抄下来,涉及的课程有电路,模拟电路,数字电路,信号与系统,微机原理,网络,数字信号处理 有关于 
1.TIC6000 DSP 2.二极管 3.RISC 4.IIR 
三 简答 
1.x(t)的傅立叶变换为X(jw)=$(w)+$(w-PI)+$(w-5) h(t)=u(t)-u(t-2) 问: (1),x(t)是周期的吗? (2),x(t)*h(t)是周期的吗? (3),两个非周期的信号卷积后可周期吗? 2.简述分组交换的特点和不足四 分析设计 1.波形变换题目 从正弦波->方波->锯齿波->方波,设计电路 2.74161计数器组成计数电路,分析几进制的 3.用D触发器构成2分频电路 4.判断MCS-51单片机的指令正确还是错误,并指出错误原因 (1) MUL R0,R1 (2) MOV A,@R7 (3) MOV A,#3000H (4) MOVC @A+DPTR,A (5) LJMP #1000H () 5.MCS-51单片机中,采用12Mhz时钟,定时器T0采用模式1(16位计数器),请问在下面程序中,p1.0的输出频率 MOV TMOD,#01H SETB TR0 LOOP:MOV TH0,#0B1H MOV TL0,#0E0H LOOP1:JNB TF0,LOOP1 CLR TR0 CPL P1.0 SJMP LOOP      
华为硬件面试题 2006-09-30 13:02 　　全都是几本模电数电信号单片机题目　　 
1.用与非门等设计全加法器 　　 
2.给出两个门电路让你分析异同 　　 
3.名词:sram,ssram,sdram 　　 
4.信号与系统:在时域与频域关系 　　 
5.信号与系统:和4题差不多 　　 
6.晶体振荡器,好像是给出振荡频率让你求周期(应该是单片机的,12分之一周期.. 　　..) 　　 
7.串行通信与同步通信异同,特点,比较 　　 
8.RS232c高电平脉冲对应的TTL逻辑是?(负逻辑?) 　　 
9.延时问题,判错 　　 
10.史密斯特电路,求回差电压 　　 
11.VCO是什么,什么参数(压控振荡器?) 　　 
12. 用D触发器做个二分颦的电路.又问什么是状态图 
13. 什么耐奎斯特定律,怎么由模拟信号转为数字信号 　　 
14. 用D触发器做个4进制的计数 　　 
15.那种排序方法最快? 　　 
一、 研发（软件）　　 
用C语言写一个递归算法求N！； 　　给一个C的函数，关于字符串和数组，找出错误； 　　防火墙是怎么实现的？　　你对哪方面编程熟悉？  
硬件： 1、继电器控制电路。 2、SDRAM是怎么工作的 3、写出逻辑表达式说明A2A1A0大于B2B1B0。 4、常用触发器有几种 5、示波器有几种触发方式，举出三种      
华为3COM数据通信工程师试题 2006-09-29 18:53 
1 H.323协商答案：12个包协商，先H225然后H245，需要注意的是面试官可能会问到跟SIP的比较 
2 ipsec为什么是三层的。L2tp为什么是二层的？ 答案：IPSec (Internet 协议安全)是一个工业标准网络安全协议，为 IP 网络通信提供透明的安全服务，保护 TCP/IP 通信免遭窃听和篡改，可以有效抵御网络攻击，同时保持易用性。IPSec有两个基本目标：1）保护IP数据包安全；2）为抵御网络攻击提供防护措施。 第三层保护的优点 　　通常IPSec提供的保护需要对系统做一定的修改。但是IPSec在IP传输层即第三层的"策略执行"（strategic implementation）几乎不需要什么额外开销就可以实现为绝大多数应用系统、服务和上层协议提供较高级别的保护；为现有的应用系统和操作系统配置IPSec几乎无须做任何修改，安全策略可以在Active Directory里集中定义也可以在某台主机上进行本地化管理。　　IPSec策略在ISO参考模型第三层即网络层上实施的安全保护，其范围几乎涵盖了TCP/IP协议簇中所有IP协议和上层协议，如TCP、UDP、ICMP，Raw（第255号协议）、甚至包括在网络层发送数据的客户自定义协议。在第三层上提供数据安全保护的主要优点就在于：所有使用IP协议进行数据传输的应用系统和服务都可以使用IPSec，而不必对这些应用系统和服务本身做任何修改。　　运作于第三层以上的其他一些安全机制，如安全套接层SSL，仅对知道如何使用SSL的应用系统（如Web浏览器）提供保护，这极大地限制了SSL的应用范围；而运作于第三层以下的安全机制，如链路层加密，通常只保护了特定链路间的数据传输，而无法做到在数据路径所经过的所有链路间提供安全保护，这使得链接层加密无法适用于 Internet 或路由 Intranet 方案中的端对端数据保护。 L2TP（第二层隧道协议）通过使用虚拟专用网 (VPN) 连接和第二层隧道协议 (L2TP)，可以通过 Internet 或其他公共网络访问专用网。L2TP 是一个工业标准 Internet 隧道协议，它和点对点隧道协议 (PPTP) 的功能大致相同。利用L2TP来构建企业的VPN，一样需要运营商支持，因为LAC一般是在传统电话交换网络中部署的，并且一个公司的分支机构以及移动办公的员工在地域上分布很广，所以需要各地的运营商都具备LAC才能够实现企业大范围构建VPN网络。当然企业也可以构建自己的基于L2TP的VPN网络在L2TP VPN中，用户端的感觉就像是利用PPP协议直接接到了企业总部的PPP端接设备上一样，其地址分配可以由企业通过DHCP来分配，认证方式可以沿用PPP一直沿用的各种认证方式，并且L2TP是IETF定义的，其MIB库也将定义出来从而可以实现全局的网络管理。 
3 ospf中包的ttl值是多少？ 答案：1，因为224.0.0.5/224.0.0.6是本地链路组播 
4 OSPF为什么要划分区域？答案：RD用于BGP区分VPN路由，RT用于在各VRF中导入或导出路由 
5 MPLS VPN的标签一共有几层。内网的标签放在哪里。答案：如果没有流量工程则是2层，内网标签在隧道标签之后 
6 MPLS中RD和RT的作用分别是什么？答案：减少CPU负载，区域间使用距离矢量算法，因此其它区域的泛洪不会影响区域的SPF运算，这里注意面试官可能会问OSPF多区域如何防止环路。(注意答本质而不是现象，免得面试官追问) 
7 RR防止环路的机制。答案：RR中通过ORIGIN ID和CLUSTER ID防止环路，若RR收到带有自己CLUSTER ID的路由则丢弃 
8 BGP控制out-bound用local-pre，控制进来的用med. 答案：正确 
9 ospf是工作在哪个协议上的？答案：IP，OSPF协议号89 
10 ospf的LSA类型。答案：1，2，3，4，5，6，7，没有什么好说的，注意考官问到第6类LSA，组播再准备多点 
11 简述OSPF的基本工作机制。答案：这个没什么可以说了，把知道的都说出来就行了 
12 ppp的lcp和ncp协商过程。答案：LCP过程协商二层链路相关参数，MTU/PPP压缩/认证协议类型等~~~NCP协商第三层协议，IP地址，IP压缩等等，这里记住最好不要说CDP 
13 笔试中还有一道PSTN的信令控制有哪三种？答案：这个我只知道随路信令和共路信令，信工同学提供的答案是：监视\号码\音信号\，知道正确答案的朋友麻烦纠正一下 
14sloari 8.0查看进程的命令是什么？linux 7.3查看IP的命令是什么？答案：不知道华为为什么问这个，第一个是PS吧？第二个是IFCONFIG /A 
15 IP是5.32.0.0,掩码255.224.0.0。请问最大的有效地址是多少。答案：最大主机地址5。64。255。254 
17 lx/lh的有效距离是多少？答案：？？？ 
18 IP 包头几个字节？加上数据部分几个字节答案：应该是问IPV4，一般20字节，加上源路由选择等后最大60字节，加上数据部分还是根据链路MTU决定 
20 CQ能不能有一种流量dominate第二种流量? 答案：CQ不能有一种流量DOMINATE其它任何流量 21 FTP下载一个文件完成。有几个TCP连接答案：4个


今天下午参加了一下中科开元的嵌入式音频开发实习岗位的笔试面试,整理一下,希望对将
要参加实习工作面试的朋友们一点帮助!
笔试:
1 Static
关键字 static 的作用是什么?
这个简单的问题很少有人能回答完全。在 C 语言中,关键字 static 有三个明显
的作用:
1)在函数体,一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2) 在模块内(但在函数体外),一个被声明为静态的变量可以被模块内所用函
数访问,但不能被模块外其它函数访问。它是一个本地的全局变量。
3) 在模块内,一个被声明为静态的函数只可被这一模块内的其它函数调用。那
就是,这个函数被限制在声明它的模块的本地范围内使用。
Static 全局变量和普通全局变量的区别,static 局部变量和普通局部变量的区
别,static 函数和普通函数的区别
2 队列和栈的区别
栈(Stack)是限定只能在表的一端进行插入和删除操作的线性表。
队列(Queue)是限定只能在表的一端进行插入和在另一端进行删除操作的线性
表。
从"数据结构"的角度看,它们都是线性结构,即数据元素之间的关系相同。但它
们是完全不同的数据类型。除了它们各自的基本操作集不同外,主要区别是对插
入和删除操作的"限定"。栈和队列是在程序设计中被广泛使用的两种线性数据结
构,它们的特点在于基本操作的特殊性,栈必须按"后进先出"的规则进行操作,
而队列必须按"先进先出"的规则进行操作。和线性表相比,它们的插入和删除操
作受更多的约束和限定,故又称为限定性的线性表结构。
3 关于 strcpy 函数的使用,主要是操作指针数组的改错判断题
4 又是静态 Static 常量的使用
5 指针和数组的组合使用
6 判断**a[3][4]占多少位啊
7
1
/*************************************
2 编写一个函数,要求输入年月日时分秒,
3 输出该年月日时分秒的下一秒。
4 如输入2004年12月31日23时59分59秒,
5 则输出2005年1月1日0时0分0秒
6
**************************************/7
8 #include <stdio.h>
9 #include <stdlib.h>
10
11 /* define function */
void
12 void InputData(void
void);
int year);
13 int LeapYear(int
void
14 void NextSec(void
void);
15
16 /* month[0];leap year month[1]; common year */
17 int Amonth[2][13]={
18 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
19 {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
20 };
21 int leap = 0;
22 int year, month, day, hour, minute, second;
23 /*
24 * Function Name: LeapYear()
25 * Describe: judge the current year is leap year or not
26 * Paramete: int year:current year
27 * Return Value: 1-leap year; 0-not
28 */
int year)
29 int LeapYear(int
30 {
31
if ( (year%4 == 0) && (year%100 != 0) ||
32
33
(year%400 == 0) )
{
return 1;
34
35 }
36 else37
{
return 0;
38
39
}
40 }
41
42 /*
43 * Function Name: InputData()
44 * Describe: input data
45 * Paramete: void
46 * Return Value: void
47 */
void
48 void InputData(void
void)
49 {
50 printf("Input year(Press Enter to end input):");
51 if (scanf("%d", &year) != 1 || (year < 1000))
52 {
53 puts("Input year error");
54 getchar();
55 exit(0);
56 }
57 leap = LeapYear(year);
58
59 printf("Input month:");
60 if (scanf("%d", &month) != 1 || month<1 || month>12)
61 {
62 puts("Input month error!");
63 getchar();
64 exit(0);
65
66
}67 printf("Input Day:");
68 if (scanf("%d", &day) != 1 || day<1 || day>Amonth[leap][month])
69 {
70 puts("Input day error!");
71 getchar();
72 exit(0);
73
}
74
75 printf("Input Hour:");
76 if (scanf("%d", &hour) != 1 || hour<0 || hour>59)
77 {
78 puts("Input hour error!");
79 getchar();
80 exit(0);
81
}
82
83 printf("Input Minute:");
84 if (scanf("%d", &minute) != 1 || minute<0 || minute>59)
85 {
86 puts("Input minute error!");
87 getchar();
88 exit(0);
89
}
90
91 printf("Input Second:");
92 if (scanf("%d", &second) != 1 || second<0 || second>59)
93 {
94 puts("Input second error!");
95 getchar();
96 exit(0);97
}
98 }
99
100 /*
101 * Function Name: NextSec()
102 * Describle: Count the next second by the current time
103 * Paramete; void
104 * ReturnValue: void
105 */
void
106 void NextSec(void
void)
107 {
108 if (++second == 60)
109 {
110 second = 0;
111 minute++;
112 }
113 if (minute == 60)
114 {
115 minute = 0;
116 hour++;
117 }
118 if (hour == 24)
119 {
120 hour = 0;
121 day++;
122 }
123 if (day == Amonth[leap][month]+1)
124 {
125 day = 1;
126 month++;127 }
128 if (month == 13)
129 {
130 month = 1;
131 year++;
132
}
133
134
printf("The next second is %d-%d-%d %d:%d:%d\n\n",
135
year, month, day, hour, minute, second);
136 }
137
void
138 int main(void
void)
139 {
140
InputData();
141
142
NextSec();
143
144 system("PAUSE");
145 return 0;
146 }
面试题
1 简单介绍一下自己:包括学习情况 兴趣爱好
2 堆和栈的区别
一)预备知识—程序的内存分配
一个由 c/C++编译的程序占用的内存分为以下几个部分
1)栈区(stack)— 由编译器自动分配释放 ,存放函数的参数值,局部变量的
值等。其操作方式类似于数据结构中的栈。
2)堆区(heap) — 一般由程序员分配释放, 若程序员不释放,程序结束时可
能由 OS 回收 。注意它与数据结构中的堆是两回事,分配方式倒是类似于链表,
呵呵。3)全局区(静态区)(static)—,全局变量和静态变量的存储是放在一块的,
初始化的全局变量和静态变量在一块区域, 未初始化的全局变量和未初始化的
静态变量在相邻的另一块区域。 - 程序结束后有系统释放
4)文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放
5)程序代码区—存放函数体的二进制代码。
二)例子程序
这是一个前辈写的,非常详细
//main.cpp
int a = 0; 全局初始化区
char *p1; 全局未初始化区
main()
{
int b; 栈
char s[] = "abc"; 栈
char *p2; 栈
char *p3 = "123456"; 123456\0 在常量区,p3 在栈上。
static int c =0; 全局(静态)初始化区
p1 = (char *)malloc(10);
p2 = (char *)malloc(20);
分配得来得 10 和 20 字节的区域就在堆区。
strcpy(p1, "123456"); 123456\0 放在常量区,编译器可能会将它与 p3 所指向的
"123456"优化成一个地方。
}
三)堆和栈的理论知识
1)申请方式
stack:
由系统自动分配。 例如,声明在函数中一个局部变量 int b; 系统自动在栈中为
b 开辟空间
heap:
需要程序员自己申请,并指明大小,在 c 中 malloc 函数
如 p1 = (char *)malloc(10);在 C++中用 new 运算符
如 p2 = (char *)malloc(10);
但是注意 p1、p2 本身是在栈中的。
2)申请后系统的响应
栈:只要栈的剩余空间大于所申请空间,系统将为程序提供内存,否则将报异常
提示栈溢出。
堆:首先应该知道操作系统有一个记录空闲内存地址的链表,当系统收到程序的
申请时,
会遍历该链表,寻找第一个空间大于所申请空间的堆结点,然后将该结点从空闲
结点链表中删除,并将该结点的空间分配给程序,另外,对于大多数系统,会在
这块内存空间中的首地址处记录本次分配的大小,这样,代码中的 delete 语句才
能正确的释放本内存空间。另外,由于找到的堆结点的大小不一定正好等于申请
的大小,系统会自动的将多余的那部分重新放入空闲链表中。
3)申请大小的限制
栈:在 Windows 下,栈是向低地址扩展的数据结构,是一块连续的内存的区域。
这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的,在
WINDOWS 下,栈的大小是 2M(也有的说是 1M,总之是一个编译时就确定的
常数),如果申请的空间超过栈的剩余空间时,将提示 overflow。因此,能从栈
获得的空间较小。
堆:堆是向高地址扩展的数据结构,是不连续的内存区域。这是由于系统是用链
表来存储的空闲内存地址的,自然是不连续的,而链表的遍历方向是由低地址向
高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见,堆获得的空
间比较灵活,也比较大。
4)申请效率的比较:
栈由系统自动分配,速度较快。但程序员是无法控制的。
堆是由 new 分配的内存,一般速度比较慢,而且容易产生内存碎片,不过用起来
最方便.
另外,在 WINDOWS 下,最好的方式是用 VirtualAlloc 分配内存,他不是在堆,
也不是在栈是直接在进程的地址空间中保留一快内存,虽然用起来最不方便。但
是速度快,也最灵活
5)堆和栈中的存储内容
栈: 在函数调用时,第一个进栈的是主函数中后的下一条指令(函数调用语句
的下一条可执行语句)的地址,然后是函数的各个参数,在大多数的 C 编译器
中,参数是由右往左入栈的,然后是函数中的局部变量。注意静态变量是不入栈
的。当本次函数调用结束后,局部变量先出栈,然后是参数,最后栈顶指针指向最开
始存的地址,也就是主函数中的下一条指令,程序由该点继续运行。
堆:一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。
6)存取效率的比较
char s1[] = "aaaaaaaaaaaaaaa";
char *s2 = "bbbbbbbbbbbbbbbbb";
aaaaaaaaaaa 是在运行时刻赋值的;
而 bbbbbbbbbbb 是在编译时就确定的;
但是,在以后的存取中,在栈上的数组比指针所指向的字符串(例如堆)快。
比如:
#include
void main()
{
char a = 1;
char c[] = "1234567890";
char *p ="1234567890";
a = c[1];
a = p[1];
return;
}
对应的汇编代码
10: a = c[1];
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]
0040106A 88 4D FC mov byte ptr [ebp-4],cl
11: a = p[1];
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]
00401070 8A 42 01 mov al,byte ptr [edx+1]
00401073 88 45 FC mov byte ptr [ebp-4],al第一种在读取时直接就把字符串中的元素读到寄存器 cl 中,而第二种则要先把
指针值读到 edx 中,在根据 edx 读取字符,显然慢了。
7)小结:
堆和栈的区别可以用如下的比喻来看出:
使用栈就象我们去饭馆里吃饭,只管点菜(发出申请)、付钱、和吃(使用),
吃饱了就走,不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作,他的好
处是快捷,但是自由度小。
使用堆就象是自己动手做喜欢吃的菜肴,比较麻烦,但是比较符合自己的口味,
而且自由度大。
堆和栈的区别主要分:
操作系统方面的堆和栈,如上面说的那些,不多说了。
还有就是数据结构方面的堆和栈,这些都是不同的概念。这里的堆实际上指的就
是(满足堆性质的)优先队列的一种数据结构,第 1 个元素有最高的优先权;栈
实际上就是满足先进后出的性质的数学或数据结构。
虽然堆栈,堆栈的说法是连起来叫,但是他们还是有很大区别的,连着叫只是由
于历史的原因。
3 动态分配存储单元函数:calloc
4 一个 32 位的机器,该机器的指针是多少位答案:
指针是多少位只要看地址总线的位数就行了。80386 以后的机子都是 32 的数据
总线。所以指针的位数就是 4 个字节了。
5 对 Linux 了解么
6 学过什么课程
7 数据结构
8 综合评价一下自己的优缺点
9 如果被录取,准备在以后的工作中怎么做
10 有过什么团队合作的经验
11 对各种音频格式有多少了解
12 学过信号与系统 系统过程导论么
13 链表和数组的区别
14 有过什么项目经历,写过最长的代码是多少
面试问题很多,主要是关于 C 语言的指针数组链表


3.二维数组空间的动态申请
 a.简单的，已经有一维，如 
       char (*c)[5];
       c=new char[n][5];//n为已定义的行数
 b.二维的
      int **p;
      p=new int*[m_row];//创建行指针
      for(int i=0;i<m_row;i++)//为每一行分配空间
      p[i]=new int[m_cols];
写到某一个函数中：
void getmemory(int ** &p,int m_row,int m_cols)
{
     p=new int*[m_row];//创建行指针
     for(int i=0;i<m_row;i++)//为每一行分配空间
    p[i]=new int[m_cols];
}
释放空间:
void deletememory(int **&p,int m_row)
{   //释放每一行所分配的空间
    for(int i=0;i<m_row;i++)
       delete [] x[i];
   //释放行指针
    delete [] x;
     x=0;
}
2．嵌入式笔试两题
   以下是威盛嵌入式笔试的最后两道小题
题一：
原题如下：改程序，并确定运行结果
＃i nclude <stdio.h>
＃i nclude <string.h>
＃i nclude <malloc.h>
char *getstring(void)
{
        char p[]="hello everyone";
        return p;
}
char *getmemory(void)
{
        return (char *)malloc(10);
}
int main(int argc, char* argv[])
{
        char *p=getmemory();
        strcpy(p,"helloworld");
        printf("%s",p);
        printf("%s",getstring());
        return 0;
}
这个主要是char p[]前少一个static...
题二：
读程序，写出运行结果
＃i nclude <stdio.h>
＃i nclude <string.h>
＃i nclude <malloc.h>
＃i nclude <assert.h>
typedef struct
{
        int value;
        char type;
}head_t;这是什么东西啊？
typedef struct
{
        head_t head;
        int para;
}message_t;
void main(void)
{
        message_t *message=NULL;
        head_t *head=NULL;
        message=(message_t *)malloc(sizeof(message_t));
        assert(message);//测试的条件不成立则终止程序
        memset(message,0,sizeof(message_t)); //将message中前sizeof(message_t)个字节替换为0并返回message；
        message->para=100;
        message->head.type='a';
        head=(head_t *)message;
        head->value++;
        head->type++;
printf("message->head.value=%d,message->head.type=%c,message->para=%d\n",me
ssage->head.value,message->head.type,message->para);
       " free(message);
        return;
}   //结果：message->head.value=1,message->head.type=b,message->para=100
3.
#include <iostream>
#include <string>
using namespace std; 
class Student 
{ 
public: 
    Student() {} 
    Student( const string& nm, int sc = 0 ) : name( nm ), score( sc ) {} //常数据成员只能通过初始化列表来获得初值
    void set_student( const string& nm, int sc = 0 ) 
    { 
       name = nm; 
       score = sc; 
    } 
    const string& get_name() const 
    { 
       return name; 
    } 
    int get_score() const 
    { 
      return score; 
    } 
private: 
    string name; 
    int score; 
}; 
// output student's name and score 
void output_student( const Student& student ) 
{ 
   cout << student.get_name() << "\t"; 
   cout << student.get_score() << endl; 
} 
int main() 
{ 
   Student stu( "Wang", 85 ); 
   output_student( stu ); 
}
设 计了一个类 Student，数据成员有 name 和 score，有两个构造函数，有一个设置成员数据函数 set_student()，各有一个取得 name 和 score 的函数 get_name() 和 get_score()。请注意 get_name() 和 get_score() 后面都加了 const，而 set_student() 后面没有（也不能有const）。
首先说一点题外话，为什么 get_name() 前面也加 const。如果没有前后两个 const 的话，get_name() 返回的是对私有数据成员 name 的引用，所以通过这个引用可以改变私有成员 name 的值，如
  Student stu( "Wang", 85 );
  stu.get_name() = "Li";即把 name 由原来的 "Wang" 变成了 "Li"，而这不是我们希望的发生的。所以在 get_name() 前面加 const 避免这种情况的发生。
那么，get_name() 和 get_score() 这两个后面应该加 const的成员函数，如果没有 const 修饰的话可不可以呢？回答是可以！但是这样做的代价是：const对象将不能再调用这两个非const成员函数了。如
const string& get_name(); // 这两个函数都应该设成 const 型
int get_score();
void output_student( const Student& student ) 
{ 
  cout << student.get_name() << "\t"; // 如果 get_name() 和 get_score() 是非const成员函数，这一句和下一句调用是错误的
  cout << student.get_score() << endl; 
}
由 于参数student表示的是一个对const Student型对象的引用，所以 student 不能调用非const成员函数如 set_student()。如果 get_name() 和 get_score() 成员函数也变成非const型，那么上面的 student.get_name() 和 student.get_score() 的使用就是非法的，这样就会给我们处理问题造成困难。
因此，我们没有理由反对使用const，该加const时就应该加上const，这样使成员函数除了非const的对象之外，const对象也能够调用它。
c/C++ 通用 Makefile 
本文提供了一个用于对 C/C++ 程序进行编译和连接以产生可执行程序的通用 Makefile。 
在使用 Makefile 之前，只需对它进行一些简单的设置即可；而且一经设置，即使以后对源程序文件有所增减一般也不再需要改动 Makefile。因此，即便是一个没有学习过 Makefile 书写规则的人，也可以为自己的 C/C++ 程序快速建立一个可工作的 Makefile。
这个 Makefile 可以在 GNU Make 和 GCC 编译器下正常工作。但是不能保证对于其它版本的 Make 和编译器也能正常工作。 
如果你发现了本文中的错误，或者对本文有什么感想或建议，可通过 whyglinux AT hotmail DOT com 邮箱和作者联系。 
此 Makefile 的使用方法如下： 
1. 程序目录的组织 
尽量将自己的源程序集中在一个目录中，并且把 Makefile 和源程序放在一起，这样用起来比较方便。当然，也可以将源程序分类存放在不同的目录中。 

在程序目录中创建一个名为 Makefile 的文本文件，将后面列出的 Makefile 的内容复制到这个文件中。（注意：在复制的过程中，Makfile 中各命令前面的 Tab 字符有可能被转换成若干个空格。这种情况下需要把 Makefile 命令前面的这些空格替换为一个 Tab。） 

将当前工作目录切换到 Makefile 所在的目录。目前，这个 Makefile 只支持在当前目录中的调用，不支持当前目录和 Makefile 所在的路径不是同一目录的情况。 
2. 指定可执行文件 
程序编译和连接成功后产生的可执行文件在 Makefile 中的 PROGRAM 变量中设定。这一项不能为空。为自己程序的可执行文件起一个有意义的名子吧。 
3. 指定源程序 
要编译的源程序由其所在的路径和文件的扩展名两项来确定。由于头文件是通过包含来使用的，所以在这里说的源程序不应包含头文件。 

程序所在的路径在 SRCDIRS 中设定。如果源程序分布在不同的目录中，那么需要在 SRCDIRS 中一一指定，并且路径名之间用空格分隔。 

4. Makefile 目标（Targets） 
下面是关于这个 Makefile 提供的目标以及它所完成的功能： 
make 
编译和连接程序。相当于 make all。 
make objs 
仅仅编译程序产生 .o 目标文件，不进行连接（一般很少单独使用）。 
make clean 
删除编译产生的目标文件和依赖文件。 
make cleanall 
删除目标文件、依赖文件以及可执行文件。 
make rebuild 
重新编译和连接程序。相当于 make clean && make all。 
下面提供两个例子来具体说明上面 Makefile 的用法。 
例一　Hello World 程序 
这个程序的功能是输出 Hello, world! 这样一行文字。由 hello.h、hello.c、main.cxx 三个文件组成。前两个文件是 C 程序，后一个是 C++ 程序，因此这是一个 C 和 C++ 混编程序。 
代码:

/* File name: hello.h 
 * C header file */ 

#ifndef HELLO_H 
#define HELLO_H 
#ifdef __cplusplus 
extern "C" { 
#endif 

  void print_hello(); 

#ifdef __cplusplus 
} 
#endif 
#endif 

代码:
/* File name: hello.c 
 * C source file. */ 
#include "hello.h" 
#include <stdio.h> 

void print_hello() 
{ 
  puts( "Hello, world!" ); 
} 

代码:
/* File name: main.cxx 
 * C++ source file. */ 
#include "hello.h" 

int main() 
{ 
  print_hello(); 
  return 0; 
} 

建立一个新的目录，然后把这三个文件拷贝到目录中，也把 Makefile 文件拷贝到目录中。之后，对 Makefile 的相关项目进行如下设置： 
代码:
PROGRAM   := hello      # 设置运行程序名 
SRCDIRS   := .          # 源程序位于当前目录下 
SRCEXTS   := .c .cxx    # 源程序文件有 .c 和 .cxx 两种类型 
CFLAGS    := -g         # 为 C 目标程序包含 GDB 可用的调试信息 
CXXFLAGS  := -g         # 为 C++ 目标程序包含 GDB 可用的调试信息 

由于这个简单的程序只使用了 C 标准库的函数（puts），所以对于 CFLAGS 和 CXXFLAGS 没有过多的要求，LDFLAGS 和 CPPFLAGS 选项也无需设置。 
经过上面的设置之后，执行 make 命令就可以编译程序了。如果没有错误出现的话，./hello 就可以运行程序了。 
如果修改了源程序的话，可以看到只有和修改有关的源文件被编译。也可以再为程序添加新的源文件，只要它们的扩展名是已经在 Makefile 中设置过的，那么就没有必要修改　Makefile。 

C/C++程序员应聘试题剖析
1.引言 
　　本文的写作目的并不在于提供C/C++程序员求职面试指导，而旨在从技术上分析面试题的内涵。文中的大多数面试题来自各大论坛，部分试题解答也参考了网友的意见。
　　许多面试题看似简单，却需要深厚的基本功才能给出完美的解答。企业要求面试者写一个最简单的strcpy函数都可看出面试者在技术上究竟达到了怎样的程度，我们能真正写好一个strcpy函数吗？我们都觉得自己能，可是我们写出的strcpy很可能只能拿到10分中的2分。读者可从本文看到strcpy函数从2分到10分解答的例子，看看自己属于什么样的层次。此外，还有一些面试题考查面试者敏捷的思维能力。 
　　分析这些面试题，本身包含很强的趣味性；而作为一名研发人员，通过对这些面试题的深入剖析则可进一步增强自身的内功。
　　2.找错题
　　试题1：
void test1()
{
　char string[10];
　char* str1 = "0123456789";
　strcpy( string, str1 );
}

　　试题2：
void test2()
{
　char string[10], str1[10];
　int i;
　for(i=0; i<10; i++)
　{
　　str1[i] = 'a';
　}
　strcpy( string, str1 );
}

　　试题3：
void test3(char* str1)
{
　char string[10];
　if( strlen( str1 ) <= 10 )
　{
　　strcpy( string, str1 );
　}
}

　　解答：
　　试题1字符串str1需要11个字节才能存放下(包括末尾的’\0’)，而string只有10个字节的空间，strcpy会导致数组越界；
　　对试题2，如果面试者指出字符数组str1不能在数组内结束可以给3分；如果面试者指出strcpy(string, str1)调用使得从str1内存起复制到string内存起所复制的字节数具有不确定性可以给7分，在此基础上指出库函数strcpy工作方式的给10分；
　　对试题3，if(strlen(str1) <= 10)应改为if(strlen(str1) < 10)，因为strlen的结果未统计’\0’所占用的1个字节。
　　剖析：
　　考查对基本功的掌握：
　　(1)字符串以’\0’结尾；
　　(2)对数组越界把握的敏感度；
　　(3)库函数strcpy的工作方式，如果编写一个标准strcpy函数的总分值为10，下面给出几个不同得分的答案：
　　2分
void strcpy( char *strDest, char *strSrc )
{
　 while( (*strDest++ = * strSrc++) != ‘\0’ );
}

　　4分
void strcpy( char *strDest, const char *strSrc ) 
//将源字符串加const，表明其为输入参数，加2分
{
　 while( (*strDest++ = * strSrc++) != ‘\0’ );
}

　　7分
void strcpy(char *strDest, const char *strSrc) 
{
　//对源地址和目的地址加非0断言，加3分
　assert( (strDest != NULL) && (strSrc != NULL) );
　while( (*strDest++ = * strSrc++) != ‘\0’ );
}

　　10分
//为了实现链式操作，将目的地址返回，加3分！

char * strcpy( char *strDest, const char *strSrc ) 
{
　assert( (strDest != NULL) && (strSrc != NULL) );
　char *address = strDest; 
　while( (*strDest++ = * strSrc++) != ‘\0’ ); 
　　return address;
}

　　从2分到10分的几个答案我们可以清楚的看到，小小的strcpy竟然暗藏着这么多玄机，真不是盖的！需要多么扎实的基本功才能写一个完美的strcpy啊！
　　(4)对strlen的掌握，它没有包括字符串末尾的'\0'。
　　读者看了不同分值的strcpy版本，应该也可以写出一个10分的strlen函数了，完美的版本为： int strlen( const char *str ) //输入参数const
{
　assert( strt != NULL ); //断言字符串地址非0
　int len;
　while( (*str++) != '\0' ) 
　{ 
　　len++; 
　} 
　return len;
}

　　试题4：
void GetMemory( char *p )
{
　p = (char *) malloc( 100 );
}

void Test( void ) 
{
　char *str = NULL;
　GetMemory( str ); 
　strcpy( str, "hello world" );
　printf( str );
}

　　试题5：
char *GetMemory( void )
{ 
　char p[] = "hello world"; 
　return p; 
}

void Test( void )
{ 
　char *str = NULL; 
　str = GetMemory(); 
　printf( str ); 
}

　　试题6：
void GetMemory( char **p, int num )
{
　*p = (char *) malloc( num );
}

void Test( void )
{
　char *str = NULL;
　GetMemory( &str, 100 );
　strcpy( str, "hello" ); 
　printf( str ); 
}

　　试题7：
void Test( void )
{
　char *str = (char *) malloc( 100 );
　strcpy( str, "hello" );
　free( str ); 
　... //省略的其它语句
}

　　解答：
　　试题4传入中GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值，执行完
char *str = NULL;
GetMemory( str ); 
　　后的str仍然为NULL；那应该如何改？？？？？？？？？？？？、
　　试题5中
char p[] = "hello world"; 
return p; 
　　的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。
　　试题6的GetMemory避免了试题4的问题，传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句
*p = (char *) malloc( num );
　　后未判断内存是否申请成功，应加上：
if ( *p == NULL )
{
　...//进行申请内存失败处理
}

　　试题7存在与试题6同样的问题，在执行
char *str = (char *) malloc(100);

　　后未进行内存是否申请成功的判断；另外，在free(str)后未置str为空，导致可能变成一个“野”指针，？？？？？？？应加上：
str = NULL;

　　试题6的Test函数中也未对malloc的内存进行释放。
　　剖析：
　　试题4～7考查面试者对内存操作的理解程度，基本功扎实的面试者一般都能正确的回答其中50~60的错误。但是要完全解答正确，却也绝非易事。
　　对内存操作的考查主要集中在：
　　（1）指针的理解；
　　（2）变量的生存期及作用范围；
　　（3）良好的动态内存申请和释放习惯。
　　再看看下面的一段程序有什么错误：
swap( int* p1,int* p2 )
{
　int *p;// p是一个“野”指针
　*p = *p1;
　*p1 = *p2;
　*p2 = *p;
}

　　在swap函数中，p是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。在VC++中DEBUG运行时提示错误“Access Violation”。该程序应该改为：
swap( int* p1,int* p2 )
{
　int p;
　p = *p1;
　*p1 = *p2;
　*p2 = p;
}

3.内功题
　　试题1：分别给出BOOL，int，float，指针变量 与“零值”比较的 if 语句（假设变量名为var）
　　解答：
　　　BOOL型变量：if(!var)
　　　int型变量： if(var==0)
　　　float型变量：
　　　const float EPSINON = 0.00001;
　　　if ((x >= - EPSINON) && (x <= EPSINON)
　　　指针变量：　　if(var==NULL)
　　剖析：
　　考查对0值判断的“内功”，BOOL型变量的0判断完全可以写成if(var==0)，而int型变量也可以写成if(!var)，指针变量的判断也可以写成if(!var)，上述写法虽然程序都能正确运行，但是未能清晰地表达程序的意思。
　　一般的，如果想让if判断一个变量的“真”、“假”，应直接使用if(var)、if(!var)，表明其为“逻辑”判断；如果用if判断一个数值型变量(short、int、long等)，应该用if(var==0)，表明是与0进行“数值”上的比较；而判断指针则适宜用if(var==NULL)，这是一种很好的编程习惯。
　　浮点型变量并不精确，所以不可将float变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”形式。如果写成if (x == 0.0)，则判为错，得0分。
　　试题2：以下为Windows NT下的32位C++程序，请计算sizeof的值
void Func ( char str[100] )
{
　sizeof( str ) = ?
}

void *p = malloc( 100 );
sizeof ( p ) = ?

　　解答：
sizeof( str ) = 4
sizeof ( p ) = 4

　　剖析：
　　Func ( char str[100] )函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。
　　数组名的本质如下：
　　（1）数组名指代一种数据结构，这种数据结构就是数组；
　　例如：
char str[10];
cout << sizeof(str) << endl;

　　输出结果为10，str指代数据结构char[10]。
　　（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、自减等操作，不能被修改；
char str[10]; 
str++; //编译出错，提示str不是左值　//注意与上面的数组作函数形参区别，讲解如下：

　　（3）数组名作为函数形参时，沦为普通指针。
　　Windows NT 32位平台下，指针的长度（占用内存的大小）为4字节，故sizeof( str ) 、sizeof ( p ) 都为4。
　　试题3：写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。另外，当你写下面的代码时会发生什么事？
least = MIN(*p++, b);
　　解答：
#define MIN(A,B) ((A) <= (B) ? (A) : (B))
　　MIN(*p++, b)会产生宏的副作用
　　剖析：
　　这个面试题主要考查面试者对宏定义的使用，宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进行的是一对一的替换。
　　程序员对宏定义的使用要非常小心，特别要注意两个问题：
　　（1）谨慎地将宏定义中的“参数”和整个宏用括弧括起来。所以，严格地讲，下述解答：
#define MIN(A,B) (A) <= (B) ? (A) : (B)
#define MIN(A,B) (A <= B ? A : B )
　　都应判0分；
　　（2）防止宏的副作用。
　　宏定义#define MIN(A,B) ((A) <= (B) ? (A) : (B))对MIN(*p++, b)的作用结果是：
((*p++) <= (b) ? (*p++) : (*p++))
　　这个表达式会产生副作用，指针p会作三次++自增操作。
　　
　　试题4：为什么标准头文件都有类似以下的结构？ 
#ifndef __INCvxWorksh
#define __INCvxWorksh 
#ifdef __cplusplus

extern "C" {
#endif 
/*...*/ 
#ifdef __cplusplus
}

#endif 
#endif /* __INCvxWorksh */
　　解答：
　　头文件中的编译宏
#ifndef　__INCvxWorksh
#define　__INCvxWorksh
#endif 
　　的作用是防止被重复引用。
　　作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在symbol库中的名字与C语言的不同。例如，假设某个函数的原型为： 
void foo(int x, int y);

　　该函数被C编译器编译后在symbol库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。_foo_int_int这样的名字包含了函数名和函数参数数量及类型信息，C++就是考这种机制来实现函数重载的。
　　为了实现C和C++的混合编程，C++提供了C连接交换指定符号extern "C"来解决名字匹配问题，函数声明前加上extern "C"后，则编译器就会按照C语言的方式将该函数编译为_foo，这样C语言中就可以调用C++的函数了。
试题5：编写一个函数，作用是把一个char组成的字符串循环右移n个。比如原来是“abcdefghi”如果n=2，移位后应该是“hiabcdefgh” 
　　函数头是这样的：
//pStr是指向以'\0'结尾的字符串的指针
//steps是要求移动的n

void LoopMove ( char * pStr, int steps )
{
　//请填充...
}

　　解答：
　　正确解答1：
void LoopMove ( char *pStr, int steps )
{
　int n = strlen( pStr ) - steps;
　char tmp[MAX_LEN]; //这是何物啊？？重新定义一个中间数组 
　strcpy ( tmp, pStr + n );把后n位复制给tmp 
　strcpy ( tmp + steps, pStr);把pstr复制给tmp,从steps位开始
　*( tmp + strlen ( pStr ) ) = '\0';截取strlen()长度，
　strcpy( pStr, tmp );
}

　　正确解答2：
void LoopMove ( char *pStr, int steps )
{
　int n = strlen( pStr ) - steps;
　char tmp[MAX_LEN]; 
　memcpy( tmp, pStr + n, steps ); 将后steps位复制给tmp
　memcpy(pStr + steps, pStr, n ); 
　memcpy(pStr, tmp, steps ); 
}

　　剖析：
　　这个试题主要考查面试者对标准库函数的熟练程度，在需要的时候引用库函数可以很大程度上简化程序编写的工作量。
　　最频繁被使用的库函数包括：
　　（1） strcpy
　　（2） memcpy
　　（3） memset
　　试题6：已知WAV文件格式如下表，打开一个WAV文件，以适当的数据结构组织WAV文件头并解析WAV格式的各项信息。
　　WAVE文件格式说明表
 
偏移地址
字节数
数据类型
内 容
文件头 
 
00H
4 
Char
"RIFF"标志

04H
4
int32
文件长度

08H
4
Char
"WAVE"标志

0CH
4
Char
"fmt"标志

10H
4
 
过渡字节（不定）

14H
2
int16
格式类别

16H
2
int16
通道数

18H
2
int16 
采样率（每秒样本数），表示每个通道的播放速度

1CH
4
int32
波形音频数据传送速率

20H
2
int16
数据块的调整数（按字节算的）

22H
2
 
每样本的数据位数

24H
4
Char
数据标记符＂data＂

28H
4
int32
语音数据的长度

　　解答：
　　将WAV文件格式定义为结构体WAVEFORMAT： 
typedef struct tagWaveFormat
{ 
　char cRiffFlag[4]; 
　UIN32 nFileLen; 
　char cWaveFlag[4]; 
　char cFmtFlag[4]; 
　char cTransition[4]; 
　UIN16 nFormatTag ; 
　UIN16 nChannels; 
　UIN16 nSamplesPerSec; 
　UIN32 nAvgBytesperSec; 
　UIN16 nBlockAlign; 
　UIN16 nBitNumPerSample; 
　char cDataFlag[4]; 
　UIN16 nAudioLength; 

} WAVEFORMAT;

　　假设WAV文件内容读出后存放在指针buffer开始的内存单元内，则分析文件格式的代码很简单，为：
WAVEFORMAT waveFormat;
memcpy( &waveFormat, buffer,sizeof( WAVEFORMAT ) ); 

　　直接通过访问waveFormat的成员，就可以获得特定WAV文件的各项格式信息。
　　剖析：
　　试题6考查面试者组织数据结构的能力，有经验的程序设计者将属于一个整体的数据成员组织为一个结构体，利用指针类型转换，可以将memcpy、memset等函数直接用于结构体地址，进行结构体的整体操作。 透过这个题可以看出面试者的程序设计经验是否丰富。
　　试题7：编写类String的构造函数、析构函数和赋值函数，已知类String的原型为：?????????????????????????????????????????????????
已经封装的文件中写的程序
class String
{ 
　public: 
　　String(const char *str = NULL); // 普通构造函数 
　　String(const String &other); // 拷贝构造函数 
　　~ String(void); // 析构函数 
　　String & operate =(const String &other); // 赋值函数 
　private: 
　　char *m_data; // 用于保存字符串 
};

　　解答：
这是在实现文件中编写的程序
//普通构造函数
String::String(const char *str) 
{
　if(str==NULL) 
　{
　　m_data = new char[1]; // 得分点：对空字符串自动申请存放结束标志'\0'的空
　　//加分点：对m_data加NULL 判断
　　*m_data = '\0'; 
　} 
　else
　{
　　int length = strlen(str); 
　　m_data = new char[length+1]; // 若能加 NULL 判断则更好 
　　strcpy(m_data, str); 
　}
}
// String的析构函数
String::~String(void) 
{
　delete [] m_data; // 或delete m_data;
}
//拷贝构造函数
String::String(const String &other) 　　　// 得分点：输入参数为const型
{ 
　int length = strlen(other.m_data); 
　m_data = new char[length+1]; 　　　　//加分点：对m_data加NULL 判断
　strcpy(m_data, other.m_data); 
}
//赋值函数
String & String::operate =(const String &other) // 得分点：输入参数为const型
{ 
　if(this == &other) 　　//得分点：检查自赋值
　　return *this; 
　delete [] m_data; 　　　　//得分点：释放原有的内存资源
　int length = strlen( other.m_data ); 
　m_data = new char[length+1]; //加分点：对m_data加NULL 判断
　strcpy( m_data, other.m_data ); 
　return *this; 　　　　　　　　//得分点：返回本对象的引用
}

　　剖析：
　　能够准确无误地编写出String类的构造函数、拷贝构造函数、赋值函数和析构函数的面试者至少已经具备了C++基本功的60%以上！
　　在这个类中包括了指针类成员变量m_data，当类中包括指针类成员变量时，一定要重载其拷贝构造函数、赋值函数和析构函数，这既是对C++程序员的基本要求，也是《Effective　C++》中特别强调的条款。
　　仔细学习这个类，特别注意加注释的得分点和加分点的意义，这样就具备了60%以上的C++基本功！
　　　　const关键字至少有下列n个作用：
　　（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
　　（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
　　（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
　　（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
　　（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：
const classA operator*(const classA& a1,const classA& a2);

　　operator*的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：
classA a, b, c;
(a * b) = c; // 对a*b的结果赋值

　　操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。、
　　4.技巧题
　　试题1：请写一个C函数，若处理器是Big_endian的，则返回0；若是Little_endian的，则返回1
　　解答：
int checkCPU()
{
　{
　　union w
　　{ 
　　　int a;
　　　char b;
　　} c;
　　c.a = 1;0X00 00 00 01四个字节，c.b为一个字节
　　return (c.b == 1);大端的c.b为00，小端的c.b为01？？？？
　}//因为联合体共用一个空间
}

　　剖析：
　　嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。采用Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。例如，16bit宽的数0x1234在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
内存地址
存放内容
0x4000
0x34
0x4001
0x12

　　而在Big-endian模式CPU内存中的存放方式则为：
内存地址
存放内容
0x4000
0x12
0x4001
0x34

　　32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
内存地址
存放内容
0x4000
0x78
0x4001
0x56
0x4002
0x34
0x4003
0x12

　　而在Big-endian模式CPU内存中的存放方式则为：
内存地址
存放内容
0x4000
0x12
0x4001
0x34
0x4002
0x56
0x4003
0x78

　　联合体union的存放顺序是所有成员都从低地址开始存放，面试者的解答利用该特性，轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写。如果谁能当场给出这个解答，那简直就是一个天才的程序员。
　　试题2：写一个函数返回1+2+3+…+n的值（假定结果不会超过长整型变量的范围） 
　　解答：
int Sum( int n )
{ 
　return ( (long)1 + n) * n / 2;　　//或return (1l + n) * n / 2;
}

　　剖析：
　　对于这个题，只能说，也许最简单的答案就是最好的答案。下面的解答，或者基于下面的解答思路去优化，不管怎么“折腾”，其效率也不可能与直接return ( 1 l + n ) * n / 2相比！ 
int Sum( int n )
{
　long sum = 0;
　for( int i=1; i<=n; i++ )
　{
　　sum += i;
　}
　return sum;
} 

　　
volatile关键字的作用
volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。下面举例说明。在DSP开发中，经常需要等待某个事件的触发，所以经常会写出这样的程序：
short flag;
void test()
{
do1();
while(flag==0);
do2();
}这段程序等待内存变量flag的值变为1(怀疑此处是0,有点疑问,)之后才运行do2()。变量flag的值由别的程序更改，这个程序可能是某个硬件中断服务程序。例如：如果某个按钮按下的话，就会对DSP产生中断，在按键中断程序中修改flag为1，这样上面的程序就能够得以继续运行。但是，编译器并不知道flag的值会被别的程序修改，因此在它进行优化的时候，可能会把flag的值先读入某个寄存器，然后等待那个寄存器变为1。如果不幸进行了这样的优化，那么while循环就变成了死循环，因为寄存器的内容不可能被中断服务程序修改。为了让程序每次都读取真正flag变量的值，就需要定义为如下形式：
volatile short flag;
需要注意的是，没有volatile也可能能正常运行，但是可能修改了编译器的优化级别之后就又不能正常运行了。因此经常会出现debug版本正常，但是release版本却不能正常的问题。所以为了安全起见，只要是等待别的程序修改某个变量的话，就加上volatile关键字。

C语言void及void指针深层探索

　　1、void的含义
　　void的字面意思是“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据。
　　void几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个void变量，让我们试着来定义：
void a;
　　这行语句编译时会出错，提示“illegal use of type 'void'”。不过，即使void a的编译不会出错，它也没有任何实际意义。
　　void真正发挥的作用在于：
　　（1） 对函数返回的限定；
　　（2） 对函数参数的限定。
　　我们将在第三节对以上二点进行具体说明。
　　众所周知，如果指针p1和p2的类型相同，那么我们可以直接在p1和p2间互相赋值；如果p1和p2指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。 
　　例如：
float *p1;
int *p2;
p1 = p2;
　　其中p1 = p2语句会编译出错，提示“'=' : cannot convert from 'int *' to 'float *'”，必须改为：
p1 = (float *)p2;
　　而void *则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换：
void *p1;
int *p2;
p1 = p2;
　　但这并不意味着，void *也可以无需强制类型转换地赋给其它类型的指针。因为“无类型”可以包容“有类型”，而“有类型”则不能包容“无类型”。道理很简单，我们可以说“男人和女人都是人”，但不能说“人是男人”或者“人是女人”。下面的语句编译出错：
void *p1;
int *p2;
p2 = p1;
　　提示“'=' : cannot convert from 'void *' to 'int *'”。
3.void的使用
　　下面给出void关键字的使用规则：
　　规则一 如果函数没有返回值，那么应声明为void类型
　　在C语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理。但是许多程序员却误以为其为void类型。例如：
add ( int a, int b )
{
return a + b;
}
int main(int argc, char* argv[])
{
printf ( "2 + 3 = %d", add ( 2, 3) );
}
　　程序运行的结果为输出：
　　2 + 3 = 5
　　这说明不加返回值说明的函数的确为int函数。
　　林锐博士《高质量C/C++编程》中提到：“C++语言有很严格的类型安全检查，不允许上述情况（指函数不加类型声明）发生”。可是编译器并不一定这么认定，譬如在Visual C++6.0中上述add函数的编译无错也无警告且运行正确，所以不能寄希望于编译器会做严格的类型检查。
　　因此，为了避免混乱，我们在编写C/C++程序时，对于任何函数都必须一个不漏地指定其类型。如果函数没有返回值，一定要声明为void类型。这既是程序良好可读性的需要，也是编程规范性的要求。另外，加上void类型声明后，也可以发挥代码的“自注释”作用。代码的“自注释”即代码能自己注释自己。
　　规则二 如果函数无参数，那么应声明其参数为void
　　在C++语言中声明一个这样的函数：
int function(void)
{
return 1;
}
　　则进行下面的调用是不合法的：
function(2);
　　因为在C++中，函数参数为void的意思是这个函数不接受任何参数。
　　我们在Turbo C 2.0中编译：
＃i nclude "stdio.h"
fun()
{
return 1;
}
main()
{
printf("%d",fun(2));
getchar();
}
　　编译正确且输出1，这说明，在C语言中，可以给无参数的函数传送任意类型的参数，但是在C++编译器中编译同样的代码则会出错。在C++中，不能向无参数的函数传送任何参数，出错提示“'fun' : function does not take 1 parameters”。
　　所以，无论在C还是C++中，若函数不接受任何参数，一定要指明参数为void。
　　规则三 小心使用void指针类型
　　按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即下列操作都是不合法的：
void * pvoid;
pvoid++; //ANSI：错误
pvoid += 1; //ANSI：错误
//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。
//例如：
int *pint;
pint++; //ANSI：正确
　　pint++的结果是使其增大sizeof(int)。
　　但是大名鼎鼎的GNU(GNU's Not Unix的缩写)则不这么认定，它指定void *的算法操作与char *一致。
　　因此下列语句在GNU编译器中皆正确：
pvoid++; //GNU：正确
pvoid += 1; //GNU：正确
　　pvoid++的执行结果是其增大了1。
　　在实际的程序设计中，为迎合ANSI标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：
void * pvoid;
(char *)pvoid++; //ANSI：正确；GNU：正确
(char *)pvoid += 1; //ANSI：错误；GNU：正确
　　GNU和ANSI还有一些区别，总体而言，GNU较ANSI更“开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合ANSI标准。
　　规则四 如果函数的参数可以是任意类型指针，那么应声明其参数为void *
　　典型的如内存操作函数memcpy和memset的函数原型分别为：
void * memcpy(void *dest, const void *src, size_t len);
void * memset ( void * buffer, int c, size_t num );
　　这样，任何类型的指针都可以传入memcpy和memset中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。如果memcpy和memset的参数类型不是void *，而是char *，那才叫真的奇怪了！这样的memcpy和memset明显不是一个“纯粹的，脱离低级趣味的”函数！
　　下面的代码执行正确：
//示例：memset接受任意类型指针
int intarray[100];
memset ( intarray, 0, 100*sizeof(int) ); //将intarray清0
//示例：memcpy接受任意类型指针
int intarray1[100], intarray2[100];
memcpy ( intarray1, intarray2, 100*sizeof(int) ); //将intarray2拷贝给intarray1
　　有趣的是，memcpy和memset函数返回的也是void *类型，标准库函数的编写者是多么地富有学问啊！
　　规则五 void不能代表一个真实的变量
　　下面代码都企图让void代表一个真实的变量，因此都是错误的代码：
void a; //错误
function(void a); //错误
　　void体现了一种抽象，这个世界上的变量都是“有类型”的，譬如一个人不是男人就是女人.
　　void的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中“抽象基类”的概念，也很容易理解void数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个void（让我们类比的称void为“抽象数据类型”）变量。
关于CONST的用法
const在C语言中算是一个比较新的描述符，我们称之为常量修饰符，意即其所修饰
的对象为常量(immutable)。
我们来分情况看语法上它该如何被使用。
1、函数体内修饰局部变量。
例：
void func(){
const int a=0;
}
首先，我们先把const这个单词忽略不看，那么a是一个int类型的局部自动变量，
我们给它赋予初始值0。
然后再看const.
const作为一个类型限定词，和int有相同的地位。
const int a;
int const a;
是等价的。于是此处我们一定要清晰的明白，const修饰的对象是谁，是a,和int没
有关系。const 要求他所修饰的对象为常量，不可被改变，不可被赋值，不可作为
左值（l-value)。
这样的写法也是错误的。
const int a;
a=0;
这是一个很常见的使用方式：
const double pi=3.14;
在程序的后面如果企图对pi再次赋值或者修改就会出错。
然后看一个稍微复杂的例子。
const int* p;
还是先去掉const 修饰符号。
注意，下面两个是等价的。
int* p;
int *p;
其实我们想要说的是，*p是int类型。那么显然，p就是指向int的指针。
同理
const int* p;
其实等价于
const int (*p);
int const (*p);
即，*p是常量。也就是说，p指向的数据是常量。
于是
p+=8; //合法
*p=3; //非法，p指向的数据是常量。
那么如何声明一个自身是常量指针呢？方法是让const尽可能的靠近p;
int* const p;
const右面只有p,显然，它修饰的是p,说明p不可被更改。然后把const去掉，可以
看出p是一个指向 int形式变量的指针。
于是
p+=8; //非法
*p=3; //合法
再看一个更复杂的例子，它是上面二者的综合
const int* const p;
说明p自己是常量，且p指向的变量也是常量。
于是
p+=8; //非法
*p=3; //非法
const 还有一个作用就是用于修饰常量静态字符串。
例如：
const char* name="David";
如果没有const,我们可能会在后面有意无意的写name[4]='x'这样的语句，这样会
导致对只读内存区域的赋值，然后程序会立刻异常终止。有了 const,这个错误就
能在程序被编译的时候就立即检查出来，这就是const的好处。让逻辑错误在编译
期被发现。
const 还可以用来修饰数组
const char s[]="David";
与上面有类似的作用。
2、在函数声明时修饰参数
来看实际中的一个例子。
NAME
memmove -- copy byte string
LIBRARY
Standard C Library (libc, -lc)
SYNOPSIS
＃i nclude <string.h>
void *
memmove(void *dst, const void *src, size_t len);
这是标准库中的一个函数，用于按字节方式复制字符串（内存）。
它的第一个参数，是将字符串复制到哪里去（dest),是目的地，这段内存区域必须
是可写。
它的第二个参数，是要将什么样的字符串复制出去，我们对这段内存区域只做读
取，不写。
于是，我们站在这个函数自己的角度来看，src 这个指针，它所指向的内存内所存
储的数据在整个函数执行的过程中是不变。于是src所指向的内容是常量。于是就
需要用const修饰。
例如，我们这里这样使用它。
const char* s="hello";
char buf[100];
memmove(buf,s,6); //这里其实应该用strcpy或memcpy更好
如果我们反过来写，
memmove(s,buf,6);
那么编译器一定会报错。事实是我们经常会把各种函数的参数顺序写反。事实是编
译器在此时帮了我们大忙。如果编译器静悄悄的不报错，(在函数声明处去掉
const即可),那么这个程序在运行的时候一定会崩溃。
这里还要说明的一点是在函数参数声明中const一般用来声明指针而不是变量本身。
例如，上面的size_t len,在函数实现的时候可以完全不用更改len的值，那么是否
应该把len也声明为常量呢？可以，可以这么做。我们来分析这么做有什么优劣。
如果加了const,那么对于这个函数的实现者，可以防止他在实现这个函数的时候修
改不需要修改的值(len),这样很好。
但是对于这个函数的使用者，
1。这个修饰符号毫无意义，我们可以传递一个常量整数或者一个非常量整数过
去，反正对方获得的只是我们传递的一个copy。
2。暴露了实现。我不需要知道你在实现这个函数的时候是否修改过len的值。
所以，const一般只用来修饰指针。
再看一个复杂的例子
int execv(const char *path, char *const argv[]);
着重看后面这个，argv.它代表什么。
如果去掉const,我们可以看出
char * argv[];
argv是一个数组，它的每个元素都是char *类型的指针。
如果加上const.那么const修饰的是谁呢？他修饰的是一个数组，argv[],意思就是
说这个数组的元素是只读的。那么数组的元素的是什么类型呢？是char *类型的指
针.也就是说指针是常量，而它指向的数据不是。
于是
argv[1]=NULL; //非法
argv[0][0]='a'; //合法
3、全局变量。
我们的原则依然是，尽可能少的使用全局变量。
我们的第二条规则 则是，尽可能多的使用const。
如果一个全局变量只在本文件中使用，那么用法和前面所说的函数局部变量没有什
么区别。
如果它要在多个文件间共享，那么就牵扯到一个存储类型的问题。
有两种方式。
1.使用extern
例如
/* file1.h */
extern const double pi;
/* file1.c */
const double pi=3.14;
然后其他需要使用pi这个变量的，包含file1.h
＃i nclude "file1.h"
或者，自己把那句声明复制一遍就好。
这样做的结果是，整个程序链接完后，所有需要使用pi这个变量的共享一个存储区域。
2.使用static,静态外部存储类
/* constant.h */
static const pi=3.14;
需要使用这个变量的*.c文件中，必须包含这个头文件。
前面的static一定不能少。否则链接的时候会报告说该变量被多次定义。
这样做的结果是，每个包含了constant.h的*.c文件，都有一份该变量自己的copy,
该变量实际上还是被定义了多次，占用了多个存储空间，不过在加了static关键字
后，解决了文件间重定义的冲突。
坏处是浪费了存储空间，导致链接完后的可执行文件变大。但是通常，这个，小小
几字节的变化，不是问题。
好处是，你不用关心这个变量是在哪个文件中被初始化的。
最后，说说const的作用。
const 的好处，是引入了常量的概念，让我们不要去修改不该修改的内存。直接的
作用就是让更多的逻辑错误在编译期被发现。所以我们要尽可能的多使用const。
但是很多人并不习惯使用它，更有甚者，是在整个程序 编写／调试 完后才补
const。如果是给函数的声明补const,尚好。如果是给 全局／局部变量补const,那
么……那么，为时已晚，无非是让代码看起来更漂亮了。
c语言中的结构（struct)和联合（union）简介

联     合(union)
  1. 联合说明和联合变量定义
  联合也是一种新的数据类型, 它是一种特殊形式的变量。
  联合说明和联合变量定义与结构十分相似。其形式为:
  union 联合名{
      数据类型成员名;
      数据类型成员名;
      ...
  } 联合变量名;
  联合表示几个变量公用一个内存位置, 在不同的时间保存不同的数据类型 和不同长度的变量。
  下例表示说明一个联合a_bc:
  union a_bc{
      int i;
      char mm;
  };
  再用已说明的联合可定义联合变量。
  例如用上面说明的联合定义一个名为lgc的联合变量, 可写成:
    union a_bc lgc;
  在联合变量lgc中, 整型量i和字符mm公用同一内存位置。
  当一个联合被说明时, 编译程序自动地产生一个变量, 其长度为联合中最大的变量长度。
  联合访问其成员的方法与结构相同。同样联合变量也可以定义成数组或指针,但定义为指针时, 也要用"->;"符号, 此时联合访问成员可表示成:
  联合名->;成员名
  另外, 联合既可以出现在结构内, 它的成员也可以是结构。
  例如:
  struct{
      int age;
      char *addr;
      union{
          int i;
          char *ch;
      }x;
  }y[10];
  若要访问结构变量y[1]中联合x的成员i, 可以写成:
    y[1].x.i;
  若要访问结构变量y[2]中联合x的字符串指针ch的第一个字符可写成:
    *y[2].x.ch;
  若写成"y[2].x.*ch;"是错误的。
  2. 结构和联合的区别
  结构和联合有下列区别:
  1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合转只存放了一个被选中的成员, 而结构的所有成员都存在。
  2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。
  下面举一个例了来加对深联合的理解。
  例4:
main()
{
  union{             /*定义一个联合*/
  int i;
  struct{         /*在联合中定义一个结构*/
        char first;
        char second;
        }half;
  }number;
  number.i=0x4241;       /*联合成员赋值*/
  printf("%c%c\n", number.half.first, mumber.half.second);
  number.half.first='a';   /*联合中结构成员赋值*/
  number.half.second='b';
  printf("%x\n", number.i);
  getch();
}
  输出结果为:
  AB
  6261
  从上例结果可以看出: 当给i赋值后, 其低八位也就是first和second的值;当给first和second赋字符后, 这两个字符的ASCII码也将作为i 的低八位和高八位。
Volatile 关键字告诉编译器不要持有变量的临时性拷贝。一般用在多线程程序中，以避免在其中一个线程操作该变量时，将其拷贝入寄存器。请看以下情形:
    A线程将变量复制入寄存器，然后进入循环，反复检测寄存器的值是否满足一定条件(它期待B线程改变变量的值。
在此种情况下，当B线程改变了变量的值时，已改变的值对其在寄存器的值没有影响。所以A线程进入死循环。
    volatile 就是在此种情况下使用。
堆和栈的区别
一、预备知识—程序的内存分配
    一个由c/C++编译的程序占用的内存分为以下几个部分
    1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
    2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。
    3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放
    4、文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放
    5、程序代码区—存放函数体的二进制代码。

例子程序
这是一个前辈写的，非常详细
//main.cpp
int a = 0; 全局初始化区
char *p1; 全局未初始化区
main()
{
int b; 栈
char s[] = "abc"; 栈
char *p2; 栈
char *p3 = "123456"; 123456\0在常量区，p3在栈上。
static int c =0； 全局（静态）初始化区
p1 = (char *)malloc(10);
p2 = (char *)malloc(20);
分配得来得10和20字节的区域就在堆区。
strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
}


二、堆和栈的理论知识

2.1申请方式
stack:
由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间
heap:
需要程序员自己申请，并指明大小，在c中malloc函数
如p1 = (char *)malloc(10);
在C++中用new运算符
如p2 = (char *)malloc(10);
但是注意p1、p2本身是在栈中的。

2.2申请后系统的响应
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

2.4申请效率的比较
栈由系统自动分配，速度较快。但程序员是无法控制的。
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。

2.5堆和栈中的存储内容
栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

2.6存取效率的比较
char s1[] = "aaaaaaaaaaaaaaa";
char *s2 = "bbbbbbbbbbbbbbbbb";
aaaaaaaaaaa是在运行时刻赋值的；
而bbbbbbbbbbb是在编译时就确定的；
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。
比如：
＃i nclude
void main()
{
char a = 1;
char c[] = "1234567890";
char *p ="1234567890";
a = c[1];
a = p[1];
return;
}
对应的汇编代码
10: a = c[1];
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]
0040106A 88 4D FC mov byte ptr [ebp-4],cl
11: a = p[1];
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]
00401070 8A 42 01 mov al,byte ptr [edx+1]
00401073 88 45 FC mov byte ptr [ebp-4],al
第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。

2.7小结
堆和栈的区别可以用如下的比喻来看出：
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。



windows进程中的内存结构


在阅读本文之前，如果你连堆栈是什么多不知道的话，请先阅读文章后面的基础知识。

接触过编程的人都知道，高级语言都能通过变量名来访问内存中的数据。那么这些变量在内存中是如何存放的呢？程序又是如何使用这些变量的呢？下面就会对此进行深入的讨论。下文中的C语言代码如没有特别声明，默认都使用VC编译的release版。

首先，来了解一下 C 语言的变量是如何在内存分部的。C 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码：

＃i nclude <stdio.h>

int g1=0, g2=0, g3=0;

int main()
{
static int s1=0, s2=0, s3=0;
int v1=0, v2=0, v3=0;

//打印出各个变量的内存地址

printf("0x%08x\n",&v1); //打印各本地变量的内存地址
printf("0x%08x\n",&v2);
printf("0x%08x\n\n",&v3);
printf("0x%08x\n",&g1); //打印各全局变量的内存地址
printf("0x%08x\n",&g2);
printf("0x%08x\n\n",&g3);
printf("0x%08x\n",&s1); //打印各静态变量的内存地址
printf("0x%08x\n",&s2);
printf("0x%08x\n\n",&s3);
return 0;
}

编译后的执行结果是：

0x0012ff78
0x0012ff7c
0x0012ff80

0x004068d0
0x004068d4
0x004068d8

0x004068dc
0x004068e0
0x004068e4

输出的结果就是变量的内存地址。其中v1,v2,v3是本地变量，g1,g2,g3是全局变量，s1,s2,s3是静态变量。你可以看到这些变量在内存是连续分布的，但是本地变量和全局变量分配的内存地址差了十万八千里，而全局变量和静态变量分配的内存是连续的。这是因为本地变量和全局/静态变量是分配在不同类型的内存区域中的结果。对于一个进程的内存空间而言，可以在逻辑上分成3个部份：代码区，静态数据区和动态数据区。动态数据区一般就是“堆栈”。“栈 (stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址”和“栈顶”地址来描述。全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区，即堆栈中。程序通过堆栈的基地址和偏移量来访问本地变量。


├———————┤低端内存区域
│ …… │
├———————┤
│ 动态数据区 │
├———————┤
│ …… │
├———————┤
│ 代码区 │
├———————┤
│ 静态数据区 │
├———————┤
│ …… │
├———————┤高端内存区域


堆栈是一个先进后出的数据结构，栈顶地址总是小于等于栈的基地址。我们可以先了解一下函数调用的过程，以便对堆栈在程序中的作用有更深入的了解。不同的语言有不同的函数调用规定，这些因素有参数的压入规则和堆栈的平衡。windows API的调用规则和ANSI C的函数调用规则是不一样的，前者由被调函数调整堆栈，后者由调用者调整堆栈。两者通过“__stdcall”和“__cdecl”前缀区分。先看下面这段代码：

＃i nclude <stdio.h>

void __stdcall func(int param1,int param2,int param3)
{
int var1=param1;
int var2=param2;
int var3=param3;
printf("0x%08x\n",?m1); //打印出各个变量的内存地址
printf("0x%08x\n",?m2);
printf("0x%08x\n\n",?m3);
printf("0x%08x\n",&var1);
printf("0x%08x\n",&var2);
printf("0x%08x\n\n",&var3);
return;
}

int main()
{
func(1,2,3);
return 0;
}

编译后的执行结果是：

0x0012ff78
0x0012ff7c
0x0012ff80

0x0012ff68
0x0012ff6c
0x0012ff70


├———————┤<—函数执行时的栈顶（ESP）、低端内存区域
│ …… │
├———————┤
│ var 1 │
├———————┤
│ var 2 │
├———————┤
│ var 3 │
├———————┤
│ RET │
├———————┤<—“__cdecl”函数返回后的栈顶（ESP）
│ parameter 1 │
├———————┤
│ parameter 2 │
├———————┤
│ parameter 3 │
├———————┤<—“__stdcall”函数返回后的栈顶（ESP）
│ …… │
├———————┤<—栈底（基地址 EBP）、高端内存区域


上图就是函数调用过程中堆栈的样子了。首先，三个参数以从又到左的次序压入堆栈，先压“param3”，再压“param2”，最后压入“param1”；然后压入函数的返回地址(RET)，接着跳转到函数地址接着执行（这里要补充一点，介绍UNIX下的缓冲溢出原理的文章中都提到在压入RET后，继续压入当前EBP，然后用当前ESP代替EBP。然而，有一篇介绍windows下函数调用的文章中说，在windows下的函数调用也有这一步骤，但根据我的实际调试，并未发现这一步，这还可以从param3和var1之间只有4字节的间隙这点看出来）；第三步，将栈顶(ESP)减去一个数，为本地变量分配内存空间，上例中是减去12字节(ESP=ESP-3*4，每个int变量占用4个字节)；接着就初始化本地变量的内存空间。由于“__stdcall”调用由被调函数调整堆栈，所以在函数返回前要恢复堆栈，先回收本地变量占用的内存(ESP=ESP+3*4)，然后取出返回地址，填入EIP寄存器，回收先前压入参数占用的内存(ESP=ESP+3*4)，继续执行调用者的代码。参见下列汇编代码：

;--------------func 函数的汇编代码-------------------

:00401000 83EC0C sub esp, 0000000C //创建本地变量的内存空间
:00401003 8B442410 mov eax, dword ptr [esp+10]
:00401007 8B4C2414 mov ecx, dword ptr [esp+14]
:0040100B 8B542418 mov edx, dword ptr [esp+18]
:0040100F 89442400 mov dword ptr [esp], eax
:00401013 8D442410 lea eax, dword ptr [esp+10]
:00401017 894C2404 mov dword ptr [esp+04], ecx

……………………（省略若干代码）

:00401075 83C43C add esp, 0000003C ;恢复堆栈，回收本地变量的内存空间
:00401078 C3 ret 000C ;函数返回，恢复参数占用的内存空间
;如果是“__cdecl”的话，这里是“ret”，堆栈将由调用者恢复

;-------------------函数结束-------------------------


;--------------主程序调用func函数的代码--------------

:00401080 6A03 push 00000003 //压入参数param3
:00401082 6A02 push 00000002 //压入参数param2
:00401084 6A01 push 00000001 //压入参数param1
:00401086 E875FFFFFF call 00401000 //调用func函数
;如果是“__cdecl”的话，将在这里恢复堆栈，“add esp, 0000000C”

聪明的读者看到这里，差不多就明白缓冲溢出的原理了。先来看下面的代码：

＃i nclude <stdio.h>
＃i nclude <string.h>

void __stdcall func()
{
char lpBuff[8]="\0";
strcat(lpBuff,"AAAAAAAAAAA");
return;
}

int main()
{
func();
return 0;
}

编译后执行一下回怎么样？哈，“"0x00414141"指令引用的"0x00000000"内存。该内存不能为"read"。”，“非法操作”喽！ "41"就是"A"的16进制的ASCII码了，那明显就是strcat这句出的问题了。"lpBuff"的大小只有8字节，算进结尾的\0，那 strcat最多只能写入7个"A"，但程序实际写入了11个"A"外加1个\0。再来看看上面那幅图，多出来的4个字节正好覆盖了RET的所在的内存空间，导致函数返回到一个错误的内存地址，执行了错误的指令。如果能精心构造这个字符串，使它分成三部分，前一部份仅仅是填充的无意义数据以达到溢出的目的，接着是一个覆盖RET的数据，紧接着是一段shellcode，那只要着个RET地址能指向这段shellcode的第一个指令，那函数返回时就能执行shellcode了。但是软件的不同版本和不同的运行环境都可能影响这段shellcode在内存中的位置，那么要构造这个RET是十分困难的。一般都在RET和shellcode之间填充大量的NOP指令，使得exploit有更强的通用性。


├———————┤<—低端内存区域
│ …… │
├———————┤<—由exploit填入数据的开始
│ │
│ buffer │<—填入无用的数据
│ │
├———————┤
│ RET │<—指向shellcode，或NOP指令的范围
├———————┤
│ NOP │
│ …… │<—填入的NOP指令，是RET可指向的范围
│ NOP │
├———————┤
│ │
│ shellcode │
│ │
├———————┤<—由exploit填入数据的结束
│ …… │
├———————┤<—高端内存区域


windows下的动态数据除了可存放在栈中，还可以存放在堆中。了解C++的朋友都知道，C++可以使用new关键字来动态分配内存。来看下面的C++代码：

＃i nclude <stdio.h>
＃i nclude <iostream.h>
＃i nclude <windows.h>

void func()
{
char *buffer=new char[128];
char bufflocal[128];
static char buffstatic[128];
printf("0x%08x\n",buffer); //打印堆中变量的内存地址
printf("0x%08x\n",bufflocal); //打印本地变量的内存地址
printf("0x%08x\n",buffstatic); //打印静态变量的内存地址
}

void main()
{
func();
return;
}

程序执行结果为：

0x004107d0
0x0012ff04
0x004068c0

可以发现用new关键字分配的内存即不在栈中，也不在静态数据区。VC编译器是通过windows下的“堆(heap)”来实现new关键字的内存动态分配。在讲“堆”之前，先来了解一下和“堆”有关的几个API函数：

HeapAlloc 在堆中申请内存空间
HeapCreate 创建一个新的堆对象
HeapDestroy 销毁一个堆对象
HeapFree 释放申请的内存
HeapWalk 枚举堆对象的所有内存块
GetProcessHeap 取得进程的默认堆对象
GetProcessHeaps 取得进程所有的堆对象
LocalAlloc
GlobalAlloc

当进程初始化时，系统会自动为进程创建一个默认堆，这个堆默认所占内存的大小为1M。堆对象由系统进行管理，它在内存中以链式结构存在。通过下面的代码可以通过堆动态申请内存空间：

HANDLE hHeap=GetProcessHeap();
char *buff=HeapAlloc(hHeap,0,8);

其中hHeap是堆对象的句柄，buff是指向申请的内存空间的地址。那这个hHeap究竟是什么呢？它的值有什么意义吗？看看下面这段代码吧：

#pragma comment(linker,"/entry:main") //定义程序的入口
＃i nclude <windows.h>

_CRTIMP int (__cdecl *printf)(const char *, ...); //定义STL函数printf
/*---------------------------------------------------------------------------
写到这里，我们顺便来复习一下前面所讲的知识：
(*注)printf函数是C语言的标准函数库中函数，VC的标准函数库由msvcrt.dll模块实现。
由函数定义可见，printf的参数个数是可变的，函数内部无法预先知道调用者压入的参数个数，函数只能通过分析第一个参数字符串的格式来获得压入参数的信息，由于这里参数的个数是动态的，所以必须由调用者来平衡堆栈，这里便使用了__cdecl调用规则。BTW，Windows系统的API函数基本上是 __stdcall调用形式，只有一个API例外，那就是wsprintf，它使用__cdecl调用规则，同printf函数一样，这是由于它的参数个数是可变的缘故。
---------------------------------------------------------------------------*/
void main()
{
HANDLE hHeap=GetProcessHeap();
char *buff=HeapAlloc(hHeap,0,0x10);
char *buff2=HeapAlloc(hHeap,0,0x10);
HMODULE hMsvcrt=LoadLibrary("msvcrt.dll");
printf=(void *)GetProcAddress(hMsvcrt,"printf");
printf("0x%08x\n",hHeap);
printf("0x%08x\n",buff);
printf("0x%08x\n\n",buff2);
}

执行结果为：

0x00130000
0x00133100
0x00133118

hHeap 的值怎么和那个buff的值那么接近呢？其实hHeap这个句柄就是指向HEAP首部的地址。在进程的用户区存着一个叫PEB(进程环境块)的结构，这个结构中存放着一些有关进程的重要信息，其中在PEB首地址偏移0x18处存放的ProcessHeap就是进程默认堆的地址，而偏移0x90处存放了指向进程所有堆的地址列表的指针。windows有很多API都使用进程的默认堆来存放动态数据，如windows 2000下的所有ANSI版本的函数都是在默认堆中申请内存来转换ANSI字符串到Unicode字符串的。对一个堆的访问是顺序进行的，同一时刻只能有一个线程访问堆中的数据，当多个线程同时有访问要求时，只能排队等待，这样便造成程序执行效率下降。

最后来说说内存中的数据对齐。所位数据对齐，是指数据所在的内存地址必须是该数据长度的整数倍，DWORD数据的内存起始地址能被4除尽，WORD数据的内存起始地址能被2除尽，x86 CPU能直接访问对齐的数据，当他试图访问一个未对齐的数据时，会在内部进行一系列的调整，这些调整对于程序来说是透明的，但是会降低运行速度，所以编译器在编译程序时会尽量保证数据对齐。同样一段代码，我们来看看用VC、Dev-C++和lcc三个不同编译器编译出来的程序的执行结果：

＃i nclude <stdio.h>

int main()
{
int a;
char b;
int c;
printf("0x%08x\n",&a);
printf("0x%08x\n",&b);
printf("0x%08x\n",&c);
return 0;
}

这是用VC编译后的执行结果：
0x0012ff7c
0x0012ff7b
0x0012ff80
变量在内存中的顺序：b(1字节)-a(4字节)-c(4字节)。

这是用Dev-C++编译后的执行结果：
0x0022ff7c
0x0022ff7b
0x0022ff74
变量在内存中的顺序：c(4字节)-中间相隔3字节-b(占1字节)-a(4字节)。

这是用lcc编译后的执行结果：
0x0012ff6c
0x0012ff6b
0x0012ff64
变量在内存中的顺序：同上。

三个编译器都做到了数据对齐，但是后两个编译器显然没VC“聪明”，让一个char占了4字节，浪费内存哦。


基础知识：
堆栈是一种简单的数据结构，是一种只允许在其一端进行插入或删除的线性表。允许插入或删除操作的一端称为栈顶，另一端称为栈底，对堆栈的插入和删除操作被称为入栈和出栈。有一组CPU指令可以实现对进程的内存实现堆栈访问。其中，POP指令实现出栈操作，PUSH指令实现入栈操作。CPU的ESP寄存器存放当前线程的栈顶指针，EBP寄存器中保存当前线程的栈底指针。CPU的EIP寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从 EIP寄存器中读取下一条指令的内存地址，然后继续执行。 
 <br>
堆（Heap）栈（Stack） 
1、内存分配方面： 
    堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下：new、malloc、delete、free等等。 
    栈：由编译器(Compiler)自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 
2、申请方式方面： 
    堆：需要程序员自己申请，并指明大小。在c中malloc函数如p1 = (char *)malloc(10)；在C++中用new运算符，但是注意p1、p2本身是在栈中的。因为他们还是可以认为是局部变量。 
    栈：由系统自动分配。 例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。 
3、系统响应方面： 
    堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 
    栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 
4、大小限制方面： 
    堆：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 
    栈：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 
5、效率方面： 
    堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。 
    栈：由系统自动分配，速度较快。但程序员是无法控制的。 
6、存放内容方面： 
    堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 
    栈：在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈，然后是函数中的局部变量。 注意: 静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
7、存取效率方面： 
    堆：char *s1 = "Hellow Word"；是在编译时就确定的； 
    栈：char s1[] = "Hellow Word"； 是在运行时赋值的；用数组比用指针速度要快一些，因为指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上直接读取。


suningin详解笔试面试题（6）－－moto笔试
10月21号moto的笔试是在我们学校举行的，120分钟的笔试时间，试题内容大致涵盖了c/c++，数据库，数字通信，IQ等方面。我自我感觉做的很顺利，至少两道编程题我都搞定了。一个多小时就把试题做完了，于是，我就把一些试题偷偷抄到了草稿纸上，回去和大家一齐分享。下面就是我抄回来的试题：
1。打印如下图案，共19行，只能有一个for循环（程序已经提供）
         *          
        ***         
       *****        
      *******       
     *********      
    ***********
   *************    
  ***************   
  ***************** 
******************* 
  ***************** 
  ***************   
   *************    
    ***********     
     *********      
      *******       
       *****        
        ***         
         *          
for(i=0;i<19;i++)
{
}
在网上搜寻了些解答，如下：
1.
#include<iostream>
#include<iomanip>
#include<string>
using namespace std;
int main()
{
 int a[2]={-1,1};
 string str="*******************";
 int i=0,j=9,t=1;
 for(i=0;i<19;++i)
 {
  j+=a[i<10];
  if(i!=0)t=t+a[i<10]*2;
  cout<<setw(j)<<right<<str.substr(0,t)<<endl;
 }
 return 0;
} 

2.
#include<stdio.h>
#include<string.h> 
int main()
{
 char * tempStr = "*******************";
 char * blank = " ";
 int i = 0;
 char * dataStr [20];
 char blankstr[10];

 for ( i=0; i<19; i++)
 {
  memset(dataStr, 0, 20);
  memset(blankstr,0,10);
  if (i<10)
  {
   memcpy(blankstr,blank,9-i);
   memcpy(dataStr, tempStr, (i+1)*2-1);
  }
  else
  {
   memcpy(blankstr,blank,i-9);
   memcpy(dataStr, tempStr, (19-i)*2-1);
  }
  printf("%s",blankstr);
  printf("%s\n", dataStr);
 }
 return 0;
} 
3。
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define MAXSIZE 19
void main()
{
    int i,k;
   char ch;
   char format[30],stars[30],tmp[3];
   ch = '*';
   strcpy(stars,"");
   for(i=0; i<MAXSIZE; i++)
  {
      if(i <= MAXSIZE/2)
     {
         k = (MAXSIZE + 1)/2 - i;
         strcpy(format,"%");
         itoa(k,tmp,10);
        strcat(format,tmp);
        strcat(format,"c");
        if(i>0)
           {
                strcat(stars,"**");
                strcat(format,stars);
            }
         printf(format,ch);
         printf("\n");
      }
     else
     {
         k = i + 2 - (MAXSIZE + 1)/2;
         strcpy(format,"%");
         itoa(k,tmp,10);
        strcat(format,tmp);
        strcat(format,"c");
        stars[MAXSIZE -1 -(2*(i+1) - MAXSIZE -1)] = 0;
         strcat(format,stars);
        printf(format,ch);
        printf("\n");
     }
 }
 //getchar();
 //getchar();
}
 
注:printf格式%mc表示输入字符宽度为m位,左边补空格.

4。
有高人发的回帖:
#include<iostream.h>
int main(int argv,int * argc[])
{
 for(int i=0;i<19;i++)
 {
  static char cc[19] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};
        //19个空格
  static const int j = 19 / 2;   //j值为9
        static int count = 0;          //count为离中间元素的距离
        if( i < ( 19 / 2 + 1)) 
  {
          cc[j - count] = '*';
          cc[j + count] = '*';
          cout << cc << endl;
          count++;
  } 
  else 
  {
          count--;
          cc[j - count] = ' ';
          cc[j + count] = ' ';
          cout << cc << endl;
  }
 }
 return 0;
}
 
一看就知差距,我的晦涩难懂
我想用两个数组,一个存放空格数量,一个存放'*'
但是下面这个程序只用了一个数组，把每一行输出的形状存到数组中，妙！我咋就没想到？！

2.
void fun(int x)
{
 if(x/2>0)fun(x/2);
 printf("%d",x);
}
求fun(10)的输出结果     //12510，一个递归，很简单的
3。
#define f1(n) (n)*(n)
         int i=5;
 int k=0;
 k=f1(i++);
 printf("%d %d",i,k);
输出结果：  ：// 7 25，++放后面是后算的
4。下面那个for循环是无限循环？
for(int i=010;i==10;i+=0)       //这个明显不是，010等于8，8 != 10，一判断就出去了
for(int i=10;(i++^--i)==0;i+=0)   //无限循环
还有几个忘了
5.Email relay 和Email access分别用了什么协议？（其他还有很多，略）
SMTP,POP3
注: SMTP：Simple MAIL Transfer Protocol，简单邮件传输协议，互联网上的电子邮件发送就是使用这个协议。SMTP open relay host：开放的SMTP中继主机——它很可能被恶意的人利用，来产生大量垃圾邮件.
POP3协议允许客户机通过（临时的或永久的）TCP/IP连接或其他网络协议的连接，从一个服务器（这时就称为POP3服务器）上获取电子邮件（E-MAIL），POP3不负责发送邮件.

6。in a mobile phone,软件运行期，stack data 存在于
a.rom,b.flash c.eeprom d.ram e.none of the above
答：D.ram。这题稍微涉及到一点硬件知识，ROM的全称是Read Only Memory，即只读存储器，flash ，eeprom都是ROM家族的一员，RAM是Random Access Memory的简称，意为随机存取存储器，也就是内存了。不管是堆还是栈都是放在内存里的。

8.
 char a[2][2][3]={{{1,6,3},{5,4,15}},{{3,5,33},{23,12,7}} };
 for(int i=0;i<12;i++)
 printf("%d ",_______);   //a[i/6][((i>=6 ? (i-6):i)+2)/5][i%3]);  或者：*(*(*(a+i/6)+(i/3%2))+i%3)    *((char *)a + i)
 //*(**a + i)
空格处填上合适的语句，顺序打印出a中的数字？？？？？？？？？？？
9。void fun(char *a,char *b)
{
 a=b;
 (*a)++;//把b的地址给a,访问a的地址相当于访问b的地址也就是访问s2，于是本函数只是该变了s2的值，s1没被改变
}
void main()
{
 char s1='A',s2='b';
 char *p1=&s1;
 char *p2=&s2;
 fun(p1,p2);
 printf("%c%c",s1,s2);
输出结果：  // Ac吧，这个比较简单考完出来，我是很有信心能进入面试的，等了几天，陆续有人收到通知，我却没有。我的信心大受打击，怎么可能呢！？后来了解到，moto的笔试25道选择题做对19道才能参加面试，后面的题目基本不看。回想下，我后面填空和大题做的不错可是选择题确实做的不咋的（ 郁闷啊，给宿舍的同学鄙视了：你的水平也不行啊~~~）
    这个时候我开始感觉有点压力了，有点危机感了
MTK深圳公司嵌入式软件工程师笔试题 
//MTK深圳嵌入式软件工程师笔试题(B卷)
//1*****************************************
#define pi 3.14
#define Area(R) pi*R*R
main()
{
 int r1=5,r2=2;
 double s=0;
 s=Area(r1-r2);
 printf("The area is %f",s);
}
//求结果       我：3.14*5-2*5-2=
//2*********************************************
//函数 int compare(int a,int b),定义为该函数的函数指针P:为___                      我：int（*p）(int,int)__总结：将函数名换为*p即可__________
//3*********************************************
#include<stdio.h>
void sub(char*s,int num)
{
 int i ,j=num;
 char t;
 while(j-->1)
 {
   for(i=0;i<j;i++)
   {
     if(s[i]<s[i+1])
     {
       t=s[i];
       s[i]=s[i+1];
       s[i+1]=t;
     }
   }
 }
}
main()
{
 char*s="CEAeded";
 sub(s,6);
 printf("%s\n",s)
}
//求结果 我eeddECA
//4**********************************************
//交换两个变量的值,不使用第三个变量,即a=3,b=5交换
//后b=3,a=5
     unsigned char a=3,b=5;
     
     
//5**************************************************
#define N 100
void GetMemory1(char*p)
{
 p=(char*)malloc(sizeof(char)*N);
 strcpy(p,"Have a good day!");
}
char*GetMemory2(void)
{
 char p[]="Have a good day!";
 return p;
}
void main(void)
{
 char*str1=NULL,*str2=NULL;
 GetMemory1(str1);
 GetMemory2(str2);
 printf("\nstr1:%s",str1);
 printf("\nstr2:%s",str2);
 
//6******************************************************
//构造N个结点的单链表返回链表头指针,要求链表中各结点顺序
//与结点数据输入顺序相反,例如输入1,2,3,4,5,形成的链表为
//head->5 4 3 2 1 ,补充程序
#define N 10
typedef struct Node
{
 int data;
 struct Node*next;
}NODE;
int Get_Data(int i);//定义省略
Node*Create_u()
{
 int i;
 NODE*p,*Head=NULL;
 for(i=0;i<N;i++)
 {
  VP=New NODE;
  P->Data=Get_Data(i);
  _____？？？？？？？___________;
  ________________;
 }
 return Head;
}
//7**********************************************
//N个结点链表,每个结点中存放一个字符,判断链表存放的字符是否
//中心对称,即a b c c b a或a b c b a,补充程序
typedef struct Node
{
 int data;
 struct Node*next;
}NODE;
bool Is_symmeic(NODE*head,*int n)
{
 char D[N];
 int i,d;
 __________;
 for(i=0;i<d;i++)
 {
  D[i]=head->data;
  head=head->next;
 }
 if(__________)
 {
  head=head->next;
 }
 while(head)
 {
  _______________;
  if(D[i]!=head->data)
  {
   return false;
  }
  head=head->next;
 }
 return true;
}
//8*************************************
//str中只含有大写和小写字母函数change_move(char*str)将字符串中大写改成*并
//移到前面小写后返回*的个数
//如AabBdcYY改为*****abd,返回5
int chang_move(char*str)
{
 int len,i,curstr=-1;
 len=strlen(str);
 for(i=len-1;i>=0;i--)
 {
  if(str[i]>='A'&&str[i]<='Z')
   {
    str[i]='*';
    if(cursor==-1)
    {
     cursor=i;
    }
    else if(cursor>i)
    {
     _____________;
     str[i]='*';
     _____________;
     
    }
 }
 return____________;
}
//9***********************************************
//求两个字符串的第一个公共子串,并返回该子串
//如:"a b c d e f g e h i" "a a c d e f * * g e h i"
//第一个为"c d e f";不许用strcmp()
char*Maxf(char*str1,char*str2)
{
}


//6******************************************************
//构造N个结点的单链表返回链表头指针,要求链表中各结点顺序
//与结点数据输入顺序相反,例如输入1,2,3,4,5,形成的链表为
//head->5 4 3 2 1 ,补充程序
#define N 10
typedef struct Node
{
 int data;
 struct Node*next;
}NODE;
int Get_Data(int i);//定义省略
Node*Create_u()
{
 int i;
 NODE*p,*Head=NULL;
 for(i=0;i<N;i++)
 {
  VP=New NODE;
  P->Data=Get_Data(i);
  ___ p->next = Head->next;
  ______ Head =p _____;
 }
 return Head;
}
//7**********************************************
//N个结点链表,每个结点中存放一个字符,判断链表存放的字符是否
//中心对称,即a b c c b a或a b c b a,补充程序
typedef struct Node
{
 int data;
 struct Node*next;
}NODE;
bool Is_symmeic(NODE*head,*int n)
{
 char D[N];
 int i,d;
 _____d=n/2

 ___;
 for(i=0;i<d;i++)
 {
  D[i]=head->data;
  head=head->next;
 }
 if(_____head!=NULL&&_ 1==n%2___)
 {
  head=head->next;
 }
 while(head)
 {
  _____ --i __________;
  if(D[i]!=head->data)
  {
   return false;
  }
  head=head->next;
 }
 return true;
}
//8*************************************
//str中只含有大写和小写字母函数change_move(char*str)将字符串中大写改成*并
//移到前面小写后返回*的个数
//如AabBdcYY改为*****abd,返回5
int chang_move(char*str)
{
 int len,i,curstr=-1;
 len=strlen(str);
 for(i=len-1;i>=0;i--)
 {
  if(str[i]>='A'&&str[i]<='Z')
   {
    str[i]='*';
    if(cursor==-1)
    {
     cursor=i;
    }
    else if(cursor>i)
    {
     _____________;
     str[i]='*';
     _____________;
     
    }
 }
 return____________;
}
//9***********************************************
//求两个字符串的第一个公共子串,并返回该子串
//如:"a b c d e f g e h i" "a a c d e f * * g e h i"
//第一个为"c d e f";不许用strcmp()
char*Maxf(char*str1,char*str2)
{
}


3.二维数组空间的动态申请
   a.简单的，已经有一维，如 
char (*c)[5];
c=new char[n][5];//n为已定义的行数
b.二维的
int **p;
p=new int*[m_row];//创建行指针
for(int i=0;i<m_row;i++)//为每一行分配空间
    p[i]=new int[m_cols];
写到某一个函数中：
void getmemory(int ** &p,int m_row,int m_cols)
{
     p=new int*[m_row];//创建行指针
for(int i=0;i<m_row;i++)//为每一行分配空间
    p[i]=new int[m_cols];
}
释放空间:
void deletememory(int **&p,int m_row)
{
   //释放每一行所分配的空间
    for(int i=0;i<m_row;i++)
       delete [] x[i];
//释放行指针
    delete [] x;
     x=0;
via嵌入式笔试两题
     -|yingwang294 发表于 2006-10-31 10:40:00 

以下是威盛嵌入式笔试的最后两道小题
题一：
原题如下：改程序，并确定运行结果
＃i nclude <stdio.h>
＃i nclude <string.h>
＃i nclude <malloc.h>
char *getstring(void)
{
        char p[]="hello everyone";
        return p;
}
char *getmemory(void)
{
        return (char *)malloc(10);
}
int main(int argc, char* argv[])
{
        char *p=getmemory();
        strcpy(p,"helloworld");
        printf("%s",p);
        printf("%s",getstring());
        return 0;
}
这个主要是char p[]前少一个static...
题二：
读程序，写出运行结果
＃i nclude <stdio.h>
＃i nclude <string.h>
＃i nclude <malloc.h>
＃i nclude <assert.h>
typedef struct
{
        int value;
        char type;
}head_t;这是什么东西啊？
typedef struct
{
        head_t head;
        int para;
}message_t;
void main(void)
{
        message_t *message=NULL;
        head_t *head=NULL;
        message=(message_t *)malloc(sizeof(message_t));
        assert(message);//测试的条件不成立则终止程序
        memset(message,0,sizeof(message_t));
        message->para=100;
        message->head.type='a';
        head=(head_t *)message;
        head->value++;
        head->type++;

printf("message->head.value=%d,message->head.type=%c,message->para=%d\n",me
ssage->head.value,message->head.type,message->para);
       " free(message);
        return;
}

#include <iostream>
#include <string>
using namespace std; 
class Student { 
public: 
  Student() {} 
  Student( const string& nm, int sc = 0 ) 
    : name( nm ), score( sc ) {} 
  void set_student( const string& nm, int sc = 0 ) 
  { 
    name = nm; 
    score = sc; 
  } 
  const string& get_name() const 
  { 
    return name; 
  } 
  int get_score() const 
  { 
    return score; 
  } 
private: 
  string name; 
  int score; 
}; 
// output student's name and score 
void output_student( const Student& student ) 
{ 
  cout << student.get_name() << "\t"; 
  cout << student.get_score() << endl; 
} 
int main() 
{ 
  Student stu( "Wang", 85 ); 
  output_student( stu ); 
}
设 计了一个类 Student，数据成员有 name 和 score，有两个构造函数，有一个设置成员数据函数 set_student()，各有一个取得 name 和 score 的函数 get_name() 和 get_score()。请注意 get_name() 和 get_score() 后面都加了 const，而 set_student() 后面没有（也不能有const）。
首先说一点题外话，为什么 get_name() 前面也加 const。如果没有前后两个 const 的话，get_name() 返回的是对私有数据成员 name 的引用，所以通过这个引用可以改变私有成员 name 的值，如
  Student stu( "Wang", 85 );
  stu.get_name() = "Li";

即把 name 由原来的 "Wang" 变成了 "Li"，而这不是我们希望的发生的。所以在 get_name() 前面加 const 避免这种情况的发生。
那么，get_name() 和 get_score() 这两个后面应该加 const的成员函数，如果没有 const 修饰的话可不可以呢？回答是可以！但是这样做的代价是：const对象将不能再调用这两个非const成员函数了。如
const string& get_name(); // 这两个函数都应该设成 const 型
int get_score();
void output_student( const Student& student ) 
{ 
  cout << student.get_name() << "\t"; // 如果 get_name() 和 get_score() 是非const成员函数，这一句和下一句调用是错误的
  cout << student.get_score() << endl; 
}
由 于参数student表示的是一个对const Student型对象的引用，所以 student 不能调用非const成员函数如 set_student()。如果 get_name() 和 get_score() 成员函数也变成非const型，那么上面的 student.get_name() 和 student.get_score() 的使用就是非法的，这样就会给我们处理问题造成困难。
因此，我们没有理由反对使用const，该加const时就应该加上const，这样使成员函数除了非const的对象之外，const对象也能够调用它。
c/C++ 通用 Makefile 
本文提供了一个用于对 C/C++ 程序进行编译和连接以产生可执行程序的通用 Makefile。 
在使用 Makefile 之前，只需对它进行一些简单的设置即可；而且一经设置，即使以后对源程序文件有所增减一般也不再需要改动 Makefile。因此，即便是一个没有学习过 Makefile 书写规则的人，也可以为自己的 C/C++ 程序快速建立一个可工作的 Makefile。
这个 Makefile 可以在 GNU Make 和 GCC 编译器下正常工作。但是不能保证对于其它版本的 Make 和编译器也能正常工作。 
如果你发现了本文中的错误，或者对本文有什么感想或建议，可通过 whyglinux AT hotmail DOT com 邮箱和作者联系。 
此 Makefile 的使用方法如下： 
1. 程序目录的组织 
尽量将自己的源程序集中在一个目录中，并且把 Makefile 和源程序放在一起，这样用起来比较方便。当然，也可以将源程序分类存放在不同的目录中。 

在程序目录中创建一个名为 Makefile 的文本文件，将后面列出的 Makefile 的内容复制到这个文件中。（注意：在复制的过程中，Makfile 中各命令前面的 Tab 字符有可能被转换成若干个空格。这种情况下需要把 Makefile 命令前面的这些空格替换为一个 Tab。） 

将当前工作目录切换到 Makefile 所在的目录。目前，这个 Makefile 只支持在当前目录中的调用，不支持当前目录和 Makefile 所在的路径不是同一目录的情况。 
2. 指定可执行文件 
程序编译和连接成功后产生的可执行文件在 Makefile 中的 PROGRAM 变量中设定。这一项不能为空。为自己程序的可执行文件起一个有意义的名子吧。 
3. 指定源程序 
要编译的源程序由其所在的路径和文件的扩展名两项来确定。由于头文件是通过包含来使用的，所以在这里说的源程序不应包含头文件。 

程序所在的路径在 SRCDIRS 中设定。如果源程序分布在不同的目录中，那么需要在 SRCDIRS 中一一指定，并且路径名之间用空格分隔。 

4. Makefile 目标（Targets） 
下面是关于这个 Makefile 提供的目标以及它所完成的功能： 
make 
编译和连接程序。相当于 make all。 
make objs 
仅仅编译程序产生 .o 目标文件，不进行连接（一般很少单独使用）。 
make clean 
删除编译产生的目标文件和依赖文件。 
make cleanall 
删除目标文件、依赖文件以及可执行文件。 
make rebuild 
重新编译和连接程序。相当于 make clean && make all。 
下面提供两个例子来具体说明上面 Makefile 的用法。 
例一　Hello World 程序 
这个程序的功能是输出 Hello, world! 这样一行文字。由 hello.h、hello.c、main.cxx 三个文件组成。前两个文件是 C 程序，后一个是 C++ 程序，因此这是一个 C 和 C++ 混编程序。 
代码:

/* File name: hello.h 
 * C header file 
 */ 

#ifndef HELLO_H 
#define HELLO_H 

#ifdef __cplusplus 
extern "C" { 
#endif 

  void print_hello(); 

#ifdef __cplusplus 
} 
#endif 

#endif 

代码:
/* File name: hello.c 
 * C source file. 
 */ 
#include "hello.h" 
#include <stdio.h> 

void print_hello() 
{ 
  puts( "Hello, world!" ); 
} 

代码:
/* File name: main.cxx 
 * C++ source file. 
 */ 
#include "hello.h" 

int main() 
{ 
  print_hello(); 

  return 0; 
} 

建立一个新的目录，然后把这三个文件拷贝到目录中，也把 Makefile 文件拷贝到目录中。之后，对 Makefile 的相关项目进行如下设置： 
代码:
PROGRAM   := hello      # 设置运行程序名 
SRCDIRS   := .          # 源程序位于当前目录下 
SRCEXTS   := .c .cxx    # 源程序文件有 .c 和 .cxx 两种类型 
CFLAGS    := -g         # 为 C 目标程序包含 GDB 可用的调试信息 
CXXFLAGS  := -g         # 为 C++ 目标程序包含 GDB 可用的调试信息 

由于这个简单的程序只使用了 C 标准库的函数（puts），所以对于 CFLAGS 和 CXXFLAGS 没有过多的要求，LDFLAGS 和 CPPFLAGS 选项也无需设置。 
经过上面的设置之后，执行 make 命令就可以编译程序了。如果没有错误出现的话，./hello 就可以运行程序了。 
如果修改了源程序的话，可以看到只有和修改有关的源文件被编译。也可以再为程序添加新的源文件，只要它们的扩展名是已经在 Makefile 中设置过的，那么就没有必要修改　Makefile。 


C/C++程序员应聘试题剖析
1.引言 
　　本文的写作目的并不在于提供C/C++程序员求职面试指导，而旨在从技术上分析面试题的内涵。文中的大多数面试题来自各大论坛，部分试题解答也参考了网友的意见。
　　许多面试题看似简单，却需要深厚的基本功才能给出完美的解答。企业要求面试者写一个最简单的strcpy函数都可看出面试者在技术上究竟达到了怎样的程度，我们能真正写好一个strcpy函数吗？我们都觉得自己能，可是我们写出的strcpy很可能只能拿到10分中的2分。读者可从本文看到strcpy函数从2分到10分解答的例子，看看自己属于什么样的层次。此外，还有一些面试题考查面试者敏捷的思维能力。 
　　分析这些面试题，本身包含很强的趣味性；而作为一名研发人员，通过对这些面试题的深入剖析则可进一步增强自身的内功。
　　2.找错题
　　试题1：
void test1()
{
　char string[10];
　char* str1 = "0123456789";
　strcpy( string, str1 );
}

　　试题2：
void test2()
{
　char string[10], str1[10];
　int i;
　for(i=0; i<10; i++)
　{
　　str1[i] = 'a';
　}
　strcpy( string, str1 );
}

　　试题3：
void test3(char* str1)
{
　char string[10];
　if( strlen( str1 ) <= 10 )
　{
　　strcpy( string, str1 );
　}
}

　　解答：
　　试题1字符串str1需要11个字节才能存放下(包括末尾的’\0’)，而string只有10个字节的空间，strcpy会导致数组越界；
　　对试题2，如果面试者指出字符数组str1不能在数组内结束可以给3分；如果面试者指出strcpy(string, str1)调用使得从str1内存起复制到string内存起所复制的字节数具有不确定性可以给7分，在此基础上指出库函数strcpy工作方式的给10分；
　　对试题3，if(strlen(str1) <= 10)应改为if(strlen(str1) < 10)，因为strlen的结果未统计’\0’所占用的1个字节。
　　剖析：
　　考查对基本功的掌握：
　　(1)字符串以’\0’结尾；
　　(2)对数组越界把握的敏感度；
　　(3)库函数strcpy的工作方式，如果编写一个标准strcpy函数的总分值为10，下面给出几个不同得分的答案：
　　2分
void strcpy( char *strDest, char *strSrc )
{
　 while( (*strDest++ = * strSrc++) != ‘\0’ );
}

　　4分
void strcpy( char *strDest, const char *strSrc ) 
//将源字符串加const，表明其为输入参数，加2分
{
　 while( (*strDest++ = * strSrc++) != ‘\0’ );
}

　　7分
void strcpy(char *strDest, const char *strSrc) 
{
　//对源地址和目的地址加非0断言，加3分
　assert( (strDest != NULL) && (strSrc != NULL) );
　while( (*strDest++ = * strSrc++) != ‘\0’ );
}

　　10分
//为了实现链式操作，将目的地址返回，加3分！

char * strcpy( char *strDest, const char *strSrc ) 
{
　assert( (strDest != NULL) && (strSrc != NULL) );
　char *address = strDest; 
　while( (*strDest++ = * strSrc++) != ‘\0’ ); 
　　return address;
}

　　从2分到10分的几个答案我们可以清楚的看到，小小的strcpy竟然暗藏着这么多玄机，真不是盖的！需要多么扎实的基本功才能写一个完美的strcpy啊！
　　(4)对strlen的掌握，它没有包括字符串末尾的'\0'。
　　读者看了不同分值的strcpy版本，应该也可以写出一个10分的strlen函数了，完美的版本为： int strlen( const char *str ) //输入参数const
{
　assert( strt != NULL ); //断言字符串地址非0
　int len;
　while( (*str++) != '\0' ) 
　{ 
　　len++; 
　} 
　return len;
}

　　试题4：
void GetMemory( char *p )
{
　p = (char *) malloc( 100 );没有返回，错
}

void Test( void ) 
{
　char *str = NULL;
　GetMemory( str ); 
　strcpy( str, "hello world" );
　printf( str );
}

　　试题5：
char *GetMemory( void )
{ 
　char p[] = "hello world"; 
　return p;返回栈区局部变量的地址，错 
}

void Test( void )
{ 
　char *str = NULL; 
　str = GetMemory(); 
　printf( str ); 
}

　　试题6：
void GetMemory( char **p, int num )
{
　*p = (char *) malloc( num );
}

void Test( void )
{
　char *str = NULL;
　GetMemory( &str, 100 );
　strcpy( str, "hello" ); 
　printf( str ); 
}

　　试题7：
void Test( void )
{
　char *str = (char *) malloc( 100 );
　strcpy( str, "hello" );
　free( str ); 
　... //省略的其它语句
}

　　解答：
　　试题4传入中GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值，执行完
char *str = NULL;
GetMemory( str ); 

　　后的str仍然为NULL；那应该如何改？？？？？？？？？？？？返回return、
　　试题5中
char p[] = "hello world"; 
return p; 

　　的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。
　　试题6的GetMemory避免了试题4的问题，传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句
*p = (char *) malloc( num );

　　后未判断内存是否申请成功，应加上：
if ( *p == NULL )
{
　...//进行申请内存失败处理
}

　　试题7存在与试题6同样的问题，在执行
char *str = (char *) malloc(100);

　　后未进行内存是否申请成功的判断；另外，在free(str)后未置str为空，导致可能变成一个“野”指针，？？？？？？？应加上：
str = NULL;

　　试题6的Test函数中也未对malloc的内存进行释放。
　　剖析：
　　试题4～7考查面试者对内存操作的理解程度，基本功扎实的面试者一般都能正确的回答其中50~60的错误。但是要完全解答正确，却也绝非易事。
　　对内存操作的考查主要集中在：
　　（1）指针的理解；
　　（2）变量的生存期及作用范围；
　　（3）良好的动态内存申请和释放习惯。
　　再看看下面的一段程序有什么错误：
swap( int* p1,int* p2 )
{
　int *p;// p是一个“野”指针
　*p = *p1;
　*p1 = *p2;
　*p2 = *p;
}

　　在swap函数中，p是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。在VC++中DEBUG运行时提示错误“Access Violation”。该程序应该改为：
swap( int* p1,int* p2 )
{
　int p;
　p = *p1;
　*p1 = *p2;
　*p2 = p;
}

3.内功题
　　试题1：分别给出BOOL，int，float，指针变量 与“零值”比较的 if 语句（假设变量名为var）
　　解答：
　　　BOOL型变量：if(!var)
　　　int型变量： if(var==0)
　　　float型变量：
　　　const float EPSINON = 0.000001;
　　　if ((x >= - EPSINON) && (x <= EPSINON)
　　　指针变量：　　if(var==NULL)
　　剖析：
　　考查对0值判断的“内功”，BOOL型变量的0判断完全可以写成if(var==0)，而int型变量也可以写成if(!var)，指针变量的判断也可以写成if(!var)，上述写法虽然程序都能正确运行，但是未能清晰地表达程序的意思。
　　一般的，如果想让if判断一个变量的“真”、“假”，应直接使用if(var)、if(!var)，表明其为“逻辑”判断；如果用if判断一个数值型变量(short、int、long等)，应该用if(var==0)，表明是与0进行“数值”上的比较；而判断指针则适宜用if(var==NULL)，这是一种很好的编程习惯。
　　浮点型变量并不精确，所以不可将float变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”形式。如果写成if (x == 0.0)，则判为错，得0分。
　　试题2：以下为Windows NT下的32位C++程序，请计算sizeof的值
void Func ( char str[100] )
{
　sizeof( str ) = ?
}

void *p = malloc( 100 );
sizeof ( p ) = ?

　　解答：
sizeof( str ) = 4
sizeof ( p ) = 4

　　剖析：
　　Func ( char str[100] )函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。
　　数组名的本质如下：
　　（1）数组名指代一种数据结构，这种数据结构就是数组；
　　例如：
char str[10];
cout << sizeof(str) << endl;

　　输出结果为10，str指代数据结构char[10]。
　　（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、自减等操作，不能被修改；
char str[10]; 
str++; //编译出错，提示str不是左值　//注意与上面的数组作函数形参区别，讲解如下：

　　（3）数组名作为函数形参时，沦为普通指针。
　　Windows NT 32位平台下，指针的长度（占用内存的大小）为4字节，故sizeof( str ) 、sizeof ( p ) 都为4。
　　试题3：写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。另外，当你写下面的代码时会发生什么事？
least = MIN(*p++, b);

　　解答：
#define MIN(A,B) ((A) <= (B) ? (A) : (B))

　　MIN(*p++, b)会产生宏的副作用
　　剖析：
　　这个面试题主要考查面试者对宏定义的使用，宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进行的是一对一的替换。
　　程序员对宏定义的使用要非常小心，特别要注意两个问题：
　　（1）谨慎地将宏定义中的“参数”和整个宏用括弧括起来。所以，严格地讲，下述解答：
#define MIN(A,B) (A) <= (B) ? (A) : (B)
#define MIN(A,B) (A <= B ? A : B )

　　都应判0分；
　　（2）防止宏的副作用。
　　宏定义#define MIN(A,B) ((A) <= (B) ? (A) : (B))对MIN(*p++, b)的作用结果是：
((*p++) <= (b) ? (*p++) : (*p++))
　　这个表达式会产生副作用，指针p会作三次++自增操作。
　　
　　试题4：为什么标准头文件都有类似以下的结构？ 
#ifndef __INCvxWorksh
#define __INCvxWorksh 
#ifdef __cplusplus

extern "C" {
#endif 
/*...*/ 
#ifdef __cplusplus
}

#endif 
#endif /* __INCvxWorksh */

　　解答：
　　头文件中的编译宏
#ifndef　__INCvxWorksh
#define　__INCvxWorksh
#endif 

　　的作用是防止被重复引用。
　　作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在symbol库中的名字与C语言的不同。例如，假设某个函数的原型为： 
void foo(int x, int y);

　　该函数被C编译器编译后在symbol库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。_foo_int_int这样的名字包含了函数名和函数参数数量及类型信息，C++就是考这种机制来实现函数重载的。
　　为了实现C和C++的混合编程，C++提供了C连接交换指定符号extern "C"来解决名字匹配问题，函数声明前加上extern "C"后，则编译器就会按照C语言的方式将该函数编译为_foo，这样C语言中就可以调用C++的函数了。
试题5：编写一个函数，作用是把一个char组成的字符串循环右移n个。比如原来是“abcdefghi”如果n=2，移位后应该是“hiabcdefgh” 
　　函数头是这样的：
//pStr是指向以'\0'结尾的字符串的指针
//steps是要求移动的n

void LoopMove ( char * pStr, int steps )
{
　//请填充...
}

　　解答：
　　正确解答1：
void LoopMove ( char *pStr, int steps )
{
　int n = strlen( pStr ) - steps;
　char tmp[MAX_LEN]; //这是何物啊？？重新定义一个中间数组 
　strcpy ( tmp, pStr + n );把前n位复制给tmp 
　strcpy ( tmp + steps, pStr);把pstr复制给tmp,从steps位开始
　*( tmp + strlen ( pStr ) ) = '\0';截取strlen()长度，
　strcpy( pStr, tmp );
}

　　正确解答2：
void LoopMove ( char *pStr, int steps )
{
　int n = strlen( pStr ) - steps;
　char tmp[MAX_LEN]; 
　memcpy( tmp, pStr + n, steps ); 将后steps位复制给tmp
　memcpy(pStr + steps, pStr, n ); 
　memcpy(pStr, tmp, steps ); 
}

　　剖析：
　　这个试题主要考查面试者对标准库函数的熟练程度，在需要的时候引用库函数可以很大程度上简化程序编写的工作量。
　　最频繁被使用的库函数包括：
　　（1） strcpy
　　（2） memcpy
　　（3） memset
　　试题6：已知WAV文件格式如下表，打开一个WAV文件，以适当的数据结构组织WAV文件头并解析WAV格式的各项信息。
　　WAVE文件格式说明表
 
偏移地址
字节数
数据类型
内 容
文件头 
 
00H
4 
Char
"RIFF"标志

04H
4
int32
文件长度

08H
4
Char
"WAVE"标志

0CH
4
Char
"fmt"标志

10H
4
 
过渡字节（不定）

14H
2
int16
格式类别

16H
2
int16
通道数

18H
2
int16 
采样率（每秒样本数），表示每个通道的播放速度

1CH
4
int32
波形音频数据传送速率

20H
2
int16
数据块的调整数（按字节算的）

22H
2
 
每样本的数据位数

24H
4
Char
数据标记符＂data＂

28H
4
int32
语音数据的长度

　　解答：
　　将WAV文件格式定义为结构体WAVEFORMAT： 
typedef struct tagWaveFormat
{ 
　char cRiffFlag[4]; 
　UIN32 nFileLen; 
　char cWaveFlag[4]; 
　char cFmtFlag[4]; 
　char cTransition[4]; 
　UIN16 nFormatTag ; 
　UIN16 nChannels; 
　UIN16 nSamplesPerSec; 
　UIN32 nAvgBytesperSec; 
　UIN16 nBlockAlign; 
　UIN16 nBitNumPerSample; 
　char cDataFlag[4]; 
　UIN16 nAudioLength; 

} WAVEFORMAT;

　　假设WAV文件内容读出后存放在指针buffer开始的内存单元内，则分析文件格式的代码很简单，为：
WAVEFORMAT waveFormat;
memcpy( &waveFormat, buffer,sizeof( WAVEFORMAT ) ); 

　　直接通过访问waveFormat的成员，就可以获得特定WAV文件的各项格式信息。
　　剖析：
　　试题6考查面试者组织数据结构的能力，有经验的程序设计者将属于一个整体的数据成员组织为一个结构体，利用指针类型转换，可以将memcpy、memset等函数直接用于结构体地址，进行结构体的整体操作。 透过这个题可以看出面试者的程序设计经验是否丰富。
　　试题7：编写类String的构造函数、析构函数和赋值函数，已知类String的原型为：?????????????????????????????????????????????????
已经封装的文件中写的程序
class String
{ 
　public: 
　　String(const char *str = NULL); // 普通构造函数 
　　String(const String &other); // 拷贝构造函数 
　　~ String(void); // 析构函数 
　　String & operate =(const String &other); // 赋值函数 
　private: 
　　char *m_data; // 用于保存字符串 
};

　　解答：
这是在实现文件中编写的程序
//普通构造函数
String::String(const char *str) 
{
　if(str==NULL) 
　{
　　m_data = new char[1]; // 得分点：对空字符串自动申请存放结束标志'\0'的空
　　//加分点：对m_data加NULL 判断
　　*m_data = '\0'; 
　} 
　else
　{
　　int length = strlen(str); 
　　m_data = new char[length+1]; // 若能加 NULL 判断则更好 
　　strcpy(m_data, str); 
　}
}
// String的析构函数
String::~String(void) 
{
　delete [] m_data; // 或delete m_data;
}
//拷贝构造函数
String::String(const String &other) 　　　// 得分点：输入参数为const型
{ 
　int length = strlen(other.m_data); 
　m_data = new char[length+1]; 　　　　//加分点：对m_data加NULL 判断
　strcpy(m_data, other.m_data); 
}
//赋值函数
String & String::operate =(const String &other) // 得分点：输入参数为const型
{ 
　if(this == &other) 　　//得分点：检查自赋值
　　return *this; 
　delete [] m_data; 　　　　//得分点：释放原有的内存资源
　int length = strlen( other.m_data ); 
　m_data = new char[length+1]; //加分点：对m_data加NULL 判断
　strcpy( m_data, other.m_data ); 
　return *this; 　　　　　　　　//得分点：返回本对象的引用
}

　　剖析：
　　能够准确无误地编写出String类的构造函数、拷贝构造函数、赋值函数和析构函数的面试者至少已经具备了C++基本功的60%以上！
　　在这个类中包括了指针类成员变量m_data，当类中包括指针类成员变量时，一定要重载其拷贝构造函数、赋值函数和析构函数，这既是对C++程序员的基本要求，也是《Effective　C++》中特别强调的条款。
　　仔细学习这个类，特别注意加注释的得分点和加分点的意义，这样就具备了60%以上的C++基本功！
　　　　const关键字至少有下列n个作用：
　　（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
　　（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
　　（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
　　（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
　　（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：
const classA operator*(const classA& a1,const classA& a2);

　　operator*的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：
classA a, b, c;
(a * b) = c; // 对a*b的结果赋值

　　操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。、
　　4.技巧题
　　试题1：请写一个C函数，若处理器是Big_endian的，则返回0；若是Little_endian的，则返回
　　解答：
int checkCPU()
{
　{
　　union w
　　{ 
　　　int a;
　　　char b;
　　} c;
　　c.a = 1;0X00 00 00 01四个字节，c.b为一个字节
　　return (c.b == 1);大端的c.b为00，小端的c.b为01？？？？
　}//因为联合体共用一个空间
}

　　剖析：
　　嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。采用Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。例如，16bit宽的数0x1234在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
内存地址
存放内容
0x4000
0x34
0x4001
0x12

　　而在Big-endian模式CPU内存中的存放方式则为：
内存地址
存放内容
0x4000
0x12
0x4001
0x34

　　32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
内存地址
存放内容
0x4000
0x78
0x4001
0x56
0x4002
0x34
0x4003
0x12

　　而在Big-endian模式CPU内存中的存放方式则为：
内存地址
存放内容
0x4000
0x12
0x4001
0x34
0x4002
0x56
0x4003
0x78

　　联合体union的存放顺序是所有成员都从低地址开始存放，面试者的解答利用该特性，轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写。如果谁能当场给出这个解答，那简直就是一个天才的程序员。
　　试题2：写一个函数返回1+2+3+…+n的值（假定结果不会超过长整型变量的范围） 
　　解答：
int Sum( int n )
{ 
　return ( (long)1 + n) * n / 2;　　//或return (1l + n) * n / 2;
}

　　剖析：
　　对于这个题，只能说，也许最简单的答案就是最好的答案。下面的解答，或者基于下面的解答思路去优化，不管怎么“折腾”，其效率也不可能与直接return ( 1 l + n ) * n / 2相比！ 
int Sum( int n )
{
　long sum = 0;
　for( int i=1; i<=n; i++ )
　{
　　sum += i;
　}
　return sum;
} 

　　
volatile关键字的作用
volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。下面举例说明。在DSP开发中，经常需要等待某个事件的触发，所以经常会写出这样的程序：
short flag;
void test()
{
do1();
while(flag==0);
do2();
}这段程序等待内存变量flag的值变为1(怀疑此处是0,有点疑问,)之后才运行do2()。变量flag的值由别的程序更改，这个程序可能是某个硬件中断服务程序。例如：如果某个按钮按下的话，就会对DSP产生中断，在按键中断程序中修改flag为1，这样上面的程序就能够得以继续运行。但是，编译器并不知道flag的值会被别的程序修改，因此在它进行优化的时候，可能会把flag的值先读入某个寄存器，然后等待那个寄存器变为1。如果不幸进行了这样的优化，那么while循环就变成了死循环，因为寄存器的内容不可能被中断服务程序修改。为了让程序每次都读取真正flag变量的值，就需要定义为如下形式：
volatile short flag;
需要注意的是，没有volatile也可能能正常运行，但是可能修改了编译器的优化级别之后就又不能正常运行了。因此经常会出现debug版本正常，但是release版本却不能正常的问题。所以为了安全起见，只要是等待别的程序修改某个变量的话，就加上volatile关键字。

C语言void及void指针深层探索

　　1、void的含义
　　void的字面意思是“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据。
　　void几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个void变量，让我们试着来定义：
void a;
　　这行语句编译时会出错，提示“illegal use of type 'void'”。不过，即使void a的编译不会出错，它也没有任何实际意义。
　　void真正发挥的作用在于：
　　（1） 对函数返回的限定；
　　（2） 对函数参数的限定。
　　我们将在第三节对以上二点进行具体说明。
　　众所周知，如果指针p1和p2的类型相同，那么我们可以直接在p1和p2间互相赋值；如果p1和p2指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。 
　　例如：
float *p1;
int *p2;
p1 = p2;
　　其中p1 = p2语句会编译出错，提示“'=' : cannot convert from 'int *' to 'float *'”，必须改为：
p1 = (float *)p2;
　　而void *则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换：
void *p1;
int *p2;
p1 = p2;
　　但这并不意味着，void *也可以无需强制类型转换地赋给其它类型的指针。因为“无类型”可以包容“有类型”，而“有类型”则不能包容“无类型”。道理很简单，我们可以说“男人和女人都是人”，但不能说“人是男人”或者“人是女人”。下面的语句编译出错：
void *p1;
int *p2;
p2 = p1;
　　提示“'=' : cannot convert from 'void *' to 'int *'”。
3.void的使用
　　下面给出void关键字的使用规则：
　　规则一 如果函数没有返回值，那么应声明为void类型
　　在C语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理。但是许多程序员却误以为其为void类型。例如：
add ( int a, int b )
{
return a + b;
}
int main(int argc, char* argv[])
{
printf ( "2 + 3 = %d", add ( 2, 3) );
}
　　程序运行的结果为输出：
　　2 + 3 = 5
　　这说明不加返回值说明的函数的确为int函数。
　　林锐博士《高质量C/C++编程》中提到：“C++语言有很严格的类型安全检查，不允许上述情况（指函数不加类型声明）发生”。可是编译器并不一定这么认定，譬如在Visual C++6.0中上述add函数的编译无错也无警告且运行正确，所以不能寄希望于编译器会做严格的类型检查。
　　因此，为了避免混乱，我们在编写C/C++程序时，对于任何函数都必须一个不漏地指定其类型。如果函数没有返回值，一定要声明为void类型。这既是程序良好可读性的需要，也是编程规范性的要求。另外，加上void类型声明后，也可以发挥代码的“自注释”作用。代码的“自注释”即代码能自己注释自己。
　　规则二 如果函数无参数，那么应声明其参数为void
　　在C++语言中声明一个这样的函数：
int function(void)
{
return 1;
}
　　则进行下面的调用是不合法的：
function(2);
　　因为在C++中，函数参数为void的意思是这个函数不接受任何参数。
　　我们在Turbo C 2.0中编译：
＃i nclude "stdio.h"
fun()
{
return 1;
}
main()
{
printf("%d",fun(2));
getchar();
}
　　编译正确且输出1，这说明，在C语言中，可以给无参数的函数传送任意类型的参数，但是在C++编译器中编译同样的代码则会出错。在C++中，不能向无参数的函数传送任何参数，出错提示“'fun' : function does not take 1 parameters”。
　　所以，无论在C还是C++中，若函数不接受任何参数，一定要指明参数为void。
　　规则三 小心使用void指针类型
　　按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即下列操作都是不合法的：
void * pvoid;
pvoid++; //ANSI：错误
pvoid += 1; //ANSI：错误
//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。
//例如：
int *pint;
pint++; //ANSI：正确
　　pint++的结果是使其增大sizeof(int)。
　　但是大名鼎鼎的GNU(GNU's Not Unix的缩写)则不这么认定，它指定void *的算法操作与char *一致。
　　因此下列语句在GNU编译器中皆正确：
pvoid++; //GNU：正确
pvoid += 1; //GNU：正确
　　pvoid++的执行结果是其增大了1。
　　在实际的程序设计中，为迎合ANSI标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：
void * pvoid;
(char *)pvoid++; //ANSI：正确；GNU：正确
(char *)pvoid += 1; //ANSI：错误；GNU：正确
　　GNU和ANSI还有一些区别，总体而言，GNU较ANSI更“开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合ANSI标准。
　　规则四 如果函数的参数可以是任意类型指针，那么应声明其参数为void *
　　典型的如内存操作函数memcpy和memset的函数原型分别为：
void * memcpy(void *dest, const void *src, size_t len);
void * memset ( void * buffer, int c, size_t num );
　　这样，任何类型的指针都可以传入memcpy和memset中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。如果memcpy和memset的参数类型不是void *，而是char *，那才叫真的奇怪了！这样的memcpy和memset明显不是一个“纯粹的，脱离低级趣味的”函数！
　　下面的代码执行正确：
//示例：memset接受任意类型指针
int intarray[100];
memset ( intarray, 0, 100*sizeof(int) ); //将intarray清0
//示例：memcpy接受任意类型指针
int intarray1[100], intarray2[100];
memcpy ( intarray1, intarray2, 100*sizeof(int) ); //将intarray2拷贝给intarray1
　　有趣的是，memcpy和memset函数返回的也是void *类型，标准库函数的编写者是多么地富有学问啊！
　　规则五 void不能代表一个真实的变量
　　下面代码都企图让void代表一个真实的变量，因此都是错误的代码：
void a; //错误
function(void a); //错误
　　void体现了一种抽象，这个世界上的变量都是“有类型”的，譬如一个人不是男人就是女人.
　　void的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中“抽象基类”的概念，也很容易理解void数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个void（让我们类比的称void为“抽象数据类型”）变量。
关于CONST的用法
const在C语言中算是一个比较新的描述符，我们称之为常量修饰符，意即其所修饰
的对象为常量(immutable)。
我们来分情况看语法上它该如何被使用。
1、函数体内修饰局部变量。
例：
void func(){
const int a=0;
}
首先，我们先把const这个单词忽略不看，那么a是一个int类型的局部自动变量，
我们给它赋予初始值0。
然后再看const.
const作为一个类型限定词，和int有相同的地位。
const int a;
int const a;
是等价的。于是此处我们一定要清晰的明白，const修饰的对象是谁，是a,和int没
有关系。const 要求他所修饰的对象为常量，不可被改变，不可被赋值，不可作为
左值（l-value)。
这样的写法也是错误的。
const int a;
a=0;
这是一个很常见的使用方式：
const double pi=3.14;
在程序的后面如果企图对pi再次赋值或者修改就会出错。
然后看一个稍微复杂的例子。
const int* p;
还是先去掉const 修饰符号。
注意，下面两个是等价的。
int* p;
int *p;
其实我们想要说的是，*p是int类型。那么显然，p就是指向int的指针。
同理
const int* p;
其实等价于
const int (*p);
int const (*p);
即，*p是常量。也就是说，p指向的数据是常量。
于是
p+=8; //合法
*p=3; //非法，p指向的数据是常量。
那么如何声明一个自身是常量指针呢？方法是让const尽可能的靠近p;
int* const p;
const右面只有p,显然，它修饰的是p,说明p不可被更改。然后把const去掉，可以
看出p是一个指向 int形式变量的指针。
于是
p+=8; //非法
*p=3; //合法
再看一个更复杂的例子，它是上面二者的综合
const int* const p;
说明p自己是常量，且p指向的变量也是常量。
于是
p+=8; //非法
*p=3; //非法
const 还有一个作用就是用于修饰常量静态字符串。
例如：
const char* name="David";
如果没有const,我们可能会在后面有意无意的写name[4]='x'这样的语句，这样会
导致对只读内存区域的赋值，然后程序会立刻异常终止。有了 const,这个错误就
能在程序被编译的时候就立即检查出来，这就是const的好处。让逻辑错误在编译
期被发现。
const 还可以用来修饰数组
const char s[]="David";
与上面有类似的作用。
2、在函数声明时修饰参数
来看实际中的一个例子。
NAME
memmove -- copy byte string
LIBRARY
Standard C Library (libc, -lc)
SYNOPSIS
＃i nclude <string.h>
void *
memmove(void *dst, const void *src, size_t len);
这是标准库中的一个函数，用于按字节方式复制字符串（内存）。
它的第一个参数，是将字符串复制到哪里去（dest),是目的地，这段内存区域必须
是可写。
它的第二个参数，是要将什么样的字符串复制出去，我们对这段内存区域只做读
取，不写。
于是，我们站在这个函数自己的角度来看，src 这个指针，它所指向的内存内所存
储的数据在整个函数执行的过程中是不变。于是src所指向的内容是常量。于是就
需要用const修饰。
例如，我们这里这样使用它。
const char* s="hello";
char buf[100];
memmove(buf,s,6); //这里其实应该用strcpy或memcpy更好
如果我们反过来写，
memmove(s,buf,6);
那么编译器一定会报错。事实是我们经常会把各种函数的参数顺序写反。事实是编
译器在此时帮了我们大忙。如果编译器静悄悄的不报错，(在函数声明处去掉
const即可),那么这个程序在运行的时候一定会崩溃。
这里还要说明的一点是在函数参数声明中const一般用来声明指针而不是变量本身。
例如，上面的size_t len,在函数实现的时候可以完全不用更改len的值，那么是否
应该把len也声明为常量呢？可以，可以这么做。我们来分析这么做有什么优劣。
如果加了const,那么对于这个函数的实现者，可以防止他在实现这个函数的时候修
改不需要修改的值(len),这样很好。
但是对于这个函数的使用者，
1。这个修饰符号毫无意义，我们可以传递一个常量整数或者一个非常量整数过
去，反正对方获得的只是我们传递的一个copy。
2。暴露了实现。我不需要知道你在实现这个函数的时候是否修改过len的值。
所以，const一般只用来修饰指针。
再看一个复杂的例子
int execv(const char *path, char *const argv[]);
着重看后面这个，argv.它代表什么。
如果去掉const,我们可以看出
char * argv[];
argv是一个数组，它的每个元素都是char *类型的指针。
如果加上const.那么const修饰的是谁呢？他修饰的是一个数组，argv[],意思就是
说这个数组的元素是只读的。那么数组的元素的是什么类型呢？是char *类型的指
针.也就是说指针是常量，而它指向的数据不是。
于是
argv[1]=NULL; //非法
argv[0][0]='a'; //合法
3、全局变量。
我们的原则依然是，尽可能少的使用全局变量。
我们的第二条规则 则是，尽可能多的使用const。
如果一个全局变量只在本文件中使用，那么用法和前面所说的函数局部变量没有什
么区别。
如果它要在多个文件间共享，那么就牵扯到一个存储类型的问题。
有两种方式。
1.使用extern
例如
/* file1.h */
extern const double pi;
/* file1.c */
const double pi=3.14;
然后其他需要使用pi这个变量的，包含file1.h
＃i nclude "file1.h"
或者，自己把那句声明复制一遍就好。
这样做的结果是，整个程序链接完后，所有需要使用pi这个变量的共享一个存储区域。
2.使用static,静态外部存储类
/* constant.h */
static const pi=3.14;
需要使用这个变量的*.c文件中，必须包含这个头文件。
前面的static一定不能少。否则链接的时候会报告说该变量被多次定义。
这样做的结果是，每个包含了constant.h的*.c文件，都有一份该变量自己的copy,
该变量实际上还是被定义了多次，占用了多个存储空间，不过在加了static关键字
后，解决了文件间重定义的冲突。
坏处是浪费了存储空间，导致链接完后的可执行文件变大。但是通常，这个，小小
几字节的变化，不是问题。
好处是，你不用关心这个变量是在哪个文件中被初始化的。
最后，说说const的作用。
const 的好处，是引入了常量的概念，让我们不要去修改不该修改的内存。直接的
作用就是让更多的逻辑错误在编译期被发现。所以我们要尽可能的多使用const。
但是很多人并不习惯使用它，更有甚者，是在整个程序 编写／调试 完后才补
const。如果是给函数的声明补const,尚好。如果是给 全局／局部变量补const,那
么……那么，为时已晚，无非是让代码看起来更漂亮了。
c语言中的结构（struct)和联合（union）简介

联     合(union)
  1. 联合说明和联合变量定义
  联合也是一种新的数据类型, 它是一种特殊形式的变量。
  联合说明和联合变量定义与结构十分相似。其形式为:
  union 联合名{
      数据类型成员名;
      数据类型成员名;
      ...
  } 联合变量名;
  联合表示几个变量公用一个内存位置, 在不同的时间保存不同的数据类型 和不同长度的变量。
  下例表示说明一个联合a_bc:
  union a_bc{
      int i;
      char mm;
  };
  再用已说明的联合可定义联合变量。
  例如用上面说明的联合定义一个名为lgc的联合变量, 可写成:
    union a_bc lgc;
  在联合变量lgc中, 整型量i和字符mm公用同一内存位置。
  当一个联合被说明时, 编译程序自动地产生一个变量, 其长度为联合中最大的变量长度。
  联合访问其成员的方法与结构相同。同样联合变量也可以定义成数组或指针,但定义为指针时, 也要用"->;"符号, 此时联合访问成员可表示成:
  联合名->;成员名
  另外, 联合既可以出现在结构内, 它的成员也可以是结构。
  例如:
  struct{
      int age;
      char *addr;
      union{
          int i;
          char *ch;
      }x;
  }y[10];
  若要访问结构变量y[1]中联合x的成员i, 可以写成:
    y[1].x.i;
  若要访问结构变量y[2]中联合x的字符串指针ch的第一个字符可写成:
    *y[2].x.ch;
  若写成"y[2].x.*ch;"是错误的。
  2. 结构和联合的区别
  结构和联合有下列区别:
  1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合转只存放了一个被选中的成员, 而结构的所有成员都存在。
  2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。
  下面举一个例了来加对深联合的理解。
  例4:
main()
{
  union{             /*定义一个联合*/
  int i;
  struct{         /*在联合中定义一个结构*/
        char first;
        char second;
        }half;
  }number;
  number.i=0x4241;       /*联合成员赋值*/
  printf("%c%c\n", number.half.first, mumber.half.second);
  number.half.first='a';   /*联合中结构成员赋值*/
  number.half.second='b';
  printf("%x\n", number.i);
  getch();
}
  输出结果为:
  AB
  6261
  从上例结果可以看出: 当给i赋值后, 其低八位也就是first和second的值;当给first和second赋字符后, 这两个字符的ASCII码也将作为i 的低八位和高八位。
Volatile 关键字告诉编译器不要持有变量的临时性拷贝。一般用在多线程程序中，以避免在其中一个线程操作该变量时，将其拷贝入寄存器。请看以下情形:
    A线程将变量复制入寄存器，然后进入循环，反复检测寄存器的值是否满足一定条件(它期待B线程改变变量的值。
在此种情况下，当B线程改变了变量的值时，已改变的值对其在寄存器的值没有影响。所以A线程进入死循环。
    volatile 就是在此种情况下使用。
堆和栈的区别
一、预备知识—程序的内存分配
    一个由c/C++编译的程序占用的内存分为以下几个部分
    1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
    2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。
    3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放
    4、文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放
    5、程序代码区—存放函数体的二进制代码。

例子程序
这是一个前辈写的，非常详细
//main.cpp
int a = 0; 全局初始化区
char *p1; 全局未初始化区
main()
{
int b; 栈
char s[] = "abc"; 栈
char *p2; 栈
char *p3 = "123456"; 123456\0在常量区，p3在栈上。
static int c =0； 全局（静态）初始化区
p1 = (char *)malloc(10);
p2 = (char *)malloc(20);
分配得来得10和20字节的区域就在堆区。
strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
}


二、堆和栈的理论知识

2.1申请方式
stack:
由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间
heap:
需要程序员自己申请，并指明大小，在c中malloc函数
如p1 = (char *)malloc(10);
在C++中用new运算符
如p2 = (char *)malloc(10);
但是注意p1、p2本身是在栈中的。

2.2申请后系统的响应
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

2.4申请效率的比较
栈由系统自动分配，速度较快。但程序员是无法控制的。
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。

2.5堆和栈中的存储内容
栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

2.6存取效率的比较
char s1[] = "aaaaaaaaaaaaaaa";
char *s2 = "bbbbbbbbbbbbbbbbb";
aaaaaaaaaaa是在运行时刻赋值的；
而bbbbbbbbbbb是在编译时就确定的；
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。
比如：
＃i nclude
void main()
{
char a = 1;
char c[] = "1234567890";
char *p ="1234567890";
a = c[1];
a = p[1];
return;
}
对应的汇编代码
10: a = c[1];
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]
0040106A 88 4D FC mov byte ptr [ebp-4],cl
11: a = p[1];
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]
00401070 8A 42 01 mov al,byte ptr [edx+1]
00401073 88 45 FC mov byte ptr [ebp-4],al
第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。

2.7小结
堆和栈的区别可以用如下的比喻来看出：
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。



windows进程中的内存结构


在阅读本文之前，如果你连堆栈是什么多不知道的话，请先阅读文章后面的基础知识。

接触过编程的人都知道，高级语言都能通过变量名来访问内存中的数据。那么这些变量在内存中是如何存放的呢？程序又是如何使用这些变量的呢？下面就会对此进行深入的讨论。下文中的C语言代码如没有特别声明，默认都使用VC编译的release版。

首先，来了解一下 C 语言的变量是如何在内存分部的。C 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码：

＃i nclude <stdio.h>

int g1=0, g2=0, g3=0;

int main()
{
static int s1=0, s2=0, s3=0;
int v1=0, v2=0, v3=0;

//打印出各个变量的内存地址

printf("0x%08x\n",&v1); //打印各本地变量的内存地址
printf("0x%08x\n",&v2);
printf("0x%08x\n\n",&v3);
printf("0x%08x\n",&g1); //打印各全局变量的内存地址
printf("0x%08x\n",&g2);
printf("0x%08x\n\n",&g3);
printf("0x%08x\n",&s1); //打印各静态变量的内存地址
printf("0x%08x\n",&s2);
printf("0x%08x\n\n",&s3);
return 0;
}

编译后的执行结果是：

0x0012ff78
0x0012ff7c
0x0012ff80

0x004068d0
0x004068d4
0x004068d8

0x004068dc
0x004068e0
0x004068e4

输出的结果就是变量的内存地址。其中v1,v2,v3是本地变量，g1,g2,g3是全局变量，s1,s2,s3是静态变量。你可以看到这些变量在内存是连续分布的，但是本地变量和全局变量分配的内存地址差了十万八千里，而全局变量和静态变量分配的内存是连续的。这是因为本地变量和全局/静态变量是分配在不同类型的内存区域中的结果。对于一个进程的内存空间而言，可以在逻辑上分成3个部份：代码区，静态数据区和动态数据区。动态数据区一般就是“堆栈”。“栈 (stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址”和“栈顶”地址来描述。全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区，即堆栈中。程序通过堆栈的基地址和偏移量来访问本地变量。


├———————┤低端内存区域
│ …… │
├———————┤
│ 动态数据区 │
├———————┤
│ …… │
├———————┤
│ 代码区 │
├———————┤
│ 静态数据区 │
├———————┤
│ …… │
├———————┤高端内存区域


堆栈是一个先进后出的数据结构，栈顶地址总是小于等于栈的基地址。我们可以先了解一下函数调用的过程，以便对堆栈在程序中的作用有更深入的了解。不同的语言有不同的函数调用规定，这些因素有参数的压入规则和堆栈的平衡。windows API的调用规则和ANSI C的函数调用规则是不一样的，前者由被调函数调整堆栈，后者由调用者调整堆栈。两者通过“__stdcall”和“__cdecl”前缀区分。先看下面这段代码：

＃i nclude <stdio.h>

void __stdcall func(int param1,int param2,int param3)
{
int var1=param1;
int var2=param2;
int var3=param3;
printf("0x%08x\n",?m1); //打印出各个变量的内存地址
printf("0x%08x\n",?m2);
printf("0x%08x\n\n",?m3);
printf("0x%08x\n",&var1);
printf("0x%08x\n",&var2);
printf("0x%08x\n\n",&var3);
return;
}

int main()
{
func(1,2,3);
return 0;
}

编译后的执行结果是：

0x0012ff78
0x0012ff7c
0x0012ff80

0x0012ff68
0x0012ff6c
0x0012ff70


├———————┤<—函数执行时的栈顶（ESP）、低端内存区域
│ …… │
├———————┤
│ var 1 │
├———————┤
│ var 2 │
├———————┤
│ var 3 │
├———————┤
│ RET │
├———————┤<—“__cdecl”函数返回后的栈顶（ESP）
│ parameter 1 │
├———————┤
│ parameter 2 │
├———————┤
│ parameter 3 │
├———————┤<—“__stdcall”函数返回后的栈顶（ESP）
│ …… │
├———————┤<—栈底（基地址 EBP）、高端内存区域


上图就是函数调用过程中堆栈的样子了。首先，三个参数以从又到左的次序压入堆栈，先压“param3”，再压“param2”，最后压入“param1”；然后压入函数的返回地址(RET)，接着跳转到函数地址接着执行（这里要补充一点，介绍UNIX下的缓冲溢出原理的文章中都提到在压入RET后，继续压入当前EBP，然后用当前ESP代替EBP。然而，有一篇介绍windows下函数调用的文章中说，在windows下的函数调用也有这一步骤，但根据我的实际调试，并未发现这一步，这还可以从param3和var1之间只有4字节的间隙这点看出来）；第三步，将栈顶(ESP)减去一个数，为本地变量分配内存空间，上例中是减去12字节(ESP=ESP-3*4，每个int变量占用4个字节)；接着就初始化本地变量的内存空间。由于“__stdcall”调用由被调函数调整堆栈，所以在函数返回前要恢复堆栈，先回收本地变量占用的内存(ESP=ESP+3*4)，然后取出返回地址，填入EIP寄存器，回收先前压入参数占用的内存(ESP=ESP+3*4)，继续执行调用者的代码。参见下列汇编代码：

;--------------func 函数的汇编代码-------------------

:00401000 83EC0C sub esp, 0000000C //创建本地变量的内存空间
:00401003 8B442410 mov eax, dword ptr [esp+10]
:00401007 8B4C2414 mov ecx, dword ptr [esp+14]
:0040100B 8B542418 mov edx, dword ptr [esp+18]
:0040100F 89442400 mov dword ptr [esp], eax
:00401013 8D442410 lea eax, dword ptr [esp+10]
:00401017 894C2404 mov dword ptr [esp+04], ecx

……………………（省略若干代码）

:00401075 83C43C add esp, 0000003C ;恢复堆栈，回收本地变量的内存空间
:00401078 C3 ret 000C ;函数返回，恢复参数占用的内存空间
;如果是“__cdecl”的话，这里是“ret”，堆栈将由调用者恢复

;-------------------函数结束-------------------------


;--------------主程序调用func函数的代码--------------

:00401080 6A03 push 00000003 //压入参数param3
:00401082 6A02 push 00000002 //压入参数param2
:00401084 6A01 push 00000001 //压入参数param1
:00401086 E875FFFFFF call 00401000 //调用func函数
;如果是“__cdecl”的话，将在这里恢复堆栈，“add esp, 0000000C”

聪明的读者看到这里，差不多就明白缓冲溢出的原理了。先来看下面的代码：

＃i nclude <stdio.h>
＃i nclude <string.h>

void __stdcall func()
{
char lpBuff[8]="\0";
strcat(lpBuff,"AAAAAAAAAAA");
return;
}

int main()
{
func();
return 0;
}

编译后执行一下回怎么样？哈，“"0x00414141"指令引用的"0x00000000"内存。该内存不能为"read"。”，“非法操作”喽！ "41"就是"A"的16进制的ASCII码了，那明显就是strcat这句出的问题了。"lpBuff"的大小只有8字节，算进结尾的\0，那 strcat最多只能写入7个"A"，但程序实际写入了11个"A"外加1个\0。再来看看上面那幅图，多出来的4个字节正好覆盖了RET的所在的内存空间，导致函数返回到一个错误的内存地址，执行了错误的指令。如果能精心构造这个字符串，使它分成三部分，前一部份仅仅是填充的无意义数据以达到溢出的目的，接着是一个覆盖RET的数据，紧接着是一段shellcode，那只要着个RET地址能指向这段shellcode的第一个指令，那函数返回时就能执行shellcode了。但是软件的不同版本和不同的运行环境都可能影响这段shellcode在内存中的位置，那么要构造这个RET是十分困难的。一般都在RET和shellcode之间填充大量的NOP指令，使得exploit有更强的通用性。


├———————┤<—低端内存区域
│ …… │
├———————┤<—由exploit填入数据的开始
│ │
│ buffer │<—填入无用的数据
│ │
├———————┤
│ RET │<—指向shellcode，或NOP指令的范围
├———————┤
│ NOP │
│ …… │<—填入的NOP指令，是RET可指向的范围
│ NOP │
├———————┤
│ │
│ shellcode │
│ │
├———————┤<—由exploit填入数据的结束
│ …… │
├———————┤<—高端内存区域


windows下的动态数据除了可存放在栈中，还可以存放在堆中。了解C++的朋友都知道，C++可以使用new关键字来动态分配内存。来看下面的C++代码：

＃i nclude <stdio.h>
＃i nclude <iostream.h>
＃i nclude <windows.h>

void func()
{
char *buffer=new char[128];
char bufflocal[128];
static char buffstatic[128];
printf("0x%08x\n",buffer); //打印堆中变量的内存地址
printf("0x%08x\n",bufflocal); //打印本地变量的内存地址
printf("0x%08x\n",buffstatic); //打印静态变量的内存地址
}

void main()
{
func();
return;
}

程序执行结果为：

0x004107d0
0x0012ff04
0x004068c0

可以发现用new关键字分配的内存即不在栈中，也不在静态数据区。VC编译器是通过windows下的“堆(heap)”来实现new关键字的内存动态分配。在讲“堆”之前，先来了解一下和“堆”有关的几个API函数：

HeapAlloc 在堆中申请内存空间
HeapCreate 创建一个新的堆对象
HeapDestroy 销毁一个堆对象
HeapFree 释放申请的内存
HeapWalk 枚举堆对象的所有内存块
GetProcessHeap 取得进程的默认堆对象
GetProcessHeaps 取得进程所有的堆对象
LocalAlloc
GlobalAlloc

当进程初始化时，系统会自动为进程创建一个默认堆，这个堆默认所占内存的大小为1M。堆对象由系统进行管理，它在内存中以链式结构存在。通过下面的代码可以通过堆动态申请内存空间：

HANDLE hHeap=GetProcessHeap();
char *buff=HeapAlloc(hHeap,0,8);

其中hHeap是堆对象的句柄，buff是指向申请的内存空间的地址。那这个hHeap究竟是什么呢？它的值有什么意义吗？看看下面这段代码吧：

#pragma comment(linker,"/entry:main") //定义程序的入口
＃i nclude <windows.h>

_CRTIMP int (__cdecl *printf)(const char *, ...); //定义STL函数printf
/*---------------------------------------------------------------------------
写到这里，我们顺便来复习一下前面所讲的知识：
(*注)printf函数是C语言的标准函数库中函数，VC的标准函数库由msvcrt.dll模块实现。
由函数定义可见，printf的参数个数是可变的，函数内部无法预先知道调用者压入的参数个数，函数只能通过分析第一个参数字符串的格式来获得压入参数的信息，由于这里参数的个数是动态的，所以必须由调用者来平衡堆栈，这里便使用了__cdecl调用规则。BTW，Windows系统的API函数基本上是 __stdcall调用形式，只有一个API例外，那就是wsprintf，它使用__cdecl调用规则，同printf函数一样，这是由于它的参数个数是可变的缘故。
---------------------------------------------------------------------------*/
void main()
{
HANDLE hHeap=GetProcessHeap();
char *buff=HeapAlloc(hHeap,0,0x10);
char *buff2=HeapAlloc(hHeap,0,0x10);
HMODULE hMsvcrt=LoadLibrary("msvcrt.dll");
printf=(void *)GetProcAddress(hMsvcrt,"printf");
printf("0x%08x\n",hHeap);
printf("0x%08x\n",buff);
printf("0x%08x\n\n",buff2);
}

执行结果为：

0x00130000
0x00133100
0x00133118

hHeap 的值怎么和那个buff的值那么接近呢？其实hHeap这个句柄就是指向HEAP首部的地址。在进程的用户区存着一个叫PEB(进程环境块)的结构，这个结构中存放着一些有关进程的重要信息，其中在PEB首地址偏移0x18处存放的ProcessHeap就是进程默认堆的地址，而偏移0x90处存放了指向进程所有堆的地址列表的指针。windows有很多API都使用进程的默认堆来存放动态数据，如windows 2000下的所有ANSI版本的函数都是在默认堆中申请内存来转换ANSI字符串到Unicode字符串的。对一个堆的访问是顺序进行的，同一时刻只能有一个线程访问堆中的数据，当多个线程同时有访问要求时，只能排队等待，这样便造成程序执行效率下降。

最后来说说内存中的数据对齐。所位数据对齐，是指数据所在的内存地址必须是该数据长度的整数倍，DWORD数据的内存起始地址能被4除尽，WORD数据的内存起始地址能被2除尽，x86 CPU能直接访问对齐的数据，当他试图访问一个未对齐的数据时，会在内部进行一系列的调整，这些调整对于程序来说是透明的，但是会降低运行速度，所以编译器在编译程序时会尽量保证数据对齐。同样一段代码，我们来看看用VC、Dev-C++和lcc三个不同编译器编译出来的程序的执行结果：

＃i nclude <stdio.h>

int main()
{
int a;
char b;
int c;
printf("0x%08x\n",&a);
printf("0x%08x\n",&b);
printf("0x%08x\n",&c);
return 0;
}

这是用VC编译后的执行结果：
0x0012ff7c
0x0012ff7b
0x0012ff80
变量在内存中的顺序：b(1字节)-a(4字节)-c(4字节)。

这是用Dev-C++编译后的执行结果：
0x0022ff7c
0x0022ff7b
0x0022ff74
变量在内存中的顺序：c(4字节)-中间相隔3字节-b(占1字节)-a(4字节)。

这是用lcc编译后的执行结果：
0x0012ff6c
0x0012ff6b
0x0012ff64
变量在内存中的顺序：同上。

三个编译器都做到了数据对齐，但是后两个编译器显然没VC“聪明”，让一个char占了4字节，浪费内存哦。


基础知识：
堆栈是一种简单的数据结构，是一种只允许在其一端进行插入或删除的线性表。允许插入或删除操作的一端称为栈顶，另一端称为栈底，对堆栈的插入和删除操作被称为入栈和出栈。有一组CPU指令可以实现对进程的内存实现堆栈访问。其中，POP指令实现出栈操作，PUSH指令实现入栈操作。CPU的ESP寄存器存放当前线程的栈顶指针，EBP寄存器中保存当前线程的栈底指针。CPU的EIP寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从 EIP寄存器中读取下一条指令的内存地址，然后继续执行。 
 <br>
堆（Heap）栈（Stack） 
1、内存分配方面： 
    堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下：new、malloc、delete、free等等。 
    栈：由编译器(Compiler)自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 
2、申请方式方面： 
    堆：需要程序员自己申请，并指明大小。在c中malloc函数如p1 = (char *)malloc(10)；在C++中用new运算符，但是注意p1、p2本身是在栈中的。因为他们还是可以认为是局部变量。 
    栈：由系统自动分配。 例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。 
3、系统响应方面： 
    堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 
    栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 
4、大小限制方面： 
    堆：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 
    栈：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 
5、效率方面： 
    堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。 
    栈：由系统自动分配，速度较快。但程序员是无法控制的。 
6、存放内容方面： 
    堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 
    栈：在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈，然后是函数中的局部变量。 注意: 静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
7、存取效率方面： 
    堆：char *s1 = "Hellow Word"；是在编译时就确定的； 
    栈：char s1[] = "Hellow Word"； 是在运行时赋值的；用数组比用指针速度要快一些，因为指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上直接读取。


suningin详解笔试面试题（6）－－moto笔试
10月21号moto的笔试是在我们学校举行的，120分钟的笔试时间，试题内容大致涵盖了c/c++，数据库，数字通信，IQ等方面。我自我感觉做的很顺利，至少两道编程题我都搞定了。一个多小时就把试题做完了，于是，我就把一些试题偷偷抄到了草稿纸上，回去和大家一齐分享。下面就是我抄回来的试题：
1。打印如下图案，共19行，只能有一个for循环（程序已经提供）
         *          
        ***         
       *****        
      *******       
     *********      
    ***********
   *************    
  ***************   
  ***************** 
******************* 
  ***************** 
  ***************   
   *************    
    ***********     
     *********      
      *******       
       *****        
        ***         
         *          
for(i=0;i<19;i++)
{
}
在网上搜寻了些解答，如下：
1.
#include<iostream>
#include<iomanip>
#include<string>
using namespace std;
int main()
{
 int a[2]={-1,1};
 string str="*******************";
 int i=0,j=9,t=1;
 for(i=0;i<19;++i)
 {
  j+=a[i<10];
  if(i!=0)t=t+a[i<10]*2;
  cout<<setw(j)<<right<<str.substr(0,t)<<endl;
 }
 return 0;
} 

2.
#include<stdio.h>
#include<string.h> 
int main()
{
 char * tempStr = "*******************";
 char * blank = " ";
 int i = 0;
 char * dataStr [20];
 char blankstr[10];

 for ( i=0; i<19; i++)
 {
  memset(dataStr, 0, 20);
  memset(blankstr,0,10);
  if (i<10)
  {
   memcpy(blankstr,blank,9-i);
   memcpy(dataStr, tempStr, (i+1)*2-1);
  }
  else
  {
   memcpy(blankstr,blank,i-9);
   memcpy(dataStr, tempStr, (19-i)*2-1);
  }
  printf("%s",blankstr);
  printf("%s\n", dataStr);
 }
 return 0;
} 
3。
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define MAXSIZE 19
void main()
{
    int i,k;
   char ch;
   char format[30],stars[30],tmp[3];
   ch = '*';
   strcpy(stars,"");
   for(i=0; i<MAXSIZE; i++)
  {
      if(i <= MAXSIZE/2)
     {
         k = (MAXSIZE + 1)/2 - i;
         strcpy(format,"%");
         itoa(k,tmp,10);
        strcat(format,tmp);
        strcat(format,"c");
        if(i>0)
           {
                strcat(stars,"**");
                strcat(format,stars);
            }
         printf(format,ch);
         printf("\n");
      }
     else
     {
         k = i + 2 - (MAXSIZE + 1)/2;
         strcpy(format,"%");
         itoa(k,tmp,10);
        strcat(format,tmp);
        strcat(format,"c");
        stars[MAXSIZE -1 -(2*(i+1) - MAXSIZE -1)] = 0;
         strcat(format,stars);
        printf(format,ch);
        printf("\n");
     }
 }
 //getchar();
 //getchar();
}
 
注:printf格式%mc表示输入字符宽度为m位,左边补空格.

4。
有高人发的回帖:
#include<iostream.h>
int main(int argv,int * argc[])
{
 for(int i=0;i<19;i++)
 {
  static char cc[19] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};
        //19个空格
  static const int j = 19 / 2;   //j值为9
        static int count = 0;          //count为离中间元素的距离
        if( i < ( 19 / 2 + 1)) 
  {
          cc[j - count] = '*';
          cc[j + count] = '*';
          cout << cc << endl;
          count++;
  } 
  else 
  {
          count--;
          cc[j - count] = ' ';
          cc[j + count] = ' ';
          cout << cc << endl;
  }
 }
 return 0;
}
 
一看就知差距,我的晦涩难懂
我想用两个数组,一个存放空格数量,一个存放'*'
但是下面这个程序只用了一个数组，把每一行输出的形状存到数组中，妙！我咋就没想到？！

2.
void fun(int x)
{
 if(x/2>0)fun(x/2);
 printf("%d",x);
}
求fun(10)的输出结果     //12510，一个递归，很简单的
3。
#define f1(n) (n)*(n)
         int i=5;
 int k=0;
 k=f1(i++);
 printf("%d %d",i,k);
输出结果：  ：// 7 25，++放后面是后算的
4。下面那个for循环是无限循环？
for(int i=010;i==10;i+=0)       //这个明显不是，010等于8，8 != 10，一判断就出去了
for(int i=10;(i++^--i)==0;i+=0)   //无限循环
还有几个忘了
5.Email relay 和Email access分别用了什么协议？（其他还有很多，略）
SMTP,POP3
注: SMTP：Simple MAIL Transfer Protocol，简单邮件传输协议，互联网上的电子邮件发送就是使用这个协议。SMTP open relay host：开放的SMTP中继主机——它很可能被恶意的人利用，来产生大量垃圾邮件.
POP3协议允许客户机通过（临时的或永久的）TCP/IP连接或其他网络协议的连接，从一个服务器（这时就称为POP3服务器）上获取电子邮件（E-MAIL），POP3不负责发送邮件.

6。in a mobile phone,软件运行期，stack data 存在于
a.rom,b.flash c.eeprom d.ram e.none of the above
答：D.ram。这题稍微涉及到一点硬件知识，ROM的全称是Read Only Memory，即只读存储器，flash ，eeprom都是ROM家族的一员，RAM是Random Access Memory的简称，意为随机存取存储器，也就是内存了。不管是堆还是栈都是放在内存里的。

8.
 char a[2][2][3]={{{1,6,3},{5,4,15}},{{3,5,33},{23,12,7}} };
 for(int i=0;i<12;i++)
 printf("%d ",_______);   //a[i/6][((i>=6 ? (i-6):i)+2)/5][i%3]);  或者：*(*(*(a+i/6)+(i/3%2))+i%3)    *((char *)a + i)
 //*(**a + i)
空格处填上合适的语句，顺序打印出a中的数字？？？？？？？？？？？
9。void fun(char *a,char *b)
{
 a=b;
 (*a)++;//把b的地址给a,访问a的地址相当于访问b的地址也就是访问s2，于是本函数只是该变了s2的值，s1没被改变
}
void main()
{
 char s1='A',s2='b';
 char *p1=&s1;
 char *p2=&s2;
 fun(p1,p2);
 printf("%c%c",s1,s2);
输出结果：  // Ac吧，这个比较简单考完出来，我是很有信心能进入面试的，等了几天，陆续有人收到通知，我却没有。我的信心大受打击，怎么可能呢！？后来了解到，moto的笔试25道选择题做对19道才能参加面试，后面的题目基本不看。回想下，我后面填空和大题做的不错可是选择题确实做的不咋的（ 郁闷啊，给宿舍的同学鄙视了：你的水平也不行啊~~~）
    这个时候我开始感觉有点压力了，有点危机感了
MTK深圳公司嵌入式软件工程师笔试题 
//MTK深圳嵌入式软件工程师笔试题(B卷)
//1*****************************************
#define pi 3.14
#define Area(R) pi*R*R
main()
{
 int r1=5,r2=2;
 double s=0;
 s=Area(r1-r2);
 printf("The area is %f",s);
}
//求结果       我：3.14*5-2*5-2=
//2*********************************************
//函数 int compare(int a,int b),定义为该函数的函数指针P:为___                      我：int（*p）(int,int)__总结：将函数名换为*p即可__________
//3*********************************************
#include<stdio.h>
void sub(char*s,int num)
{
 int i ,j=num;
 char t;
 while(j-->1)
 {
   for(i=0;i<j;i++)
   {
     if(s[i]<s[i+1])
     {
       t=s[i];
       s[i]=s[i+1];
       s[i+1]=t;
     }
   }
 }
}
main()
{
 char*s="CEAeded";
 sub(s,6);
 printf("%s\n",s)
}
//求结果 我eeddECA
//4**********************************************
//交换两个变量的值,不使用第三个变量,即a=3,b=5交换
//后b=3,a=5
     unsigned char a=3,b=5;
     
     
//5**************************************************
#define N 100
void GetMemory1(char*p)
{
 p=(char*)malloc(sizeof(char)*N);
 strcpy(p,"Have a good day!");
}
char*GetMemory2(void)
{
 char p[]="Have a good day!";
 return p;
}
void main(void)
{
 char*str1=NULL,*str2=NULL;
 GetMemory1(str1);
 GetMemory2(str2);
 printf("\nstr1:%s",str1);
 printf("\nstr2:%s",str2);
 


