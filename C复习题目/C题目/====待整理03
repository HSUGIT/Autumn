
3.二维数组空间的动态申请
   a.简单的，已经有一维，如 
char (*c)[5];
c=new char[n][5];//n为已定义的行数
b.二维的
int **p;
p=new int*[m_row];//创建行指针
for(int i=0;i<m_row;i++)//为每一行分配空间
    p[i]=new int[m_cols];
写到某一个函数中：
void getmemory(int ** &p,int m_row,int m_cols)
{
     p=new int*[m_row];//创建行指针
for(int i=0;i<m_row;i++)//为每一行分配空间
    p[i]=new int[m_cols];
}
释放空间:
void deletememory(int **&p,int m_row)
{
   //释放每一行所分配的空间
    for(int i=0;i<m_row;i++)
       delete [] x[i];
//释放行指针
    delete [] x;
     x=0;
via嵌入式笔试两题
     -|yingwang294 发表于 2006-10-31 10:40:00 

以下是威盛嵌入式笔试的最后两道小题
题一：
原题如下：改程序，并确定运行结果
＃i nclude <stdio.h>
＃i nclude <string.h>
＃i nclude <malloc.h>
char *getstring(void)
{
        char p[]="hello everyone";
        return p;
}
char *getmemory(void)
{
        return (char *)malloc(10);
}
int main(int argc, char* argv[])
{
        char *p=getmemory();
        strcpy(p,"helloworld");
        printf("%s",p);
        printf("%s",getstring());
        return 0;
}
这个主要是char p[]前少一个static...
题二：
读程序，写出运行结果
＃i nclude <stdio.h>
＃i nclude <string.h>
＃i nclude <malloc.h>
＃i nclude <assert.h>
typedef struct
{
        int value;
        char type;
}head_t;这是什么东西啊？
typedef struct
{
        head_t head;
        int para;
}message_t;
void main(void)
{
        message_t *message=NULL;
        head_t *head=NULL;
        message=(message_t *)malloc(sizeof(message_t));
        assert(message);//测试的条件不成立则终止程序
        memset(message,0,sizeof(message_t));
        message->para=100;
        message->head.type='a';
        head=(head_t *)message;
        head->value++;
        head->type++;

printf("message->head.value=%d,message->head.type=%c,message->para=%d\n",me
ssage->head.value,message->head.type,message->para);
       " free(message);
        return;
}

#include <iostream>
#include <string>
using namespace std; 
class Student { 
public: 
  Student() {} 
  Student( const string& nm, int sc = 0 ) 
    : name( nm ), score( sc ) {} 
  void set_student( const string& nm, int sc = 0 ) 
  { 
    name = nm; 
    score = sc; 
  } 
  const string& get_name() const 
  { 
    return name; 
  } 
  int get_score() const 
  { 
    return score; 
  } 
private: 
  string name; 
  int score; 
}; 
// output student's name and score 
void output_student( const Student& student ) 
{ 
  cout << student.get_name() << "\t"; 
  cout << student.get_score() << endl; 
} 
int main() 
{ 
  Student stu( "Wang", 85 ); 
  output_student( stu ); 
}
设 计了一个类 Student，数据成员有 name 和 score，有两个构造函数，有一个设置成员数据函数 set_student()，各有一个取得 name 和 score 的函数 get_name() 和 get_score()。请注意 get_name() 和 get_score() 后面都加了 const，而 set_student() 后面没有（也不能有const）。
首先说一点题外话，为什么 get_name() 前面也加 const。如果没有前后两个 const 的话，get_name() 返回的是对私有数据成员 name 的引用，所以通过这个引用可以改变私有成员 name 的值，如
  Student stu( "Wang", 85 );
  stu.get_name() = "Li";

即把 name 由原来的 "Wang" 变成了 "Li"，而这不是我们希望的发生的。所以在 get_name() 前面加 const 避免这种情况的发生。
那么，get_name() 和 get_score() 这两个后面应该加 const的成员函数，如果没有 const 修饰的话可不可以呢？回答是可以！但是这样做的代价是：const对象将不能再调用这两个非const成员函数了。如
const string& get_name(); // 这两个函数都应该设成 const 型
int get_score();
void output_student( const Student& student ) 
{ 
  cout << student.get_name() << "\t"; // 如果 get_name() 和 get_score() 是非const成员函数，这一句和下一句调用是错误的
  cout << student.get_score() << endl; 
}
由 于参数student表示的是一个对const Student型对象的引用，所以 student 不能调用非const成员函数如 set_student()。如果 get_name() 和 get_score() 成员函数也变成非const型，那么上面的 student.get_name() 和 student.get_score() 的使用就是非法的，这样就会给我们处理问题造成困难。
因此，我们没有理由反对使用const，该加const时就应该加上const，这样使成员函数除了非const的对象之外，const对象也能够调用它。
c/C++ 通用 Makefile 
本文提供了一个用于对 C/C++ 程序进行编译和连接以产生可执行程序的通用 Makefile。 
在使用 Makefile 之前，只需对它进行一些简单的设置即可；而且一经设置，即使以后对源程序文件有所增减一般也不再需要改动 Makefile。因此，即便是一个没有学习过 Makefile 书写规则的人，也可以为自己的 C/C++ 程序快速建立一个可工作的 Makefile。
这个 Makefile 可以在 GNU Make 和 GCC 编译器下正常工作。但是不能保证对于其它版本的 Make 和编译器也能正常工作。 
如果你发现了本文中的错误，或者对本文有什么感想或建议，可通过 whyglinux AT hotmail DOT com 邮箱和作者联系。 
此 Makefile 的使用方法如下： 
1. 程序目录的组织 
尽量将自己的源程序集中在一个目录中，并且把 Makefile 和源程序放在一起，这样用起来比较方便。当然，也可以将源程序分类存放在不同的目录中。 

在程序目录中创建一个名为 Makefile 的文本文件，将后面列出的 Makefile 的内容复制到这个文件中。（注意：在复制的过程中，Makfile 中各命令前面的 Tab 字符有可能被转换成若干个空格。这种情况下需要把 Makefile 命令前面的这些空格替换为一个 Tab。） 

将当前工作目录切换到 Makefile 所在的目录。目前，这个 Makefile 只支持在当前目录中的调用，不支持当前目录和 Makefile 所在的路径不是同一目录的情况。 
2. 指定可执行文件 
程序编译和连接成功后产生的可执行文件在 Makefile 中的 PROGRAM 变量中设定。这一项不能为空。为自己程序的可执行文件起一个有意义的名子吧。 
3. 指定源程序 
要编译的源程序由其所在的路径和文件的扩展名两项来确定。由于头文件是通过包含来使用的，所以在这里说的源程序不应包含头文件。 

程序所在的路径在 SRCDIRS 中设定。如果源程序分布在不同的目录中，那么需要在 SRCDIRS 中一一指定，并且路径名之间用空格分隔。 

4. Makefile 目标（Targets） 
下面是关于这个 Makefile 提供的目标以及它所完成的功能： 
make 
编译和连接程序。相当于 make all。 
make objs 
仅仅编译程序产生 .o 目标文件，不进行连接（一般很少单独使用）。 
make clean 
删除编译产生的目标文件和依赖文件。 
make cleanall 
删除目标文件、依赖文件以及可执行文件。 
make rebuild 
重新编译和连接程序。相当于 make clean && make all。 
下面提供两个例子来具体说明上面 Makefile 的用法。 
例一　Hello World 程序 
这个程序的功能是输出 Hello, world! 这样一行文字。由 hello.h、hello.c、main.cxx 三个文件组成。前两个文件是 C 程序，后一个是 C++ 程序，因此这是一个 C 和 C++ 混编程序。 
代码:

/* File name: hello.h 
 * C header file 
 */ 

#ifndef HELLO_H 
#define HELLO_H 

#ifdef __cplusplus 
extern "C" { 
#endif 

  void print_hello(); 

#ifdef __cplusplus 
} 
#endif 

#endif 

代码:
/* File name: hello.c 
 * C source file. 
 */ 
#include "hello.h" 
#include <stdio.h> 

void print_hello() 
{ 
  puts( "Hello, world!" ); 
} 

代码:
/* File name: main.cxx 
 * C++ source file. 
 */ 
#include "hello.h" 

int main() 
{ 
  print_hello(); 

  return 0; 
} 

建立一个新的目录，然后把这三个文件拷贝到目录中，也把 Makefile 文件拷贝到目录中。之后，对 Makefile 的相关项目进行如下设置： 
代码:
PROGRAM   := hello      # 设置运行程序名 
SRCDIRS   := .          # 源程序位于当前目录下 
SRCEXTS   := .c .cxx    # 源程序文件有 .c 和 .cxx 两种类型 
CFLAGS    := -g         # 为 C 目标程序包含 GDB 可用的调试信息 
CXXFLAGS  := -g         # 为 C++ 目标程序包含 GDB 可用的调试信息 

由于这个简单的程序只使用了 C 标准库的函数（puts），所以对于 CFLAGS 和 CXXFLAGS 没有过多的要求，LDFLAGS 和 CPPFLAGS 选项也无需设置。 
经过上面的设置之后，执行 make 命令就可以编译程序了。如果没有错误出现的话，./hello 就可以运行程序了。 
如果修改了源程序的话，可以看到只有和修改有关的源文件被编译。也可以再为程序添加新的源文件，只要它们的扩展名是已经在 Makefile 中设置过的，那么就没有必要修改　Makefile。 


C/C++程序员应聘试题剖析
1.引言 
　　本文的写作目的并不在于提供C/C++程序员求职面试指导，而旨在从技术上分析面试题的内涵。文中的大多数面试题来自各大论坛，部分试题解答也参考了网友的意见。
　　许多面试题看似简单，却需要深厚的基本功才能给出完美的解答。企业要求面试者写一个最简单的strcpy函数都可看出面试者在技术上究竟达到了怎样的程度，我们能真正写好一个strcpy函数吗？我们都觉得自己能，可是我们写出的strcpy很可能只能拿到10分中的2分。读者可从本文看到strcpy函数从2分到10分解答的例子，看看自己属于什么样的层次。此外，还有一些面试题考查面试者敏捷的思维能力。 
　　分析这些面试题，本身包含很强的趣味性；而作为一名研发人员，通过对这些面试题的深入剖析则可进一步增强自身的内功。
　　2.找错题
　　试题1：
void test1()
{
　char string[10];
　char* str1 = "0123456789";
　strcpy( string, str1 );
}

　　试题2：
void test2()
{
　char string[10], str1[10];
　int i;
　for(i=0; i<10; i++)
　{
　　str1[i] = 'a';
　}
　strcpy( string, str1 );
}

　　试题3：
void test3(char* str1)
{
　char string[10];
　if( strlen( str1 ) <= 10 )
　{
　　strcpy( string, str1 );
　}
}

　　解答：
　　试题1字符串str1需要11个字节才能存放下(包括末尾的’\0’)，而string只有10个字节的空间，strcpy会导致数组越界；
　　对试题2，如果面试者指出字符数组str1不能在数组内结束可以给3分；如果面试者指出strcpy(string, str1)调用使得从str1内存起复制到string内存起所复制的字节数具有不确定性可以给7分，在此基础上指出库函数strcpy工作方式的给10分；
　　对试题3，if(strlen(str1) <= 10)应改为if(strlen(str1) < 10)，因为strlen的结果未统计’\0’所占用的1个字节。
　　剖析：
　　考查对基本功的掌握：
　　(1)字符串以’\0’结尾；
　　(2)对数组越界把握的敏感度；
　　(3)库函数strcpy的工作方式，如果编写一个标准strcpy函数的总分值为10，下面给出几个不同得分的答案：
　　2分
void strcpy( char *strDest, char *strSrc )
{
　 while( (*strDest++ = * strSrc++) != ‘\0’ );
}

　　4分
void strcpy( char *strDest, const char *strSrc ) 
//将源字符串加const，表明其为输入参数，加2分
{
　 while( (*strDest++ = * strSrc++) != ‘\0’ );
}

　　7分
void strcpy(char *strDest, const char *strSrc) 
{
　//对源地址和目的地址加非0断言，加3分
　assert( (strDest != NULL) && (strSrc != NULL) );
　while( (*strDest++ = * strSrc++) != ‘\0’ );
}

　　10分
//为了实现链式操作，将目的地址返回，加3分！

char * strcpy( char *strDest, const char *strSrc ) 
{
　assert( (strDest != NULL) && (strSrc != NULL) );
　char *address = strDest; 
　while( (*strDest++ = * strSrc++) != ‘\0’ ); 
　　return address;
}

　　从2分到10分的几个答案我们可以清楚的看到，小小的strcpy竟然暗藏着这么多玄机，真不是盖的！需要多么扎实的基本功才能写一个完美的strcpy啊！
　　(4)对strlen的掌握，它没有包括字符串末尾的'\0'。
　　读者看了不同分值的strcpy版本，应该也可以写出一个10分的strlen函数了，完美的版本为： int strlen( const char *str ) //输入参数const
{
　assert( strt != NULL ); //断言字符串地址非0
　int len;
　while( (*str++) != '\0' ) 
　{ 
　　len++; 
　} 
　return len;
}

　　试题4：
void GetMemory( char *p )
{
　p = (char *) malloc( 100 );
}

void Test( void ) 
{
　char *str = NULL;
　GetMemory( str ); 
　strcpy( str, "hello world" );
　printf( str );
}

　　试题5：
char *GetMemory( void )
{ 
　char p[] = "hello world"; 
　return p; 
}

void Test( void )
{ 
　char *str = NULL; 
　str = GetMemory(); 
　printf( str ); 
}

　　试题6：
void GetMemory( char **p, int num )
{
　*p = (char *) malloc( num );
}

void Test( void )
{
　char *str = NULL;
　GetMemory( &str, 100 );
　strcpy( str, "hello" ); 
　printf( str ); 
}

　　试题7：
void Test( void )
{
　char *str = (char *) malloc( 100 );
　strcpy( str, "hello" );
　free( str ); 
　... //省略的其它语句
}

　　解答：
　　试题4传入中GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并不能真正的改变传入形参的值，执行完
char *str = NULL;
GetMemory( str ); 

　　后的str仍然为NULL；那应该如何改？？？？？？？？？？？？、
　　试题5中
char p[] = "hello world"; 
return p; 

　　的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序员常犯的错误，其根源在于不理解变量的生存期。
　　试题6的GetMemory避免了试题4的问题，传入GetMemory的参数为字符串指针的指针，但是在GetMemory中执行申请内存及赋值语句
*p = (char *) malloc( num );

　　后未判断内存是否申请成功，应加上：
if ( *p == NULL )
{
　...//进行申请内存失败处理
}

　　试题7存在与试题6同样的问题，在执行
char *str = (char *) malloc(100);

　　后未进行内存是否申请成功的判断；另外，在free(str)后未置str为空，导致可能变成一个“野”指针，？？？？？？？应加上：
str = NULL;

　　试题6的Test函数中也未对malloc的内存进行释放。
　　剖析：
　　试题4～7考查面试者对内存操作的理解程度，基本功扎实的面试者一般都能正确的回答其中50~60的错误。但是要完全解答正确，却也绝非易事。
　　对内存操作的考查主要集中在：
　　（1）指针的理解；
　　（2）变量的生存期及作用范围；
　　（3）良好的动态内存申请和释放习惯。
　　再看看下面的一段程序有什么错误：
swap( int* p1,int* p2 )
{
　int *p;// p是一个“野”指针
　*p = *p1;
　*p1 = *p2;
　*p2 = *p;
}

　　在swap函数中，p是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。在VC++中DEBUG运行时提示错误“Access Violation”。该程序应该改为：
swap( int* p1,int* p2 )
{
　int p;
　p = *p1;
　*p1 = *p2;
　*p2 = p;
}

3.内功题
　　试题1：分别给出BOOL，int，float，指针变量 与“零值”比较的 if 语句（假设变量名为var）
　　解答：
　　　BOOL型变量：if(!var)
　　　int型变量： if(var==0)
　　　float型变量：
　　　const float EPSINON = 0.00001;
　　　if ((x >= - EPSINON) && (x <= EPSINON)
　　　指针变量：　　if(var==NULL)
　　剖析：
　　考查对0值判断的“内功”，BOOL型变量的0判断完全可以写成if(var==0)，而int型变量也可以写成if(!var)，指针变量的判断也可以写成if(!var)，上述写法虽然程序都能正确运行，但是未能清晰地表达程序的意思。
　　一般的，如果想让if判断一个变量的“真”、“假”，应直接使用if(var)、if(!var)，表明其为“逻辑”判断；如果用if判断一个数值型变量(short、int、long等)，应该用if(var==0)，表明是与0进行“数值”上的比较；而判断指针则适宜用if(var==NULL)，这是一种很好的编程习惯。
　　浮点型变量并不精确，所以不可将float变量用“==”或“！=”与数字比较，应该设法转化成“>=”或“<=”形式。如果写成if (x == 0.0)，则判为错，得0分。
　　试题2：以下为Windows NT下的32位C++程序，请计算sizeof的值
void Func ( char str[100] )
{
　sizeof( str ) = ?
}

void *p = malloc( 100 );
sizeof ( p ) = ?

　　解答：
sizeof( str ) = 4
sizeof ( p ) = 4

　　剖析：
　　Func ( char str[100] )函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。
　　数组名的本质如下：
　　（1）数组名指代一种数据结构，这种数据结构就是数组；
　　例如：
char str[10];
cout << sizeof(str) << endl;

　　输出结果为10，str指代数据结构char[10]。
　　（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、自减等操作，不能被修改；
char str[10]; 
str++; //编译出错，提示str不是左值　//注意与上面的数组作函数形参区别，讲解如下：

　　（3）数组名作为函数形参时，沦为普通指针。
　　Windows NT 32位平台下，指针的长度（占用内存的大小）为4字节，故sizeof( str ) 、sizeof ( p ) 都为4。
　　试题3：写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。另外，当你写下面的代码时会发生什么事？
least = MIN(*p++, b);

　　解答：
#define MIN(A,B) ((A) <= (B) ? (A) : (B))

　　MIN(*p++, b)会产生宏的副作用
　　剖析：
　　这个面试题主要考查面试者对宏定义的使用，宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进行的是一对一的替换。
　　程序员对宏定义的使用要非常小心，特别要注意两个问题：
　　（1）谨慎地将宏定义中的“参数”和整个宏用括弧括起来。所以，严格地讲，下述解答：
#define MIN(A,B) (A) <= (B) ? (A) : (B)
#define MIN(A,B) (A <= B ? A : B )

　　都应判0分；
　　（2）防止宏的副作用。
　　宏定义#define MIN(A,B) ((A) <= (B) ? (A) : (B))对MIN(*p++, b)的作用结果是：
((*p++) <= (b) ? (*p++) : (*p++))
　　这个表达式会产生副作用，指针p会作三次++自增操作。
　　
　　试题4：为什么标准头文件都有类似以下的结构？ 
#ifndef __INCvxWorksh
#define __INCvxWorksh 
#ifdef __cplusplus

extern "C" {
#endif 
/*...*/ 
#ifdef __cplusplus
}

#endif 
#endif /* __INCvxWorksh */

　　解答：
　　头文件中的编译宏
#ifndef　__INCvxWorksh
#define　__INCvxWorksh
#endif 

　　的作用是防止被重复引用。
　　作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在symbol库中的名字与C语言的不同。例如，假设某个函数的原型为： 
void foo(int x, int y);

　　该函数被C编译器编译后在symbol库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。_foo_int_int这样的名字包含了函数名和函数参数数量及类型信息，C++就是考这种机制来实现函数重载的。
　　为了实现C和C++的混合编程，C++提供了C连接交换指定符号extern "C"来解决名字匹配问题，函数声明前加上extern "C"后，则编译器就会按照C语言的方式将该函数编译为_foo，这样C语言中就可以调用C++的函数了。
试题5：编写一个函数，作用是把一个char组成的字符串循环右移n个。比如原来是“abcdefghi”如果n=2，移位后应该是“hiabcdefgh” 
　　函数头是这样的：
//pStr是指向以'\0'结尾的字符串的指针
//steps是要求移动的n

void LoopMove ( char * pStr, int steps )
{
　//请填充...
}

　　解答：
　　正确解答1：
void LoopMove ( char *pStr, int steps )
{
　int n = strlen( pStr ) - steps;
　char tmp[MAX_LEN]; //这是何物啊？？重新定义一个中间数组 
　strcpy ( tmp, pStr + n );把前n位复制给tmp 
　strcpy ( tmp + steps, pStr);把pstr复制给tmp,从steps位开始
　*( tmp + strlen ( pStr ) ) = '\0';截取strlen()长度，
　strcpy( pStr, tmp );
}

　　正确解答2：
void LoopMove ( char *pStr, int steps )
{
　int n = strlen( pStr ) - steps;
　char tmp[MAX_LEN]; 
　memcpy( tmp, pStr + n, steps ); 将后steps位复制给tmp
　memcpy(pStr + steps, pStr, n ); 
　memcpy(pStr, tmp, steps ); 
}

　　剖析：
　　这个试题主要考查面试者对标准库函数的熟练程度，在需要的时候引用库函数可以很大程度上简化程序编写的工作量。
　　最频繁被使用的库函数包括：
　　（1） strcpy
　　（2） memcpy
　　（3） memset
　　试题6：已知WAV文件格式如下表，打开一个WAV文件，以适当的数据结构组织WAV文件头并解析WAV格式的各项信息。
　　WAVE文件格式说明表
 
偏移地址
字节数
数据类型
内 容
文件头 
 
00H
4 
Char
"RIFF"标志

04H
4
int32
文件长度

08H
4
Char
"WAVE"标志

0CH
4
Char
"fmt"标志

10H
4
 
过渡字节（不定）

14H
2
int16
格式类别

16H
2
int16
通道数

18H
2
int16 
采样率（每秒样本数），表示每个通道的播放速度

1CH
4
int32
波形音频数据传送速率

20H
2
int16
数据块的调整数（按字节算的）

22H
2
 
每样本的数据位数

24H
4
Char
数据标记符＂data＂

28H
4
int32
语音数据的长度

　　解答：
　　将WAV文件格式定义为结构体WAVEFORMAT： 
typedef struct tagWaveFormat
{ 
　char cRiffFlag[4]; 
　UIN32 nFileLen; 
　char cWaveFlag[4]; 
　char cFmtFlag[4]; 
　char cTransition[4]; 
　UIN16 nFormatTag ; 
　UIN16 nChannels; 
　UIN16 nSamplesPerSec; 
　UIN32 nAvgBytesperSec; 
　UIN16 nBlockAlign; 
　UIN16 nBitNumPerSample; 
　char cDataFlag[4]; 
　UIN16 nAudioLength; 

} WAVEFORMAT;

　　假设WAV文件内容读出后存放在指针buffer开始的内存单元内，则分析文件格式的代码很简单，为：
WAVEFORMAT waveFormat;
memcpy( &waveFormat, buffer,sizeof( WAVEFORMAT ) ); 

　　直接通过访问waveFormat的成员，就可以获得特定WAV文件的各项格式信息。
　　剖析：
　　试题6考查面试者组织数据结构的能力，有经验的程序设计者将属于一个整体的数据成员组织为一个结构体，利用指针类型转换，可以将memcpy、memset等函数直接用于结构体地址，进行结构体的整体操作。 透过这个题可以看出面试者的程序设计经验是否丰富。
　　试题7：编写类String的构造函数、析构函数和赋值函数，已知类String的原型为：?????????????????????????????????????????????????
已经封装的文件中写的程序
class String
{ 
　public: 
　　String(const char *str = NULL); // 普通构造函数 
　　String(const String &other); // 拷贝构造函数 
　　~ String(void); // 析构函数 
　　String & operate =(const String &other); // 赋值函数 
　private: 
　　char *m_data; // 用于保存字符串 
};

　　解答：
这是在实现文件中编写的程序
//普通构造函数
String::String(const char *str) 
{
　if(str==NULL) 
　{
　　m_data = new char[1]; // 得分点：对空字符串自动申请存放结束标志'\0'的空
　　//加分点：对m_data加NULL 判断
　　*m_data = '\0'; 
　} 
　else
　{
　　int length = strlen(str); 
　　m_data = new char[length+1]; // 若能加 NULL 判断则更好 
　　strcpy(m_data, str); 
　}
}
// String的析构函数
String::~String(void) 
{
　delete [] m_data; // 或delete m_data;
}
//拷贝构造函数
String::String(const String &other) 　　　// 得分点：输入参数为const型
{ 
　int length = strlen(other.m_data); 
　m_data = new char[length+1]; 　　　　//加分点：对m_data加NULL 判断
　strcpy(m_data, other.m_data); 
}
//赋值函数
String & String::operate =(const String &other) // 得分点：输入参数为const型
{ 
　if(this == &other) 　　//得分点：检查自赋值
　　return *this; 
　delete [] m_data; 　　　　//得分点：释放原有的内存资源
　int length = strlen( other.m_data ); 
　m_data = new char[length+1]; //加分点：对m_data加NULL 判断
　strcpy( m_data, other.m_data ); 
　return *this; 　　　　　　　　//得分点：返回本对象的引用
}

　　剖析：
　　能够准确无误地编写出String类的构造函数、拷贝构造函数、赋值函数和析构函数的面试者至少已经具备了C++基本功的60%以上！
　　在这个类中包括了指针类成员变量m_data，当类中包括指针类成员变量时，一定要重载其拷贝构造函数、赋值函数和析构函数，这既是对C++程序员的基本要求，也是《Effective　C++》中特别强调的条款。
　　仔细学习这个类，特别注意加注释的得分点和加分点的意义，这样就具备了60%以上的C++基本功！
　　　　const关键字至少有下列n个作用：
　　（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
　　（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
　　（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
　　（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
　　（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。例如：
const classA operator*(const classA& a1,const classA& a2);

　　operator*的返回结果必须是一个const对象。如果不是，这样的变态代码也不会编译出错：
classA a, b, c;
(a * b) = c; // 对a*b的结果赋值

　　操作(a * b) = c显然不符合编程者的初衷，也没有任何意义。、
　　4.技巧题
　　试题1：请写一个C函数，若处理器是Big_endian的，则返回0；若是Little_endian的，则返回
　　解答：
int checkCPU()
{
　{
　　union w
　　{ 
　　　int a;
　　　char b;
　　} c;
　　c.a = 1;0X00 00 00 01四个字节，c.b为一个字节
　　return (c.b == 1);大端的c.b为00，小端的c.b为01？？？？
　}//因为联合体共用一个空间
}

　　剖析：
　　嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。采用Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。例如，16bit宽的数0x1234在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
内存地址
存放内容
0x4000
0x34
0x4001
0x12

　　而在Big-endian模式CPU内存中的存放方式则为：
内存地址
存放内容
0x4000
0x12
0x4001
0x34

　　32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
内存地址
存放内容
0x4000
0x78
0x4001
0x56
0x4002
0x34
0x4003
0x12

　　而在Big-endian模式CPU内存中的存放方式则为：
内存地址
存放内容
0x4000
0x12
0x4001
0x34
0x4002
0x56
0x4003
0x78

　　联合体union的存放顺序是所有成员都从低地址开始存放，面试者的解答利用该特性，轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写。如果谁能当场给出这个解答，那简直就是一个天才的程序员。
　　试题2：写一个函数返回1+2+3+…+n的值（假定结果不会超过长整型变量的范围） 
　　解答：
int Sum( int n )
{ 
　return ( (long)1 + n) * n / 2;　　//或return (1l + n) * n / 2;
}

　　剖析：
　　对于这个题，只能说，也许最简单的答案就是最好的答案。下面的解答，或者基于下面的解答思路去优化，不管怎么“折腾”，其效率也不可能与直接return ( 1 l + n ) * n / 2相比！ 
int Sum( int n )
{
　long sum = 0;
　for( int i=1; i<=n; i++ )
　{
　　sum += i;
　}
　return sum;
} 

　　
volatile关键字的作用
volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。下面举例说明。在DSP开发中，经常需要等待某个事件的触发，所以经常会写出这样的程序：
short flag;
void test()
{
do1();
while(flag==0);
do2();
}这段程序等待内存变量flag的值变为1(怀疑此处是0,有点疑问,)之后才运行do2()。变量flag的值由别的程序更改，这个程序可能是某个硬件中断服务程序。例如：如果某个按钮按下的话，就会对DSP产生中断，在按键中断程序中修改flag为1，这样上面的程序就能够得以继续运行。但是，编译器并不知道flag的值会被别的程序修改，因此在它进行优化的时候，可能会把flag的值先读入某个寄存器，然后等待那个寄存器变为1。如果不幸进行了这样的优化，那么while循环就变成了死循环，因为寄存器的内容不可能被中断服务程序修改。为了让程序每次都读取真正flag变量的值，就需要定义为如下形式：
volatile short flag;
需要注意的是，没有volatile也可能能正常运行，但是可能修改了编译器的优化级别之后就又不能正常运行了。因此经常会出现debug版本正常，但是release版本却不能正常的问题。所以为了安全起见，只要是等待别的程序修改某个变量的话，就加上volatile关键字。

C语言void及void指针深层探索

　　1、void的含义
　　void的字面意思是“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据。
　　void几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个void变量，让我们试着来定义：
void a;
　　这行语句编译时会出错，提示“illegal use of type 'void'”。不过，即使void a的编译不会出错，它也没有任何实际意义。
　　void真正发挥的作用在于：
　　（1） 对函数返回的限定；
　　（2） 对函数参数的限定。
　　我们将在第三节对以上二点进行具体说明。
　　众所周知，如果指针p1和p2的类型相同，那么我们可以直接在p1和p2间互相赋值；如果p1和p2指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。 
　　例如：
float *p1;
int *p2;
p1 = p2;
　　其中p1 = p2语句会编译出错，提示“'=' : cannot convert from 'int *' to 'float *'”，必须改为：
p1 = (float *)p2;
　　而void *则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换：
void *p1;
int *p2;
p1 = p2;
　　但这并不意味着，void *也可以无需强制类型转换地赋给其它类型的指针。因为“无类型”可以包容“有类型”，而“有类型”则不能包容“无类型”。道理很简单，我们可以说“男人和女人都是人”，但不能说“人是男人”或者“人是女人”。下面的语句编译出错：
void *p1;
int *p2;
p2 = p1;
　　提示“'=' : cannot convert from 'void *' to 'int *'”。
3.void的使用
　　下面给出void关键字的使用规则：
　　规则一 如果函数没有返回值，那么应声明为void类型
　　在C语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理。但是许多程序员却误以为其为void类型。例如：
add ( int a, int b )
{
return a + b;
}
int main(int argc, char* argv[])
{
printf ( "2 + 3 = %d", add ( 2, 3) );
}
　　程序运行的结果为输出：
　　2 + 3 = 5
　　这说明不加返回值说明的函数的确为int函数。
　　林锐博士《高质量C/C++编程》中提到：“C++语言有很严格的类型安全检查，不允许上述情况（指函数不加类型声明）发生”。可是编译器并不一定这么认定，譬如在Visual C++6.0中上述add函数的编译无错也无警告且运行正确，所以不能寄希望于编译器会做严格的类型检查。
　　因此，为了避免混乱，我们在编写C/C++程序时，对于任何函数都必须一个不漏地指定其类型。如果函数没有返回值，一定要声明为void类型。这既是程序良好可读性的需要，也是编程规范性的要求。另外，加上void类型声明后，也可以发挥代码的“自注释”作用。代码的“自注释”即代码能自己注释自己。
　　规则二 如果函数无参数，那么应声明其参数为void
　　在C++语言中声明一个这样的函数：
int function(void)
{
return 1;
}
　　则进行下面的调用是不合法的：
function(2);
　　因为在C++中，函数参数为void的意思是这个函数不接受任何参数。
　　我们在Turbo C 2.0中编译：
＃i nclude "stdio.h"
fun()
{
return 1;
}
main()
{
printf("%d",fun(2));
getchar();
}
　　编译正确且输出1，这说明，在C语言中，可以给无参数的函数传送任意类型的参数，但是在C++编译器中编译同样的代码则会出错。在C++中，不能向无参数的函数传送任何参数，出错提示“'fun' : function does not take 1 parameters”。
　　所以，无论在C还是C++中，若函数不接受任何参数，一定要指明参数为void。
　　规则三 小心使用void指针类型
　　按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即下列操作都是不合法的：
void * pvoid;
pvoid++; //ANSI：错误
pvoid += 1; //ANSI：错误
//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。
//例如：
int *pint;
pint++; //ANSI：正确
　　pint++的结果是使其增大sizeof(int)。
　　但是大名鼎鼎的GNU(GNU's Not Unix的缩写)则不这么认定，它指定void *的算法操作与char *一致。
　　因此下列语句在GNU编译器中皆正确：
pvoid++; //GNU：正确
pvoid += 1; //GNU：正确
　　pvoid++的执行结果是其增大了1。
　　在实际的程序设计中，为迎合ANSI标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：
void * pvoid;
(char *)pvoid++; //ANSI：正确；GNU：正确
(char *)pvoid += 1; //ANSI：错误；GNU：正确
　　GNU和ANSI还有一些区别，总体而言，GNU较ANSI更“开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合ANSI标准。
　　规则四 如果函数的参数可以是任意类型指针，那么应声明其参数为void *
　　典型的如内存操作函数memcpy和memset的函数原型分别为：
void * memcpy(void *dest, const void *src, size_t len);
void * memset ( void * buffer, int c, size_t num );
　　这样，任何类型的指针都可以传入memcpy和memset中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。如果memcpy和memset的参数类型不是void *，而是char *，那才叫真的奇怪了！这样的memcpy和memset明显不是一个“纯粹的，脱离低级趣味的”函数！
　　下面的代码执行正确：
//示例：memset接受任意类型指针
int intarray[100];
memset ( intarray, 0, 100*sizeof(int) ); //将intarray清0
//示例：memcpy接受任意类型指针
int intarray1[100], intarray2[100];
memcpy ( intarray1, intarray2, 100*sizeof(int) ); //将intarray2拷贝给intarray1
　　有趣的是，memcpy和memset函数返回的也是void *类型，标准库函数的编写者是多么地富有学问啊！
　　规则五 void不能代表一个真实的变量
　　下面代码都企图让void代表一个真实的变量，因此都是错误的代码：
void a; //错误
function(void a); //错误
　　void体现了一种抽象，这个世界上的变量都是“有类型”的，譬如一个人不是男人就是女人.
　　void的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中“抽象基类”的概念，也很容易理解void数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个void（让我们类比的称void为“抽象数据类型”）变量。
关于CONST的用法
const在C语言中算是一个比较新的描述符，我们称之为常量修饰符，意即其所修饰
的对象为常量(immutable)。
我们来分情况看语法上它该如何被使用。
1、函数体内修饰局部变量。
例：
void func(){
const int a=0;
}
首先，我们先把const这个单词忽略不看，那么a是一个int类型的局部自动变量，
我们给它赋予初始值0。
然后再看const.
const作为一个类型限定词，和int有相同的地位。
const int a;
int const a;
是等价的。于是此处我们一定要清晰的明白，const修饰的对象是谁，是a,和int没
有关系。const 要求他所修饰的对象为常量，不可被改变，不可被赋值，不可作为
左值（l-value)。
这样的写法也是错误的。
const int a;
a=0;
这是一个很常见的使用方式：
const double pi=3.14;
在程序的后面如果企图对pi再次赋值或者修改就会出错。
然后看一个稍微复杂的例子。
const int* p;
还是先去掉const 修饰符号。
注意，下面两个是等价的。
int* p;
int *p;
其实我们想要说的是，*p是int类型。那么显然，p就是指向int的指针。
同理
const int* p;
其实等价于
const int (*p);
int const (*p);
即，*p是常量。也就是说，p指向的数据是常量。
于是
p+=8; //合法
*p=3; //非法，p指向的数据是常量。
那么如何声明一个自身是常量指针呢？方法是让const尽可能的靠近p;
int* const p;
const右面只有p,显然，它修饰的是p,说明p不可被更改。然后把const去掉，可以
看出p是一个指向 int形式变量的指针。
于是
p+=8; //非法
*p=3; //合法
再看一个更复杂的例子，它是上面二者的综合
const int* const p;
说明p自己是常量，且p指向的变量也是常量。
于是
p+=8; //非法
*p=3; //非法
const 还有一个作用就是用于修饰常量静态字符串。
例如：
const char* name="David";
如果没有const,我们可能会在后面有意无意的写name[4]='x'这样的语句，这样会
导致对只读内存区域的赋值，然后程序会立刻异常终止。有了 const,这个错误就
能在程序被编译的时候就立即检查出来，这就是const的好处。让逻辑错误在编译
期被发现。
const 还可以用来修饰数组
const char s[]="David";
与上面有类似的作用。
2、在函数声明时修饰参数
来看实际中的一个例子。
NAME
memmove -- copy byte string
LIBRARY
Standard C Library (libc, -lc)
SYNOPSIS
＃i nclude <string.h>
void *
memmove(void *dst, const void *src, size_t len);
这是标准库中的一个函数，用于按字节方式复制字符串（内存）。
它的第一个参数，是将字符串复制到哪里去（dest),是目的地，这段内存区域必须
是可写。
它的第二个参数，是要将什么样的字符串复制出去，我们对这段内存区域只做读
取，不写。
于是，我们站在这个函数自己的角度来看，src 这个指针，它所指向的内存内所存
储的数据在整个函数执行的过程中是不变。于是src所指向的内容是常量。于是就
需要用const修饰。
例如，我们这里这样使用它。
const char* s="hello";
char buf[100];
memmove(buf,s,6); //这里其实应该用strcpy或memcpy更好
如果我们反过来写，
memmove(s,buf,6);
那么编译器一定会报错。事实是我们经常会把各种函数的参数顺序写反。事实是编
译器在此时帮了我们大忙。如果编译器静悄悄的不报错，(在函数声明处去掉
const即可),那么这个程序在运行的时候一定会崩溃。
这里还要说明的一点是在函数参数声明中const一般用来声明指针而不是变量本身。
例如，上面的size_t len,在函数实现的时候可以完全不用更改len的值，那么是否
应该把len也声明为常量呢？可以，可以这么做。我们来分析这么做有什么优劣。
如果加了const,那么对于这个函数的实现者，可以防止他在实现这个函数的时候修
改不需要修改的值(len),这样很好。
但是对于这个函数的使用者，
1。这个修饰符号毫无意义，我们可以传递一个常量整数或者一个非常量整数过
去，反正对方获得的只是我们传递的一个copy。
2。暴露了实现。我不需要知道你在实现这个函数的时候是否修改过len的值。
所以，const一般只用来修饰指针。
再看一个复杂的例子
int execv(const char *path, char *const argv[]);
着重看后面这个，argv.它代表什么。
如果去掉const,我们可以看出
char * argv[];
argv是一个数组，它的每个元素都是char *类型的指针。
如果加上const.那么const修饰的是谁呢？他修饰的是一个数组，argv[],意思就是
说这个数组的元素是只读的。那么数组的元素的是什么类型呢？是char *类型的指
针.也就是说指针是常量，而它指向的数据不是。
于是
argv[1]=NULL; //非法
argv[0][0]='a'; //合法
3、全局变量。
我们的原则依然是，尽可能少的使用全局变量。
我们的第二条规则 则是，尽可能多的使用const。
如果一个全局变量只在本文件中使用，那么用法和前面所说的函数局部变量没有什
么区别。
如果它要在多个文件间共享，那么就牵扯到一个存储类型的问题。
有两种方式。
1.使用extern
例如
/* file1.h */
extern const double pi;
/* file1.c */
const double pi=3.14;
然后其他需要使用pi这个变量的，包含file1.h
＃i nclude "file1.h"
或者，自己把那句声明复制一遍就好。
这样做的结果是，整个程序链接完后，所有需要使用pi这个变量的共享一个存储区域。
2.使用static,静态外部存储类
/* constant.h */
static const pi=3.14;
需要使用这个变量的*.c文件中，必须包含这个头文件。
前面的static一定不能少。否则链接的时候会报告说该变量被多次定义。
这样做的结果是，每个包含了constant.h的*.c文件，都有一份该变量自己的copy,
该变量实际上还是被定义了多次，占用了多个存储空间，不过在加了static关键字
后，解决了文件间重定义的冲突。
坏处是浪费了存储空间，导致链接完后的可执行文件变大。但是通常，这个，小小
几字节的变化，不是问题。
好处是，你不用关心这个变量是在哪个文件中被初始化的。
最后，说说const的作用。
const 的好处，是引入了常量的概念，让我们不要去修改不该修改的内存。直接的
作用就是让更多的逻辑错误在编译期被发现。所以我们要尽可能的多使用const。
但是很多人并不习惯使用它，更有甚者，是在整个程序 编写／调试 完后才补
const。如果是给函数的声明补const,尚好。如果是给 全局／局部变量补const,那
么……那么，为时已晚，无非是让代码看起来更漂亮了。
c语言中的结构（struct)和联合（union）简介

联     合(union)
  1. 联合说明和联合变量定义
  联合也是一种新的数据类型, 它是一种特殊形式的变量。
  联合说明和联合变量定义与结构十分相似。其形式为:
  union 联合名{
      数据类型成员名;
      数据类型成员名;
      ...
  } 联合变量名;
  联合表示几个变量公用一个内存位置, 在不同的时间保存不同的数据类型 和不同长度的变量。
  下例表示说明一个联合a_bc:
  union a_bc{
      int i;
      char mm;
  };
  再用已说明的联合可定义联合变量。
  例如用上面说明的联合定义一个名为lgc的联合变量, 可写成:
    union a_bc lgc;
  在联合变量lgc中, 整型量i和字符mm公用同一内存位置。
  当一个联合被说明时, 编译程序自动地产生一个变量, 其长度为联合中最大的变量长度。
  联合访问其成员的方法与结构相同。同样联合变量也可以定义成数组或指针,但定义为指针时, 也要用"->;"符号, 此时联合访问成员可表示成:
  联合名->;成员名
  另外, 联合既可以出现在结构内, 它的成员也可以是结构。
  例如:
  struct{
      int age;
      char *addr;
      union{
          int i;
          char *ch;
      }x;
  }y[10];
  若要访问结构变量y[1]中联合x的成员i, 可以写成:
    y[1].x.i;
  若要访问结构变量y[2]中联合x的字符串指针ch的第一个字符可写成:
    *y[2].x.ch;
  若写成"y[2].x.*ch;"是错误的。
  2. 结构和联合的区别
  结构和联合有下列区别:
  1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合转只存放了一个被选中的成员, 而结构的所有成员都存在。
  2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。
  下面举一个例了来加对深联合的理解。
  例4:
main()
{
  union{             /*定义一个联合*/
  int i;
  struct{         /*在联合中定义一个结构*/
        char first;
        char second;
        }half;
  }number;
  number.i=0x4241;       /*联合成员赋值*/
  printf("%c%c\n", number.half.first, mumber.half.second);
  number.half.first='a';   /*联合中结构成员赋值*/
  number.half.second='b';
  printf("%x\n", number.i);
  getch();
}
  输出结果为:
  AB
  6261
  从上例结果可以看出: 当给i赋值后, 其低八位也就是first和second的值;当给first和second赋字符后, 这两个字符的ASCII码也将作为i 的低八位和高八位。
Volatile 关键字告诉编译器不要持有变量的临时性拷贝。一般用在多线程程序中，以避免在其中一个线程操作该变量时，将其拷贝入寄存器。请看以下情形:
    A线程将变量复制入寄存器，然后进入循环，反复检测寄存器的值是否满足一定条件(它期待B线程改变变量的值。
在此种情况下，当B线程改变了变量的值时，已改变的值对其在寄存器的值没有影响。所以A线程进入死循环。
    volatile 就是在此种情况下使用。
堆和栈的区别
一、预备知识—程序的内存分配
    一个由c/C++编译的程序占用的内存分为以下几个部分
    1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
    2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。
    3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放
    4、文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放
    5、程序代码区—存放函数体的二进制代码。

例子程序
这是一个前辈写的，非常详细
//main.cpp
int a = 0; 全局初始化区
char *p1; 全局未初始化区
main()
{
int b; 栈
char s[] = "abc"; 栈
char *p2; 栈
char *p3 = "123456"; 123456\0在常量区，p3在栈上。
static int c =0； 全局（静态）初始化区
p1 = (char *)malloc(10);
p2 = (char *)malloc(20);
分配得来得10和20字节的区域就在堆区。
strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
}


二、堆和栈的理论知识

2.1申请方式
stack:
由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间
heap:
需要程序员自己申请，并指明大小，在c中malloc函数
如p1 = (char *)malloc(10);
在C++中用new运算符
如p2 = (char *)malloc(10);
但是注意p1、p2本身是在栈中的。

2.2申请后系统的响应
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

2.4申请效率的比较
栈由系统自动分配，速度较快。但程序员是无法控制的。
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。

2.5堆和栈中的存储内容
栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

2.6存取效率的比较
char s1[] = "aaaaaaaaaaaaaaa";
char *s2 = "bbbbbbbbbbbbbbbbb";
aaaaaaaaaaa是在运行时刻赋值的；
而bbbbbbbbbbb是在编译时就确定的；
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。
比如：
＃i nclude
void main()
{
char a = 1;
char c[] = "1234567890";
char *p ="1234567890";
a = c[1];
a = p[1];
return;
}
对应的汇编代码
10: a = c[1];
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]
0040106A 88 4D FC mov byte ptr [ebp-4],cl
11: a = p[1];
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]
00401070 8A 42 01 mov al,byte ptr [edx+1]
00401073 88 45 FC mov byte ptr [ebp-4],al
第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。

2.7小结
堆和栈的区别可以用如下的比喻来看出：
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。



windows进程中的内存结构


在阅读本文之前，如果你连堆栈是什么多不知道的话，请先阅读文章后面的基础知识。

接触过编程的人都知道，高级语言都能通过变量名来访问内存中的数据。那么这些变量在内存中是如何存放的呢？程序又是如何使用这些变量的呢？下面就会对此进行深入的讨论。下文中的C语言代码如没有特别声明，默认都使用VC编译的release版。

首先，来了解一下 C 语言的变量是如何在内存分部的。C 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码：

＃i nclude <stdio.h>

int g1=0, g2=0, g3=0;

int main()
{
static int s1=0, s2=0, s3=0;
int v1=0, v2=0, v3=0;

//打印出各个变量的内存地址

printf("0x%08x\n",&v1); //打印各本地变量的内存地址
printf("0x%08x\n",&v2);
printf("0x%08x\n\n",&v3);
printf("0x%08x\n",&g1); //打印各全局变量的内存地址
printf("0x%08x\n",&g2);
printf("0x%08x\n\n",&g3);
printf("0x%08x\n",&s1); //打印各静态变量的内存地址
printf("0x%08x\n",&s2);
printf("0x%08x\n\n",&s3);
return 0;
}

编译后的执行结果是：

0x0012ff78
0x0012ff7c
0x0012ff80

0x004068d0
0x004068d4
0x004068d8

0x004068dc
0x004068e0
0x004068e4

输出的结果就是变量的内存地址。其中v1,v2,v3是本地变量，g1,g2,g3是全局变量，s1,s2,s3是静态变量。你可以看到这些变量在内存是连续分布的，但是本地变量和全局变量分配的内存地址差了十万八千里，而全局变量和静态变量分配的内存是连续的。这是因为本地变量和全局/静态变量是分配在不同类型的内存区域中的结果。对于一个进程的内存空间而言，可以在逻辑上分成3个部份：代码区，静态数据区和动态数据区。动态数据区一般就是“堆栈”。“栈 (stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址”和“栈顶”地址来描述。全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区，即堆栈中。程序通过堆栈的基地址和偏移量来访问本地变量。


├———————┤低端内存区域
│ …… │
├———————┤
│ 动态数据区 │
├———————┤
│ …… │
├———————┤
│ 代码区 │
├———————┤
│ 静态数据区 │
├———————┤
│ …… │
├———————┤高端内存区域


堆栈是一个先进后出的数据结构，栈顶地址总是小于等于栈的基地址。我们可以先了解一下函数调用的过程，以便对堆栈在程序中的作用有更深入的了解。不同的语言有不同的函数调用规定，这些因素有参数的压入规则和堆栈的平衡。windows API的调用规则和ANSI C的函数调用规则是不一样的，前者由被调函数调整堆栈，后者由调用者调整堆栈。两者通过“__stdcall”和“__cdecl”前缀区分。先看下面这段代码：

＃i nclude <stdio.h>

void __stdcall func(int param1,int param2,int param3)
{
int var1=param1;
int var2=param2;
int var3=param3;
printf("0x%08x\n",?m1); //打印出各个变量的内存地址
printf("0x%08x\n",?m2);
printf("0x%08x\n\n",?m3);
printf("0x%08x\n",&var1);
printf("0x%08x\n",&var2);
printf("0x%08x\n\n",&var3);
return;
}

int main()
{
func(1,2,3);
return 0;
}

编译后的执行结果是：

0x0012ff78
0x0012ff7c
0x0012ff80

0x0012ff68
0x0012ff6c
0x0012ff70


├———————┤<—函数执行时的栈顶（ESP）、低端内存区域
│ …… │
├———————┤
│ var 1 │
├———————┤
│ var 2 │
├———————┤
│ var 3 │
├———————┤
│ RET │
├———————┤<—“__cdecl”函数返回后的栈顶（ESP）
│ parameter 1 │
├———————┤
│ parameter 2 │
├———————┤
│ parameter 3 │
├———————┤<—“__stdcall”函数返回后的栈顶（ESP）
│ …… │
├———————┤<—栈底（基地址 EBP）、高端内存区域


上图就是函数调用过程中堆栈的样子了。首先，三个参数以从又到左的次序压入堆栈，先压“param3”，再压“param2”，最后压入“param1”；然后压入函数的返回地址(RET)，接着跳转到函数地址接着执行（这里要补充一点，介绍UNIX下的缓冲溢出原理的文章中都提到在压入RET后，继续压入当前EBP，然后用当前ESP代替EBP。然而，有一篇介绍windows下函数调用的文章中说，在windows下的函数调用也有这一步骤，但根据我的实际调试，并未发现这一步，这还可以从param3和var1之间只有4字节的间隙这点看出来）；第三步，将栈顶(ESP)减去一个数，为本地变量分配内存空间，上例中是减去12字节(ESP=ESP-3*4，每个int变量占用4个字节)；接着就初始化本地变量的内存空间。由于“__stdcall”调用由被调函数调整堆栈，所以在函数返回前要恢复堆栈，先回收本地变量占用的内存(ESP=ESP+3*4)，然后取出返回地址，填入EIP寄存器，回收先前压入参数占用的内存(ESP=ESP+3*4)，继续执行调用者的代码。参见下列汇编代码：

;--------------func 函数的汇编代码-------------------

:00401000 83EC0C sub esp, 0000000C //创建本地变量的内存空间
:00401003 8B442410 mov eax, dword ptr [esp+10]
:00401007 8B4C2414 mov ecx, dword ptr [esp+14]
:0040100B 8B542418 mov edx, dword ptr [esp+18]
:0040100F 89442400 mov dword ptr [esp], eax
:00401013 8D442410 lea eax, dword ptr [esp+10]
:00401017 894C2404 mov dword ptr [esp+04], ecx

……………………（省略若干代码）

:00401075 83C43C add esp, 0000003C ;恢复堆栈，回收本地变量的内存空间
:00401078 C3 ret 000C ;函数返回，恢复参数占用的内存空间
;如果是“__cdecl”的话，这里是“ret”，堆栈将由调用者恢复

;-------------------函数结束-------------------------


;--------------主程序调用func函数的代码--------------

:00401080 6A03 push 00000003 //压入参数param3
:00401082 6A02 push 00000002 //压入参数param2
:00401084 6A01 push 00000001 //压入参数param1
:00401086 E875FFFFFF call 00401000 //调用func函数
;如果是“__cdecl”的话，将在这里恢复堆栈，“add esp, 0000000C”

聪明的读者看到这里，差不多就明白缓冲溢出的原理了。先来看下面的代码：

＃i nclude <stdio.h>
＃i nclude <string.h>

void __stdcall func()
{
char lpBuff[8]="\0";
strcat(lpBuff,"AAAAAAAAAAA");
return;
}

int main()
{
func();
return 0;
}

编译后执行一下回怎么样？哈，“"0x00414141"指令引用的"0x00000000"内存。该内存不能为"read"。”，“非法操作”喽！ "41"就是"A"的16进制的ASCII码了，那明显就是strcat这句出的问题了。"lpBuff"的大小只有8字节，算进结尾的\0，那 strcat最多只能写入7个"A"，但程序实际写入了11个"A"外加1个\0。再来看看上面那幅图，多出来的4个字节正好覆盖了RET的所在的内存空间，导致函数返回到一个错误的内存地址，执行了错误的指令。如果能精心构造这个字符串，使它分成三部分，前一部份仅仅是填充的无意义数据以达到溢出的目的，接着是一个覆盖RET的数据，紧接着是一段shellcode，那只要着个RET地址能指向这段shellcode的第一个指令，那函数返回时就能执行shellcode了。但是软件的不同版本和不同的运行环境都可能影响这段shellcode在内存中的位置，那么要构造这个RET是十分困难的。一般都在RET和shellcode之间填充大量的NOP指令，使得exploit有更强的通用性。


├———————┤<—低端内存区域
│ …… │
├———————┤<—由exploit填入数据的开始
│ │
│ buffer │<—填入无用的数据
│ │
├———————┤
│ RET │<—指向shellcode，或NOP指令的范围
├———————┤
│ NOP │
│ …… │<—填入的NOP指令，是RET可指向的范围
│ NOP │
├———————┤
│ │
│ shellcode │
│ │
├———————┤<—由exploit填入数据的结束
│ …… │
├———————┤<—高端内存区域


windows下的动态数据除了可存放在栈中，还可以存放在堆中。了解C++的朋友都知道，C++可以使用new关键字来动态分配内存。来看下面的C++代码：

＃i nclude <stdio.h>
＃i nclude <iostream.h>
＃i nclude <windows.h>

void func()
{
char *buffer=new char[128];
char bufflocal[128];
static char buffstatic[128];
printf("0x%08x\n",buffer); //打印堆中变量的内存地址
printf("0x%08x\n",bufflocal); //打印本地变量的内存地址
printf("0x%08x\n",buffstatic); //打印静态变量的内存地址
}

void main()
{
func();
return;
}

程序执行结果为：

0x004107d0
0x0012ff04
0x004068c0

可以发现用new关键字分配的内存即不在栈中，也不在静态数据区。VC编译器是通过windows下的“堆(heap)”来实现new关键字的内存动态分配。在讲“堆”之前，先来了解一下和“堆”有关的几个API函数：

HeapAlloc 在堆中申请内存空间
HeapCreate 创建一个新的堆对象
HeapDestroy 销毁一个堆对象
HeapFree 释放申请的内存
HeapWalk 枚举堆对象的所有内存块
GetProcessHeap 取得进程的默认堆对象
GetProcessHeaps 取得进程所有的堆对象
LocalAlloc
GlobalAlloc

当进程初始化时，系统会自动为进程创建一个默认堆，这个堆默认所占内存的大小为1M。堆对象由系统进行管理，它在内存中以链式结构存在。通过下面的代码可以通过堆动态申请内存空间：

HANDLE hHeap=GetProcessHeap();
char *buff=HeapAlloc(hHeap,0,8);

其中hHeap是堆对象的句柄，buff是指向申请的内存空间的地址。那这个hHeap究竟是什么呢？它的值有什么意义吗？看看下面这段代码吧：

#pragma comment(linker,"/entry:main") //定义程序的入口
＃i nclude <windows.h>

_CRTIMP int (__cdecl *printf)(const char *, ...); //定义STL函数printf
/*---------------------------------------------------------------------------
写到这里，我们顺便来复习一下前面所讲的知识：
(*注)printf函数是C语言的标准函数库中函数，VC的标准函数库由msvcrt.dll模块实现。
由函数定义可见，printf的参数个数是可变的，函数内部无法预先知道调用者压入的参数个数，函数只能通过分析第一个参数字符串的格式来获得压入参数的信息，由于这里参数的个数是动态的，所以必须由调用者来平衡堆栈，这里便使用了__cdecl调用规则。BTW，Windows系统的API函数基本上是 __stdcall调用形式，只有一个API例外，那就是wsprintf，它使用__cdecl调用规则，同printf函数一样，这是由于它的参数个数是可变的缘故。
---------------------------------------------------------------------------*/
void main()
{
HANDLE hHeap=GetProcessHeap();
char *buff=HeapAlloc(hHeap,0,0x10);
char *buff2=HeapAlloc(hHeap,0,0x10);
HMODULE hMsvcrt=LoadLibrary("msvcrt.dll");
printf=(void *)GetProcAddress(hMsvcrt,"printf");
printf("0x%08x\n",hHeap);
printf("0x%08x\n",buff);
printf("0x%08x\n\n",buff2);
}

执行结果为：

0x00130000
0x00133100
0x00133118

hHeap 的值怎么和那个buff的值那么接近呢？其实hHeap这个句柄就是指向HEAP首部的地址。在进程的用户区存着一个叫PEB(进程环境块)的结构，这个结构中存放着一些有关进程的重要信息，其中在PEB首地址偏移0x18处存放的ProcessHeap就是进程默认堆的地址，而偏移0x90处存放了指向进程所有堆的地址列表的指针。windows有很多API都使用进程的默认堆来存放动态数据，如windows 2000下的所有ANSI版本的函数都是在默认堆中申请内存来转换ANSI字符串到Unicode字符串的。对一个堆的访问是顺序进行的，同一时刻只能有一个线程访问堆中的数据，当多个线程同时有访问要求时，只能排队等待，这样便造成程序执行效率下降。

最后来说说内存中的数据对齐。所位数据对齐，是指数据所在的内存地址必须是该数据长度的整数倍，DWORD数据的内存起始地址能被4除尽，WORD数据的内存起始地址能被2除尽，x86 CPU能直接访问对齐的数据，当他试图访问一个未对齐的数据时，会在内部进行一系列的调整，这些调整对于程序来说是透明的，但是会降低运行速度，所以编译器在编译程序时会尽量保证数据对齐。同样一段代码，我们来看看用VC、Dev-C++和lcc三个不同编译器编译出来的程序的执行结果：

＃i nclude <stdio.h>

int main()
{
int a;
char b;
int c;
printf("0x%08x\n",&a);
printf("0x%08x\n",&b);
printf("0x%08x\n",&c);
return 0;
}

这是用VC编译后的执行结果：
0x0012ff7c
0x0012ff7b
0x0012ff80
变量在内存中的顺序：b(1字节)-a(4字节)-c(4字节)。

这是用Dev-C++编译后的执行结果：
0x0022ff7c
0x0022ff7b
0x0022ff74
变量在内存中的顺序：c(4字节)-中间相隔3字节-b(占1字节)-a(4字节)。

这是用lcc编译后的执行结果：
0x0012ff6c
0x0012ff6b
0x0012ff64
变量在内存中的顺序：同上。

三个编译器都做到了数据对齐，但是后两个编译器显然没VC“聪明”，让一个char占了4字节，浪费内存哦。


基础知识：
堆栈是一种简单的数据结构，是一种只允许在其一端进行插入或删除的线性表。允许插入或删除操作的一端称为栈顶，另一端称为栈底，对堆栈的插入和删除操作被称为入栈和出栈。有一组CPU指令可以实现对进程的内存实现堆栈访问。其中，POP指令实现出栈操作，PUSH指令实现入栈操作。CPU的ESP寄存器存放当前线程的栈顶指针，EBP寄存器中保存当前线程的栈底指针。CPU的EIP寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从 EIP寄存器中读取下一条指令的内存地址，然后继续执行。 
 <br>
堆（Heap）栈（Stack） 
1、内存分配方面： 
    堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式是类似于链表。可能用到的关键字如下：new、malloc、delete、free等等。 
    栈：由编译器(Compiler)自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 
2、申请方式方面： 
    堆：需要程序员自己申请，并指明大小。在c中malloc函数如p1 = (char *)malloc(10)；在C++中用new运算符，但是注意p1、p2本身是在栈中的。因为他们还是可以认为是局部变量。 
    栈：由系统自动分配。 例如，声明在函数中一个局部变量 int b；系统自动在栈中为b开辟空间。 
3、系统响应方面： 
    堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。另外由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 
    栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 
4、大小限制方面： 
    堆：是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 
    栈：在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 
5、效率方面： 
    堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便，另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。 
    栈：由系统自动分配，速度较快。但程序员是无法控制的。 
6、存放内容方面： 
    堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 
    栈：在函数调用时第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈，然后是函数中的局部变量。 注意: 静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
7、存取效率方面： 
    堆：char *s1 = "Hellow Word"；是在编译时就确定的； 
    栈：char s1[] = "Hellow Word"； 是在运行时赋值的；用数组比用指针速度要快一些，因为指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上直接读取。


suningin详解笔试面试题（6）－－moto笔试
10月21号moto的笔试是在我们学校举行的，120分钟的笔试时间，试题内容大致涵盖了c/c++，数据库，数字通信，IQ等方面。我自我感觉做的很顺利，至少两道编程题我都搞定了。一个多小时就把试题做完了，于是，我就把一些试题偷偷抄到了草稿纸上，回去和大家一齐分享。下面就是我抄回来的试题：
1。打印如下图案，共19行，只能有一个for循环（程序已经提供）
         *          
        ***         
       *****        
      *******       
     *********      
    ***********
   *************    
  ***************   
  ***************** 
******************* 
  ***************** 
  ***************   
   *************    
    ***********     
     *********      
      *******       
       *****        
        ***         
         *          
for(i=0;i<19;i++)
{
}
在网上搜寻了些解答，如下：
1.
#include<iostream>
#include<iomanip>
#include<string>
using namespace std;
int main()
{
 int a[2]={-1,1};
 string str="*******************";
 int i=0,j=9,t=1;
 for(i=0;i<19;++i)
 {
  j+=a[i<10];
  if(i!=0)t=t+a[i<10]*2;
  cout<<setw(j)<<right<<str.substr(0,t)<<endl;
 }
 return 0;
} 

2.
#include<stdio.h>
#include<string.h> 
int main()
{
 char * tempStr = "*******************";
 char * blank = " ";
 int i = 0;
 char * dataStr [20];
 char blankstr[10];

 for ( i=0; i<19; i++)
 {
  memset(dataStr, 0, 20);
  memset(blankstr,0,10);
  if (i<10)
  {
   memcpy(blankstr,blank,9-i);
   memcpy(dataStr, tempStr, (i+1)*2-1);
  }
  else
  {
   memcpy(blankstr,blank,i-9);
   memcpy(dataStr, tempStr, (19-i)*2-1);
  }
  printf("%s",blankstr);
  printf("%s\n", dataStr);
 }
 return 0;
} 
3。
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define MAXSIZE 19
void main()
{
    int i,k;
   char ch;
   char format[30],stars[30],tmp[3];
   ch = '*';
   strcpy(stars,"");
   for(i=0; i<MAXSIZE; i++)
  {
      if(i <= MAXSIZE/2)
     {
         k = (MAXSIZE + 1)/2 - i;
         strcpy(format,"%");
         itoa(k,tmp,10);
        strcat(format,tmp);
        strcat(format,"c");
        if(i>0)
           {
                strcat(stars,"**");
                strcat(format,stars);
            }
         printf(format,ch);
         printf("\n");
      }
     else
     {
         k = i + 2 - (MAXSIZE + 1)/2;
         strcpy(format,"%");
         itoa(k,tmp,10);
        strcat(format,tmp);
        strcat(format,"c");
        stars[MAXSIZE -1 -(2*(i+1) - MAXSIZE -1)] = 0;
         strcat(format,stars);
        printf(format,ch);
        printf("\n");
     }
 }
 //getchar();
 //getchar();
}
 
注:printf格式%mc表示输入字符宽度为m位,左边补空格.

4。
有高人发的回帖:
#include<iostream.h>
int main(int argv,int * argc[])
{
 for(int i=0;i<19;i++)
 {
  static char cc[19] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};
        //19个空格
  static const int j = 19 / 2;   //j值为9
        static int count = 0;          //count为离中间元素的距离
        if( i < ( 19 / 2 + 1)) 
  {
          cc[j - count] = '*';
          cc[j + count] = '*';
          cout << cc << endl;
          count++;
  } 
  else 
  {
          count--;
          cc[j - count] = ' ';
          cc[j + count] = ' ';
          cout << cc << endl;
  }
 }
 return 0;
}
 
一看就知差距,我的晦涩难懂
我想用两个数组,一个存放空格数量,一个存放'*'
但是下面这个程序只用了一个数组，把每一行输出的形状存到数组中，妙！我咋就没想到？！

2.
void fun(int x)
{
 if(x/2>0)fun(x/2);
 printf("%d",x);
}
求fun(10)的输出结果     //12510，一个递归，很简单的
3。
#define f1(n) (n)*(n)
         int i=5;
 int k=0;
 k=f1(i++);
 printf("%d %d",i,k);
输出结果：  ：// 7 25，++放后面是后算的
4。下面那个for循环是无限循环？
for(int i=010;i==10;i+=0)       //这个明显不是，010等于8，8 != 10，一判断就出去了
for(int i=10;(i++^--i)==0;i+=0)   //无限循环
还有几个忘了
5.Email relay 和Email access分别用了什么协议？（其他还有很多，略）
SMTP,POP3
注: SMTP：Simple MAIL Transfer Protocol，简单邮件传输协议，互联网上的电子邮件发送就是使用这个协议。SMTP open relay host：开放的SMTP中继主机——它很可能被恶意的人利用，来产生大量垃圾邮件.
POP3协议允许客户机通过（临时的或永久的）TCP/IP连接或其他网络协议的连接，从一个服务器（这时就称为POP3服务器）上获取电子邮件（E-MAIL），POP3不负责发送邮件.

6。in a mobile phone,软件运行期，stack data 存在于
a.rom,b.flash c.eeprom d.ram e.none of the above
答：D.ram。这题稍微涉及到一点硬件知识，ROM的全称是Read Only Memory，即只读存储器，flash ，eeprom都是ROM家族的一员，RAM是Random Access Memory的简称，意为随机存取存储器，也就是内存了。不管是堆还是栈都是放在内存里的。

8.
 char a[2][2][3]={{{1,6,3},{5,4,15}},{{3,5,33},{23,12,7}} };
 for(int i=0;i<12;i++)
 printf("%d ",_______);   //a[i/6][((i>=6 ? (i-6):i)+2)/5][i%3]);  或者：*(*(*(a+i/6)+(i/3%2))+i%3)    *((char *)a + i)
 //*(**a + i)
空格处填上合适的语句，顺序打印出a中的数字？？？？？？？？？？？
9。void fun(char *a,char *b)
{
 a=b;
 (*a)++;//把b的地址给a,访问a的地址相当于访问b的地址也就是访问s2，于是本函数只是该变了s2的值，s1没被改变
}
void main()
{
 char s1='A',s2='b';
 char *p1=&s1;
 char *p2=&s2;
 fun(p1,p2);
 printf("%c%c",s1,s2);
输出结果：  // Ac吧，这个比较简单考完出来，我是很有信心能进入面试的，等了几天，陆续有人收到通知，我却没有。我的信心大受打击，怎么可能呢！？后来了解到，moto的笔试25道选择题做对19道才能参加面试，后面的题目基本不看。回想下，我后面填空和大题做的不错可是选择题确实做的不咋的（ 郁闷啊，给宿舍的同学鄙视了：你的水平也不行啊~~~）
    这个时候我开始感觉有点压力了，有点危机感了
MTK深圳公司嵌入式软件工程师笔试题 
//MTK深圳嵌入式软件工程师笔试题(B卷)
//1*****************************************
#define pi 3.14
#define Area(R) pi*R*R
main()
{
 int r1=5,r2=2;
 double s=0;
 s=Area(r1-r2);
 printf("The area is %f",s);
}
//求结果       我：3.14*5-2*5-2=
//2*********************************************
//函数 int compare(int a,int b),定义为该函数的函数指针P:为___                      我：int（*p）(int,int)__总结：将函数名换为*p即可__________
//3*********************************************
#include<stdio.h>
void sub(char*s,int num)
{
 int i ,j=num;
 char t;
 while(j-->1)
 {
   for(i=0;i<j;i++)
   {
     if(s[i]<s[i+1])
     {
       t=s[i];
       s[i]=s[i+1];
       s[i+1]=t;
     }
   }
 }
}
main()
{
 char*s="CEAeded";
 sub(s,6);
 printf("%s\n",s)
}
//求结果 我eeddECA
//4**********************************************
//交换两个变量的值,不使用第三个变量,即a=3,b=5交换
//后b=3,a=5
     unsigned char a=3,b=5;
     
     
//5**************************************************
#define N 100
void GetMemory1(char*p)
{
 p=(char*)malloc(sizeof(char)*N);
 strcpy(p,"Have a good day!");
}
char*GetMemory2(void)
{
 char p[]="Have a good day!";
 return p;
}
void main(void)
{
 char*str1=NULL,*str2=NULL;
 GetMemory1(str1);
 GetMemory2(str2);
 printf("\nstr1:%s",str1);
 printf("\nstr2:%s",str2);
 
//6******************************************************
//构造N个结点的单链表返回链表头指针,要求链表中各结点顺序
//与结点数据输入顺序相反,例如输入1,2,3,4,5,形成的链表为
//head->5 4 3 2 1 ,补充程序
#define N 10
typedef struct Node
{
 int data;
 struct Node*next;
}NODE;
int Get_Data(int i);//定义省略
Node*Create_u()
{
 int i;
 NODE*p,*Head=NULL;
 for(i=0;i<N;i++)
 {
  VP=New NODE;
  P->Data=Get_Data(i);
  _____？？？？？？？___________;
  ________________;
 }
 return Head;
}
//7**********************************************
//N个结点链表,每个结点中存放一个字符,判断链表存放的字符是否
//中心对称,即a b c c b a或a b c b a,补充程序
typedef struct Node
{
 int data;
 struct Node*next;
}NODE;
bool Is_symmeic(NODE*head,*int n)
{
 char D[N];
 int i,d;
 __________;
 for(i=0;i<d;i++)
 {
  D[i]=head->data;
  head=head->next;
 }
 if(__________)
 {
  head=head->next;
 }
 while(head)
 {
  _______________;
  if(D[i]!=head->data)
  {
   return false;
  }
  head=head->next;
 }
 return true;
}
//8*************************************
//str中只含有大写和小写字母函数change_move(char*str)将字符串中大写改成*并
//移到前面小写后返回*的个数
//如AabBdcYY改为*****abd,返回5
int chang_move(char*str)
{
 int len,i,curstr=-1;
 len=strlen(str);
 for(i=len-1;i>=0;i--)
 {
  if(str[i]>='A'&&str[i]<='Z')
   {
    str[i]='*';
    if(cursor==-1)
    {
     cursor=i;
    }
    else if(cursor>i)
    {
     _____________;
     str[i]='*';
     _____________;
     
    }
 }
 return____________;
}
//9***********************************************
//求两个字符串的第一个公共子串,并返回该子串
//如:"a b c d e f g e h i" "a a c d e f * * g e h i"
//第一个为"c d e f";不许用strcmp()
char*Maxf(char*str1,char*str2)
{
}



嵌入式或LINUX相关研发面试题目
基础试题(C语言) 
  
一、ANSI C/C++方面的知识 
一.1、简答题。下面的题目必须全部答对才给分(20分)： 
1、 如何在C中初始化一个字符数组。 
2、 如何在C中为一个数组分配空间。 
3、 如何初始化一个指针数组。 
4、 如何定义一个有10个元素的整数型指针数组。 
5、 s[10]的另外一种表达方式是什么。 
6、 GCC3.2.2版本中支持哪几种编程语言。 
7、 要使用CHAR_BIT需要包含哪个头文件。 
8、 对(-1.2345)取整是多少？ 
9、 如何让局部变量具有全局生命期。 
10、C中的常量字符串应在何时定义？ 
11、如何在两个.c文件中引用对方的变量。 
12、使用malloc之前需要做什么准备工作。 
13、realloc函数在使用上要注意什么问题。 
14、strtok函数在使用上要注意什么问题。 
15、gets函数在使用上要注意什么问题。 
16、C语言的词法分析在长度规则方面采用的是什么策略？ 
17、a+++++b所表示的是什么意思？有什么问题？ 
18、如何定义Bool变量的TRUE和FALSE的值。 
19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。 
20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。 
  
一.2、问答题。 
1、----------------------------------------------------------- 
  
"匈牙利命名法"有什么优缺点？(2分) 
  
2、----------------------------------------------------------- 
  
下面x, y, *p的值是多少，有什么问题？(2分) 
int x, y, z = 2; 
int *p=&z; 
x=sizeof*p; 
y=x/*p; /* x=?, *p=?, y=?, 有什么问题？*/ 
  
3、----------------------------------------------------------- 
  
下面的语句是什么意思？如何声明或定义才使它们更易懂？(10分) 
int (*foo())(); 
int (*foo())[]; 
int (*foo[])(); 
(*(void(*)())0)(); 
void (*signal(int,void(*)(int)))(int); 
  
4、----------------------------------------------------------- 
  
本题(2分)。一般使用malloc时，需要进行强制类型转换，如： 
char *s; s = (char *)malloc(31); 
下面中???该如何填写，才可以正确执行强制类型转换？ 
int (*monthp)[31]; monthp = (???)malloc(31); 
  
5、----------------------------------------------------------- 
  
关于C语言运算符优先级的记忆技巧是什么？(2分) 
/* 下面r的值是多少 */ 
int hi, low, r; 
hi=7;low=3; 
r=hi<<4+low; 
  
6、----------------------------------------------------------- 
  
指针和数组的区别是什么？用一个简单的声明把它们区分开。(2分) 
指针和数组的声明在什么情况下是相同的？(2分) 
  
7、----------------------------------------------------------- 
  
C语言的左值(lvalue)和右值(rvalue)的含义是什么？(2分) 
  
8、----------------------------------------------------------- 
  
为什么C语言可以实现printf(char *format, ...)这样可变参数的调用形式？这样有什么缺点？(2分) 
  
9、----------------------------------------------------------- 
  
说明C语言中术语"声明""定义""原型"的含义？(2分) 
  
10、----------------------------------------------------------- 
  
举一个例子，说明使用assert和防错代码的区别。(5分) 
  
11、----------------------------------------------------------- 
  
对语句 if else 与操作符 ? : 使用场合的比较。(2分) 
  
12、----------------------------------------------------------- 
  
编写一个函数，输入一个的整型数字，可以选择按照8/10/16进制输出字符串。 
注意边界值。(5分) 
  
13、----------------------------------------------------------- 
  
本题(2分)。下面是一个16x16的黑白图标： 
static unsigned short stopwatch[] = { 
0x07c6, 
0x1ff7, 
0x383b, 
0x600c, 
0x600c, 
0xc006, 
0xc006, 
0xdf06, 
0xc106, 
0xc106, 
0x610c, 
0x610c, 
0x3838, 
0x1ff0, 
0x07c0, 
0x0000, 
}; 
如何修改声明，可以使之在源代码中形象地表现出图形的模样。 
  
14、----------------------------------------------------------- 
说出可以使用calendar[11][30]变量的四种类型定义。(5分) 
如：int calendar[12][31];   /* 二维数组 */ 
  
15、----------------------------------------------------------- 
使用strcmp，当字符串相同时会返回'\0'。但'\0'一般作为逻辑假， 
因此下面的语句不容易理解: 
if (!strcmp(s, "string")) return EQUATION; 
如何经过简单修改，使之更易懂？(2分) 
  
16、----------------------------------------------------------- 
编写一个自己的完全C语言版本的memset函数，并且评价这个实现的性能和可移植性。(5 
  
分) 
  
17、----------------------------------------------------------- 
在树和图这些数据结构中，通常使用指针来组织数据。如果我们要把这些数据保存到文 
  
件 
中，指针是没有意义的。我们该如何解决这个问题。(2分) 
  
18、----------------------------------------------------------- 
用2种不同的方法计算long变量的"1"bit的个数。(2分) 
  
19、----------------------------------------------------------- 
任意给出一个C的基本数据类型，如何编码判断这个数据类型是有符号还是无符号的？(2 分) 
不得上机实验，写出下面代码的输出。解释这个行为是标准定义的，还是依赖实现的。( 2分) 
int i; 
for (i = 0; i < 10; i++) { 
    int j = i; 
    printf ("%d\n", j); 
} 
  
20、----------------------------------------------------------- 
列出5种以上你所看过的C编程的书籍，并写简要书评。(5分) 
对C的评价。如果要你改造一把菜刀，使之更加安全，你是否会使用这样的菜刀，为什么 ？(5分) 
  
一.3、分析题。 
本题(各5分)。假设下面代码中的变量都是合法变量，调用外部的函数都是正确的。回答几个问题： 
这些代码意图要干什么？ 
是否有问题？ 
如果有问题，该如何修改，或者如何避免类似错误发生？ 
如果没有问题，如果代码有输出，输出是什么？ 
1、----------------------------------------------------------- 
  
int isvowel (char c) 
{ 
    return c=='a'||c=='e'||c=='i'||c=='o'||c=='u'; 
} 
  
2、----------------------------------------------------------- 
  
while (c=='\t'||c=' '||c=='\n') 
    c=getc(f); 
  
3、----------------------------------------------------------- 
  
/* 当x=2, y=3, z=? */ 
if (x==0) 
    if (y==0) 
        z=-1; 
else 
    z=x+y; 
  
4、----------------------------------------------------------- 
  
/* 处理网络事件 */ 
void process_network_code(int x, int y) 
{ 
    /* 选择modes_pointer资源 */ 
    switch (line) { 
        case THING1: 
            /* 处理异常1#, 使用老的modes_pointer资源 */ 
            doit1(); 
            break; 
        case THING2: 
            /* 处理异常2#, 需要重新启动服务 */ 
            if (x == STUFF) { 
                /* 重新申请modes_pointer资源，没有初始化 */ 
                do_first_stuff(); 
                /* 在这种条件下，有些资源不用重新申请 */ 
                if (y == OTHER_STUFF) 
                    break; 
                /* 申请剩下的资源，并初始化 */ 
                do_later_stuff(); 
            } 
            /* 初始化modes_pointer资源 */ 
            initialize_modes_pointer(); 
            break; 
        default: 
            /* 处理普通事件, 使用老的modes_pointer资源 */ 
            processing(); 
    } 
    /* 使用modes_pointer资源，处理事件 */ 
    use_modes_pointer(); 
} 
  
5、----------------------------------------------------------- 
  
int is_gb2312_char(char c1, char c2) 
{ 
    if (c1 >= 0xa1 && c2 >= 0xa1) 
        return 1; 
    else 
        return 0; 
} 
  
6、----------------------------------------------------------- 
  
下面x, y的值是多少，有什么问题？ 
int x = 10, y = 3; 
x ^= y; 
y ^= x; 
x ^= y; 
/* x=?, y = ? */ 
  
7、----------------------------------------------------------- 
  
int days[]={31,28,31,30,31,30,31,31,30,31,30,31,}; 
int calendar[12][31]; 
int (*monthp)[31]; 
int *dayp; 
int i; 
  
memset(calendar, 0, sizeof(calendar)); 
i = 0; 
for (monthp = calendar; monthp < &calendar[12]; monthp++) { 
    for (dayp = *monthp; dayp < &(*monthp)[31]; dayp++) { 
        if (dayp - *monthp < days[calendar - monthp]) { 
            *dayp = i++ % 7 + 1; 
        } 
    } 
} 
  
8、----------------------------------------------------------- 
  
void printnum(long n) 
{ 
    if (n < 0) { 
        putchar('-'); 
        n = -n; 
    } 
  
    if (n >= 10) { 
        printnum(n/10); 
    } 
  
    putchar ("0123456789"[n%10]); 
} 
  
9、----------------------------------------------------------- 
  
void * memchr(void *pv, unsigned char ch, size_t size) 
{ 
    unsigned char *pch = (unsigned char *) pv; 
    unsigned char *pchEnd = pch + size; 
  
    while (pch < pchEnd) { 
        if (*pch == ch) 
            return (pch); 
        pch++; 
    } 
  
    return NULL; 
} 
  
10、----------------------------------------------------------- 
  
void * memchr(void *pv, unsigned char ch, size_t size) 
{ 
    unsigned char *pch = (unsigned char *) pv; 
    unsigned char *pchPlant = pch + size; 
    unsigned char chSave = *pchPlant; 
  
    *pchPlant = ch; 
    while (pch != ch) { 
        pch++; 
    } 
    *pchPlant = chSave; 
  
    return ((pch == pchPlant) ? NULL : pch); 
} 
  
11、----------------------------------------------------------- 
  
void UnsToStr(unsigned short int u, char *str) 
{ 
    char *pch; 
  
    assert(u <= 65535); 
    pch = &str[5]; 
    *pch = '\0'; 
    do { 
        *--pch = u % 10 + '0'; 
    } while ((u / 10) > 0); 
  
    strcpy(str, pch); 
} 
  
12、----------------------------------------------------------- 
  
void *memmove(void *pvTo, void pvFrom, size_t size) 
{ 
    char *pbTo = (char *)pvTo; 
    char *pbFrom = (char *)pvFrom; 
  
    ((pbTo < pbFrom) ? tailmove : headmove) (pbTo, pbFrom, size); 
    return (pvTo); 
} 
  
13、----------------------------------------------------------- 
  
void *memcpy(void *pvTo, void pvFrom, size_t size) 
{ 
    char *pbTo = (char *)pvTo; 
    char *pbFrom = (char *)pvFrom; 
  
    while (size-- > 0); 
        *pbTo++ = *pbFrom++; 
    return (pvTo); 
} 
  
14、----------------------------------------------------------- 
  
#include <stdio.h> 
  
int main(int argc, char *argv[]) 
{ 
    char s[]="0123456789"; 
    int i = 0; 
  
    do { 
        printf ("%c", i++[s]); 
    } while(s?1:printf("\n")-1); 
  
    return 0; 
} 
  
15、----------------------------------------------------------- 
  
int fibonacci(int x) 
{ 
    if (x == 1 || x == 2) 
        return 1; 
    return fibonacci(x - 2) + fibonacci(x - 1); 
} 
  
16、----------------------------------------------------------- 
  
这里有一个程序cdecl.c。写出它的工作流程。写出它的使用方法。 
给出一个典型输入用例，记录下它的输出。 
  
一.4、综合编程题。 
要求： 
1、完成需求，程序运行正确。 
2、工作原理文档，使用文档完整。 
3、代码规整优美。注释得当。 
4、运行速度足够快。 
5、用工具分析出是哪些代码或函数造成速度瓶颈。 
  
1、----------------------------------------------------------- 
编写一个排序程序。被排序的文件有8MB大小，一行一个随机整数(ASCII格式)。要求对这些整数进行排序，并计算平均值，打印出排序所需的时间。(20分) 
  
2、----------------------------------------------------------- 
用dummy header技巧实现一个链表DEMO。要求具有create, insert, delete, search功能。 
编写一个应用程序，使用上面的函数。使用dummy header技巧有什么优点。(20分) 
  
3、----------------------------------------------------------- 
用heapsort算法实现优先队列。要求具有create, insert, delete功能。 
编写一个应用程序，使用上面的函数。使用heapsort算法有什么优点。(20分) 
  
用trie(一种多叉树)实现一个字典。要求具有create, insert, delete, search功能。 
  
编写一个应用程序，使用上面的函数。使用trie树有什么优点。(20分) 
  
二、POSIX方面的知识。 
二.1、简答题。下面的题目必须全部答对才给分：(5分) 
1、在UNIX环境中，编译流程是什么？ 
2、ABI，ELF的英文全称是什么 
3、一般UNIX的程序有多少段，举一个实际的例子说明。 
4、如何在kernel二进制代码中找一个字符串。 
5、段地址F000:FFF0转换为线形地址的值是多少(16进制表达)。 
6、在一个UNIX文件系统中，文件的唯一性标志是什么？ 
  
二.2、问答题。 
1、----------------------------------------------------------- 
写一些代码。如何用文件实现信号灯？要求如果程序崩溃了，这个文件也将自动被删除。 
为什么可以这样实现信号灯？(5分) 
传统的signal函数信号处理为什么是不可靠的，信号和系统调用有何关系？(5分) 
在图形库系统中往往提供timer的功能，除了使用ALARM信号外，你还可以使用什么系统 
  
调用来实现timer？(5分) 
2、----------------------------------------------------------- 
写一些代码，演示如何正确使用write系统调用。注意看好手册再回答。(2分) 
如果一个文件以rw模式打开，在进行read/write操作转换时，需要进行什么操作。(2分) 
    
3、----------------------------------------------------------- 
解释终端结构termios.c_cc的MIN/TIME数值变化的带来read/write的特性。(5分) 
如何理解终端、控制终端、虚拟终端、控制台、tty等类同的概念？(5分) 
4、----------------------------------------------------------- 
  
解释计算机中Copy-On-Write的概念。(2分) 
  
调用fork之后，子进程没有继承父进程的属性有哪些？(5分) 
解释为什么每个程序在装入执行之后，总是已经预先打开了stdout、stdin、stderr？(2 分) 
在fork之前，父进程打开了一个文件。在fork之后，如果子进程移动了文件指针,父进程的文件指针有什么变化；如果子进程关闭了文件，父进程有什么变化？为什么会这样？(5分) 
标准输入、输出和错误输出分别是什么类型的缓冲，这些缓冲在用户空间还是在核心空间？ 
怎样关闭他们的缓冲？如果父进程关闭了缓冲，在fork之后建立的子进程是否也关闭了缓冲？(5分) 
vfork和fork相比，有什么特色？(2分) 
system函数是否等同于fork+exec？(2分) 
  
wait系统调用有多少种条件可以退出？(2分) 
  
5、----------------------------------------------------------- 
系统调用和库函数调用有什么区别。(2分) 
在linux2.4.x上的glibc和newlib(一种嵌入式C库)的系统调用有什么不同？(2分) 
在linux2.4.x上，对系统调用execve如果调用成功，它返回的值是多少。(2分) 
  
6、----------------------------------------------------------- 
列出你所知道的2个内存跟踪库。(2分) 
设计一个内存跟踪方案，为什么选择这个方案(5分) 
  
二.3、综合编程题。 
要求： 
1、完成需求，程序运行正确。 
2、工作原理文档，使用文档完整。 
3、代码规整优美。注释得当。 
4、运行速度足够快。 
  
1、----------------------------------------------------------- 
这里有一个8MB的文件，编写一个copy程序，拷贝这个文件，并计算所需时间。用工具分析 出是哪些代码或函数造成速度瓶颈。 
提示：如果只是使用read/write调用，不是一个好的实现。(20分) 
  
2、----------------------------------------------------------- 
Linux系统中，什么时候会出现类似Y2K的问题。写一个程序证明。(20分) 
  
3、----------------------------------------------------------- 
编写一个程序，测试系统最小的睡眠时间间隔。(20分) 
  
4、----------------------------------------------------------- 
编写一个pipe程序，测试有N个管道，size大小的buffer情况下，pipe的传输性能是多少 ？(20分) 
  
5、----------------------------------------------------------- 
在ext2文件系统上，单个文件最大可以达到多少？ 
写一个程序获得这方面的限制。(20分) 
  
三、Linux编程基本使用知识。 
三.1、命令和shell 
1）编写一个脚本，统计一个目录下面所有C代码的行数。(2分) 
2）编写一个sed脚本，去除HTML文件中的HTML标记。(2分) 
3）编写一个脚本获得当前系统eth0的IP地址。(2分) 
4）编写一个脚本以交互的方式，进行DNS的设定。(2分) 
5）使用ls命令编写一个脚本，实现ls -R，递归列出当前目录下的所有目录、文件。(2 分) 
6）----------------------------------------------------------- 
在一个目录下，找soft-link files，用下面的命令，原理是可行的，但无法操作，该如何解决？要2种方法。(2分) 
ls -l | grep -> 
  
7）----------------------------------------------------------- 
如何把标准错误输出，重定向到标准输出上。(2分) 
  
8）----------------------------------------------------------- 
我们的系统中的软件包是使用RPM管理的。要求下面的问题写出shell命令和运行结果。( 5分) 
如何知道系统中安装了几个软件包。 
如何知道系统中安装了哪几类(group)软件包。 
如何知道kernel软件包的简述。 
如何知道kernel软件包的Changelog。 
如何知道kernel软件包有几个文件。 
如何知道kernel软件包安装后有多大。 
  
三.2、编辑工具的使用。(各2分) 
1）如何使用vi进行块拷贝、粘贴、删除的操作 
2）如何设置Tab的长度，以及自动缩进的长度 
3）如何使用tag进行代码阅读 
4）如何在1～10行，有确认的进把所有的RedHat改为RedFlag 
5）在SourceNavigator中，如何跳到一个变量的声明处？如何得知光标当前的位置在那个函数体内？ 
  
三.3、编译器与调试器。(各2分) 
1）如何使用gcc得到宏展开的中间代码 
2）如何通过gcc在命令行中传入宏定义 
3）在那一级优化的情况下，内联函数才真正的内联到代码中 
4）gdb的watch命令如何使用，有何缺点 
5）gdb中使用什么命令可以显式调用的栈帧，如何查看某个栈帧上的局部变量 
6）如何使用gdb调试多进程 
7）如何使能/禁止core dump？ 
  
三.4、库。(各2分) 
1）如何知道XSetIMValues这个符号在那个X的库文件中 
2）如何读取C++的符号名，更具可读性 
3）请解释动态库的soname概念 
4）解释在链接时rpath选项的含义 
  
三.5、Makefile。(10分) 
如果有一个简单的Test项目目录如下： 
# tree Test 
Test 
|-- common.h 
|-- main.cpp 
|-- test.cpp 
`-- test.h 
  
1）使用wildcard、patsubst函数编写一个C++项目的Makefile文件 
2）使用automake、autoconfig编写一个支持configure选项的configure.in脚本 
  
三.6、CVS。(10分) 
1）如果一个CVS项目中，甲添加了一个子目录模块，那么乙在update时是否会自动检出这个新添加的子模块？如果不能，那么你有什么好的解决方案？ 
2）如何在一个CVS项目中添加一个二进制文件，这个二进制文件可以进行增量的版本管理吗？ 
3）如何检出标记（tag）为milestone-1的版本，如何创建以milestone-1为基础的分支 
  
   milestone-1-b1，并如何把分支的修改合并到milestone-1的主分支上 
  
三.7、Linux/GNU编程基本知识 
1、----------------------------------------------------------- 
Linux2.4.x有多少种类型的设备文件？分别写出来。(2分) 
  
2、----------------------------------------------------------- 
glibc动态库的搜寻次序是什么？(2分) 
glibc 2.1.x 与 2.2.x的动态库的搜寻次序有什么不同？为什么会采用现在的方案？(2 分) 
  
  
三.3、综合编程题。 
要求： 
1、完成需求，程序运行正确。 
2、工作原理文档，使用文档完整。 
3、代码规整优美。注释得当。 
4、运行速度足够快。 
  
1、----------------------------------------------------------- 
本题(20分)。写一个程序，有三个功能： 
a)取得CMOS中的当前时间，按照YY:MMD:HH:MM:SS格式输出。 
b)取得物理内存的大小，格式化输出。 
c)取得从物理段地址F000:FFF0起，16个字节的值，每字节按照16进制格式输出。 
  
2、----------------------------------------------------------- 
本题(20分)。对串口编程，编写一对类似ping的程序，作用在串口上，了解serial的联 
  
通情况。 
定义协议 
要求： 
定义一个联通和响应协议。至少具有：发送、回复、超时三种状态。除超时状态外，所 有 状态的数据必须经过校验才可使用。 
  
ping_serial_client 
要求： 
1,发送数据包； 
2,等待回复数据包，直到超时； 
3,如果有回复数据包，对数据包进行校验； 
4,计算校验通过的数据包之间的时间差； 
5,重复直到用户退出； 
6,统计丢包率，时间。 
界面： 
bash# ping_serial_client /dev/ttyS0 baud_value 
??bytes from ttyS0, time=??ms 
...... 
^C 
--- ttyS0 ping statistics --- 
?? packets transmitted, ?? received, ??% loss 
time ??ms, min/avg/max = ??/??/?? ms 
  
ping_serial_server 
要求： 
1,等待对方的发送数据包； 
2,对发送数据包进行校验； 
3,校验通过则回复数据包； 
4,重复直到用户退出； 
  
界面： 
bash# ping_serial_server /dev/ttyS0 baud_value 
  
3、----------------------------------------------------------- 
编写一对socket程序，要求类似于network echo procotol。 
Client每隔1秒把自己的IP地址轮流循环发送给一个Server. 
Server接到IP后，在屏幕上打印对方IP；然后把自己的IP发送回去。 
Client收到回复后，在屏幕上打印对方IP。 
程序一直运行，直到用户退出。各自分类统计接收到的各IP的数据包的个数。 
注意：Client可以向多个Server发送请求，Server也可以接收多个Client请求。 
注意：输出信息的美观，和对错误的处理。 
----------------------------------------------------------- 
  
四、C++题目。 
  
----------------------------------------------------------- 
  
1。给定下面的代码: 
  
class Graph{ 
public: 
    Graph() { s_gCount++; } 
  
    virtual ~Graph() { s_gCount--;} 
  
    virtual int drawOut() = 0; 
  
    static int getTotalCount() { return s_gCount; } 
  
protected: 
    int m_x; 
    int m_y; 
    static int s_gCount; 
}; 
  
回答下列问题：(各5分) 
  
1）这个类能否生成实例，为什么？ 
2）上述代码中有什么错误？ 
3）如果有一个Rectangle类公共继承该类，那么s_gCount对Rectangle的成员属性是什么 ？ 
4）对Graph及其子类的计数是否有效，如果无效应该采取什么措施？ 
5）请画出该类的内存布局结构示意图 
    
----------------------------------------------------------- 
  
2。给定下面的代码: 
class A 
{ 
    int a; 
}; 
  
class AA : public A 
{ 
    int aa; 
}; 
  
class X : public virtual A 
{ 
    int x; 
}; 
  
class Y : public virtual A 
{ 
    int y; 
}; 
  
class Z : public X, public Y { 
    int z; 
}; 
  
回答下列问题：(各5分) 
  
1）请画出上述5个类的UML类图 
2）请画出A、AA、X、Z的内存布局结构示意图 
    
----------------------------------------------------------- 
  
3。给定下面代码: 
#include <stdio.h> 
#include <stdlib.h> 
  
typedef struct _AAA 
{ 
    int a; 
}AAA, *PAAA; 
  
class CAAA 
{ 
public: 
    CAAA() { m_a.a = 0; } 
    CAAA(CAAA& in) { printf("CAAA(CAAA& in)\n"); } 
  
    CAAA(AAA in) { printf("CAAA(AAA in)\n"); } 
    CAAA(int in) { printf("CAAA(int in)\n"); } 
  
private: 
    AAA m_a; 
  
public: 
    operator PAAA () 
    { 
        return &m_a; 
    } 
}; 
  
void test0(PAAA pa) 
{ 
    printf("test0\n"); 
} 
  
void test1(CAAA ca) 
{ 
    printf("test1\n"); 
} 
  
void test2(CAAA ca) 
{ 
    printf ("test2\n"); 
} 
  
void main(void) 
{ 
    CAAA a; 
    test0 (a); 
  
    AAA b; 
    test1 (b); 
  
    int i=0; 
    test2 (i); 
} 
  
请回答下列问题：(各5分) 
  
1）找出程序中的错误 
2）test0函数声明传入的参数为PAAA类型，而在main函数中，实际传入的是CAAA类型，这是否是一个错误？如果不是，请解释原因。 
    
4。回答下列问题： 
1）C++中的struct和class类型有什么区别？(2分) 
2）假定一个class名为Test，具有构造函数、拷贝构造函数、operator =，那么 
    Test a; 
    Test b=a; 
   分别执行的是哪一个函数？(2分) 
3）C++程序进行链接时是否必须链接stdc++函数库，如果不必须情况下不需要，什么情况下需要？(2分) 
4）你所熟悉的关于C++的中英文经典书籍都有哪些，它们分别都侧重于什么方面？(5分) 
  
  
五、QT编程。任选2题完成。(各20分) 
要求：按照综合编程题目的要求编写代码和文档。 
1.编写一个简单的clock控件, 要求从QWidget继承, 有一个指针和表盘,指针每12秒转一圈,并且可以用鼠标左键,起动和停止指针的转动. 
  
2.给定一个designer生成的UI文件, 读取指定名字控件的几何信息,计算出该控件的面积 大小. (用Dom和SAX都可) 
  
3.设计一个程序, 建立个人信息库,包括:姓名,年龄,性别,住址.建立完之后可以查处特定人的信息,用designer设计你的界面, 不要求把信息库存在硬盘上. 
  
4.把第三题变成国际化程序, 要求两种语言中文和英文.需要用qt-linquist等工具. 
  
5. 用QSocket实现两台不同机器间的收发, 收发要求用户动态输入. 
  
提示：以上各题需在qt3.0以上实现,推荐用qt-3.1.1,不限止qt-embedded或qt-desktop. 
  
  
六、MiniGUI编程 
要求：按照综合编程题目的要求编写代码和文档。 
1.裁剪MiniGUI字体库,使它仅支持英文和繁体中文。(10分) 
2.描述MiniGUI/MPP的消息机制(20分) 
3.使用MPP和MySql,编写一使用在商场POS机上的应用,要求如下50分) 
    1)收银员帐户管理:每台POS机供若干个收银员和一个系统管理员使用.收银员凭密码 
  
登录POS机,密码可修改.收银员只能查看自己的销售数据, 
    但不能删除.系统管理员可以增加删减收银员帐户,查询销售记录. 
    2)收款管理:计算顾客购买商品总金额;计算找零 
    3)顾客会员管理:根据顾客ID,判断会员等级及相应打折级别. 
    4)屏幕锁定功能:特定按健触发屏幕锁定,输入密码后解锁 
  
七、Kernel & Driver 
内核基础试题 
1. 简答题。(各10分) 
1.1  Spin Lock 相对于信号量的特点；在UP/MP/SMP这些不同环境下，Spin Lock的不同 
  
实现方法。 
1.2  简要说明e2compr压缩文件系统的压缩策略；经其处理后，上层文件系统（EXT2/3 等）是否会受到影响。 
1.3  比较linux操作系统内核态和用户态的抢占性，及两者之间存在差异的原因。 
1.4  linux2.2支持的最大进程数是多少，演进至2.4后，这一制约是如何克服的。 
1.5  列举中断屏蔽的类型，并简单比较。 
1.6  列举linux所要处理的定时/计数器（实际的外围硬件设备，不是指软件定时器），及其用途。 
  
2. 问答题。(各20分) 
2.1  穷举在用户态空间，内核消息的获取方式、差异、以及差异的原因。 
2.2  解释linux进程调度中的epoch概念，该机制的目的。 
2.3  描述一个硬件中断信号发生，到为其注册的中断服务例程开始执行，之间所经过的 内核处理过程。并进一步分析，制约linux中断响应时间的因素存在于哪些方面。 
2.4  比较底半机制（BH）和Tasklet的特点，及运行方面的差异。 
2.5  说明引导过程中initrd.img和linuxrc作用，给出制作initrd.img的伪代码形式的 
  
流程。 
2.6  在VFS层中如何区分设备文件和正规文件? 
2.7  内核有几种方式访问硬件设备? 
2.8  内核如何访问iomem?请举例说明。 
  
3. 分析题。 
3.1  系统时间设置问题。(10分) 
     同样采用date命令，目的在于修改系统时间，在不同的系统上却有不同的现象： 
     假定初始时间（T1）为 03月01日16：00 2003年，期望的修改后时间（T2）为 12 月31日00：00 2002年， 
     <1> 在EDK系统中，执行命令 #date 123100002002，系统时间立即会变为T2； 
         但系统重新启动之后，系统时间仍恢复为T1的时间区间： 03月01日16：02　2003年，修改并未保留下来。 
     <2> 在RedHat7.2/8.0中，重复上述设置，系统重新启动之后，时间设置得到了保留，系统运行于T2的时间区间：12月31日00：02 2002年。 
     请分析<1> 中所表现出的现象是由于什么原因造成的； 
  
3.2  在大家相关于串口的工作中，可能会遇到这样的问题：(20分) 
     串口在发送数据时，不是连续且迅速地发送，而是以一个固定的节拍（10秒），且每次只发送等长度的一段数据，请列举可能造成这一问题的所有原因； 
  
3.3  Oops分析。(50分) 
     以下是一段经过符号解析过的Oops信息，我们知道造成这个Oops的直接原因在于对 于 内核函数__wake_up的调用过程之中出现了问题；基于上述判断，请基于已经给出的__wake_up相关源码和反汇编码，大致分析问题出现在哪个源码行，并给出分析结论； 
  
  
----------------------------------------------------------- 
ksymoops信息： 
ksymoops 2.4.4 on i686 2.2.19-rthal3.  Options used 
-v /usr/src/linux-2.2.19/vmlinux (specified) 
-k /proc/ksyms (specified) 
-l /proc/modules (specified) 
-o /lib/modules/2.2.19-rthal3/ (default) 
-m /usr/src/linux-2.2.19/System.map (specified) 
  
current->tss.cr3 = 07d29000, %cr3 = 07d29000 
*pde = 00000000 
Oops: 0000 
CPU:   0 
EIP:   0010:[<C01110C1>] 
Using defaults from ksymoops -t elf32-i386 -a i386 
eax: 00000014   ebx: c0eabf74  ecx: 00000013  edx: 00000021 
esi: 00000000   edi: 00000020  ebp: c0eabf6c  esp: c0eabf60 
ds: 0018   es: 0018  ss: 0018 
Process in.identd (pid: 828, process nr: 6, stackpage=c0eab000) 
Stack: 00000000 c807ca04 00000021 c0eabf74 c807be21 c0eabfb0 c807bf74 
c807c940 
       00000000 00000000 00000000 c803fb60 c807e000 00000e20 2b124c28 
0000027c 
       0010a000 c807c900 00000000 0000f944 bffff944 c803d2ec 00000000 
00000000 
Call Trace: [<c807ca04>] [<c807be21>] [<c807bf74>] [<c807c940>] 
[<c803fb60>] [<c807e000>] 
[<c807c900>] [<c803d2ec>] [<c803c0a0>] 
Code: 8b 02 85 45 fc 74 1b 85 ff 74 10 83 7a 44 00 74 0a 85 f6 75 
  
>>EIP; c01110c1 <__wake_up+2d/6c>   <===== 
  
Trace; c807ca04 <[rt_das]timeout+c4/c8> 
Trace; c807be21 <[rt_das]read_timeout+25/28> 
Trace; c807bf74 <[rt_das]pulse_isr+150/19c> 
Trace; c807c940 <[rt_das]timeout+0/c8> 
Trace; c803fb60 <[rtai]global_irq_handler+0/80> 
Trace; c807e000 <.bss.end+14a1/????> 
Trace; c807c900 <[rt_das]board+0/28> 
Trace; c803d2ec <[rtai]dispatch_global_irq+28/90> 
Trace; c803c0a0 <[rtai]GLOBAL0_interrupt+18/34> 
Code;  c01110c1 <__wake_up+2d/6c> 
00000000 <_EIP>: 
Code;  c01110c1 <__wake_up+2d/6c>   <===== 
   0:   8b 02                     movl   (%edx),%eax   <===== 
Code;  c01110c3 <__wake_up+2f/6c> 
   2:   85 45 fc                  testl  %eax,0xfffffffc(%ebp) 
Code;  c01110c6 <__wake_up+32/6c> 
   5:   74 1b                     je     22 <_EIP+0x22> c01110e3 
<__wake_up+4f/6c> 
Code;  c01110c8 <__wake_up+34/6c> 
   7:   85 ff                     testl  %edi,%edi 
Code;  c01110ca <__wake_up+36/6c> 
   9:   74 10                     je     1b <_EIP+0x1b> c01110dc 
<__wake_up+48/6c> 
Code;  c01110cc <__wake_up+38/6c> 
   b:   83 7a 44 00               cmpl   $0x0,0x44(%edx) 
Code;  c01110d0 <__wake_up+3c/6c> 
   f:   74 0a                     je     1b <_EIP+0x1b> c01110dc 
<__wake_up+48/6c> 
Code;  c01110d2 <__wake_up+3e/6c> 
  11:   85 f6                     testl  %esi,%esi 
Code;  c01110d4 <__wake_up+40/6c> 
  13:   75 00                     jne    15 <_EIP+0x15> c01110d6 
<__wake_up+42/6c> 
  
Unable to handle kernel paging request at virtual address 66fe4603 
current->tss.cr3 = 00e94000, %cr3 = 00e94000 
*pde = 00000000 
Oops: 0000 
CPU: 0 
EIP: 0010:[<c01113e6>] 
EFLAGS: 00010a83 
Warning (Oops_read): Code line not seen, dumping what data is available 
  
>>EIP; c01113e6 <interruptible_sleep_on+5a/78>   <===== 
    
1 warning issued.  Results may not be reliable. 
    
<附录> 
1. __wake_up的源码： 
    void __wake_up(struct wait_queue **q, unsigned int mode) 
    { 
        struct task_struct *p, *best_exclusive; 
        struct wait_queue *head, *next; 
        unsigned int do_exclusive; 
  
            if (!q) 
            goto out; 
        /* 
         * this is safe to be done before the check because it 
         * means no deference, just pointer operations. 
         */ 
        head = WAIT_QUEUE_HEAD(q); 
  
        read_lock(&waitqueue_lock); 
        next = *q; 
        if (!next) 
            goto out_unlock; 
  
        best_exclusive = 0; 
        do_exclusive = mode & TASK_EXCLUSIVE; 
        while (next != head) { 
            p = next->task; 
            next = next->next; 
            if (p->state & mode) { 
                if (do_exclusive && p->task_exclusive) { 
                    if (best_exclusive == NULL) 
                        best_exclusive = p; 
                } 
                else { 
                    wake_up_process(p); 
                } 
            } 
        } 
        if (best_exclusive) 
            wake_up_process(best_exclusive); 
    out_unlock: 
        read_unlock(&waitqueue_lock); 
    out: 
        return; 
    } 
  
  
2. __wake_up的反汇编码： 
    c0111094 <__wake_up>: 
    c0111094:   55                      pushl  %ebp 
    c0111095:   89 e5                   movl   %esp,%ebp 
    c0111097:   83 ec 08                subl   $0x8,%esp 
    c011109a:   57                      pushl  %edi 
    c011109b:   56                      pushl  %esi 
    c011109c:   53                      pushl  %ebx 
    c011109d:   89 55 fc                movl   %edx,0xfffffffc(%ebp) 
    c01110a0:   85 c0                   testl  %eax,%eax 
    c01110a2:   74 50                   je     c01110f4 <__wake_up+0x60> 
    c01110a4:   8d 48 fc                leal   0xfffffffc(%eax),%ecx 
    c01110a7:   89 4d f8                movl   %ecx,0xfffffff8(%ebp) 
    c01110aa:   8b 18                   movl   (%eax),%ebx 
    c01110ac:   85 db                   testl  %ebx,%ebx 
    c01110ae:   74 44                   je     c01110f4 <__wake_up+0x60> 
    c01110b0:   31 f6                   xorl   %esi,%esi 
    c01110b2:   89 d7                   movl   %edx,%edi 
    c01110b4:   83 e7 20                andl   $0x20,%edi 
    c01110b7:   39 cb                   cmpl   %ecx,%ebx 
    c01110b9:   74 2d                   je     c01110e8 <__wake_up+0x54> 
    c01110bb:   90                      nop 
    c01110bc:   8b 13                   movl   (%ebx),%edx 
    c01110be:   8b 5b 04                movl   0x4(%ebx),%ebx 
    c01110c1:   8b 02                   movl   (%edx),%eax 
    c01110c3:   85 45 fc                testl  %eax,0xfffffffc(%ebp) 
    c01110c6:   74 1b                   je     c01110e3 <__wake_up+0x4f> 
    c01110c8:   85 ff                   testl  %edi,%edi 
    c01110ca:   74 10                   je     c01110dc <__wake_up+0x48> 
    c01110cc:   83 7a 44 00             cmpl   $0x0,0x44(%edx) 
    c01110d0:   74 0a                   je     c01110dc <__wake_up+0x48> 
    c01110d2:   85 f6                   testl  %esi,%esi 
    c01110d4:   75 0d                   jne    c01110e3 <__wake_up+0x4f> 
    c01110d6:   89 d6                   movl   %edx,%esi 
    c01110d8:   eb 09                   jmp    c01110e3 <__wake_up+0x4f> 
    c01110da:   89 f6                   movl   %esi,%esi 
    c01110dc:   89 d0                   movl   %edx,%eax 
    c01110de:   e8 2d f9 ff ff          call   c0110a10 <wake_up_process> 
    c01110e3:   3b 5d f8                cmpl   0xfffffff8(%ebp),%ebx 
    c01110e6:   75 d4                   jne    c01110bc <__wake_up+0x28> 
    c01110e8:   85 f6                   testl  %esi,%esi 
    c01110ea:   74 08                   je     c01110f4 <__wake_up+0x60> 
    c01110ec:   89 f0                   movl   %esi,%eax 
    c01110ee:   e8 1d f9 ff ff          call   c0110a10 <wake_up_process> 
    c01110f3:   90                      nop 
    c01110f4:   8d 65 ec                leal   0xffffffec(%ebp),%esp 
    c01110f7:   5b                      popl   %ebx 
    c01110f8:   5e                      popl   %esi 
    c01110f9:   5f                      popl   %edi 
    c01110fa:   89 ec                   movl   %ebp,%esp 
    c01110fc:   5d                      popl   %ebp 
    c01110fd:   c3                      ret 
    c01110fe:   89 f6                   movl   %esi,%esi 
  
----------------------------------------------------------- 
内核驱动题 
以下设计应该包括设计文档,实现策略说明,代码包,测试用例,使用说明. 
要求：按照综合编程题目的要求编写代码和文档。 
参考资料: <Linux设备驱动程序>第二版. 
  
1.设计并实现一个软件watchdog设备，以监视系统运行情况.(50分) 
说明:watchdog设备用于监测系统运行状态,正常运行的系统定期写watchdog以使其 不会超时,一旦超时,意味系统已挂起;watchdog应该重启系统. 现在的软件watchdog 不重启系统,只用于监视应用程序的运行. 
  
2.设计并实现一个简化的、容量可以变化的内存FIFO设备.(50分) 
  
八、用中文Linux办公。 
要求本考卷完全在Linux完成，并要求进行版面的格式化或美化。如果只提交TEXT版本， 本题不得分。(各10分) 
本题要求是： 
1、提交进行版面的格式化或美化的PDF版本。为方便修改和评分，还须提交一个lyx或tex版本。 
2、PDF内嵌的中文字体使用的是红旗桌面版4.0所携带的新版宋体。 
  
九、娱乐。(没有分数) 
不会娱乐的程序员不是好的程序员。本部分没有分数，但是聪明的人在这里是不会留下空白的。 
1、运行RedHat 7.3上面的推箱子游戏。用方向-数字的方式(如左3，右4)记录下通过第一关 的过程，同时记录下过关的时间。看谁的步数少，时间短。 
2、运行emacs + doctor游戏。摘录下10句以上的对话，看谁的对话最精彩，同时也看谁的 心理最变态。
感谢浏览，希望此文档对你有所帮助！



嵌入式系统开发人员C语言测试题 (运算符与表达式)
一. 选择题（共15题，每题3分。）
（1）设有以下语句:
    char a=3, b=6, c;
    c = a^b<<2;
    则c的二进制值是_____。
a. 00011011 
b. 00010100 
c. 00011100 
d. 00011000
（2）表达式0x13&0x17的值是___。
a. 0x17
b. 0x13
c. 0xf8
d. 0xec
（3）表达式0xl3|0xl7的值是____。
a. 0x13
b. 0x17
c. 0xE8
d. 0xc8
（4） 以下叙述中正确的是_____。
a. 表达式a&＝b等价于a＝a&b
b. 表达式a|＝b等价于a＝a|b
c. 表达式a!＝b等价于a＝a!b
d. 表达式a^＝b等价于a＝a^b
（5） 运作对象必须是整型数的运算符是_____。
a. %    b. .    c. /    d. **
（6） 根据以下定义，错误的表达式是_____。
struct
{
    int a;
    char b; 
} Q, *p = &Q;
a. Q.a 
b. (*p).b
c. p->a
d. *p.b
（7） 若x是单精度实型变量，表达式 x = 10/4 的值是_____ 。
a. 2.5         b. 2.0        c. 3         d. 2
（8） 表达式 !x 等价于_____。
a. x == 0        b. x == 1       c. x != 0     d. x != 1
（9） ______是合法的用户自定义标识符。
a. b-b        b. float         c. <fr>          d. _isw 
（10） 若变量已正确定义并赋值，表达式______不符合C语言语法。
a. a*b/c;     b. 3.14%2       c. 2, b         d. a/b/c 
（11） _____是不正确的字符常量。
a. '\n'        b. '1'           c. "a"          d. '\101'
（12） 在 C 程序中，用_____表示逻辑值"真"。
a. 1           b. 非 0 的数      c. 非 1 的数     d. 大于 0 的数
（13） ______把x、y定义成float类型变量，并赋同一初值3.14。
a. float x, y=3.14;              b. float x, y=2*3.14;  
c. float x=3.14, y=x=3.14;     d. float x=y=3.14;
（14） 假设变量已正确定义，表达式______的值不是2。
a. 2&3       b. 1<<1         c. a==2         d. 1^3
（15） 若变量已正确定义，语句if(a>b) k=0; else k=1;和______等价。   
a. k=(a>b)?1:0;              b. k=a>b;
c. k=a<=b;                    d. a<=b ? 0 : 1;
二．填空题（每题5分）。
（1） &运算符作为单目运算符时表示的是____运算；作为双目运算符时表示的是_____运算。
（2） 请计算sizeof的值：
char str[] = "Hello" ;
char *p = str ;
int n = 10;
请计算
sizeof (str ) = ____
sizeof ( p ) = _____
sizeof ( n ) = ______
（3） 请计算sizeof的值：
void Func ( char str[100])
{
    // 请计算
    sizeof( str ) = _____
}
（4） 请计算sizeof的值：
void *p = malloc( 100 );
// 请计算
sizeof ( p ) = ______
（5） 下列程序段的输出是_______。
#define f(a, b, x)  a*x+b
printf("%d, %d\n", f(3,2,1), f(6, 5, f(3, 2, 1)));
（6） 下列程序段的输出是_____。
main()
{  
    int k;
    for(k=1; k<5; k++) 
    {
        if(k % 2)  printf("*");
        else continue;
        printf("#");
    }}
三.简单题（共3题，每题10分）
（1） 指出下面程序的错误并改正：
void main(void)
{int a,b;
    a = 1;
    b = a/++a;
    printf("b equals %d\n", b);}
（2） int a=391,b=1971; 写出 a^b^a的值。
（3） 语句：x++;?++x; x=x+1;?x=l+x; ，执行后都使变量x中的值增1，请写出一条同一功能的赋值语句。
嵌入式系统开发人员C语言测试题 (数据类型和变量)
一. 选择题（共15题，每题3分。）
（ 1）在C语言中,  char型数据在内存中的存储形式是_____。
a. 补码   b. 反码   c. 原码    d. ASCII码
 （2）设C语言中,一个int型数据在内存中占2个字节,则unsigned  int型数据的取值范围为______。
a. 0～255   b. 0～32767     c. 0～65535   d. 0～2147483647
 （3）已知ch是字符型变量,下面不正确的赋值语句是____。
a. ch='a+b';   b. ch='\0';   c. ch='7'+'9';    d. ch=5+9;
 （4）已知ch是字符型变量,下面正确的赋值语句是____。
a. ch= '123';   b. ch= '\xff';  c. ch= '\08';   d. ch="\";
 （5）以下选项中不正确的整型常量是_____。
a. 12L        b. -10       c. 1,900    d. 123U
  （6）假设int型变量占两个字节的存储单元，若有定义：
   int x[10]={0,2,4};
则数组x在内存中所占字节数为______。
a. 3           b. 6           c. 10             d. 20
 （7）C语言中能用八进制表示的数据类型为_____。
a. 字符型、整型                    b. 整形、实型
c. 字符型、实型、双精度型      d. 字符型、整型、实型、双精度型
（8）以下只有在使用时才为该类型变量分配内存的存储类说明是____。
a. auto和static              b. auto和register
c. register和static         d. extern和register
（9）下面四个选项中,均是合法整型常量的选项是____。
a. 160          b. 0xcdf    c. 01        d. 0x48a
   0xffff           01a       986,012        2e5
011              0xe        0668           0x
（10）下面四个选项中,均是不合法的整型常量的选项是____。
a. 0f1     b. 0Xcdf c. 018    d. 0x48eg
0xffff        017          999        068
0011          12,456       5e2         03f
（11）下面四个选项中,均是不合法的浮点数的选项是____。
a. 160.      b. 123      c. 18      d. e3
   0.12          2e4.2       123e4         .234
e3           .e5          0.0            1e3
（12）下面四个选项中,均是合法浮点数的选项是____。
 a.  +le+1      b. 60.       c. 123e      d. e3
     5e-9.4  12e-4      1.2e-.4      .8e4
03e2          8e5         +2e           5.e
（13）下面四个选项中,均是合法转义字符的选项是____。
 a. '\''        b. '\'     c. '\018'   d. '\\0'
    '\\'            '\017'     '\f'         '101'
'\n'            '\"'        'xab'       'xlf'
（14）下面四个选项中,均是不合法的转义字符的选项是____。
  a. '\''     b. '\1011'    c. '\011'    d. '\abc'
     '\\'          '\'           '\f'          '\1011'
    '\xf'          '\a'          '\}'         'xlf'
（15）下面正确的字符常量是____。
a. "a"     b. '\\''    c. 'W'    d. ''
二．填空题（每题6分）。
 （1）说明下面变量的定义：
char (*p[])();          _____________________
char *p()[];    _____________________
char (*p)[10][10];     _____________________
char(*(*p())[])[];     _____________________
（2）下面共同体的存储空间是_____
union BOOKNUMBER
{
    T_S16 age;
    T_S8 title[10];
    T_S8 post[32];
}
（3）若整数值范围是 -32768 至 32767。在执行下面的表达式之后, i 的结果是什么?
int i=32766;
i=i+1;          i =       
i=i+1;          i =       
（4）对于联合类型：
union x
{
    char ch[7];
    int i[2];
    float f;
}tom;
那么, sizeof(tom) =        
（5）有以下程序，程序的输出结果是______（注意: ch[0]在低字节,ch[1]在高字节）。
#include<stdio.h>
union pw
{ 
    int i;
    char ch[2];
 }a;
main()
{
    a.ch[0] = 13; 
    a.ch[1] = 0; 
    printf("%d\n", a.i);
}
三.简单题（共3题，每题10分）
（1）已知a为整数，比较下面代码的效率并说明原因：
        a++;
        a = a+1;
（2）已知a为整数，比较下面代码的效率并说明原因：
        a = a*4;
        a << 2;
（3）说明一个变量和定义一个变量有什么区别?
嵌入式系统开发人员C语言测试题-数据结构与算法
一.选择题（共15题，每题3分）
（1）下面关于算法说法错误的是_______。 
a. 算法最终必须由计算机程序实现 
b. 为解决某问题的算法同为该问题编写的程序含义是相同的 
c. 算法的可行性是指指令不能有二义性  
d. 以上几个都是错误的 
（2）下面说法错误的是______. 
a. 算法原地工作的含义是指不需要任何额外的辅助空间 
b. 在相同的规模n下，复杂度O(n)的算法在时间上总是优于复杂度O(2n)的算法 
c. 所谓时间复杂度是指最坏情况下，估算算法执行时间的一个上界 
d. 同一个算法，实现语言的级别越高，执行效率就越低 
（3）在下面的程序段中，对x的赋值语句的频度为_____。 
for (int i; i<n; i++) 
{ for (int j=o; j<n; j++) 
{ x:=x+1; 
} } 
a. 0(2n)            b. 0(n)        c. 0(n2)     d. O(log2n)  
（4）下面说法正确的是______。 
a. 数据元素是数据的最小单位； 
b. 数据元素是数据的最小单位； 
c. 数据的物理结构是指数据在计算机内的实际存储形式 
d. 数据结构的抽象操作的定义与具体实现有关 
（5）下面说法正确的是_______。 
a. 在顺序存储结构中，有时也存储数据结构中元素之间的关系 
b. 顺序存储方式的优点是存储密度大，且插入、删除运算效率高 
c. 数据结构的基本操作的设置的最重要的准则是，实现应用程序与存储结构的独立 
d. 数据的逻辑结构说明数据元素之间的顺序关系,它依赖于计算机的储存结构 
（6） 下述_____是顺序存储结构的优点。 
a. 存储密度大 
b. 插入运算方便 
c. 删除运算方便 
d. 可方便地用于各种逻辑结构的存储表示 
（7）下面关于线性表的叙述中，错误的是_____。 
a. 线性表采用顺序存储，必须占用一片连续的存储单元 
b. 线性表采用顺序存储，便于进行插入和删除操作 
c. 线性表采用链接存储，不必占用一片连续的存储单元 
d. 线性表采用链接存储，便于插入和删除操作 
（8） 某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用_______存储方式最节省时间。 
a. 顺序表      b. 双链表        c. 带头结点的双循环链表     d. 单循环链表 
（9）静态链表中指针表示的是______。 
a. 内存地址     b. 数组下标     c. 下一元素地址     d. 左、右孩子地址 
（10）下面的叙述不正确的是_______。 
a. 线性表在链式存储时，查找第i个元素的时间同i的值成正比 
b. 线性表在链式存储时，查找第i个元素的时间同i的值无关 
c. 线性表在顺序存储时，查找第i个元素的时间同i 的值成正比 
d. 线性表在顺序存储时，查找第i个元素的时间同i的值无关 
（11）下面说法错误的是_____。 
a. 静态链表既有顺序存储的优点，又有动态链表的优点。所以，它存取表中第i个元素的时间与i无关。 
b. 静态链表中能容纳的元素个数的最大数在表定义时就确定了，以后不能增加。 
c. 静态链表与动态链表在元素的插入、删除上类似，不需做元素的移动。 
d. 静态链表就是一直不发生变化的链表。 
（12）在双向链表指针p的结点前插入一个指针q的结点操作是______。 
a. p->Llink=q; q->Rlink=p; p->Llink->Rlink=q; q->Llink=q； 
b. p->Llink=q; p->Llink->Rlink=q; q->Rlink=p; q->Llink=p->Llink; 
c. q->Rlink=p; q->Llink=p->Llink; p->Llink->Rlink=q; p->Llink=q; 
d. q->Llink=p->Llink; q->Rlink=q; p->Llink=q; p->Llink=q; 
（13）下面说法正确的是______。 
a. 顺序存储结构的主要缺点是不利于插入或删除操作； 
b. 线性表采用链表存储时，结点和结点内部的存储空间可以是不连续的； 
c. 顺序存储方式插入和删除时效率太低，因此它不如链式存储方式好； 
d. 顺序存储方式只能用于存储线性结构。 
（14）下面说法正确的是______。 
a. 线性表只能用顺序存储结构实现。  
b. 为了很方便的插入和删除数据，可以使用双向链表存放数据。  
c. 顺序存储方式的优点是存储密度大，且插入、删除运算效率高。  
d. 链表是采用链式存储结构的线性表,进行插入、删除操作时，在链表中比在顺序存储结构中效率高。 
（15）下面说法正确的是_________。 
a. 数据元素是数据的最小单位。 
b. 队列逻辑上是一个下端口和上端能增加又能减少的线性表。 
c. 任何一个递归过程都可以转换成非递归过程。 
d. 只有那种使用了局部变量的递归过程在转换成非递归过程时才必须使用栈。 
二.  填空题(共5题，每题5分) 
（1）    下列程序的功能是创建单向链表，请补充完整。 
#include <stdio.h> 
#include <alloc.h> 
struct link 
{ char  name[10]; 
  int mark; 
  struct link  * next; 
}; 
void insert(char * name,  int mark); 
struct link * head = NULL; 
main() 
{ char  name[10]; 
    int    mark; 
    struct  link *t; 
    while (1) 
{  scanf("%s %d",  name,  &mark); 
       if (strcmp(name, "#") == 0 ) 
  { break; } 
           ______(1)_______; 
        } 
       for (t=head; ______(2)_______) 
       { 
              printf("<%s>: %d\n",  t->name,  t->mark); 
} 
    } 
    void insert(char * name,  int mark) 
    { 
        struct link * p; 
        p = ______(3)_______ ; 
        strcpy(p->name,  name); 
        p->mark = mark; 
            ______(4)_______; 
        if ( head != NULL )   
{ 
______(5)_______; 
} 
        head = p; 
    } 
（2）用循环链表表示的队列长度为n，若只设头指针,则出队和入队的时间复杂度分别是______和_____； 若只设尾指针,则出队和入队的时间复杂度分别是_____和_____。 
（3）    在n个记录的有序顺序表中进行折半查找,最大的比较次数是______。 
（4）    仔细阅读下列程序，在空白处填入适当的语句。 
函数match(s,t)完成在字符串s中寻找与t匹配的字符，若存在一个匹配，则返回t在字符串s中的下标；否则，返回-1。其中，字符指针*b始终指向s的第一元素。 
Match(s,t) 
Char s,t; 
｛ char *b=s; 
char *p, *r; 
for _________________________________ 
｛ 
for (p=s, r=t; *r!=`\0` && *p= =*r; p++, r++); 
if__________________________________ 
return(s-b); 
｝ 
return(-1); 
｝
（5）    补充下列程序：设一棵二叉序列树b，下列算法函数是实现在b中插入一个结点s。 
函数： 
void insert（btree *b，btree *s） 
{ if（b == NULL） b = s； 
else 
   if（s->data == b->data） return(); 
   else 
      if(s->data < b->data) 
                       ； 
      else 
                       ；  }
三.简答题（共3题，每题10分）
（1）    在一个包含 n 个元素的数组 M 中查找一个元素 x。 算法假设 M 已经按升序排列了，请写出二分搜索算法的步骤。
（2）    试将一个无序的线性表A=(11,16,8,5,14,10,38,23)转换成一个按升序排列的有序线性表（用链表实现）。 
（3）    何为栈和队列？简述两者的区别和联系。

6、请写出下列代码的输出内容
　　#include
　　main()
　　{
　　　int a,b,c,d;
　　　a=10;
　　　b=a++;
　　　c=++a;
　　　d=10*a++;
　　　printf("b，c，d：%d，%d，%d"，b，c，d）;
　　　return 0;
　　} 
答： b=10,c=12,d=120
7、设有以下说明和定义：（32位编译器情况下）
typedef union {long i; int k[5]; char c;} DATE;
struct data { int cat; DATE cow; double dog;} too;
DATE max;
则语句 printf("%d",sizeof(struct date)+sizeof(max));的执行结果是：_(4+20+8)+20_



第1题: 考查对volatile关键字的认识
#include<setjmp.h>static jmp_buf   buf;main()     {   volatile   int b;   b =3;   if(setjmp(buf)!=0)     {     printf("%d ", b);       exit(0);   }   b=5;   longjmp(buf , 1);}   
请问，这段程序的输出是
(a) 3
(b) 5
(c) 0
(d) 以上均不是
第2题:考查类型转换
main()
{    
	struct node     
	{      
		int a;      
		int b;    
	     int c;         
	};    
	struct node   s= { 3, 5,6 };    
	struct node *pt = &s;    
	printf("%d" ,   *(int*)pt);
}  
这段程序的输出是:a
(a) 3
(b) 5
(c) 6
(d) 7

//----

这段代码对x和n完成什么样的功能(操作)? b
(a) xn
(b) x*n
(c) nx
(d) 以上均不是
第4题:考查指针
main() 
{   
	int   a[5] = {1,2,3,4,5};   
	int *ptr =   (int*)(&a+1);   
	printf("%d %d" , *(a+1), *(ptr-1) );
}  
这段程序的输出是:c
(a) 2 2
(b) 2 1
(c) 2 5
(d) 以上均不是
第5题:考查多维数组与指针
void foo(int [][3] );      
main()
{   
	int a [3][3]= { { 1,2,3} , { 4,5,6},{7,8,9}};   
	foo(a);   
	printf("%d" , a[2][1]);
}
void foo( int b[][3])    
{   
	++ b;   
	b[1][1] =9;
}  
这段程序的输出是:a
(a) 8
(b) 9
(c) 7
(d)以上均不对
第6题目:考查逗号表达式
main()
{   
	int a, b,c, d;   
	a=3;   
	b=5;   
	c=a,b;   
	d=(a,b);   
	printf("c=%d" ,c);   
	printf("d=%d" ,d);
}
这段程序的输出是:c
(a) c=3 d=3
(b) c=5 d=3
(c) c=3 d=5
(d) c=5 d=5
第7题:考查指针数组
main()
{   
	int a[][3] = { 1,2,3 ,4,5,6};   
	int (*ptr)[3] =a;   
	printf("%d %d "   ,(*ptr)[1], (*ptr)[2] );   
	++ptr;   
	printf("%d %d"   ,(*ptr)[1], (*ptr)[2] );
}
这段程序的输出是:a
(a) 2 3 5 6
(b) 2 3 4 5
(c) 4 5 0 0
(d) 以上均不对
第8题:考查函数指针
int *f1(void)
{   
	int x =10;   
	return(&x);
}
int *f2(void)
{   
	int*ptr;   
	*ptr =10;   
	return ptr;
}int *f3(void)
{   
	int *ptr;   
	ptr=(int*) malloc(sizeof(int));   
return ptr;
}
上面这3个函数哪一个最可能引起指针方面的问题a
(a) 只有 f3
(b) 只有f1 and f3
(c) 只有f1 and f2
(d) f1 , f2 ,f3
第9题:考查自加操作(++)
main()
{   
	int i=3;   
	int j;   
	j = sizeof(++i+ ++i);   
	printf("i=%d j=%d", i ,j);
}
这段程序的输出是:c
(a) i=4 j=2
(b) i=3 j=2
(c) i=3 j=4
(d) i=3 j=6
第10题:考查形式参数，实际参数，指针和数组
void f1(int *, int); 
void f2(int *, int); 
void(*p[2]) ( int *, int);
main()
{   
	int a;   	
	int b;  
 	p[0] = f1;   
	 p[1] = f2;   
	a=3;   
	b=5;   
	p[0](&a , b);   
	printf("%d\t %d\t" , a ,b);   
	p[1](&a , b);   
	printf("%d\t %d\t" , a ,b);
}
void f1( int* p , int q)
{   
	int tmp;   
	tmp =*p;   
	*p = q;   
	q= tmp;
}
void f2( int* p , int q)
{   
	int tmp;   
	tmp =*p;   
	*p = q;   
	q= tmp;
}  
这段程序的输出是:a
(a) 5 5 5 5
(b) 3 5 3 5
(c) 5 3 5 3
(d) 3 3 3 3
第11题:考查自减操作(--)
void e(int );   
main()
{   
	int a;   
	a=3;   
	e(a);
}
void e(int n)
{   
	if(n>0)   
	{     
		e(--n);     
		printf("%d" , n);     
		e(--n);   
	}
}
这段程序的输出是:a
(a) 0 1 2 0
(b) 0 1 2 1
(c) 1 2 0 1
(d) 0 2 1 1
第12题:考查typedef类型定义,函数指针
typedef int (*test) ( float * , float*)test tmp;c
tmp 的类型是
(a) 函数的指针，该函数以 两个指向浮点数(float)的指针(pointer)作为参数(arguments)
       Pointer to function of having two arguments that is pointer to float
(b) 整型
(c) 函数的指针，该函数以 两个指向浮点数(float)的指针(pointer)作为参数(arguments),并且函数的返回值类型是整型
       Pointer to function having two argument that is pointer to float and return int
(d) 以上都不是
第13题:数组与指针的区别与联系
main()
{   
char *p;   
char buf[10] ={ 1,2,3,4,5,6,9,8};   
p = (buf+1)[5];   
printf("%d" , p);
}
这段程序的输出是:
(a) 5
(b) 6
(c) 9
(d) 以上都不对
第14题:
Void f(char**);
main()
{   
	char * argv[] = { "ab" ,"cd" , "ef" ,"gh", "ij" ,"kl" };   
	f( argv );
}
void f( char **p )
{   
	char* t;   
	t= (p+= sizeof(int))[-1];   
	printf( "%s" , t);
}
这段程序的输出是:
(a) ab
(b) cd
(c) ef
(d) gh
第15题:
#include<stdarg.h>
int ripple ( int , ...);
main()
{   
	int num;   
	num = ripple ( 3, 5,7);   
	printf( " %d" , num);
}
int ripple (int n, ...)
{   
	int i , j;   
	int k;     
	va_list p;   
	k= 0;   
	j = 1;   
	va_start( p , n);        
	for (; j<n;   ++j)    
	{     
		i =   va_arg( p , int);     
		for (; i;     i &=i-1   )       
			++k;   
	}   
	return k;
}
这段程序的输出是:
(a) 7
(b) 6
(c) 5
(d) 3
第16题:
int counter (int i)
{   
	static int count =0;   
	count = count +i;   
	return (count );
}
main()
{   
	int i , j;   
	for (i=0; i <=5; i++)     
		j = counter(i);
}
The value of j at the end of the execution of the this program is:b
(a) 10
(b) 15
(c) 6
(d) 7
详细参考答案
第1题:    (b)
volatile字面意思是易于挥发的。这个关键字来描述一个变量时，意味着 给该变量赋值(写入)之后，马上再读取，写入的值与读取的值可能不一样,所以说它"容易挥发"的。
这是因为这个变量可能一个寄存器，直接与外部设备相连，你写入之后，该寄存器也有可能被外部设备的写操作所改变;或者，该变量被一个中断程序，或另一个进程
改变了.
volatile variable isn't affected by the optimization. Its value after the longjump is the last value variable assumed.
b last value is 5 hence 5 is printed.
setjmp : Sets up for nonlocal goto /* setjmp.h*/
Stores context information such as register values so that the lomgjmp function can return control to the statement following the one calling setjmp.Returns 0 when it is initially called.
Lonjjmp: longjmp Performs nonlocal goto /* setjmp.h*/
Transfers control to the statement where the call to setjmp (which initialized buf) was made. Execution continues at this point as if longjmp cannot return the value 0.A nonvolatile automatic variable might be changed by a call to longjmp.When you use setjmp and longjmp, the only automatic variables guaranteed to remain valid are those declared volatile.
Note: Test program without volatile qualifier (result may very)
第2题:    (a)
The members of structures have address in increasing order of their declaration. If a pointer to a structure is cast to the type of a pointer to its first member, the result refers to the first member.
第3题:   (a)
Non recursive version of the program 
int   what ( int x ,int n){   int val;  int product;  product =1;val =x;   while(n>0)   
{   if (n%2 == 1)  product = product*val;   n = n/2;   val = val* val;   }}
/* Code raise a number (x) to a large power (n) using binary doubling strategy */
Algorithm description
(while n>0)   {   if   next most significant binary digit of   n( power)   is one   then multiply accumulated product by current val   ,    reduce n(power)   sequence by a factor of two using integer division .   get next val by multiply current value of itself                    }
第4题:   (c)
type of a is array of int
type of &a is pointer to array of int
Taking a pointer to the element one beyond the end of an array is sure to work.
第5题:   (b)
第6题:   (c)
The comma separates the elements of a function argument list. The comma is also used as an operator in comma expressions. Mixing the two uses of comma is legal, but you must use parentheses to distinguish them. the left operand E1 is evaluated as a void expression, then E2 is evaluated to give the result and type of the comma expression. By recursion, the expression
E1, E2, ..., En
results in the left-to-right evaluation of each Ei, with the value and type of En giving the result of the whole expression. 
c=a,b;   / *yields c=a* /d=(a,b); /* d =b   */
第7题:   (a)
/* ptr is pointer to array of 3 int */
第8题:   (c)
f1 and f2 return address of local variable ,when function exit local variable disappeared
第9题:   (b)
sizeof operator gives the number of bytes required to store an object of the type of its operand . The operands is either an expression, which is not evaluated ( (++i + ++ i ) is not evaluated so i remain 3 and j is sizeof int that is 2) or a parenthesized type name.
第10题:   (a)
void(*p[2]) ( int *, int);
define array of pointer to function accept two argument that is pointer to int and return int. p[0] = f1; p[1] = f2 contain address of function .function name without parenthesis represent address of function Value and address of variable is passed to function only argument that is effected is a (address is passed). Because of call by value f1, f2 can not effect b
第11题:   (a)
第12题:   (c)
C provide a facility called typedef for creating new data type names, for example declaration 
typedef char string
Makes the name string a synonym for int .The type string can be used in declaration, cast, etc, exactly the same way that the type int can be. Notice that the type being declared in a typedef appears in the position of a variable name not after the word typedef.
第13题:   (c)
If the type of an expression is "array of T" for some type T, then the value of the expression is a pointer to the first object in the array, and the type of the expression is altered to "pointer to T"
So (buf+1)[5] is equvalent to *(buf +6) or buf[6]
第14题:   (b)
p+=sizeof(int) point to argv[2]
(p+=sizeof(int))[-1] points to argv[1]
第15题:   (c)
When we call ripple value of the first argument passed to ripple is collected in the n that is 3. va_start initialize p to point to first unnamed argument that is 5 (first argument).Each call of va_arg return an argument and step p to the next argument. va_arg uses a type name to determine what type to return and how big a step to take Consider inner loop
(; i; i&=i-1) k++ /* count number of   1 bit in i *
in five number of 1 bits is (101) 2
in seven number of 1 bits is (111) 3
hence k return 5
example
let  i=9=1001      i-1= 1000             (i-1) +1 = i                1000  +1    1 001
The right most 1 bit of i has corresponding 0 bit in i-1 this way i & i-1, in a two complement number system will delete the right most 1 bit I(repeat until I become 0 gives number of 1 bits) 
第16题:   (b)
The answer is (b)
Static variable count remain in existence rather than coming and going each time function is called
so first call counter(0) count =0
second call counter(1) count = 0+1;
third call counter(2) count = 1+2; /* count = count +i */
fourth call counter(3) count = 3+3;
fifth call counter(4) count = 6+4;
sixth call counter(5) count = 10+5;
C语言面试题
     1、局部变量能否和全局变量重名？
答：能，局部会屏蔽全局。要用全局变量，需要使用"::"
局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。
2、如何引用一个已经定义过的全局变量？
答：extern
可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。
3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？
答：可以，在不同的C文件中以static形式来声明同名全局变量。
可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错
4、语句for( ；1 ；)有什么问题？它是什么意思？
答：和while(1)相同。
5、do……while和while……do有什么区别？
答：前一个循环一遍再判断，后一个判断以后再循环
6、请写出下列代码的输出内容
#include
main()
{
int a,b,c,d;
a=10;
b=a++;
c=++a;
d=10*a++;
printf("b，c，d：%d，%d，%d"，b，c，d）;
return 0;
}
答：10，12，120
7、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。
从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。
static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件
static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;
static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；
static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝.
8、程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。
9、设有以下说明和定义：
typedef union {long i; int k[5]; char c;} DATE;
struct data { int cat; DATE cow; double dog;} too;
DATE max;
则语句 printf("%d",sizeof(struct date)+sizeof(max));的执行结果是：___52____
答：DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20
data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32.
所以结果是 20 + 32 = 52.
当然...在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 = 20
10、队列和栈有什么区别？
队列先进先出，栈后进先出
11、写出下列代码的输出内容
#include
int inc(int a)
{
return(++a);
}
int multi(int*a,int*b,int*c)
{
return(*c=*a**b);
}
typedef int(FUNC1)(int in);
typedef int(FUNC2) (int*,int*,int*);
void show(FUNC2 fun,int arg1, int*arg2)
{
INCp=&inc;
int temp =p(arg1);
fun(&temp,&arg1, arg2);
printf("%d\n",*arg2);
}
main()
{
int a;
show(multi,10,&a);
return 0;
}
答：110
19.
enum string
{
x1,
x2,
x3=10,
x4,
x5,
}x;
问x= 0x801005，0x8010f4 ;
20.
unsigned char *p1;
unsigned long *p2;
p1=(unsigned char *)0x801000;
p2=(unsigned long *)0x810000;
请问p1+5= ;
p2+5= ;
选择题: 
24.
unsigned short hash(unsigned short key)
{
return (key>>)%256
}
请问hash(16),hash(256)的值分别是:
A.1.16;B.8.32;C.4.16;D.1.32
找错题:
 28.
typedef unsigned char BYTE
int examply_fun(BYTE gt_len; BYTE *gt_code)
{
BYTE *gt_buf;
gt_buf=(BYTE *)MALLOC(Max_GT_Length);
......
if(gt_len>Max_GT_Length)
{
return GT_Length_ERROR;
}
.......
}
3.描述一下嵌入式基于ROM的运行方式基于ram的运行方式有什么区别。
4.task 有几种状态？
5.task 有几种通讯方式？
6.C函数允许重入吗？
7.嵌入式操作系统和通用操作系统有什么差别 

嵌入式系统开发人员C语言测试题 (运算符与表达式)
一. 选择题（共15题，每题3分。）
（1）设有以下语句:
    char a=3, b=6, c;
    c = a^b<<2;
    则c的二进制值是___b__。
a. 00011011 
b. 00010100 
c. 00011100 
d. 00011000
（2）表达式0x13&0x17的值是_b__。
a. 0x17
b. 0x13
c. 0xf8
d. 0xec
（3）表达式0xl3|0xl7的值是__b__。
a. 0x13
b. 0x17
c. 0xE8
d. 0xc8
（4） 以下叙述中正确的是_____。
a. 表达式a&＝b等价于a＝a&b
b. 表达式a|＝b等价于a＝a|b
c. 表达式a!＝b等价于a＝a!b
d. 表达式a^＝b等价于a＝a^b
（5） 运作对象必须是整型数的运算符是___a__。
a. %    b. .    c. /    d. **
（6） 根据以下定义，错误的表达式是__d___。
struct
{
    int a;
    char b; 
} Q, *p = &Q;
a. Q.a 
b. (*p).b
c. p->a
d. *p.b
（7） 若x是单精度实型变量，表达式 x = 10/4 的值是__d___ 。
a. 2.5         b. 2.0        c. 3         d. 2
（8） 表达式 !x 等价于___a__。
a. x == 0        b. x == 1       c. x != 0     d. x != 1
（9） ____d__是合法的用户自定义标识符。
a. b-b        b. float         c. <fr>          d. _isw 
（10） 若变量已正确定义并赋值，表达式___b___不符合C语言语法。
a. a*b/c;     b. 3.14%2       c. 2, b         d. a/b/c 
（11） ___c__是不正确的字符常量。
a. '\n'        b. '1'           c. "a"          d. '\101'
（12） 在 C 程序中，用__b___表示逻辑值"真"。
a. 1           b. 非 0 的数      c. 非 1 的数     d. 大于 0 的数
（13） ___c___把x、y定义成float类型变量，并赋同一初值3.14。
a. float x, y=3.14;              b. float x, y=2*3.14;  
c. float x=3.14, y=x=3.14;     d. float x=y=3.14;
（14） 假设变量已正确定义，表达式__c____的值不是2。
a. 2&3       b. 1<<1         c. a==2         d. 1^3
（15） 若变量已正确定义，语句if(a>b) k=0; else k=1;和____c__等价。   
a. k=(a>b)?1:0;              b. k=a>b;
c. k=a<=b;                    d. a<=b ? 0 : 1;
二．填空题（每题5分）。
（1） &运算符作为单目运算符时表示的是____运算；作为双目运算符时表示的是_____运算。
（2） 请计算sizeof的值：
char str[] = "Hello" ;
char *p = str ;
int n = 10;
请计算
sizeof (str ) = __6__
sizeof ( p ) = ___4__
sizeof ( n ) = ____4__
（3） 请计算sizeof的值：
void Func ( char str[100])
{
    // 请计算
    sizeof( str ) = __4___
}
（4） 请计算sizeof的值：
void *p = malloc( 100 );
// 请计算
sizeof ( p ) = ___4___
（5） 下列程序段的输出是_______。
#define f(a, b, x)  a*x+b
printf("%d, %d\n", f(3,2,1), f(6, 5, f(3, 2, 1)));
（6） 下列程序段的输出是_____。
main()
{  
    int k;
    for(k=1; k<5; k++) 
    {
        if(k % 2)  printf("*");
        else continue;
        printf("#");
    }}
三.简单题（共3题，每题10分）
（1） 指出下面程序的错误并改正：
void main(void)
{
	int a,b;
    a = 1;
    b = a/++a;
    printf("b equals %d\n", b);
}
（2） int a=391,b=1971; 写出 a^b^a的值。
（3） 语句：x++;?++x; x=x+1;?x=l+x; ，执行后都使变量x中的值增1，请写出一条同一功能的赋值语句。
嵌入式系统开发人员C语言测试题 (数据类型和变量)
一. 选择题（共15题，每题3分。）
（ 1）在C语言中,  char型数据在内存中的存储形式是___d__。
a. 补码   b. 反码   c. 原码    d. ASCII码
 （2）设C语言中,一个int型数据在内存中占2个字节,则unsigned  int型数据的取值范围为___a___。
a. 0～255   b. 0～32767     c. 0～65535   d. 0～2147483647
 （3）已知ch是字符型变量,下面不正确的赋值语句是__a__。
a. ch='a+b';   b. ch='\0';   c. ch='7'+'9';    d. ch=5+9;
 （4）已知ch是字符型变量,下面正确的赋值语句是__b__。
a. ch= '123';   b. ch= '\xff';  c. ch= '\08';   d. ch="\";
 （5）以下选项中不正确的整型常量是__c___。
a. 12L        b. -10       c. 1,900    d. 123U
  （6）假设int型变量占两个字节的存储单元，若有定义：
   int x[10]={0,2,4};
则数组x在内存中所占字节数为___d___。
a. 3           b. 6           c. 10             d. 20
 （7）C语言中能用八进制表示的数据类型为_____。
a. 字符型、整型                    b. 整形、实型
c. 字符型、实型、双精度型      d. 字符型、整型、实型、双精度型
（8）以下只有在使用时才为该类型变量分配内存的存储类说明是__d__。
a. auto和static              b. auto和register
c. register和static         d. extern和register
（9）下面四个选项中,均是合法整型常量的选项是__a__。
a. 160          b. 0xcdf    c. 01        d. 0x48a
   0xffff           01a       986,012        2e5
011              0xe        0668           0x
（10）下面四个选项中,均是不合法的整型常量的选项是__d__。
a. 0f1     b. 0Xcdf c. 018    d. 0x48eg
0xffff        017          999        068
0011          12,456       5e2         03f
（11）下面四个选项中,均是不合法的浮点数的选项是__d__。
a. 160.      b. 123      c. 18      d. e3
   0.12          2e4.2       123e4         .234
e3           .e5          0.0            1e3
（12）下面四个选项中,均是合法浮点数的选项是____。
 a.  +le+1      b. 60.       c. 123e      d. e3
     5e-9.4  12e-4      1.2e-.4      .8e4
03e2          8e5         +2e           5.e
（13）下面四个选项中,均是合法转义字符的选项是____。
 a. '\''        b. '\'     c. '\018'   d. '\\0'
    '\\'            '\017'     '\f'         '101'
'\n'            '\"'        'xab'       'xlf'
（14）下面四个选项中,均是不合法的转义字符的选项是____。
  a. '\''     b. '\1011'    c. '\011'    d. '\abc'
     '\\'          '\'           '\f'          '\1011'
    '\xf'          '\a'          '\}'         'xlf'
（15）下面正确的字符常量是__c__。
a. "a"     b. '\\''    c. 'W'    d. ''
二．填空题（每题6分）。
 （1）说明下面变量的定义：
char (*p[])();          _____________________
char *p()[];    _____________________
char (*p)[10][10];     _____________________
char(*(*p())[])[];     _____________________
（2）下面共同体的存储空间是_____
union BOOKNUMBER
{
    T_S16 age;
    T_S8 title[10];
    T_S8 post[32];
}
（3）若整数值范围是 -32768 至 32767。在执行下面的表达式之后, i 的结果是什么?
int i=32766;
i=i+1;          i =       
i=i+1;          i =       
（4）对于联合类型：
union x
{
    char ch[7];
    int i[2];
    float f;
}tom;
那么, sizeof(tom) =        
（5）有以下程序，程序的输出结果是______（注意: ch[0]在低字节,ch[1]在高字节）。
#include<stdio.h>
union pw
{ 
    int i;
    char ch[2];
 }a;
main()
{
    a.ch[0] = 13; 
    a.ch[1] = 0; 
    printf("%d\n", a.i);
}
三.简单题（共3题，每题10分）
（1）已知a为整数，比较下面代码的效率并说明原因：
        a++;
        a = a+1;
（2）已知a为整数，比较下面代码的效率并说明原因：
        a = a*4;
        a << 2;
（3）说明一个变量和定义一个变量有什么区别?
嵌入式系统开发人员C语言测试题-数据结构与算法
一.选择题（共15题，每题3分）
（1）下面关于算法说法错误的是_______。 
a. 算法最终必须由计算机程序实现 
b. 为解决某问题的算法同为该问题编写的程序含义是相同的 
c. 算法的可行性是指指令不能有二义性  
d. 以上几个都是错误的 
（2）下面说法错误的是______. 
a. 算法原地工作的含义是指不需要任何额外的辅助空间 
b. 在相同的规模n下，复杂度O(n)的算法在时间上总是优于复杂度O(2n)的算法 
c. 所谓时间复杂度是指最坏情况下，估算算法执行时间的一个上界 
d. 同一个算法，实现语言的级别越高，执行效率就越低 
（3）在下面的程序段中，对x的赋值语句的频度为_____。 
for (int i; i<n; i++) 
{ for (int j=o; j<n; j++) 
{ x:=x+1; 
} } 
a. 0(2n)            b. 0(n)        c. 0(n2)     d. O(log2n)  
（4）下面说法正确的是______。 
a. 数据元素是数据的最小单位； 
b. 数据元素是数据的最小单位； 
c. 数据的物理结构是指数据在计算机内的实际存储形式 
d. 数据结构的抽象操作的定义与具体实现有关 
（5）下面说法正确的是_______。 
a. 在顺序存储结构中，有时也存储数据结构中元素之间的关系 
b. 顺序存储方式的优点是存储密度大，且插入、删除运算效率高 
c. 数据结构的基本操作的设置的最重要的准则是，实现应用程序与存储结构的独立 
d. 数据的逻辑结构说明数据元素之间的顺序关系,它依赖于计算机的储存结构 
（6） 下述_____是顺序存储结构的优点。 
a. 存储密度大 
b. 插入运算方便 
c. 删除运算方便 
d. 可方便地用于各种逻辑结构的存储表示 
（7）下面关于线性表的叙述中，错误的是_____。 
a. 线性表采用顺序存储，必须占用一片连续的存储单元 
b. 线性表采用顺序存储，便于进行插入和删除操作 
c. 线性表采用链接存储，不必占用一片连续的存储单元 
d. 线性表采用链接存储，便于插入和删除操作 
（8） 某线性表中最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用_______存储方式最节省时间。 
a. 顺序表      b. 双链表        c. 带头结点的双循环链表     d. 单循环链表 
（9）静态链表中指针表示的是______。 
a. 内存地址     b. 数组下标     c. 下一元素地址     d. 左、右孩子地址 
（10）下面的叙述不正确的是_______。 
a. 线性表在链式存储时，查找第i个元素的时间同i的值成正比 
b. 线性表在链式存储时，查找第i个元素的时间同i的值无关 
c. 线性表在顺序存储时，查找第i个元素的时间同i 的值成正比 
d. 线性表在顺序存储时，查找第i个元素的时间同i的值无关 
（11）下面说法错误的是_____。 
a. 静态链表既有顺序存储的优点，又有动态链表的优点。所以，它存取表中第i个元素的时间与i无关。 
b. 静态链表中能容纳的元素个数的最大数在表定义时就确定了，以后不能增加。 
c. 静态链表与动态链表在元素的插入、删除上类似，不需做元素的移动。 
d. 静态链表就是一直不发生变化的链表。 
（12）在双向链表指针p的结点前插入一个指针q的结点操作是______。 
a. p->Llink=q; q->Rlink=p; p->Llink->Rlink=q; q->Llink=q； 
b. p->Llink=q; p->Llink->Rlink=q; q->Rlink=p; q->Llink=p->Llink; 
c. q->Rlink=p; q->Llink=p->Llink; p->Llink->Rlink=q; p->Llink=q; 
d. q->Llink=p->Llink; q->Rlink=q; p->Llink=q; p->Llink=q; 
（13）下面说法正确的是______。 
a. 顺序存储结构的主要缺点是不利于插入或删除操作； 
b. 线性表采用链表存储时，结点和结点内部的存储空间可以是不连续的； 
c. 顺序存储方式插入和删除时效率太低，因此它不如链式存储方式好； 
d. 顺序存储方式只能用于存储线性结构。 
（14）下面说法正确的是______。 
a. 线性表只能用顺序存储结构实现。  
b. 为了很方便的插入和删除数据，可以使用双向链表存放数据。  
c. 顺序存储方式的优点是存储密度大，且插入、删除运算效率高。  
d. 链表是采用链式存储结构的线性表,进行插入、删除操作时，在链表中比在顺序存储结构中效率高。 
（15）下面说法正确的是_________。 
a. 数据元素是数据的最小单位。 
b. 队列逻辑上是一个下端口和上端能增加又能减少的线性表。 
c. 任何一个递归过程都可以转换成非递归过程。 
d. 只有那种使用了局部变量的递归过程在转换成非递归过程时才必须使用栈。 
二.  填空题(共5题，每题5分) 
（1）    下列程序的功能是创建单向链表，请补充完整。 
    #include <stdio.h> 
    #include <alloc.h> 
struct link 
{ char  name[10]; 
  int    mark; 
  struct link  * next; 
    }; 
    void insert(char * name,  int mark); 
    struct link * head = NULL; 
    main() 
    { char  name[10]; 
        int    mark; 
        struct  link *t; 
        while (1)  
{  scanf("%s %d",  name,  &mark); 
       if (strcmp(name, "#") == 0 ) 
  { break; } 
           ______(1)_______; 
        } 
       for (t=head; ______(2)_______) 
       { 
              printf("<%s>: %d\n",  t->name,  t->mark); 
} 
    } 
    void insert(char * name,  int mark) 
    { 
        struct link * p; 
        p = ______(3)_______ ; 
        strcpy(p->name,  name); 
        p->mark = mark; 
            ______(4)_______; 
        if ( head != NULL )   
{ 
______(5)_______; 
} 
        head = p; 
    } 
（2）    用循环链表表示的队列长度为n， 若只设头指针,则出队和入队的时间复杂度分别是______和_____； 若只设尾指针,则出队和入队的时间复杂度分别是_____和_____。 
（3）    在n个记录的有序顺序表中进行折半查找,最大的比较次数是______。 
（4）    仔细阅读下列程序，在空白处填入适当的语句。 
函数match(s,t)完成在字符串s中寻找与t匹配的字符，若存在一个匹配，则返回t在字符串s中的下标；否则，返回-1。其中，字符指针*b始终指向s的第一元素。 
Match(s,t) 
Char s,t; 
｛ char *b=s; 
char *p, *r; 
for _________________________________ 
｛ 
for (p=s, r=t; *r!=`\0` && *p= =*r; p++, r++); 
if__________________________________ 
return(s-b); 
｝ 
return(-1); 
｝
（5）    补充下列程序：设一棵二叉序列树b，下列算法函数是实现在b中插入一个结点s。 
函数： 
void insert（btree *b，btree *s） 
{ if（b == NULL） b = s； 
else 
   if（s->data == b->data） return(); 
   else 
      if(s->data < b->data) 
                       ； 
      else 
                       ；  }
三.简答题（共3题，每题10分）
（1）    在一个包含 n 个元素的数组 M 中查找一个元素 x。 算法假设 M 已经按升序排列了，请写出二分搜索算法的步骤。
（2）    试将一个无序的线性表A=(11,16,8,5,14,10,38,23)转换成一个按升序排列的有序线性表（用链表实现）。 
（3）    何为栈和队列？简述两者的区别和联系。 



电子信息类' 公司招聘C笔试题
1.改错(5分)

void test()
{
  char str[10];
  char* str1 = "0123456789";
  strcpy(str, str1);
}

2.改错(5分)

void test()
{
  char str[10], str1[10];
  for( int = 0; i < 10; i++)
  {
    str = 'a';
  }
  strcpy(str, str1);
}

3.读程序,写出结果(5分)
int sum(int a)
{
  int c = 0;
  static int b = 3;
  c += 1;
  b += 2;
  return (a + b + c);
}

int main()
{
  int a = 2;
  for(int i = 0; i < 5; i++)
  {
    printf("%d,", sum(a));
  }
  return 0;
}

4.读程序,写出结果(5分)
int main()
{
  int a[3];
  a[0] = 0;
  a[1] = 1;
  a[2] = 2;

  int *p, *q;
  p = a;
  q = &a[2];

  int c = a[q - p];

  printf("value c = %d\n", c++);
  printf("value c = %d\n", c);

  return 0;
}

5.读程序,写出结果(10分,选做)
#define STRCPY(a, b)   strcpy(a ## _p, #b)
int main()
{
  char var1_p[20];
  char var2_p[30];

  strcpy(var1_p, "aaaa");
  strcpy(var2_p, "bbbb");

  STRCPY(var1, var2);
  STRCPY(var2, var1);

  printf("var1 = %s\n", var1_p);
  printf("var2 = %s\n", var2_p);

  return 0;
}

6.(10分)不用除法(即不能使用"/"号)和库函数,计算285 / 16的商和余数, 要求效率尽量高.
8.(15分)编写将字符串转换成整数的函数atoi,只处理输入字符串仅由0-9,'-','+',和空格的情况.
函数原型为:
int atoi(char* str);

提示:如果字符串不能构成一整数,可以直接返回0.但是对于以空格开始的字符串应特殊处理.

9.(30分)编写一组单链表操作函数.链表的结构如下:
struct ListNode
{
  long id;
  struct ListNode* next;
};
链表节点以id的从小到大排列,当id相等时,节点顺序没有约定,谁在前都可以.

要求编写的函数有:

遍历函数:返回cur下一个节点, 如果没有更多的节点, 返回0; 
struct ListNode* ListNext(struct ListNode* cur);

插入函数:将newNode插入到head链表中,然后返回newNode的前一节点,
如果newNode已经在链表中,返回0.
struct ListNode* ListInsert(struct ListNode* head, struct ListNode* newNode);

删除函数:从head中删除theNode节点.返回theNode的前一节点.
如果theNode不在链表中,返回0;

struct ListNode* ListRemove(struct ListNode* head, struct ListNode* theNode);








一个公司给我的题目
早一个星期给我的,吓的我不感去拉,C的还算勉强,网络那些看的我头大
1、 选择题（答案为一个或多个）
1、对于栈中的元素进行引用，复合下列哪些规则（A，C）
A：LIFO   B：LILO   C：FILO   D：FIFO
2、单链表的每个结点中包括一个指针link，它指向该结点的后继结点。现要将指针q指向的新结点插入到指针p指向的单链表结点之后，下面的操作序列中哪一个是正确的？（C）
A:  p->link = q->link; q = p->link;
B:  p->link = q; q->link = p->link;
C:  q->link = p->link; p->link = q;
D:  q = p->link; p->link = q->link;
3、在一种语言中，运算符是从右向左结合的（例如：a+b+c =a+(b+c)）下面表达式“7-(16/(3+1)*2)-4”的结果是（C）
A、-1；   B、1；   C、3； D、7； E、9；
4、程序的局部变量存在于（B）中，全局变量存在于（A）中，动态申请数据存在于（C）中
A：数据段  B：堆栈   C：堆空间
5、循环链表指（A、C）
A：最后一个节点的指针域总是指向链表头       B：可疑自由膨胀的链表
C：链表含有指向上一级节点的指针域           D：以上都不是
6、下列是一个C语言函数：
   int f (int a)
{ 
   int b;
   switch (a)
   {
     case 1 : b = 10;
     case 2 : b = 20;
     case 3 : b = 30;
     default : b = 0;
   }
   return b;
}
在其它函数中调用f（1），f（2），f（4），的返回值依次是：D，D，D
A：10   B：20   C：30  D：0
7、进程和线程的最主要区别在于：（B、C、D）
A：进程是UNIX下的概念，线程是Windows下的概念；
B：进程的效率比线程低；
C：在进程中可以创造线程，但线程中不能生成进程；
D：进程有自己的运行空间，线程的运行空间是共享的
8、如下代码：
  unsigned int ulBuf[10];
  int I;
  unsigned char ucInfo[10];
  for (I = 0;I<10;I++)
  {
ulBuf = I+1;
ucInfo = 0;
}
sprintf(ucInfo,”%s”,ulBuf);
请问ucInfo[0]中的值应该是什么（D）
A：0    B：1    C：0或1     D：不确定
9、下面程序的运行结果是多少？（D）
main () {
char chr = 127;
int sum = 200;
chr += 1;
sum +=chr;
printf(“sum = %d\n”,sum);
return(0);
}
A: 327     B:328    C:99    D:72
11、软件需求分析阶段的测试手段一般采用（C）。
A 总结   B 阶段性报告  C 需求分析评审   D 不测试
12、有如下的Hash函数：
unsigned  short  hashf  (unsigned  short  key) { return  (key  >>  4)  %  256 }    
hashf(16)和hashf(256)的值[   ]
A: 1,16     B: 8,32   C:  4,15   D: 1,32
13、enum{A ,B ,C ,D ,E ,K =8 , J , M}; 请说出D=[   ]
A: 3   B: 4    C: 5   D: 6   E :7
14、下面的代码中的含义是什么[    ]　　　　
#ifndef  _oss_LIB_H_      
#define  _oss_LIB_H_       
#endif
A .包含oss的Lib库　　　　B: 定义一个常量      C.不包含oss的Lib库　　　
D.防止头文件被重复引用
15、下面程序的运行结果是多少？[   ]　　　　
#include  <string.h>
main( ){   char  chr  =  127;    int  sum   = 200;     
chr  +=  1;    sum  +=  chr;    pfintf( “sum=%d/n”,sum);    return  0 ; }             
A :327    B: 328   C: 199   D: 72
16、以下手段哪些可用于进程间的同步与互斥[      ] 
A：信号量与PV原语   B：B树    C：进程上下文     D：临界区加锁
17、对栈S进行下列操作：push(1), push(2), pop( ), pop( )。则此时栈顶元素是[    ]
A：1　　B：2　　　C：0　　D：　不确定
18、switch(c)中的c不能是哪种数据类型[     ]
A：char   B：long   C：unsigned    D：double   E：float
19、在Windows95环境下，定义数组：int **a[2][3]：则数组a所占用的内存单元为[    ]
A：6字节　　　　B：24字节　　　C：48字节　　　D：不能确定
20、类型定义：       chair  S[3] =”AB”     char *p;      在执行了语句p=s之后，*(p+2)的值是[    ]
A：‘B’　B：字符‘B’的地址　　　　C：‘\0　　　D：不确定     E：以上答案均不正确
21、下面对宏的定义和使用，哪些是错误的？[    ]
A：#define   RECTANGLE_AREA(a, b)  (a * b)    
B：#define  RECTANGLE_AREA(a,b)  ( a )*  ( b )
C：#define  INTI_RECT_VALUE( a, b )     
D：#define  MBUF_CLEAR_FLAG(pstMBufM, ulflagM)
((pstMEufM)-stUserTagData.stCommonInfo.ulFlag  &=( ~(ulFlagM)  ))
21、下面二叉树前序遍历的顺序是[    ]
　　　　　　　　　　　　a
                      ╱ ╲
b     c
A：a,b,c　　　B：b,a,c        C：b,c,a      D：c,b,a 
22、对下列关键字序列用快速排序进行排序时，速度最快的情形是[     ]
A：｛25、23、30、17、21、5、9｝        B：｛21、9、17、30、25、23、5｝
C：｛21、25、5、17、9、23、30｝        D：｛5、9、17、21、23、25、30｝
23、在下列叙述中，错误的一条是[    ]      
A：操作系统是用户与计算之间的接口；
B：程序的并发执行，使程序失去了顺序执行时具有的封闭性和可再现性，程序与程序的执行不再一一对应。
C：进程从一个状态到别一个状态的转换，都是靠使用不同的原语来实现。      
D：在单CPU的系统中，任何时刻处于就绪状态的进程有多个，而且，只有处于就绪状态的进程经调度程序选中后方可进入运行状态。
24、下面关于内容存管理的说法哪种是正确的[    ] 
A：页式内存管理存在严重的碎片问题   
B：段式内存管理不存在抖动问题     
C：分区式内存管理既存在碎片问题，又存在抖动问题      
D：段页式内存管理既减少了碎片问题，又减少了抖动问题
二、简答题
1、const char*, char const*, char*const的区别?
解答：
把一个声明从右向左读。 
char  * const cp;  ( * 读成 pointer to )  cp is a const pointer to char 
const char * p;    p is a pointer to const char; 
char const * p;    同上因为C++里面没有const*的运算符，所以const只能属于前面的类型。
2、下面这个程序执行后会有什么错误或者效果:
#define MAX 255
int main()
{
   unsigned char A[MAX],i;
   for (i=0;i<=MAX;i++)
      A=i;
}
解答：
MAX=255 
数组A的下标范围为:0..MAX-1,这是其一..
其二.当i循环到255时,循环内执行:
  A[255]=255;
这句本身没有问题..但是返回for (i=0;i<=MAX;i++)语句时,
由于unsigned char的取值范围在(0..255),i++以后i又为0了..无限循环下去.
注：char类型为一个字节，取值范围是[-128，127]，unsigned char [0 ,255]
3、ASSERT()是干什么用的
解答：
ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。例如，变量n在程序中不应该为0，如果为0可能导致错误，你可以这样写程序： 
...... 
ASSERT( n != 0); 
k = 10/ n; 
...... 
ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略。 
assert()的功能类似，它是ANSI C标准中规定的函数，它与ASSERT的一个重要区别是可以用在Release版本中。
4、头文件中的 ifndef/define/endif 干什么用？
解答：防止该头文件被重复引用。
5、#include <filename.h> 和 #include “filename.h” 有什么区别？
解答：
对于#include <filename.h> ，编译器从标准库路径开始搜索 filename.h
对于#include “filename.h” ，编译器从用户的工作路径开始搜索 filename.h
6、const 有什么用途？（请至少说明两种）
解答：
（1）可以定义 const 常量
（2）const 可以修饰函数的参数、返回值，甚至函数的定义体。被const 修饰的东
西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
7、在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”？ 
解答：
C++语言支持函数重载，C 语言不支持函数重载。函数被C++编译后在库中的名字
与C 语言的不同。假设某个函数的原型为： void foo(int x, int y);
该函数被C 编译器编译后在库中的名字为_foo ， 而C++编译器则会产生像
_foo_int_int 之类的名字。
C++提供了C 连接交换指定符号extern“C”来解决名字匹配问题。
8、void GetMemory(char *p)
{
p = (char *)malloc(100);
}
void Test(void)
{
char *str = NULL;
GetMemory(str);
strcpy(str, "hello world");
printf(str);
}
请问运行Test 函数会有什么样的结果？
解答：
程序崩溃。
因为GetMemory 并不能传递动态内存，
Test 函数中的 str 一直都是 NULL。
strcpy(str, "hello world");将使程序崩
溃。
9、char *GetMemory(void)
{
char p[] = "hello world";
return p;
}
void Test(void)
{
char *str = NULL;
str = GetMemory();
printf(str);
}
请问运行Test 函数会有什么样的结果？
解答：
可能是乱码。
因为GetMemory 返回的是指向“栈内存”
的指针，该指针的地址不是 NULL，但其原
现的内容已经被清除，新内容不可知。
10、void GetMemory2(char **p, int num)
{
*p = (char *)malloc(num);
}
void Test(void)
{
char *str = NULL;
GetMemory(&str, 100);
strcpy(str, "hello");
printf(str);
}
请问运行Test 函数会有什么样的结果？
解答：
（1）能够输出hello
（2）内存泄漏
11、void Test(void)
{
char *str = (char *) malloc(100);
strcpy(str, “hello”);
free(str);
if(str != NULL)
{
strcpy(str, “world”);
printf(str);
}
}
请问运行Test 函数会有什么样的结果？
解答：
篡改动态内存区的内容，后果难以预
料，非常危险。
因为free(str);之后，str 成为野指针，
if(str != NULL)语句不起作用。
12、1．下面的代码错在哪里？    
#include<string.h>     
char *  Func(void){    
char   p[10];     
strcpy(p,”11”);      
return  p;
}
解答：局部变量不能作为地址指针返回。
13、5、请描述软件工程中的瀑布模型？
解答：
五、编写strcpy 函数（10 分）
已知strcpy 函数的原型是
char *strcpy(char *strDest, const char *strSrc);
其中strDest 是目的字符串，strSrc 是源字符串。
（1）不调用C++/C 的字符串库函数，请编写函数 strcpy
char *strcpy(char *strDest, const char *strSrc);
{
assert((strDest!=NULL) && (strSrc !=NULL)); // 2分
char *address = strDest; // 2分
while( (*strDest++ = * strSrc++) != ‘\0’ ) // 2分
NULL ;
return address ; // 2分
}
六、编写用C语言实现的求n阶阶乘问题的递归算法：
long int fact(int n)
{
  int x;
  long int y;
  if(n<0)   
   {
     printf("error!");
   }
  if(n==0)
     return 1;
  x=n-1;
  y=fact(x);
  return (n*y);
}
七、编程实现删除有序数组中的重复元素？
八、编程实现双向链表和单向链表插入一个node操作。
小知识：（必须掌握）
c指针 
int *p[n];-----指针数组，每个元素均为指向整型数据的指针。
int (*)p[n];------p为指向一维数组的指针，这个一维数组有n个整型数据。
int *p();----------函数带回指针，指针指向返回的值。
int (*)p();------p为指向函数的指针。 
下面一套网络的
一．填空题：（共15题，每题1.5分  合计：22.5分）
1、  TCP/IP模型（按从高到低的顺序） 应用层 传输层 网络层 网络接口层 
2、  OSI参考模型（按从高到低的顺序） 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层
3、地址解析协议  ARP 是用于获得指定物理网络接口卡地址的目标主机的 IP    地址
4、网际控制报文协议 ICMP 是用以向源主机报告数据报文在交付时出现的一些错误
5、传输层的主要协议 TCP、SPX  和  NetBIOS         UDP
6、在TCP/IP数据报格式中            字段是设置分片长度的（填写英文名称）
7、在TCP/IP数据报格式中    TOS  字段是表示应该如何处理给数据报，并提供服务类型设置的（填写英文）
8、一个IP地址分为两部分前一部分   网络   地址，后一部分是  主机  地址。 
9、Ipv6的地址结构中每个IP地址长度为    1000 0000(128)     位（二进制） 
10、两种核心路有协议更新算法：  最短路径优先法  和   矢量距离法    。
11、RIP最大规定最大跳数为  15   ，若跳数为  16  则表示不可达。
12、BOOTP使用  UDP   风装在IP中，因而已被应用程序使用。
13、BOOTP是用两个知名的端口：服务器端口为    67  ，客户机端口为   68   。
14、FTP是基于TCP连接的，所使用的端口是    21     。
15、在简单网络管理协议的应用中，被管设备都应该运行  tcp/ip 协议。在被管设备中需要运行与管理相关的软件，叫做 代理理程序( a g e n t )或代理进程   。
二．选择题：（共25题，每题1.5分 合计：37.5分）
1、下列那些不时网际层协议 c
A、IP
B、ARP
C、MAC
D、ICMP
E、IGMP
2、TCP/IP支持那三种类型的数据发送 c
A、多播、广播、单播
B、多播、单播、IP数据
C、多播、组播、单播
D、IP数据、组播、广播
3、  传输控制协议表述正确的内容是 b
A、面向连接的协议，不提供可靠的数据传输
B、面向连接的协议，提供可靠的数据传输
C、面向无连接的服务，提供可靠数据的传输
D、面向无连接的服务，不提供可靠的数据传输
4、  文件传输协议（FTP）使用什么样的服务 c
A、ICMP服务
B、UDP服务
C、TCP服务
D、SMTP服务
5、  以太网最大可传送的帧（数据）长度为    个8位组。d
A、64
B、32
C、256
D、1500
6、  逻辑地址202.112.108.158，用 Ipv4二进制表示32地址正确的是：a
A、11001010  01110000  01101100  10011110
B、10111101  01101100  01101100  10011001
C、10110011  11001110  10010001  00110110
D、01110111  01111100  01110111  01110110
E、以上都不对
7、  IP地址分配需要注意问题，一下对IP地址分配中描述不正确的是：d
A、网络ID不能全为1
B、网络ID不能全为0
C、网络ID不能以127开头
D、同一网络上的每台主机必须有不同的网络ID
E、同一网络上的每台主机必须分配有唯一的主机ID
8、  下列地址哪一个有效：
A、131.255.255.18
B、220.103.256.56
C、240.9.12.12
D、192.5.91.255
E、129.9.200.21
9、  子网掩码的设置正确的是：c
A、对应于网络地址的所有位都设为0
B、对应于主机地址的所有位都设为1
C、对应于网络地址的所有位都设为1
D、以上都不对
10、子网掩码为255.255.0.0下列哪个IP地址不在同一网段中：c
A、172.25.15.201
B、172.25.16.15
C、172.16.25.16
D、172.25.201.15
11、对于IP地址192.168..168.0、192.168.169.0、192.168.170.0、192.168.171.0将这四个C类地址合并成一个超网应该使用子网掩码： a
A、255.255.0.0
B、255.255.255.0
C、255.240.248.0
D、255.248.240.0
12、在每一个自治系统中，都指定一个或多个路由器负责收集并向与此自治系统相连接的  a   发送本自治系统中各个网络的可达性信息a
A、路由器
B、核心路由器
C、交换机
D、服务器
13、在同一自治系统中实现路由器之间自动传播可达信息、进行路由选择的协议称为。c
A、EGP
B、BGP
C、IGP
D、GGP
14、RIPv1中规定活动节点每隔       秒广播一轮其当前路由表中的路由信息。d
A、60
B、120
C、180
D、30
15、RIPv1中规定被动节点在学到一个路由后要立即开始计时，在      秒之内，如果一直没有再次得到关于此路由的广播，则放弃此路由。b
A、160
B、180
C、30
D、60
16、RIPv1和RIPv2的区别：d
A、支持更多IP地址数
B、通过传递子网掩码扩展了对于子网路由的支持
C、规定的最大跳数不同
D、以上都不对
17、下列对OSPF描述错误的是：e
A、提供路由服务类型：如可要求低延迟或高吞吐量，路由时不仅依据路由目的，还要依据服务类型要求
B、提供负载均衡：如果到某个目的机具有多个具有相同代价的路径，OSPF将均分负载给各个路径
C、提供网络的“域”划分能力，一个域对外部是透明的，因而可独立管理，这就提供了灵活的网络扩展能力，易于规模化
D、规定路由器之间的信息交换需要有授权，提高安全性。RIP中任意路由都可广播路由信息，易被利用。
E、使用跳数来计算到墓地网络的距离。
18、对网际控制协议（ICMP）描述错误的是：b
A、ICMP封装在IP数据报的数据部分
B、ICMP消息的传输是可靠的
C、一般不把ICMP作为高层协议，而只作为IP必需的一个部分。
D、ICMP不是在物理层进行传送的
19、对UDP数据报描述不正确的是：d
A、是无连接的
B、是不可靠的
C、不提供确认
D、提供消息反馈
20、对客户-服务器模式描述不正确的是：a
A、服务器通过网络接收请求，并进而提供服务返回给请求者
B、不同节点完成近乎形同功能的两个程序
C、向服务器发送请求并等待相应的程序都可称为客户
D、客户机程序可以利用服务器节点上现有的资源
21、DNS服务器进行查询时，可以有三种方式：
A、递归查询方式、重复查询方式、逆向查询方式
B、递归查询方式、触发更新查询方式、逆向查询方式
C、重复查询方式、逆向查询方式、触发更新查询方式
D、递归查询方式、重复查询方式、触发更新查询方式
22、TELNET通过TCP/IP协议模块在客户机和远程登录服务器之间建立一个：A
A、UDP
B、ARP
C、TCP
D、RARP
23、TFTP在传输文件时，每个传输文件为固定的      。d
A、256K
B、54K
C、128K
D、512K
24、简单网络管理协议工作在         层，使用       层协议进行通信。b
A、传输层、网络层
B、应用层、传输层
C、会话层、传输层
D、应用层、网络层
25、MIME的目的
A、为允许在EMAIL中传送非ASCII数据。
B、为使用新的EMAIL帐号
C、为获得邮件传输的身份认证
D、为设置收件箱收发邮件
26、TCP/IP协议组中，传输层协议中[ a  ]是面向连接的，[d  ]是面向非连接的
A:  TCP     B:  IPX     C: ARP     D:  UDP      E:  NETBIOS
27、以下哪些协议属于路由协议?[   abf  ]
A：BGP  B：RIP  C：ICMP  D：H323   E：802.1x   F：OSPF
28、TCP/IP中，一个c类网能带多少台主机？[   ]
A：255   B：522   C：1024   D：2048    E：以上都不是
三．判断题：（共10题，每题1分  合计：10）
1、  IP负责数据交互的可靠性（x ）
2、  传输层的主要功能是负责主机到主机的端对端的通信（）
3、  用户数据报协议提供可靠的数据交互服务，且不进行差错检验（x）
4、  应用层提供TCP/IP应用协议以及应用程序的编程接口（√）
5、  普通文件传输协议（TFTP）使用UDP服务（√）
6、  IP多播地址只能用于源地址，而不能为目的地址。（x）
7、  ICMP不能为多播报告出错消息。（）
8、  在传输层目前，较小的端口号多址定给一些众所周知的服务，较大的留给应用程序。（）
9、  只要一个内核中实现了TCP/IP协议的操作系统，就可以成为TCP/IP网络操作系统（）
10、DHCP协议数据封装在TCP中。（）
四．简答题  （共10题，每题3分  合计：30分）
1、  在TCP/IP中，数据报一旦被分片，则在到达目的主机之前就一直以单独的数据报存在，在到达主机后，才组合成原始的数据报。简述这样做的优缺点。
解答：
1） 包文需要分片，2） 又需要组装，3） 增加了开销和复4） 杂度！
5） 包文分片到组合过程中容易丢包、出错
2、  已由网络设备的物理地址（网卡地址、MAC地址）作为最底层通信地址，为何还要IP地址？
3、为何要做子网划分？
解答：为了节约ip地址
4、简述子网划分的一般步骤。
5、初始化路由表可能有几种方式？
6、最短路径优先法和矢量距离法的比较。
7、简述VD算法所致慢收敛问题的解决方案。
8、简述建立TCP连接三次握手的三个步骤。
解答：
1) 请求端（通常称为客户）发送一个S Y N段指明客户打算连接的服务器的端口，以及初
始序号（I S N）。S Y N段为报文段1。
2) 服务器发回包含服务器的初始序号的S Y N报文段（报文段2）作为应答。同时，将确认
序号设置为客户的I S N加1以对客户的S Y N报文段进行确认。一个S Y N将占用一个序号。
3) 客户必须将确认序号设置为服务器的I S N加1以对服务器的S Y N报文段进行确认（报文
段3）。
这三个报文段完成连接的建立。这个过程也称为三次握手（ three-way handshake）
另外：
建立一个连接需要三次握手，而终止一个连接要经过4次握手。这由T C P的半关闭（h a l f -
c l o s e）造成的。既然一个T C P连接是全双工（即数据在两个方向上能同时传递），因此每个方
向必须单独地进行关闭。这原则就是当一方完成它的数据发送任务后就能发送一个F I N来终止这个方向连接。当一端收到一个F I N，它必须通知应用层另一端几经终止了那个方向的数据传送。发送F I N通常是应用层进行关闭的结果。

9、简述BOOTP请求和响应过程：客户-服务器模式。
10、简述SMTP中客户和服务期间的通信过程。
11、 hub和交换机以及路由器别是什么？功能有哪些区别？分别在哪个层次上面实现的？
12、 CSMA/CD的原理和具体实现过程：
解答：
概括成四句话:先听后发,边发边听,冲突停止,随机延时后重发。
具体过程: 
1当一个站点想要发送数据的时候,它检测网络察看是否有其他站点正在传输,即侦听信道是否空闲.
2如果信道忙,则等待,直到信道空闲.
3如果信道闲,站点就传输数据.
4在发送数据的同时,站点继续侦听网络确信没有其他站点在同时传输数据.因为有可能两个或多个站点都同时检测到网络空闲然后几乎在同一时刻开始传输数据.如果两个或多个站点同时发送数据,就会产生冲突.
5当一个传输节点识别出一个冲突,它就发送一个拥塞信号,这个信号使得冲突的时间足够长,让其他的节点都有能发现.
6其它节点收到拥塞信号后,都停止传输,等待一个随机产生的时间间隙(回退时间Backoff Time)后重发.
13、 IP地址如何分类？
A:0 7 24  B:10 14 16 C:110 21 8 D:1110 28  E:11110 27
14、 Ping操作有哪些报文？
解答： Icmp:request answer
15、 IPV6跟IPV4的主要区别，16、 改变的原因？
17、 
18、 IPV4地址不19、 够用的解决办法有哪些？分别的原理是什么？
解答：子网技术和VLSM（可变长）技术
VLSM(Variable Length Subnet Mask














1.2    程序设计
1.         编写用C语言实现的求n阶阶乘问题的递归算法：
long int fact(int n)
{
    int x;
    long int y;
    if(n<0)   
    {
       printf("error!");
    }
    if(n==0)
       return 1;
    x=n-1;
    y=fact(x);
    return (n*y);
}
2.         二分查找算法：
1)        递归方法实现：
int BSearch(elemtype a[],elemtype x,int low,int high)
/*在下届为low，上界为high的数组a中折半查找数据元素x*/
{
  int mid;
  if(low>high) return -1;
  mid=(low+high)/2;
  if(x==a[mid]) return mid;
  if(x<a[mid]) return(BSearch(a,x,low,mid-1));
  else return(BSearch(a,x,mid+1,high));
}
2)        非递归方法实现：
int BSearch(elemtype a[],keytype key,int n)
{
  int low,high,mid;
  low=0;high=n-1;
  while(low<=high)  
   {
      mid=(low+high)/2;
      if(a[mid].key==key) return mid;
      else if(a[mid].key<key) low=mid+1;
      else high=mid-1;
   }
  return -1;
}
3.         递归计算如下递归函数的值（斐波拉契）：
f(1)=1
f(2)=1
f(n)=f(n-1)+f(n-2) n>2
解：
int f(int n)
{
        int i,s,s1,s2;
        s1=1;/*s1用于保存f(n-1)的值*/
        s2=1;/*s2用于保存f(n-2)的值*/
        s=1;
        for(i=3;i<=n;i++)
{
       s=s1+s2;
       s2=s1;
       s1=s;
    }
return(s);
}
5.         冒泡排序：
void BubbleSort(elemtype x[],int n)
{
        int i,j;
        elemtype temp;
        for(i=1;i<n;i++)  
        for(j=0;j<n-i;j++)
{
                if(x[j].key>x[j+1].key)  
                {
                    temp=x[j];
                    x[j]=x[j+1];
                    x[j+1]=temp;
                }
}
}
7.         编程winsocket
#include <Winsock2.h>
#include <stdio.h>
void main()
{
       WORDwVersionRequested;
       WSADATA wsaData;
       int err; 
       wVersionRequested = MAKEWORD(1,1);
       err = WSAStartup(wVersionRequested,&wsaData);
       if( err != 0)
{
           return;  
       }
       if(LOBYTE( wsaData.wVersion ) != 1||
           HIBYTE( wsaData.wVersion) != 1)
{
            WSACleanup();
            return;
        }
       SOCKET sockSrv=socket(AF_INET,SOCK_STREAM,0);
       SOCKADDR_IN addrSrv;
       addrSrv.sin_addr.S_un.S_addr=htonl(INADDR_ANY);
       addrSrv.sin_family=AF_INET;
       addrSrv.sin_port=htons(6000);
       bind(sockSrv,(SOCKADDR*)&addrSrv,sizeof(SOCKADDR));
       listen(sockSrv,5);
       SOCKADDR_IN addrClient;
       int len=sizeof(SOCKADDR);
       while(1)
       {
            SOCKET sockConn=accept(sockSrv,(SOCKADDR*)&addrClient,&len);
            char sendBuf[100];
            sprint(sendBuf,"Welcome %s to http://www.sunxin.org",
           inet_ntoa(addrClient.sin_addr));
            send(sockConn,sendBuf,strlen(sendBuf)+1,0);
            char recvBuf[100];
           recv(sockConn,recvBuf);
            printf("%s\n",recvBuf);
            closesocket(sockConn);
            WSACleanup();
       }  
}
注：这是Server端；File->New->Win32 Console Application，工程名：TcpSrv；然后，File->New->C++ Source File，文件名：TcpSrv；在该工程的Setting的Link的Object/library modules项要加入ws2_32.lib
#include <Winsock2.h>
#include <stdio.h>
void main()
{
        WORDwVersionRequested;
        WSADATA wsaData;
        int err; 
        wVersionRequested = MAKEWORD(1,1);
        err = WSAStartup(wVersionRequested,&wsaData);
        if( err != 0)
{
            return;  
        }
        if(LOBYTE( wsaData.wVersion ) != 1||
            HIBYTE( wsaData.wVersion) != 1)
{
            WSACleanup();
            return;
        }
        SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0);
        SOCKADDR_IN addrSrv;
        addrSrv.sin_addr.S_un.S_addr=inet_addr("127.0.0.1"); 
        addrSrv.sin_family=AF_INET;
        addrSrv.sin_porthtons(6000);
        connect(sockClient,(SOCKADDR*)&addrSrv,sizeof(SOCKADDR));
char recvBuf[100];
recv(sockClient,recvBuf,100,0);
printf("%s\n",recvBuf);
send(sockClient,"This is zhangsan",strlen("This is zhangsan")+1,0);  
        closesocket(sockClient);
        WSACleanup();
}
注：这是Client端；File->New->Win32 Console Application，工程名：TcpClient；然后，File->New->C++ Source File，文件名：TcpClient；同理，在该工程的Setting的Link的Object/library modules项要加入ws2_32.lib
8.         类的知识
C＋＋
#include <iostream.h>
class human
{
public:
human(){ human_num++;};
static int human_num;
~human()
{
human_num--;
print();
}
void print()
{
cout<<"human num is: "<<human_num<<endl;
}
protected:
private:
};
int human::human_num = 0;
human f1(human x)
{
x.print();
return x;
}
int main(int argc, char* argv[])
{
human h1;
h1.print();
human h2  = f1(h1);
h2.print();
return 0;
}
输出：
1
1
0
0
－1
－2
－－－－－－－－－－－－－－－－－－－－－－－－－－－－
分析：
human h1;       //调用构造函数,---hum_num = 1;
h1.print();     //输出:"human is 1"
human h2  = f1(h1); //再调用f1(h1)的过程中,由于函数参数是按值传递对象,调用默认的复制构造函数,它并没有对hum_num++,所以hum_num 仍= 1,所以x.print()输出:"human is 1";   在推出f1函数时,要销毁X,调用析构函数(human_num--),输出:"human is 0"(,由于该函数返回一个human 对象,所以又调用默认构造函数,创建一个临时对象(human_num = 0;),把临时对象赋给h2,又调用默认构造函数(  human_num = 0);   h2.print();   //输出: human is 0;
//在退出main()函数是,先销毁h2,调用析构函数(human_num--),输出"human_num is -1" 然后销毁h1,调用析构函数(--),输出"human_num is -2"

3       高质量编程C/C++

5、请简述以下两个for 循环的优缺点（5 分）
for (i=0; i<N; i++)
{
    if (condition)
        DoSomething();
    else
        DoOtherthing();
}
if (condition)
{
    for (i=0; i<N; i++)
        DoSomething();
}
else
{
    for (i=0; i<N; i++)
    DoOtherthing();
}
优点：程序简洁
缺点：多执行了N-1 次逻辑判断，并且
打断了循环“流水线”作业，使得编译
器不能对循环进行优化处理，降低了效
率。
优点：循环的效率高
缺点：程序不简洁
六、编写类String 的构造函数、析构函数和赋值函数（25 分）
已知类String 的原型为：
class String
{
    public:
    String(const char *str = NULL); // 普通构造函数
    String(const String &other); // 拷贝构造函数
    ~ String(void); // 析构函数
    String & operate =(const String &other); // 赋值函数
    private:
    char *m_data; // 用于保存字符串
};
请编写String 的上述4 个函数。
标准答案：
// String 的析构函数
String::~String(void) // 3 分
{
    delete [] m_data;
    // 由于m_data 是内部数据类型，也可以写成 delete m_data;
}

// String 的普通构造函数
String::String(const char *str) // 6 分
{
    if(str==NULL)
    {
        m_data = new char[1]; // 若能加 NULL 判断则更好
        *m_data = ‘\0’;
    }
    else
    {
        int length = strlen(str);
        m_data = new char[length+1]; // 若能加 NULL 判断则更好
        strcpy(m_data, str);
     }
}

// 拷贝构造函数
String::String(const String &other) // 3 分
{
    int length = strlen(other.m_data);
    m_data = new char[length+1]; // 若能加 NULL 判断则更好
    strcpy(m_data, other.m_data);
}

// 赋值函数
String & String::operate =(const String &other) // 13 分
{
    // (1) 检查自赋值 // 4 分
    if(this == &other)
    return *this;
    // (2) 释放原有的内存资源 // 3 分
    delete [] m_data;
    // （3）分配新的内存资源，并复制内容 // 3 分
    int length = strlen(other.m_data);
    m_data = new char[length+1]; // 若能加 NULL 判断则更好
    strcpy(m_data, other.m_data);
    // （4）返回本对象的引用 // 3 分
    return *this;
}

国外嵌入式面试题
Embedded System Interview Questions: 
1. Can structures be passed to the functions by value? 
2. Why cannot arrays be passed by values to functions? 
3. Advantages and disadvantages of using macro and inline functions? 
4. What happens when recursion functions are declared inline? 
5. Scope of static variables? 
6. Difference between object oriented and object based languages? 
7. Multiple inheritance - objects contain howmany multiply inherited ancestor? 
8. What are the 4 different types of inheritance relationship? 
9. How would you find out the no of instance of a class? 
10. Is java a pure object oriented language? Why? 
11. Order of constructor and destructor call in case of multiple inheritance? 
12. Can u have inline virtual functions in a class? 
13. When you inherit a class using private keyword which members of base class are visible to the derived class? 
14. What is the output of printf("\nab\bcd\ref"); -> ef 
15. #define cat(x,y) x##y concatenates x to y. But cat(cat(1,2),3) does not expand but gives preprocessor warning. Why? 
16. Can you have constant volatile variable? Yes, you can have a volatile pointer? 
17. ++*ip increments what? it increments what ip points to 
18. Operations involving unsigned and signed — unsigned will be converted to signed 
19. a+++b -> (a++)+b 
20. malloc(sizeof(0)) will return — valid pointer 
21. main() {fork();fork();fork();printf("hello world"); } — will print 8 times. 
22. Array of pts to functions — void (*fptr[10])() 
23. Which way of writing infinite loops is more efficient than others? there are 3ways. 
24. # error — what it does? 
25. How is function itoa() written? 
26. Who to know wether systemuses big endian or little endian format and how to convert among them? 
27. What is interrupt latency? 
28. What is forward reference w.r.t. pointers in c? 
29. How is generic list manipulation function written which accepts elements of any kind? 
30. What is the difference between hard real-time and soft real-time OS? 
31. What is interrupt latency? How can you recuce it? 
32. What is the differnce between embedded systems and the system in which rtos is running? 
33. How can you define a structure with bit field members? 
34. What are the features different in pSOS and vxWorks? 
35. How do you write a function which takes 2 arguments - a byte and a field in the byte and returns the value of the field in that byte? 
36. What are the different storage classes in C? 
37. What are the different qualifiers in C? 
38. What are the different BSD and SVR4 communication mechanisms
  Persional Prospectives:
Q1. No they are always passed by reference. Think. Size of structure can be arbitrarily large.
Q2. Same as above.
Q5. Lifetime of process.
Q9. Declare a static variable, class variable, and increment(decrement) for every constructor (destructor) called.
Q11. Constructor. Base to current. Destructor. current to base. Both are done recursuively.
Q13. NONE
Q14. $> acd
ef
->ef is wrong, what happened to acd?
Q16. You can have a constant pointer to a volatile variable but not a constant volatile variable.
Q26. Write a union of int and 2 chars. Store as int retrieve as chars.
Q 27. Time taken between INT req and INT service.
Q33. Study Let us C, Yeshwant Kanetkar
Tech Interviews comment by Taran
Q. 13
Answer posted is wrong.
Public & protected members of base class will be visible to derived class, but not its objects.
Tech Interviews comment by Sumeet
Q1 - YES, a complete structure can be passed. Regarding the size, it is true that they can be very large and hence it is not a good practice to do so. In any case, one can do if one wants to.
Tech Interviews comment by Bhaskar
Q3. When using macro you can’t use data type while passing it. But in Inline function you can have data types so that it can be checked.
e.g MACRO : ADD(a,b)
INLINE : inline void Add(int a,int b );
Tech Interviews comment by VijayaKumar
Q1. Yes structure can be passed by value but the overhead of copying large values will be there. hence not usable. We should pass it by pointer.
Q2. Individual element can be passed by value of course. But not whole array.
Q5. It is alive lifetime of process, and its scope is limited to function in which it is defined.
file1.c
**********
static int i;
void main()
{
……..
}
file2.c
**********
extern int i; //error
If declared global then it is visible in that file only.
Q6. Object oriented language have Inheritance, polymorphism etc. But object based language only deal with object.
Q7. If
class D:public A,B,C
{}
then three ancestors
Q8. public ,private, protected, virtual
Q30. Hard RTS is having deadline defined and it is life critical ,should be reliable. late answer is wrong answer. in Soft RTS,process time should be predictable and reliable.
Tech Interviews comment by Pawan Kumar
Q36.What are the different storage classes in C?
A:Auto,Register,Static,Extern
Tech Interviews comment by MKS
Q5 Scope of static variables is only within the block where it is declared.
But the lifetime is till the process is running
Tech Interviews comment by Satish Parande
Questin???
How can we dynamically allocate memory without using malloc() or calloc() or realloc()?Explain in Breif.
Can any one help in finding this answer to this question……
Tech Interviews comment by Midhun V
In Java, we place even the Main() function inside a CLASS.
But it is not the case with C++.
So, i think this is one of the answers you can say, JAVA is Fully Obejct Oriented.
Tech Interviews comment by vsvraju
Q11 : Base-class constructors are called in the order in which inheritance is specified in the derived-class definition. The order in which the Base-class constructors are specified in the derived-class member initializer list does not effect the order of construction.
Tech Interviews comment by vsvraju
Q 12:
Yes we can have.
you are never guaranteed that a routine is inlined. It is only a suggestion to the compiler. If
the routine is either too complicated or a virtual function,then a static copy of the routine will be placed in the compiled module. Thus, a routine that was coded as inline may cause a performance degradation because it may consume much more space when it is not physically inlined.
With a virtual function, a copy of that routine will be created for every module that has at least one instantiation of that class.
Q 13:
NONE.
None of the Public, Protected and Private data members are visible.
Q 16:
YES. We can have a const volatile variable.
a volatile variable is a variable which can be changed by the extrenal events (like an interrput timers will increment the voltile varible. If you dont want you volatile varibale to be changed then declare them as “const volatile”.
Q 17.
I will explain this with an example:
int a = 10;
int *p = &a;
// suppose &a = 4010 (address of a)
Because both ++ and * are unary operators, the are calculated from right to left –> ++ (*p)
++*p will inrement 4010 by 4 (int size) -> ++*p will have the value 4014.
Q 21:
It will print 8 times. Because, each fork will print twice.
if u flush, (using “fflush”), then it will be printed only once. thats is you need to flush the iostreams.
Q 30:
In Hard RTOS the latency should be less the 20ns (nano sec)
in Soft RTOS the latency range 3ns - 20ns is also acceptable.
Tech Interviews comment by vsvraju
I THINK A BALOON CAN HAVE TO MUCH ELECTRICITY
Tech Interviews comment by SANDRA
Java is not a pure object oriented language as “everything” in java is not an object. It still has primitive data types such as int, char, etc. which are NOT objects. Ruby is an example of a pure object oriented language, where “everything” is an object, even int.
Tech Interviews comment by Karan
16. It is possible to have “const volatile” declaration. This indicates that the variable defined like this is not possible to change within that context. It can be changed by an external event. const declaraion just says that it will be readonly within the context, that area can be modified by an interrupt routine or another process.
18. Operations involving unsigned and signed - The signed data will be converted to unsigned - Refer arithemetic conversion rules in K&R
24. #error is used for displaying an error while compilation. for eg.
#ifdef ABC
printf(”ABC”);
#else
#ifdef DEF
printf(DEF);
#else
#error “Declaration not done”
#endif
30. Hard RTOS is system which will be having major problems if the specified time limit is crossed. For eg. missiles
Soft RTOS is systems which will not be having major problems if the specified limit is crossed. For eg. real time audio steaming.
But for both exceeding the time limit is concidered as error.
31. Interrupt latency is the time period between interrupt on the pin to the execution of 1st instuction in the interrupt routine. THis will depend upon the processor. If the execution time for the instruction is less (like in RISC) this time will also be less. If register storage is required the time will be less in the processors in which remapping of registers is present as this can be done in a single instruction.
32. RTOS systems are embedded systems with time criticality.
33.
Tech Interviews comment by deepak
What is interrupt latency?
It is the time interval between an interrupt has occured till the time it has been serviced.
Mathematically:
Int(lat)= rt+pt+dt
where rt=recognition time
pt=process time
dt=dispatch time
Tech Interviews comment by Ramesh K.B.
Q. Write a function to reverse contents in a single linked list without reversing the links?
Can anyone pls help me out?
Tech Interviews comment by Ramesh K.B.
Q.Can we have a constant volatile variable?
Soln: YES.We can have a const volatile variable.
Volatile variable is one which can be changed by user,ie programmer as well as by the external events.If we declare it as const volatile,then user cannot change but can be changed by the hardware.
Tech Interviews comment by Ramesh K.B.
20.
malloc(sizeof(0)) will return — valid pointer
yes. sizeof(0) –> int size and it is 4
25.
itoa(…)
itoa(pointer to storage buffer,int to convert, base(eg.binary,oct,hex,dec))
33.
typedef struct regset{
unsigned char onebit:1;
unsigned char twobit:2;
….
}regset;
Tech Interviews comment by Ramesh.V
i have an query regarding , interupts in Embedded systems
can we use the interrupt function call same as ordinary function,i.e. can we pass arguments and return values from an ISR routine.
Tech Interviews comment by Sushil Rana
what happens when
we put an infinite loop using for
for(;;)
what is the condition expression value by default.
Tech Interviews comment by Sushil Rana
Write a function to reverse contents in a single linked list without reversing the links?
Can anyone pls help me out?
Count number of nodes in the linear linked list. Let say cnt is the number of nodes and index = 0. You can swap content of index th node and cnt-index th node, each time increment index by 1. All the contents will be reversed.
Tech Interviews comment by Hetal
Scope of static variables?
scope of static variables is limited to the local function in which it is defined and to the functions calling the stattic variable.
Tech Interviews comment by Guneet
How virtual tables are created in case of abstract classes? Is it the same as in non-abstract classes? Virtual tables r created on stack or Heap?
Tech Interviews comment by Satish Parande
why only reference is passed as a parameter in Copy constructor? why not address?
Tech Interviews comment by Satish Parande
is it possible to call delete from the class member function ?
Tech Interviews comment by Mrinmay Biswas
1. q.3.
—- Inline is only a request that may be rejected also based on optimization policies,while macro is immediately replaced before compilation.
—- type checking is not possible in Macros, but in inline its possible.
Tech Interviews comment by Praveen 
非常有用的101道算法部分常见面试题
1. Given a rectangular (cuboidal for the puritans) cake with a rectangular piece removed (any size or orientation), how would you cut the remainder of the cake into two equal halves with one straight cut of a knife ? 
2. You're given an array containing both positive and negative integers and required to find the sub-array with the largest sum (O(N) a la KBL). Write a routine in C for the above. 
3. Given an array of size N in which every number is between 1 and N, determine if there are any duplicates in it. You are allowed to destroy the array if you like. [ I ended up giving about 4 or 5 different solutions for this, each supposedly better than the others ]. 
4. Write a routine to draw a circle (x ** 2 + y ** 2 = r ** 2) without making use of any floating point computations at all. [ This one had me stuck for quite some time and I first gave a solution that did have floating point computations ]. 
5. Given only putchar (no sprintf, itoa, etc.) write a routine putlong that prints out an unsigned long in decimal. [ I gave the obvious solution of taking % 10 and / 10, which gives us the decimal value in reverse order. This requires an array since we need to print it out in the correct order. The interviewer wasn't too pleased and asked me to give a solution which didn't need the array ]. 
6. Give a one-line C expression to test whether a number is a power of 2. [No loops allowed - it's a simple test.] 
7. Given an array of characters which form a sentence of words, give an efficient algorithm to reverse the order of the words (not characters) in it. 
8. How many points are there on the globe where by walking one mile south, one mile east and one mile north you reach the place where you started. 
9. Give a very good method to count the number of ones in a "n" (e.g. 32) bit number. 
ANS. Given below are simple solutions, find a solution that does it in log (n) steps. 

Iterative
function iterativecount (unsigned int n)
begin
int count=0;
while (n)
begin
count += n & 0x1 ;
n >>= 1;
end
return count;
end
Sparse Count
function sparsecount (unsigned int n)
begin
int count=0;
while (n)
begin
count++;
n &= (n-1);
end
return count ;
end
10. What are the different ways to implement a condition where the value of x can be either a 0 or a 1. Apparently the if then else solution has a jump when written out in assembly. if (x == 0) y=a else y=b There is a logical, arithmetic and a data structure solution to the above problem. 
11. Reverse a linked list. 
12. Insert in a sorted list 
13. In a X's and 0's game (i.e. TIC TAC TOE) if you write a program for this give a fast way to generate the moves by the computer. I mean this should be the fastest way possible. 
The answer is that you need to store all possible configurations of the board and the move that is associated with that. Then it boils down to just accessing the right element and getting the corresponding move for it. Do some analysis and do some more optimization in storage since otherwise it becomes infeasible to get the required storage in a DOS machine. 
14. I was given two lines of assembly code which found the absolute value of a number stored in two's complement form. I had to recognize what the code was doing. Pretty simple if you know some assembly and some fundaes on number representation. 
15. Give a fast way to multiply a number by 7. 
16. How would go about finding out where to find a book in a library. (You don't know how exactly the books are organized beforehand). 
17. Linked list manipulation. 
18. Tradeoff between time spent in testing a product and getting into the market first. 
19. What to test for given that there isn't enough time to test everything you want to. 
20. First some definitions for this problem: a) An ASCII character is one byte long and the most significant bit in the byte is always '0'. b) A Kanji character is two bytes long. The only characteristic of a Kanji character is that in its first byte the most significant bit is '1'. 
Now you are given an array of a characters (both ASCII and Kanji) and, an index into the array. The index points to the start of some character. Now you need to write a function to do a backspace (i.e. delete the character before the given index). 
21. Delete an element from a doubly linked list. 
22. Write a function to find the depth of a binary tree. 
23. Given two strings S1 and S2. Delete from S2 all those characters which occur in S1 also and finally create a clean S2 with the relevant characters deleted. 
24. Assuming that locks are the only reason due to which deadlocks can occur in a system. What would be a foolproof method of avoiding deadlocks in the system. 
25. Reverse a linked list. 
Ans: Possible answers - 
iterative loop 
curr->next = prev; 
prev = curr; 
curr = next; 
next = curr->next 
endloop 
recursive reverse(ptr) 
if (ptr->next == NULL) 
return ptr; 
temp = reverse(ptr->next); 
temp->next = ptr; 
return ptr; 
end 

26. Write a small lexical analyzer - interviewer gave tokens. expressions like "a*b" etc. 
27. Besides communication cost, what is the other source of inefficiency in RPC? (answer : context switches, excessive buffer copying). How can you optimize the communication? (ans : communicate through shared memory on same machine, bypassing the kernel _ A Univ. of Wash. thesis) 
28. Write a routine that prints out a 2-D array in spiral order! 
29. How is the readers-writers problem solved? - using semaphores/ada .. etc. 
30. Ways of optimizing symbol table storage in compilers. 
31. A walk-through through the symbol table functions, lookup() implementation etc. - The interviewer was on the Microsoft C team. 
32. A version of the "There are three persons X Y Z, one of which always lies".. etc.. 
33. There are 3 ants at 3 corners of a triangle, they randomly start moving towards another corner.. what is the probability that they don't collide. 
34. Write an efficient algorithm and C code to shuffle a pack of cards.. this one was a feedback process until we came up with one with no extra storage. 
35. The if (x == 0) y = 0 etc.. 
36. Some more bitwise optimization at assembly level 
37. Some general questions on Lex, Yacc etc. 
38. Given an array t[100] which contains numbers between 1..99. Return the duplicated value. Try both O(n) and O(n-square). 
39. Given an array of characters. How would you reverse it. ? How would you reverse it without using indexing in the array. 
40. Given a sequence of characters. How will you convert the lower case characters to upper case characters. ( Try using bit vector - solutions given in the C lib -typec.h) 
41. Fundamentals of RPC. 
42. Given a linked list which is sorted. How will u insert in sorted way. 
43. Given a linked list How will you reverse it. 
44. Give a good data structure for having n queues ( n not fixed) in a finite memory segment. You can have some data-structure separate for each queue. Try to use at least 90% of the memory space. 
45. Do a breadth first traversal of a tree. 
46. Write code for reversing a linked list. 
47. Write, efficient code for extracting unique elements from a sorted list of array. e.g. (1, 1, 3, 3, 3, 5, 5, 5, 9, 9, 9, 9) -> (1, 3, 5, 9). 
48. Given an array of integers, find the contiguous sub-array with the largest sum. 
ANS. Can be done in O(n) time and O(1) extra space. Scan array from 1 to n. Remember the best sub-array seen so far and the best sub-array ending in i. 
49. Given an array of length N containing integers between 1 and N, determine if it contains any duplicates. 
ANS. [Is there an O(n) time solution that uses only O(1) extra space and does not destroy the original array?] 
50. Sort an array of size n containing integers between 1 and K, given a temporary scratch integer array of size K. 
ANS. Compute cumulative counts of integers in the auxiliary array. Now scan the original array, rotating cycles! [Can someone word this more nicely?] 
* 51. An array of size k contains integers between 1 and n. You are given an additional scratch array of size n. Compress the original array by removing duplicates in it. What if k << n? 
ANS. Can be done in O(k) time i.e. without initializing the auxiliary array! 
52. An array of integers. The sum of the array is known not to overflow an integer. Compute the sum. What if we know that integers are in 2's complement form? 
ANS. If numbers are in 2's complement, an ordinary looking loop like for(i=total=0;i< n;total+=array[i++]); will do. No need to check for overflows! 
53. An array of characters. Reverse the order of words in it. 
ANS. Write a routine to reverse a character array. Now call it for the given array and for each word in it. 
* 54. An array of integers of size n. Generate a random permutation of the array, given a function rand_n() that returns an integer between 1 and n, both inclusive, with equal probability. What is the expected time of your algorithm? 
ANS. "Expected time" should ring a bell. To compute a random permutation, use the standard algorithm of scanning array from n downto 1, swapping i-th element with a uniformly random element <= i-th. To compute a uniformly random integer between 1 and k (k < n), call rand_n() repeatedly until it returns a value in the desired range. 
55. An array of pointers to (very long) strings. Find pointers to the (lexicographically) smallest and largest strings. 
ANS. Scan array in pairs. Remember largest-so-far and smallest-so-far. Compare the larger of the two strings in the current pair with largest-so-far to update it. And the smaller of the current pair with the smallest-so-far to update it. For a total of <= 3n/2 strcmp() calls. That's also the lower bound. 
56. Write a program to remove duplicates from a sorted array. 
ANS. int remove_duplicates(int * p, int size) 
{ 
int current, insert = 1; 
for (current=1; current < size; current++) 
if (p[current] != p[insert-1]) 
{ 
p[insert] = p[current]; 
current++; 
insert++; 
} else 
current++; 
return insert; 
} 

57. C++ ( what is virtual function ? what happens if an error occurs in constructor or destructor. Discussion on error handling, templates, unique features of C++. What is different in C++, ( compare with unix). 
58. Given a list of numbers ( fixed list) Now given any other list, how can you efficiently find out if there is any element in the second list that is an element of the first list (fixed list). 
59. Given 3 lines of assembly code : find it is doing. IT was to find absolute value. 
60. If you are on a boat and you throw out a suitcase, Will the level of water increase. 
61. Print an integer using only putchar. Try doing it without using extra storage. 
62. Write C code for (a) deleting an element from a linked list (b) traversing a linked list 
63. What are various problems unique to distributed databases 
64. Declare a void pointer ANS. void *ptr; 
65. Make the pointer aligned to a 4 byte boundary in a efficient manner ANS. Assign the pointer to a long number and the number with 11...1100 add 4 to the number 
66. What is a far pointer (in DOS) 
67. What is a balanced tree 
68. Given a linked list with the following property node2 is left child of node1, if node2 < node1 else, it is the right child. 
O P
|
|
O A
|
|
O B
|
|
O C
How do you convert the above linked list to the form without disturbing the property. Write C code for that. 
   O P
|
|
O B
/ \
/   \
/     \
O ?     O ?
determine where do A and C go 
69. Describe the file system layout in the UNIX OS 
ANS. describe boot block, super block, inodes and data layout 
70. In UNIX, are the files allocated contiguous blocks of data 
ANS. no, they might be fragmented 
How is the fragmented data kept track of 
ANS. Describe the direct blocks and indirect blocks in UNIX file system 
71. Write an efficient C code for 'tr' program. 'tr' has two command line arguments. They both are strings of same length. tr reads an input file, replaces each character in the first string with the corresponding character in the second string. eg. 'tr abc xyz' replaces all 'a's by 'x's, 'b's by 'y's and so on. ANS. 
a) have an array of length 26. 
put 'x' in array element corr to 'a' 
put 'y' in array element corr to 'b' 
put 'z' in array element corr to 'c' 
put 'd' in array element corr to 'd' 
put 'e' in array element corr to 'e' 
and so on. 
the code 
while (!eof) 
{ 
c = getc(); 
putc(array[c - 'a']); 
} 
72. what is disk interleaving 
73. why is disk interleaving adopted 
74. given a new disk, how do you determine which interleaving is the best a) give 1000 read operations with each kind of interleaving determine the best interleaving from the statistics 
75. draw the graph with performance on one axis and 'n' on another, where 'n' in the 'n' in n-way disk interleaving. (a tricky question, should be answered carefully) 
76. I was a c++ code and was asked to find out the bug in that. The bug was that he declared an object locally in a function and tried to return the pointer to that object. Since the object is local to the function, it no more exists after returning from the function. The pointer, therefore, is invalid outside. 
77. A real life problem - A square picture is cut into 16 squares and they are shuffled. Write a program to rearrange the 16 squares to get the original big square. 
78. 
int *a; 
char *c; 
*(a) = 20; 
*c = *a; 
printf("%c",*c); 
what is the output? 
79. Write a program to find whether a given m/c is big-endian or little-endian! 
80. What is a volatile variable? 
81. What is the scope of a static function in C ? 
82. What is the difference between "malloc" and "calloc"? 
83. struct n { int data; struct n* next}node; 
node *c,*t; 
c->data = 10; 
t->next = null; 
*c = *t; 
what is the effect of the last statement? 
84. If you're familiar with the ? operator x ? y : z 
you want to implement that in a function: int cond(int x, int y, int z); using only ~, !, ^, &, +, |, <<, >> no if statements, or loops or anything else, just those operators, and the function should correctly return y or z based on the value of x. You may use constants, but only 8 bit constants. You can cast all you want. You're not supposed to use extra variables, but in the end, it won't really matter, using vars just makes things cleaner. You should be able to reduce your solution to a single line in the end though that requires no extra vars. 
85. You have an abstract computer, so just forget everything you know about computers, this one only does what I'm about to tell you it does. You can use as many variables as you need, there are no negative numbers, all numbers are integers. You do not know the size of the integers, they could be infinitely large, so you can't count on truncating at any point. There are NO comparisons allowed, no if statements or anything like that. There are only four operations you can do on a variable. 
1) You can set a variable to 0. 
2) You can set a variable = another variable. 
3) You can increment a variable (only by 1), and it's a post increment. 
4) You can loop. So, if you were to say loop(v1) and v1 = 10, your loop would execute 10 times, but the value in v1 wouldn't change so the first line in the loop can change value of v1 without changing the number of times you loop. 
You need to do 3 things. 
1) Write a function that decrements by 1. 
2) Write a function that subtracts one variable from another. 
3) Write a function that divides one variable by another. 
4) See if you can implement all 3 using at most 4 variables. Meaning, you're not making function calls now, you're making macros. And at most you can have 4 variables. The restriction really only applies to divide, the other 2 are easy to do with 4 vars or less. Division on the other hand is dependent on the other 2 functions, so, if subtract requires 3 variables, then divide only has 1 variable left unchanged after a call to subtract. Basically, just make your function calls to decrement and subtract so you pass your vars in by reference, and you can't declare any new variables in a function, what you pass in is all it gets. 
* 86. Under what circumstances can one delete an element from a singly linked list in constant time? 
ANS. If the list is circular and there are no references to the nodes in the list from anywhere else! Just copy the contents of the next node and delete the next node. If the list is not circular, we can delete any but the last node using this idea. In that case, mark the last node as dummy! 
* 87. Given a singly linked list, determine whether it contains a loop or not. 
ANS. (a) Start reversing the list. If you reach the head, gotcha! there is a loop! 
But this changes the list. So, reverse the list again. 
(b) Maintain two pointers, initially pointing to the head. Advance one of them one node at a time. And the other one, two nodes at a time. If the latter overtakes the former at any time, there is a loop! 
          p1 = p2 = head;
do {
p1 = p1->next;
p2 = p2->next->next;
} while (p1 != p2);
88. Given a singly linked list, print out its contents in reverse order. Can you do it without using any extra space? 
ANS. Start reversing the list. Do this again, printing the contents. 
89. Given a binary tree with nodes, print out the values in pre-order/in-order/post-order without using any extra space. 
90. Reverse a singly linked list recursively. The function prototype is node * reverse (node *) ; 
ANS. 
    node * reverse (node * n)
{
node * m ;
if (! (n && n -> next))
return n ;
m = reverse (n -> next) ;
n -> next -> next = n ;
n -> next = NULL ;
return m ;
}
91. Given a singly linked list, find the middle of the list. 
HINT. Use the single and double pointer jumping. Maintain two pointers, initially pointing to the head. Advance one of them one node at a time. And the other one, two nodes at a time. When the double reaches the end, the single is in the middle. This is not asymptotically faster but seems to take less steps than going through the list twice. 
92. Reverse the bits of an unsigned integer. 
ANS. 
    #define reverse(x)                              \
(x=x>>16|(0x0000ffff&x)<<16,            \
x=(0xff00ff00&x)>>8|(0x00ff00ff&x)<<8, \
x=(0xf0f0f0f0&x)>>4|(0x0f0f0f0f&x)<<4, \
x=(0xcccccccc&x)>>2|(0x33333333&x)<<2, \
x=(0xaaaaaaaa&x)>>1|(0x55555555&x)<<1)
* 93. Compute the number of ones in an unsigned integer. 
ANS. 
   #define count_ones(x)                        \
(x=(0xaaaaaaaa&x)>>1+(0x55555555&x), \
x=(0xcccccccc&x)>>2+(0x33333333&x), \
x=(0xf0f0f0f0&x)>>4+(0x0f0f0f0f&x), \
x=(0xff00ff00&x)>>8+(0x00ff00ff&x), \
x=x>>16+(0x0000ffff&x))
94. Compute the discrete log of an unsigned integer. 
ANS. 
#define discrete_log(h) \
(h=(h>>1)|(h>>2), \
h|=(h>>2), \
h|=(h>>4), \
h|=(h>>8), \
h|=(h>>16), \
h=(0xaaaaaaaa&h)>>1+(0x55555555&h), \
h=(0xcccccccc&h)>>2+(0x33333333&h), \
h=(0xf0f0f0f0&h)>>4+(0x0f0f0f0f&h), \
h=(0xff00ff00&h)>>8+(0x00ff00ff&h), \
h=(h>>16)+(0x0000ffff&h))
If I understand it right, log2(2) =1, log2(3)=1, log2(4)=2..... But this macro does not work out log2(0) which does not exist! How do you think it should be handled? 
* 95. How do we test most simply if an unsigned integer is a power of two? 
ANS. #define power_of_two(x) \ ((x)&&(~(x&(x-1)))) 
96. Set the highest significant bit of an unsigned integer to zero. 
ANS. (from Denis Zabavchik) Set the highest significant bit of an unsigned integer to zero 
#define zero_most_significant(h) \ 
(h&=(h>>1)|(h>>2), \ 
h|=(h>>2), \ 
h|=(h>>4), \ 
h|=(h>>8), \ 
h|=(h>>16)) 
97. Let f(k) = y where k is the y-th number in the increasing sequence of non-negative integers with the same number of ones in its binary representation as y, e.g. f(0) = 1, f(1) = 1, f(2) = 2, f(3) = 1, f(4) = 3, f(5) = 2, f(6) = 3 and so on. Given k >= 0, compute f(k). 
98. A character set has 1 and 2 byte characters. One byte characters have 0 as the first bit. You just keep accumulating the characters in a buffer. Suppose at some point the user types a backspace, how can you remove the character efficiently. (Note: You cant store the last character typed because the user can type in arbitrarily many backspaces) 
99. What is the simples way to check if the sum of two unsigned integers has resulted in an overflow. 
100. How do you represent an n-ary tree? Write a program to print the nodes of such a tree in breadth first order. 
101. Write the 'tr' program of UNIX. Invoked as 
tr -str1 -str2. It reads stdin and prints it out to stdout, replacing every occurance of str1 with str2. 
e.g. tr -abc -xyz 
to be and not to be <- input 
to ye xnd not to ye <- output

8. 描述实时系统的基本特性
在特定时间内完成特定的任务，实时性与可靠性

有一个16位的整数，每4位为一个数，写函数求他们的和。
解释：
整数1101010110110111
和 1101+0101+1011+0111
感觉应该不难，当时对题理解的不是很清楚，所以写了一个函数，也不知道对不对。
疑问：
既然是16位的整数，1101010110110111是2进制的，那么函数参数怎么定义呢，请大虾指教。
答案：用十进制做参数，计算时按二进制考虑。
/* n就是16位的数，函数返回它的四个部分之和 */
char SumOfQuaters(unsigned short n)
{
char c = 0;
int i = 4;
do
{
c += n & 15;
n = n >> 4;
} while (--i);

return c;
}



有1,2,....一直到n的无序数组,求排序算法,并且要求时间复杂度为O(n),空间复杂度O(1),使用交换,而且一次只能交换两个数.

2. 写一函数，实现删除字符串str1中含有的字符串str2.
第二个就是利用一个KMP匹配算法找到str2然后删除（用链表实现的话，便捷于数组）


/*雅虎笔试题(字符串操作) 
给定字符串A和B,输出A和B中的最大公共子串。
比如A="aocdfe" B="pmcdfa" 则输出"cdf"
*/
//Author: azhen
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

char *commanstring(char shortstring[], char longstring[])
{
int i, j;

char *substring=malloc(256);

if(strstr(longstring, shortstring)!=NULL) //如果……，那么返回shortstring
return shortstring; 

for(i=strlen(shortstring)-1;i>0; i--) //否则，开始循环计算
{
for(j=0; j<=strlen(shortstring)-i; j++){
memcpy(substring, &shortstring[j], i);
substring='\0';
if(strstr(longstring, substring)!=NULL)
return substring;
}
}
return NULL;
}


main()
{
char *str1=malloc(256);
char *str2=malloc(256);
char *comman=NULL;

gets(str1);
gets(str2);

if(strlen(str1)>strlen(str2)) //将短的字符串放前面
comman=commanstring(str2, str1);
else
comman=commanstring(str1, str2);

printf("the longest comman string is: %s\n", comman);
}


11.写一个函数比较两个字符串str1和str2的大小，若相等返回0，若str1大于
str2返回1，若str1小于str2返回－1
int strcmp ( const char * src,const char * dst)
{
int ret = 0 ;
while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) && *dst)
{
++src;
++dst;
}
if ( ret < 0 )
ret = -1 ;
else if ( ret > 0 )
ret = 1 ;
return( ret );
}

3,求1000！的未尾有几个0（用素数相乘的方法来做，如72=2*2*2*3*3）;
求出1->1000里,能被5整除的数的个数n1,能被25整除的数的个数n2,能被125整除的数的个数n3,
能被625整除的数的个数n4.
1000!末尾的零的个数=n1+n2+n3+n4;
#include<stdio.h>
#define NUM 1000

int find5(int num){
int ret=0;
while(num%5==0){
num/=5;
ret++;
}
return ret;
}
int main(){
int result=0;
int i;
for(i=5;i<=NUM;i+=5)
{
result+=find5(i);
}
printf(" the total zero number is %d\n",result);
return 0;
}




1. 有双向循环链表结点定义为： 
struct node 
{ int data; 
struct node *front,*next; 
}; 
有两个双向循环链表A，B，知道其头指针为：pHeadA,pHeadB，请写一函数将两链表中data值相同的结点删除 
BOOL DeteleNode(Node *pHeader, DataType Value)
{
if (pHeader == NULL) return;

BOOL bRet = FALSE;
Node *pNode = pHead;
while (pNode != NULL)
{
if (pNode->data == Value)
{
if (pNode->front == NULL)
{
pHeader = pNode->next;
pHeader->front = NULL;
}
else
{
if (pNode->next != NULL)
{
pNode->next->front = pNode->front;
}
pNode->front->next = pNode->next;
}

Node *pNextNode = pNode->next;
delete pNode;
pNode = pNextNode;

bRet = TRUE; 
//不要break或return, 删除所有
}
else
{
pNode = pNode->next;
}
}

return bRet;
}

void DE(Node *pHeadA, Node *pHeadB)
{
if (pHeadA == NULL || pHeadB == NULL)
{
return;
}

Node *pNode = pHeadA;
while (pNode != NULL)
{
if (DeteleNode(pHeadB, pNode->data))
{
if (pNode->front == NULL)
{
pHeadA = pNode->next;
pHeadA->front = NULL;
}
else
{
pNode->front->next = pNode->next;
if (pNode->next != NULL)
{
pNode->next->front = pNode->front;
}
}
Node *pNextNode = pNode->next;
delete pNode;
pNode = pNextNode;
}
else
{
pNode = pNode->next;
}
}
}
3. 输入N, 打印 N*N 矩阵
比如 N = 3，打印：

1 2 3
8 9 4
7 6 5

N = 4，打印：

1 2 3 4
12 13 14 5
11 16 15 6
10 9 8 7
解答：
1 #define N 15
int s[N][N];
void main()
{
int k = 0, i = 0, j = 0;
int a = 1; 
for( ; k < (N+1)/2; k++ )
{
while( j < N-k ) s[j++] = a++; i++; j--;
while( i < N-k ) s[i++][j] = a++; i--; j--;
while( j > k-1 ) s[j--] = a++; i--; j++;
while( i > k ) s[i--][j] = a++; i++; j++; 
}
for( i = 0; i < N; i++ )
{
for( j = 0; j < N; j++ )
cout << s[j] << '\t';
cout << endl;
}
}
2 define MAX_N 100
int matrix[MAX_N][MAX_N];

/*
*（x,y）：第一个元素的坐标
* start：第一个元素的值
* n：矩阵的大小
*/
void SetMatrix(int x, int y, int start, int n) {
int i, j;

if (n <= 0) //递归结束条件
return;
if (n == 1) { //矩阵大小为1时
matrix[x][y] = start;
return;
}
for (i = x; i < x + n-1; i++) //矩阵上部
matrix[y] = start++;

for (j = y; j < y + n-1; j++) //右部
matrix[j][x+n-1] = start++;

for (i = x+n-1; i > x; i--) //底部
matrix[y+n-1] = start++;

for (j = y+n-1; j > y; j--) //左部
matrix[j][x] = start++;

SetMatrix(x+1, y+1, start, n-2); //递归
}

void main() {
int i, j;
int n;

scanf("%d", &n);
SetMatrix(0, 0, 1, n);

//打印螺旋矩阵
for(i = 0; i < n; i++) {
for (j = 0; j < n; j++)
printf("%4d", matrix[j]);
printf("\n");
}
}


斐波拉契数列递归实现的方法如下：
int Funct( int n )
{
if(n==0) return 1;
if(n==1) return 1;
retrurn Funct(n-1) + Funct(n-2);
}
请问，如何不使用递归，来实现上述函数？
请教各位高手！
解答：int Funct( int n ) // n 为非负整数
{
int a=0;
int b=1;
int c;
if(n==0) c=1;
else if(n==1) c=1;
else for(int i=2;i<=n;i++) //应该n从2开始算起
{
c=a+b;
a=b;
b=c;
}
return c;
}
解答：
现在大多数系统都是将低字位放在前面，而结构体中位域的申明一般是先声明高位。
100 的二进制是 001 100 100
低位在前 高位在后 
001----s3
100----s2
100----s1
所以结果应该是 1
如果先申明的在低位则：
001----s1
100----s2
100----s3
结果是 4
1、原题跟little-endian，big-endian没有关系
2、原题跟位域的存储空间分配有关，到底是从低字节分配还是从高字节分配，从Dev C++和VC7.1上看，都是从低字节开始分配，并且连续分配，中间不空，不像谭的书那样会留空位
3、原题跟编译器有关，编译器在未用堆栈空间的默认值分配上有所不同，Dev C++未用空间分配为
01110111b，VC7.1下为11001100b,所以在Dev C++下的结果为5，在VC7.1下为1。

注：PC一般采用little-endian，即高高低低，但在网络传输上，一般采用big-endian，即高低低高，华为是做网络的，所以可能考虑big-endian模式，这样输出结果可能为4




选择题

1:设float a=2, b=4, c=3；，以下C语言表达式与代数式 (a+b)+c计算结果不一致的是
A.(a+b)*c/2
B.(1/2)*(a+b)*c
C.(a+b)*c*1/2
D.c/2*(a+b)
参考答案：B，因为a,b,c三个变量都是浮点数，所以在B答案中其结果是0，因为在计算1/2是就是0，如果改成1/2.0就正确了。

2:为了向二进制文件尾部增加数据，打开文件的方式应采用
A.″ab″
B.″rb+″
C.″wb″
D.″wb+″
参考答案：D

3:下述程序执行后的输出结果是
＃include
main()
{
int x='f';
printf("%c\n",'a'+(x-'a'+1));
}
A.g
B.h
C.i
D.j
参考答案：A

4:C语言中，下列运算符优先级最高的是
A.！
B.％
C.>>
D.＝ ＝
参考答案：A

5:数组定义为“ int a [ 4 ] ; ”，表达式 ( ) 是错误的。
A.*a
B.a [ 0 ]
C.a
D.a++
参考答案：D

6:执行语句“ k=7>>1; ”后，变量 k 的当前值是
A.15
B.31
C.3
D.1
参考答案：C

7:定义函数时，缺省函数的类型声明，则函数类型取缺省类型
A.void
B.char
C.float
D.int
参考答案：D

8:若main（）函数带参数，参数个数最多是
A.0
B.1
C.2
D.3
参考答案：C 只知道有定义形式main(int argc,char* argv[])）

9:若有宏定义：#define MOD(x，y) x％y
则执行以下语句后的输出结果是
int a=13，b=94；
printf(″％d\n″，MOD(b，a+4))；
A.5
B.7
C.9
D.11
参考答案：B

10:下列各个错误中，哪一个不属于编译错误
A.改变 x 原值 3 为 5 ，写作“ x==5 ;”
B.花括号不配对
C.复合语句中的最后一条语句后未加分号
D.变量有引用、无定义
参考答案：A

11:下列程序段运行后， x 的值是( )

a=1;b=2;x=0;
if(!( -- a))x -- ;
if(!b)x=7;else ++x;
A.0
B.3
C.6
D.7
参考答案：A

12:设
#define N 3
#define Y(n) ((N+1)*n)
则表达式2*(N+Y(5+1))的值是
A.42
B.48
C.54
D.出错
参考答案：B Y(5+1) 传递过去的应该是6，而不是简单的把5+1给替换掉

13:若定义了char ch[]={″abc\0def″｝，*p=ch;则执行printf(″%c″,*p+4);语句的输出结果是
A.def
B.d
C.e
D.0
参考答案：C

14:下列转义字符中错误的是
A.′\000′
B.′\14′
C.′\x111′
D.′\2′
参考答案：C error C2022: '273' : too big for character

15:算术运算符，赋值运算符和关系运算符的运算优先级按从高到低依次为
A.算术运算、赋值运算、关系运算
B.算术运算、关系运算、赋值运算
C.关系运算、赋值运算、算术运算
D.关系运算、算术运算、赋值运算
参考答案：B

16:设#define N 3
#define Y(n) ((N+1)*n)
则表达式2*(N+Y(5+1))的值是
A.42
B.48
C.54
D.出错
参考答案：B

17:表达式 strcmp( “ 3.14 ”，“ 3.278 ” ) 的值是一个
A.非零整数
B.浮点数
C.0
D.字符
参考答案： A

18:设struct
{ short a;
char b;
float c;
}cs;
则sizeof(cs)的值是
A.4
B.5
C.6
D.7
参考答案： D 字节对齐的话应该是8

19:若变量已正确定义，表达式( j=3 ， j++ )的值是
A.3
B.4
C.5
D.0
参考答案：A

20:C 语言中运算对象必须是整型的运算符是
A.%
B./
C.!
D.**
参考答案：A
简答题

21:打印一个N*N的方阵，N为每边字符的个数（ 3〈N〈20 ），要求最外层为“X”，第二层为“Y”，从第三层起每层依次打印数字0，1，2，3，...
例子：当N =5，打印出下面的图形：
X X X X X
X Y Y Y X
X Y 0 Y X
X Y Y Y X
X X X X X

22:谈谈COM的线程模型。然后讨论进程内/外组件的差别。

23:多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?
参考答案：
虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.
而对象的隐藏成员--虚拟函数表指针是在运行期--也就是构造函数被调用时进行初始化的,这是实现多态的关键.

24:#include

　　void main()

　　{ int c;

　　while ((c=getchar())!= ′\ n ′ )

　　switch(c - ′ 2 ′ )

　　{ case 0:

　　case 1:putchar(c+4);break;

　　case 2:putchar(c+4);break;

　　case 3:putchar(c+3);break;

　　default:putchar(c+2);break;

　　}

　　printf( ″\ n ″ );

　　}

　　运行时输入： 2473 ，输出结果：
参考答案：6897 VC++6.0测试过
25:用两个栈实现一个队列的功能？
参考答案：
设2个栈为A,B, 一开始均为空.入队:
将新元素push入栈A;出队:
(1)判断栈B是否为空；
(2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；
(3)将栈B的栈顶元素pop出；这样实现的队列入队和出队的平摊复杂度都还是O(1),
26:写一语句实现x是否为2的若干次幂的判断。
参考答案：!(X)&(X-1)

27:解二次方程:a*x*x+b*x+c
int Quadratic( double a,double b,double c,double& x1,double& x2);
返回值：解的个数

28:如何判别一个数是unsigned。
参考答案;
#define issignal(x) ((x>=0 && ~x>=0) ? 1:0) //为1是无符号 为0有符号
29:执行下述程序的输出结果是  ABCDEFCDEFEF  。
#include
char b[]="ABCDEF";
main()
{
char *bp;
for (bp=b;*bp;bp+=2)
printf("%s",bp);
printf("\n");
}

30:已知一个数组table，用一个宏定义，求出数据的元素个数。
参考答案：#define NTBL
#define NTBL (sizeof(table)/sizeof(table[0]))

1.via的考题一道
这个程序设计的思想是这样的：
为了测试32位机上的浮点数的运算精度，作如下考虑：
当1.5 == 1时(二进制1.1==1)精度为1个小数位
当1.25 == 1时（二进制1.01==1)精度为2个小数位
继续判断测试，直到两者相等，从而得到精度。
所以程序代码如下：
int main()
{ int nCount;
   float number1,number2;
   nCount = 0;
   number1 = 1.0;
   number2 = 1.0
   while( number1 + number2 != number1 ){
          nCount++;
          number2 /= 2.0;
    }
    printf( "%d bits accruacy.\n", nCount );
}
问题是，结果为多少？
经测试得64或者53或者24(稍加改动)。。。
得53和24已基本得出答案，主要是ieee 754标准中规定单双精度数字的底数 指数 符号位所置。。。64的目前还没有得出结论。。。

2.改错题
void mymul(double *p)
{
         *p *= 2.0;
}
int main(int argc, char *argv[])
{
         float f   = 6.0;
         mymul((double *) &f);
         printf("now f = %f\n", f);
         return 0;
}
直接运行，结果为6.00000
这个题目很简单，可以有很多种改法，如：a.把float f=6.0;改为double f=6.0;睛面的mymul句不要强制类型转化 b.把所有的数都当成float型来处理 等等
但往细的方面想，float型默认4字节，double型默认8字节，虽然在vc6下能勉强运行（运行时报出调试窗口），但单步跟踪发现在mymul（）中并没有得到正确执行，而是：Access Violation,这个错误常常在计算机用户运行的程序试图存取未被指定使用的存储区时遇到中，可见mymyl()这个函数并没有得到正确的执行。。。同样，用gcc来直接编译上述程序，虽然没有报错，但结果仍然为6.00000,可能gcc也是在执行mymul()时没有正确执行(不过我没拿gdb来跟踪看)
以下内容是补充，主要是一些基础的知识

3.二维数组空间的动态申请
   a.简单的，已经有一维，如 
char (*c)[5];
c=new char[n][5];//n为已定义的行数
b.二维的
int **p;
p=new int*[m_row];//创建行指针
for(int i=0;i<m_row;i++)//为每一行分配空间
    p[i]=new int[m_cols];
写到某一个函数中：
void getmemory(int ** &p,int m_row,int m_cols)
{
     p=new int*[m_row];//创建行指针
for(int i=0;i<m_row;i++)//为每一行分配空间
    p[i]=new int[m_cols];
}
释放空间:
void deletememory(int **&p,int m_row)
{
   //释放每一行所分配的空间
    for(int i=0;i<m_row;i++)
       delete [] x[i];
//释放行指针
    delete [] x;
     x=0;



via嵌入式笔试两题
     -|yingwang294 发表于 2006-10-31 10:40:00 

以下是威盛嵌入式笔试的最后两道小题
题一：
原题如下：改程序，并确定运行结果
＃i nclude <stdio.h>
＃i nclude <string.h>
＃i nclude <malloc.h>
char *getstring(void)
{
        char p[]="hello everyone";
        return p;
}
char *getmemory(void)
{
        return (char *)malloc(10);
}
int main(int argc, char* argv[])
{
        char *p=getmemory();
        strcpy(p,"helloworld");
        printf("%s",p);
        printf("%s",getstring());
        return 0;
}
这个主要是char p[]前少一个static...
题二：
读程序，写出运行结果
＃i nclude <stdio.h>
＃i nclude <string.h>
＃i nclude <malloc.h>
＃i nclude <assert.h>
typedef struct
{
        int value;
        char type;
}head_t;
typedef struct
{
        head_t head;
        int para;
}message_t;
void main(void)
{
        message_t *message=NULL;
        head_t *head=NULL;
        message=(message_t *)malloc(sizeof(message_t));
        assert(message);
        memset(message,0,sizeof(message_t));
        message->para=100;
        message->head.type='a';
        head=(head_t *)message;
        head->value++;
        head->type++;

printf("message->head.value="/%d,message->head.type=%c,message->para=%d\n",me
ssage->head.value,message->head.type,message->para);
       " free(message);
        return;
}



  
类型 
序号 
问题 
测试要点 
基本情况 
1 
请用最简洁的语言描述您从前的工作经历和工作成果。 
测试应聘者是否能够用几句话概要地介绍其主要的工作信息和重点业绩，而不是以流水帐的形式重复履历表有已经注明的内容。在介绍工作成果时，注意应聘者能否正确表述其在原单位所发挥的作用。尽管有关基本能力的提问大多可以通过简历或应聘表格反映出来，但通过回答可以考察应聘者的语言表达能力、仪表神态、目光注视程度、肢体语言等方面。 

2 
您为什么重新求职？ 
测试应聘者的求职动机是否合理。重新求职的原因可能因为应聘者原单位的问题，但通过回答可以考察应聘者是否既能客观、委婉地说明原由。 

3 
什么样的单位是您求职的第一选择？ 
测试在应聘者心目中是否对自己和单位的定位清晰明确，而不是盲目应聘。 
专业背景 
4 
您认为此工作岗位应当具备哪些素质？ 
测试应聘者认为的岗位素质与招聘需要的岗位素质的吻合程度。 

5 
请谈谈你对您所从事专业的理解，在专业方面有哪些重要的成果？ 
考察应聘者的专业功底。 

6 
您认为自己应聘的职位在公司里所应当承担的主要职责是什么？您个人有哪些方面的优势能够胜任这一职位？还存在哪些缺陷和不足，准备如何来弥补？ 
考察应聘者个人对工作的理解以及是如何考虑个人与工作之间的匹配性的。 

7 
您认为自己在这个岗位上的竞争优势是什么？ 
通过回答找到此应聘者与其他应聘人员的优势差异。 
工作模式 
8 
您平时习惯于单独工作还是团队工作？ 
工作习惯与应聘者应征的工作岗位有关。通常需要经常与他人合作或接触的岗位 ( 如秘书、公关等 ) 建议团队工作习惯，而技术、设计类型的岗位则相对独立性较强。 

9 
在工作中您喜欢用哪种形式沟通？您认为什么是最有效的沟通形式？ 
通常面对面直接沟通的方式最为有效，与书面沟通相比，面对面沟通发生误解的可能性较小，除非两一见面就剑拔弩张。 

10 
在过去的工作中您学习到了什么？ 
考察应聘者是否能够从专业成就、人际关系、组织、产品、服务等多个角度来回答问题。当谈及其从前的经历时，可测试应聘者是是否是个忠诚的、懂得尊重别人的员工。 

11 
您如何使自己了解业务上的最新动态？ 
无论什么领域，都会有大量专业资料刊登在各类刊物上。对自己的专业研究得越深入，就越需要获得新的信息来源。 

12 
请介绍您原来单位的几个主要竞争对手的情况。 
通过回答测试应聘者的市场竞争意识。对本单位津津乐道，但对市场状况及竞争行情不甚了解的人员不是一名全面的工作人员。 

13 
您在工作中通常怎样分配时间？ 
测试应聘者对时间的分配和使用习惯。 

14 
您未来三年内的目标是什么？如何实现？ 
考察应聘者是否对自己能够提出明确的目标，并有切实的行动计划；而不是“继续做好现在的工作”、“加强学习”等模糊的概念。 

15 
您对我们公司以及您所应聘的岗位有什么了解？ 
一名态度认真的求职者往往会在面试之前通过多种渠道去了解应聘单位。如果在应聘的开始已经向应聘者进行介绍，可测试应聘者倾听的关注程度。如果事先没有向应聘者进行有关本单位的情况介绍，应聘者可以会借此机会提出了解单位的情况。主试人员在介绍完毕之后，仍可通过类似问题考察应聘者。 
价值取向 
16 
您对原来的单位和上司的看法如何？ 
大骂原来单位及同事的应聘者绝非一名有修养的员工。考察应聘者是否能够客观委婉地表达其看法，并结合自己放弃原来职位的意图。 

17 
业余时间您通常用来做什么？ 
考察应聘者是否能够平衡工作与生活之间的关系。 

18 
描述您上一次在工作中挨批评的情景。 
测试应聘者在既属于个人隐私、又有很强的专业性的领域里的沟通能力如何，以及应聘者是否经得起批评，并了解他以前的工作环境和沟通状况。 

19 
您是否愿意接受心理测试？ 
考察应聘者是否能够坦诚相告。 

20 
您觉得怎样才算是成功？ 
考察应聘者是否能够把受到赏识与做出有意义的贡献联系在一起，而且可以正确地平衡事业与家庭之间的关系。 

21 
您认为做人的基本原则是什么？ 
考察应聘者个人的行为准则和道德规范意识。 
资质特性 
22 
您如何描述自己的个性？ 
测试应聘者的个性与招聘单位的文化、风气、行为准则、岗位特点等之间的匹配程度。例如：外向性格在公关、市场等工作岗位更具优势，内向性格在科研、档案等工作岗位更具优势。 

23 
请列举您的三大优点和三大缺点。 
应聘者是否能够坦诚相告自身的特性，并考虑其特质是否影响到此岗位的工作及团队工作。 

24 
您原来的同事通常是如何评价您的？ 
考察应聘者是否了解自己在他人心中的看法，并正视面临的问题。 
薪资待遇 
25 
是否方便告诉我您目前的待遇是多少？ 
  

26 
您所期望的待遇是多少？ 
如果应聘者要求与更高层的主管商谈待遇问题，招聘者可巧妙地变换提问方式，“我们只是希望清楚您能够接受的待遇范围，例如税后月薪 2000-2500 元左右。” 

27 
您要求公司必须的福利有哪些？另外希望公司提供什么样的福利？ 
涉及到人力成本及相关法规的问题，同时通过应聘者谈到原单位的福利时可以看出单位实力，以及自身的承受能力。 
背景调查 
28 
您是否介意我们通过您原来的单位进行一些调查？ 
重要的职位是必须进行调查的。通过应聘者回答问题时的态度及调查的材料可以测试其诚实程度。 

1. 
suningin详解笔试面试题（6）－－moto笔试
10月21号moto的笔试是在我们学校举行的，120分钟的笔试时间，试题内容大致涵盖了c/c++，数据库，数字通信，IQ等方面。我自我感觉做的很顺利，至少两道编程题我都搞定了。一个多小时就把试题做完了，于是，我就把一些试题偷偷抄到了草稿纸上，回去和大家一齐分享。下面就是我抄回来的试题：
1。打印如下图案，共19行，只能有一个for循环（程序已经提供）
         *          
        ***         
       *****        
      *******       
     *********      
    ***********
   *************    
  ***************   
  ***************** 
******************* 
  ***************** 
  ***************   
   *************    
    ***********     
     *********      
      *******       
       *****        
        ***         
         *          
for(i=0;i<19;i++)
{
}
在网上搜寻了些解答，如下：
1.
#include<iostream>
#include<iomanip>
#include<string>
using namespace std;
int main()
{
 int a[2]={-1,1};
 string str="*******************";
 int i=0,j=9,t=1;
 for(i=0;i<19;++i)
 {
  j+=a[i<10];
  if(i!=0)t=t+a[i<10]*2;
  cout<<setw(j)<<right<<str.substr(0,t)<<endl;
 }
 return 0;
} 
2.
#include<stdio.h>
#include<string.h> 
int main()
{
 char * tempStr = "*******************";
 char * blank = " ";
 int i = 0;
 char * dataStr [20];
 char blankstr[10];
 for ( i=0; i<19; i++)
 {
  memset(dataStr, 0, 20);
  memset(blankstr,0,10);
  if (i<10)
  {
   memcpy(blankstr,blank,9-i);
   memcpy(dataStr, tempStr, (i+1)*2-1);
  }
  else
  {
   memcpy(blankstr,blank,i-9);
   memcpy(dataStr, tempStr, (19-i)*2-1);
  }
  printf("%s",blankstr);
  printf("%s\n", dataStr);
 }
 return 0;
} 
3。
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define MAXSIZE 19
void main()
{
    int i,k;
   char ch;
   char format[30],stars[30],tmp[3];
   ch = '*';
   strcpy(stars,"");
   for(i=0; i<MAXSIZE; i++)
  {
      if(i <= MAXSIZE/2)
     {
         k = (MAXSIZE + 1)/2 - i;
         strcpy(format,"%");
         itoa(k,tmp,10);
        strcat(format,tmp);
        strcat(format,"c");
        if(i>0)
           {
                strcat(stars,"**");
                strcat(format,stars);
            }
         printf(format,ch);
         printf("\n");
      }
     else
     {
         k = i + 2 - (MAXSIZE + 1)/2;
         strcpy(format,"%");
         itoa(k,tmp,10);
        strcat(format,tmp);
        strcat(format,"c");
        stars[MAXSIZE -1 -(2*(i+1) - MAXSIZE -1)] = 0;
         strcat(format,stars);
        printf(format,ch);
        printf("\n");
     }
 }
 //getchar();
 //getchar();
}
注:printf格式%mc表示输入字符宽度为m位,左边补空格.
4。
有高人发的回帖:
#include<iostream.h>
int main(int argv,int * argc[])
{
 for(int i=0;i<19;i++)
 {
  static char cc[19] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};
        //19个空格
  static const int j = 19 / 2;   //j值为9
        static int count = 0;          //count为离中间元素的距离
        if( i < ( 19 / 2 + 1)) 
  {
          cc[j - count] = '*';
          cc[j + count] = '*';
          cout << cc << endl;
          count++;
  } 
  else 
  {
          count--;
          cc[j - count] = ' ';
          cc[j + count] = ' ';
          cout << cc << endl;
  }
 }
 return 0;
}
 
一看就知差距,我的晦涩难懂
我想用两个数组,一个存放空格数量,一个存放'*'但是下面这个程序只用了一个数组，把每一行输出的形状存到数组中
2.
void fun(int x)
{
 if(x/2>0)fun(x/2);
 printf("%d",x);
}
求fun(10)的输出结果     //12510，一个递归，很简单的
3。
#define f1(n) (n)*(n)
         int i=5;
 int k=0;
 k=f1(i++);
 printf("%d %d",i,k);
输出结果：  ：// 7 25，++放后面是后算的
4。下面那个for循环是无限循环
for(int i=010;i==10;i+=0)       //这个明显不是，010等于8，8 != 10，一判断就出去了
for(int i=10;(i++^--i)==0;i+=0)   //无限循环
还有几个忘了
5.Email relay 和Email access分别用了什么协议？（其他还有很多，略）
SMTP,POP3
注: SMTP：Simple MAIL Transfer Protocol，简单邮件传输协议，互联网上的电子邮件发送就是使用这个协议。SMTP open relay host：开放的SMTP中继主机——它很可能被恶意的人利用，来产生大量垃圾邮件.
POP3协议允许客户机通过（临时的或永久的）TCP/IP连接或其他网络协议的连接，从一个服务器（这时就称为POP3服务器）上获取电子邮件（E-MAIL），POP3不负责发送邮件.
6。in a mobile phone,软件运行期，stack data 存在于
a.rom,b.flash c.eeprom d.ram e.none of the above
答：D.ram。这题稍微涉及到一点硬件知识，ROM的全称是Read Only Memory，即只读存储器，flash ，eeprom都是ROM家族的一员，RAM是Random Access Memory的简称，意为随机存取存储器，也就是内存了。不管是堆还是栈都是放在内存里的。
7.
int i;
 int x=0x12345678;
 unsigned char *p=(unsigned char *)&x;
 for(i=0;i<sizeof(x);i++)
  printf("%2x",*(p+i));
 在80x86pc机器上运行结果
 Sun Sparc Unix上运行结果
80x86系列机的堆栈的伸展方向是从高地址向低地址.堆栈操作都是字操作.数据入栈16位,高字节在前,低字节在后(即先压入高字节).出栈时,低字节在前,高字节在后(即低字节先出).低字节占低地址,高字节占高地址.  
Intel x86全部为little-endian字节顺序，即低字节的寄存器占用低内存地址线.
Sun Sparc Unix为big-endian字节顺序，即低字节寄存器占用高内存地址线.
x在PC机上的内存存放顺序为78 56 34 12，高字节在前，低字节在后，因此输出78563412
Sun Sparc Unix上输出12345678
8.
 char a[2][2][3]={{{1,6,3},{5,4,15}},{{3,5,33},{23,12,7}} };
 for(int i=0;i<12;i++)
 printf("%d ",_______);   //a[i/6][((i>=6 ? (i-6):i)+2)/5][i%3]);  或者：*(*(*(a+i/6)+(i/3%2))+i%3)    *((char *)a + i)
 //*(**a + i)
空格处填上合适的语句，顺序打印出a中的数字
9。void fun(char *a,char *b)
{
 a=b;
 (*a)++;
}
void main()
{
 char s1='A',s2='b';
 char *p1=&s1;
 char *p2=&s2;
 fun(p1,p2);
 printf("%c%c",s1,s2);
输出结果：  // Ac吧，这个比较简单
10。写一个strstr（）函数
suningin详解笔试面试题（7)－－历年名企考题专辑
基础数学题： 
1。有三个不同的信箱，今有4封不同的信欲投其中，共有多少种不同的投法？ 
答案：每封信有3种投法，于是3*3*3*3。 
2。连续4次抛掷一枚硬币，求恰出现两次是正面的概率和最后两次出现是正面的概率。 
答案：两次正面为，0.5*0.5*0.5*0.5；最后两次为正：0.5*0.5 
3。一个口袋内装有除颜色外其他都相同的6个白球和4个红球，从中任意摸出2个，求：A、2个都是白球的概率；B、2个都是红球的概率；C、一个白球，一个红球的概率。 
答案：A：（6/10）×（5/9） B：（4/10）×（3/9） 
      C：（6/10）×（4/9）＋（4/10）×（6/9） 
4。有30支篮球队，先分3组（每组10队）按单循环制进行比赛，然后将每组前三名集中，再按单循环制进行比赛，规定在小组赛已相遇的两队不再重赛，求先后比赛共有多少场？ 
答案：小组赛时候次数为 3×（9＋8＋。。。＋1） 
      每组前三名比赛次数3×6＋3×3 
5。正方形边长为1，以各个顶点半径为1做弧，在正方形中间有一个公共区域，求面积。 
答案： 
6。使用下列每组数字，排出加减乘除的公式，得出“24”。第一组“1、2、3、4”
；第二组“5、6、7、8”；第三组“3、3、8、8”。 
答案：A：(1+2+3)*4=24 
      B：(5+7)*(8-6)=24 
      C：8/(3-8/3)=24 
7。10个人排队戴帽子，10个黄帽子，9个蓝帽子，戴好后，后面的人可以看见前面所有人的帽子，然后从后面问起，问自己头上的帽子是什么颜色，结果一直问了9个人都说不知道，而最前面的人却知道自己头上的帽子的颜色。问是什么颜色，为什么？ 
答案： 
相关的题目7的还有: 
################################################ 
一位逻辑学教授有三个学生，这三个学生都非常聪明。 
一天教授想测验一下这三个学生，他在每个人头上都放了写着一个正整数的卡片，其中两个数之和等于第三个。 
每个人都可以看到其他人头上的数字，但看不到自己头上的数字。 
教授问第一个学生“你知道你头上的数字吗？” 
第一个学生回答“不知道。” 
教授接着问下去。 
第二个学生回答“不知道。” 
第三个学生也回答“不知道。” 
教授又从头问起。 
第一个学生还是回答“不知道。” 
第二个学生还是回答“不知道。” 
这时第三个学生说到“我知道了，是144！” 
请问另两个学生头上的数字和第三个学生是怎样知道自己头上的数字的？ 
################################################ 
两个大于一小于十的整数，把两数之和告诉甲，两数之积告诉乙。让他俩猜，两人都说不知道。突然甲说我知道这两个数了，乙也跟着说我知道了。请问这两个数各是多少？ 
两个大于一小于十的整数，把两数之和告诉甲，两数之积告诉乙。让他俩猜，两人都说不知道。之后两人都沉思了一会儿。突然乙说我知道这两个数了，甲也跟着说我知道了。请问这两个数各是多少？ 
两个大于一小于十的整数，把两数之和告诉甲，两数之积告诉乙。让他俩猜，两人都说不知道。突然甲说我知道这两个数了，可乙还是不知道。请问这两个数各是多少？ 
################################################ 
一个班上有50个学生。老师对同学们说：你们中有人脸上有泥巴，请自己举起手来。连续问了七遍，所有脸上有泥巴的学生都举起了手。每个人看不到自己脸上是否有泥巴，但能观察到其他人，假设每个学生都有很聪明。问：有多少个人脸上有泥巴？ 
################################################
8。一个班有m名同学，问m为多少时，有两人同一天生日的概率为0.6.建立数学模型并解答。同时说明该模型适用于通信中的那些情况。
答案： 
9。为了解决学生洗澡难的问题，东方学校新建一座澡堂，水龙头数为m，每天开放k小时，如果学生人数为n，每位学生每周洗一次澡，每次须半小时，学生到达澡堂服从均匀分布，问当m为多少时，学生洗澡等待时间不超过10分钟。建立数学模型并解答。同时请说明该模型适用于通信中的那些情况。
无两人同一天的生日概率为p1=365*364*……*(366-m)/365^m 
有两人同一天生日的概率为p2=1-p1=1-365*364*……*(366-m)/365^m=0.6 
365*364*……*(366-m)/365^m=0.4 
编写C++ 程序实现 
#include<iostream.h> 
void main() 
{ 
int i=1; 
double p=1; 
for(i=1;i<=365;i++) 
{ p=(365-i+1)/365*p; 
if (p==0.4) 
{ 
cout<<"一个班的人数为"<<i<<"使得有两人同一天的概率为0.6"<<endl; 
break;} 
else if (i==365) 
cout<<"failue"<<endl; 
} 
} 
答案：？？？ 
10。有若干台型号相同的联合收割机，收割一片土地上的小麦，若同时投入工作至收割完毕需用24小时；但它们是每隔相同的时间顺序投入工作的，每一台投入工作后都一直工作到小麦收割完毕。如果第一台收割时间是最后一台的5倍，请问：用这种收割方法收割完这片土地上的小麦需用多长时间？
答案：？？？
11。有一批货，如果本月初出售，可获利100元，然后可将本利都存入银行，已知银行月息为2.4%，如果下月初出售，可获利120元，但要付5元保管费，试问这批货何时出售最好（本月初还是下月初）？请说明理由。
答案：如果本月出手，得到的为100＋2.4；如果下个月则得到的为120－5 。 
12。5个海盗抢到了100颗宝石,每一颗都一样的大小和价值连城.他们决定这么分:第一步,抽签决定自己的号码(1,2,3,4,5);第二步,首先,由1号提出分配方案,然后5个人进行表决,当且仅当超过半数的人同意时,按照他的提案进行分配,否则他将被扔入大海喂鲨鱼;第三步,1号死后,再由2号提出分配方案,然后4人进行表决,当且仅当超过半数的人同意时,按照他的提案进行分配,否则他将被扔入大海喂鲨鱼;第四步,以此类推.
条件:每个海盗都是很聪明的人,都能很理智的判断得失,从而做出选择.
问题:最后的分配结果如何 
提示:海盗的判断原则:1.保命;2.尽量多得宝石;3.尽量多杀人. 
答案：推理的关键是找对思路.
任何推理的源泉都在于简化.所以推理过程是这样的:从后向前推,如果1-3号强盗都喂了鲨鱼,只剩4号和5号的话,5号一定投反对票让4号喂鲨鱼,以独吞全部金币.所以,4号惟有支持3号才能保命.3号知道这一点,就会提(100,0,0)的分配方案,对4号,5号一毛不拔而将全部金币归为已有,因为他知道4号一无所获但还是会投赞成票,再加上自己一票,他的方案即可通过.不过,2号推知到3号的方案,就会提出(98,0,1,1)的方案,即放弃3号,而给予4号和5号各一枚金币.由于该方案对于4号和5号来说比在3号分配时更为有利,他们将支持他而不希望他出局而由3号来分配.这样,2号将拿走98枚金币.不过,2号的方案会被1号所洞悉,1号并将提出(97,0,1,2,0)或(97,0,1,0,2)的方案,即放弃2号,而给3号一枚金币,同时给4号(或5号)2枚金币.由于1号的这一方案对于3号和4号(或5号)来说,相比2号分配时更优,他们将投1号的赞成票,再加上1号自己的票,1号的方案可获通过,97枚金币可轻松落入囊中.这无疑是1号能够获取最大收益的方案了!可以看出,这个推理过程就先考虑简化的极端情况,从而顺藤摸瓜,得出最后的结果.另外,这其实是经济学中的博弈问题,1号提出的方案就是这种情况下的纳什均衡.一道推理题目同时涉及了经济学的基本原理,可见这道考题的老辣了. 
13。一列火车上三个工人,史密斯,琼斯,罗伯特三人工作为消防员,司闸员,机械师.有三个乘客与三人名字相同,
1 罗伯特住在底特律.
2 司闸员住在芝加哥和底特律中间的地方.
3 琼斯一年赚2 万美金.
4 有一个乘客和司闸员住在一个地方,每年的薪水是司闸员的3 倍整.
5 史密斯台球打得比消防员好.
6 和司闸员同名的乘客住在芝加哥.
请问谁是机械师 
答案：地点:底特律某个地方芝加哥
工人:Robbert x y
乘客:Robbert y x
工作:司闸员
因为Johns 一年2 万,因为无法分别到底是哪一Johns,所以只能认为他们两个都拿2 万由于2 万不能被3 整除,所以如果y 是Johns,那么不能满足条件4所以x 肯定是Johns.Johns 是司闸员.又有条件5,Smith 打的比消防员好,从数学逻辑,Smith 不会是消防员.所以Smith 肯定是机械师.最后应该是
地点:底特律某个地方芝加哥
工人:Robbert Johns(2 万)Smith
乘客:Robbert Smith(6 万)Johns(2 万)
工作:消防员,司闸员,机械师. 
最前面的那个肯定是黄帽子。因为后面有九个人都不能确定自己是什么帽子，说明有可能是黄帽子，有可能是蓝帽子。 
这还不足以说服，这个要倒推才行。 
比如在有2个人的情况下，有2个黄帽子，1个蓝帽子，如果第一个人是蓝帽子，因为第二个人可以看见前面的，而蓝帽子只有一个。这种情况第二个可以推断出自己是黄帽子。如果第一个是黄帽子，则第二人是戴的黄帽子还是蓝帽子则不确定。 
比如在有3个人的情况下，有3个黄帽子，2个蓝帽子.在这种情况下有几种可能： 
A:1蓝，2蓝的情况下，3知道自己是什么颜色，因为只有两个蓝帽子。 
B：1蓝，2黄的情况下，3不知道自己是什么颜色，2知道自己是什么颜色。因为2会这样思考，1是蓝色，如果自己是蓝色的话，那3应该知道自己是什么颜色，而3不知道，则自己肯定是黄色。 
C：1黄，2蓝，的情况下，3不知道自己是什么颜色，2也不能确定自己是什么颜色。 
D:1黄，2黄的情况下，2和3都不确定自己是什么颜色。 
排除A和B的情形，只剩C和D，在这两种情况下，1都是黄色。 
比如在有4个人的情况下... 
5个人.... 
以此类推. 
所以在10个人的情况下，只有第1个人是黄帽子，其它人才不能确定。如果第1个人是蓝帽子，则剩下的九个人中，总有一个人能确定

Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 
数组实现： 
#include <stdio.h> 
#include <malloc.h> 
int Josephu(int n, int m) 
{ 
  int flag, i, j = 0; 
  int *arr = (int *)malloc(n * sizeof(int)); 
  for (i = 0; i < n; ++i) 
    arr[i] = 1; 
  for (i = 1; i < n; ++i) 
  { 
    flag = 0; 
    while (flag < m) 
    { 
      if (j == n) 
        j = 0; 
      if (arr[j]) 
        ++flag; 
      ++j; 
    } 
    arr[j - 1] = 0; 
    printf("第%4d个出局的人是：%4d号\n", i, j); 
  } 
  free(arr); 
  return j; 
} 
int main() 
{ 
  int n, m; 
  scanf("%d%d", &n, &m); 
  printf("最后胜利的是%d号！\n", Josephu(n, m)); 
  system("pause"); 
  return 0; 
} 
链表实现： 
#include <stdio.h> 
#include <malloc.h> 
typedef struct Node 
{ 
  int index; 
  struct Node *next; 
}JosephuNode; 
int Josephu(int n, int m) 
{ 
  int i, j; 
  JosephuNode *head, *tail; 
  head = tail = (JosephuNode *)malloc(sizeof(JosephuNode)); 
  for (i = 1; i < n; ++i) 
  { 
    tail->index = i; 
    tail->next = (JosephuNode *)malloc(sizeof(JosephuNode)); 
    tail = tail->next; 
  } 
  tail->index = i; 
  tail->next = head; 
  
  for (i = 1; tail != head; ++i) 
  { 
    for (j = 1; j < m; ++j) 
    { 
      tail = head; 
      head = head->next; 
    } 
    tail->next = head->next; 
    printf("第%4d个出局的人是：%4d号\n", i, head->index); 
    free(head); 
    head = tail->next; 
  } 
  i = head->index; 
  free(head); 
  return i; 
} 
int main() 
{ 
  int n, m; 
  scanf("%d%d", &n, &m); 
  printf("最后胜利的是%d号！\n", Josephu(n, m)); 
  system("pause"); 
  return 0; 
} 
已知strcpy函数的原型是： 
        char * strcpy(char * strDest,const char * strSrc); 
    1.不调用库函数，实现strcpy函数。 
    2.解释为什么要返回char *。 
    解说： 
    1.strcpy的实现代码 
        char * strcpy(char * strDest,const char * strSrc) 
        { 
                if ((strDest==NULL)||(strSrc==NULL)) file://[/1] 
                        throw "Invalid argument(s)"; //[2] 
                char * strDestCopy=strDest;  file://[/3] 
                while ((*strDest++=*strSrc++)!='\0'); file://[/4] 
                return strDestCopy; 
        } 
    错误的做法： 
    [1] 
    (A)不检查指针的有效性，说明答题者不注重代码的健壮性。 
    (B)检查指针的有效性时使用((!strDest)||(!strSrc))或(!(strDest&&strSrc))，说明答题者对C语言中类型的隐式转换没有深刻认识。在本例中char *转换为bool即是类型隐式转换，这种功能虽然灵活，但更多的是导致出错概率增大和维护成本升高。所以C++专门增加了bool、true、false三个关键字以提供更安全的条件表达式。 
    (C)检查指针的有效性时使用((strDest==0)||(strSrc==0))，说明答题者不知道使用常量的好处。直接使用字面常量（如本例中的0）会减少程序的可维护性。0虽然简单，但程序中可能出现很多处对指针的检查，万一出现笔误，编译器不能发现，生成的程序内含逻辑错误，很难排除。而使用NULL代替0，如果出现拼写错误，编译器就会检查出来。 
    [2] 
    (A)return new string("Invalid argument(s)");，说明答题者根本不知道返回值的用途，并且他对内存泄漏也没有警惕心。从函数中返回函数体内分配的内存是十分危险的做法，他把释放内存的义务抛给不知情的调用者，绝大多数情况下，调用者不会释放内存，这导致内存泄漏。 
    (B)return 0;，说明答题者没有掌握异常机制。调用者有可能忘记检查返回值，调用者还可能无法检查返回值（见后面的链式表达式）。妄想让返回值肩负返回正确值和异常值的双重功能，其结果往往是两种功能都失效。应该以抛出异常来代替返回值，这样可以减轻调用者的负担、使错误不会被忽略、增强程序的可维护性。 
    [3] 
    (A)忘记保存原始的strDest值，说明答题者逻辑思维不严密。 
    [4] 
    (A)循环写成while (*strDest++=*strSrc++);，同[1](B)。 
    (B)循环写成while (*strSrc!='\0') *strDest++=*strSrc++;，说明答题者对边界条件的检查不力。循环体结束后，strDest字符串的末尾没有正确地加上'\0'。
试题很多
4.    static有什么用途？（请至少说明两种）
1.限制变量的作用域
2.设置变量的存储域
7.    引用与指针有什么区别？
1) 引用必须被初始化，指针不必。
2) 引用初始化以后不能被改变，指针可以改变所指的对象。
2) 不存在指向空值的引用，但是存在指向空值的指针。
8.    描述实时系统的基本特性
在特定时间内完成特定的任务，实时性与可靠性
9.    全局变量和局部变量在内存中是否有区别？如果有，是什么区别？
全局变量储存在静态数据库，局部变量在堆栈
10.   什么是平衡二叉树？
左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1
11.   堆栈溢出一般是由什么原因导致的？
没有回收垃圾资源
12.   什么函数不能声明为虚函数？
constructor
13.   冒泡排序算法的时间复杂度是什么？
O(n^2)
14.   写出float x 与“零值”比较的if语句。
if(x>0.000001&&x<-0.000001)
16.   Internet采用哪种网络协议？该协议的主要层次结构？
tcp/ip 应用层/传输层/网络层/数据链路层/物理层
17.   Internet物理地址和IP地址转换采用什么协议？
ARP (Address Resolution Protocol)（地址解析協議）
18.IP地址的编码分为哪俩部分？
IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。
2.用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。
循环链表，用取余操作做
3.不能做switch()的参数类型是：
switch的参数不能为实型。
華為
1、局部变量能否和全局变量重名？
答：能，局部会屏蔽全局。要用全局变量，需要使用"::"
局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内
2、如何引用一个已经定义过的全局变量？
答：extern
可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错
3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？
答：可以，在不同的C文件中以static形式来声明同名全局变量。
可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错
4、语句for( ；1 ；)有什么问题？它是什么意思？
答：和while(1)相同。
5、do……while和while……do有什么区别？
答：前一个循环一遍再判断，后一个判断以后再循环
6、请写出下列代码的输出内容
#include<stdio.h>
main()
{
int a,b,c,d;
a=10;
b=a++;
c=++a;
d=10*a++;
printf("b，c，d：%d，%d，%d"，b，c，d）;
return 0;
} 
答：10，12，120
1、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。
从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。
static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件
static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;
static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；
static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝
2、程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。
3、设有以下说明和定义：
typedef union {long i; int k[5]; char c;} DATE;
struct data { int cat; DATE cow; double dog;} too;
DATE max;
则语句 printf("%d",sizeof(struct date)+sizeof(max));的执行结果是：___52____
答：DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20
data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32.
所以结果是 20 + 32 = 52.
当然...在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 = 20
4、队列和栈有什么区别？
队列先进先出，栈后进先出
5、写出下列代码的输出内容
#include<stdio.h>
int inc(int a)
{
return(++a);
}
int multi(int*a,int*b,int*c)
{
return(*c=*a**b);
}
typedef int(FUNC1)(int in);
typedef int(FUNC2) (int*,int*,int*);
void show(FUNC2 fun,int arg1, int*arg2)
{
INCp=&inc;
int temp =p(arg1);
fun(&temp,&arg1, arg2);
printf("%d\n",*arg2);
}
main()
{
int a;
show(multi,10,&a);
return 0;
}
答：110
7、请找出下面代码中的所以错误
说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba”
1、#include"string.h"
2、main()
3、{
4、 char*src="hello,world";
5、 char* dest=NULL;
6、 int len=strlen(src);
7、 dest=(char*)malloc(len);
8、 char* d=dest;
9、 char* s=src[len];
10、 while(len--!=0) 
11、 d++=s--;
12、 printf("%s",dest);
13、 return 0;
14、} 
答：
方法1：
int main(){
char* src = "hello,world";
int len = strlen(src);
char* dest = (char*)malloc(len+1);//要为\0分配一个空间
char* d = dest;
char* s = &src[len-1];//指向最后一个字符
while( len-- != 0 )
*d++=*s--;
*d = 0;//尾部要加\0
printf("%s\n",dest);
free(dest);// 使用完，应当释放空间，以免造成内存汇泄露
return 0;
}
方法2：
#include <stdio.h>
#include <string.h>
main()
{
char str[]="hello,world";
int len=strlen(str);
char t;
for(int i=0; i<len/2; i++)
{
t=str[i]; 
str[i]=str[len-i-1]; str[len-i-1]=t;
}
printf("%s",str);
return 0;
}
1.-1,2,7,28,,126请问28和126中间那个数是什么？为什么？
第一题的答案应该是4^3-1=63
规律是n^3-1(当n为偶数0，2，4)
      n^3+1(当n为奇数1，3，5)
答案：63
2.用两个栈实现一个队列的功能？要求给出算法和思路！
设2个栈为A,B, 一开始均为空.
入队:
将新元素push入栈A;
出队:
(1)判断栈B是否为空；
(2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；
(3)将栈B的栈顶元素pop出；
这样实现的队列入队和出队的平摊复杂度都还是O(1), 比上面的几种方法要好。3.在c语言库函数中将一个字符转换成整型的函数是atool()吗，这个函数的原型是什么？
函数名: atol 
功 能: 把字符串转换成长整型数 
用 法: long atol(const char *nptr); 
程序例: 
#include <stdlib.h> 
#include <stdio.h> 
int main(void) 
{ 
long l; 
char *str = "98765432"; 
l = atol(lstr); 
printf("string = %s integer = %ld\n", str, l); 
return(0); 
}
2.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?
c用宏定义，c++用inline
  3.直接链接两个信令点的一组链路称作什么?
PPP点到点连接
  4.接入网用的是什么接口?
  5.voip都用了那些协议?
  6.软件测试都有那些种类?
黑盒：针对系统功能的测试    白合：测试函数功能，各函数接口
  7.确定模块的功能和模块的接口是在软件设计的那个队段完成的?
概要设计阶段
  8.enum string
    {
    x1,
    x2,
    x3=10,
    x4,
    x5,
    }x;
   问x= 0x801005，0x8010f4  ;
  9.unsigned char *p1;
    unsigned long *p2;
    p1=(unsigned char *)0x801000;
    p2=(unsigned long *)0x810000;
    请问p1+5=  ;
        p2+5=  ;
三.选择题:
  1.Ethternet链接到Internet用到以下那个协议?
  A.HDLC;B.ARP;C.UDP;D.TCP;E.ID
  2.属于网络层协议的是:
  A.TCP;B.IP;C.ICMP;D.X.25
  3.Windows消息调度机制是:
  A.指令队列;B.指令堆栈;C.消息队列;D.消息堆栈;
  4.unsigned short hash(unsigned short key)
    {
      return (key>>)%256
    }
   请问hash(16),hash(256)的值分别是:
  A.1.16;B.8.32;C.4.16;D.1.32
四.找错题:
  1.请问下面程序有什么错误?
   int a[60][250][1000],i,j,k;
   for(k=0;k<=1000;k++)
    for(j=0;j<250;j++)
     for(i=0;i<60;i++)
      a[i][j][k]=0;
把循环语句内外换一下
  2.#define Max_CB 500
    void LmiQueryCSmd(Struct MSgCB * pmsg)
     {
     unsigned char ucCmdNum;
     ......
     for(ucCmdNum=0;ucCmdNum<Max_CB;ucCmdNum++)
      {
      ......;
      }
死循环
   3.以下是求一个数的平方的程序,请找出错误:
    #define SQUARE(a)((a)*(a))
    int a=5;
    int b;
    b=SQUARE(a++);
   4.typedef unsigned char BYTE
     int examply_fun(BYTE gt_len; BYTE *gt_code)
      {  
      BYTE *gt_buf;
      gt_buf=(BYTE *)MALLOC(Max_GT_Length);
      ......
      if(gt_len>Max_GT_Length)
        {
        return GT_Length_ERROR;  
        }
        .......
      }
五.问答题:
   1.IP Phone的原理是什么?
IPV6
   2.TCP/IP通信建立的过程怎样，端口有什么作用？
三次握手，确定是哪个应用程序使用该协议
   3.1号信令和7号信令有什么区别，我国某前广泛使用的是那一种？
   4.列举5种以上的电话新业务？
微软亚洲技术中心的面试题！！！
1．进程和线程的差别。
线程是指进程内的一个执行单元,也是进程内的可调度实体.
与进程的区别:
(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源. 
(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。
2.测试方法 
人工测试：个人复查、抽查和会审
机器测试：黑盒测试和白盒测试
2．Heap与stack的差别。
Heap是堆，stack是栈。
Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。
Stack空间有限，Heap是很大的自由存储区
C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。
程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行
3．Windows下的内存是如何管理的？
4．介绍.Net和.Net的安全性。
5．客户端如何访问.Net组件实现Web Service？
6．C/C++编译器中虚表是如何完成的？
7．谈谈COM的线程模型。然后讨论进程内/外组件的差别。
8．谈谈IA32下的分页机制
小页(4K)两级分页模式，大页(4M)一级
9．给两个变量，如何找出一个带环单链表中是什么地方出现环的？
一个递增一，一个递增二，他们指向同一个接点时就是环出现的地方
10．在IA32中一共有多少种办法从用户态跳到内核态？
通过调用门，从ring3到ring0，中断从ring3到ring0，进入vm86等等
11．如果只想让程序有一个实例运行，不能运行两个。像winamp一样，只能开一个窗口，怎样实现？
用内存映射或全局原子（互斥变量）、查找窗口句柄.. 
FindWindow，互斥，写标志到文件或注册表,共享内存。.　  
12．如何截取键盘的响应，让所有的‘a’变成‘b’？
键盘钩子SetWindowsHookEx
　13．Apartment在COM中有什么用？为什么要引入？
　14．存储过程是什么？有什么用？有什么优点？
我的理解就是一堆sql的集合，可以建立非常复杂的查询，编译运行，所以运行一次后，以后再运行速度比单独执行SQL快很多
　15．Template有什么特点？什么时候用？
16．谈谈Windows DNA结构的特点和优点。
网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别？
1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。
2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
两者都可以提高程序的并发度，提高程序运行效率和响应时间。
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
思科
1. 用宏定义写出swap（x，y）
#define swap(x, y)\
x = x + y;\
y = x - y;\
x = x - y;
2.数组a[N]，存放了1至N-1个数，其中某个数重复一次。写一个函数，找出被重复的数字.时间复杂度必须为o（N）函数原型：
int do_dup(int a[],int N)
3 一语句实现x是否为2的若干次幂的判断
int i = 512;
cout << boolalpha << ((i & (i - 1)) ? false : true) << endl;
4.unsigned int intvert(unsigned int x,int p,int n)实现对x的进行转换,p为起始转化位,n为需要转换的长度,假设起始点在右边.如x=0b0001 0001,p=4,n=3转换后x=0b0110 0001
unsigned int intvert(unsigned int x,int p,int n){
unsigned int _t = 0;
unsigned int _a = 1;
for(int i = 0; i < n; ++i){
_t |= _a;
_a = _a << 1;
}
_t = _t << p;
x ^= _t;
return x;
}
什么是预编译
何时需要预编译：
１、总是使用不经常改动的大型代码体。 
２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。
char * const p;
char const * p
const char *p
上述三个有什么区别？
char * const p; //常量指针，p的值不可以修改
char const * p；//指向常量的指针，指向的常量值不可以改
const char *p； //和char const *p
char str1[] = "abc";
char str2[] = "abc";
const char str3[] = "abc";
const char str4[] = "abc";
const char *str5 = "abc";
const char *str6 = "abc";
char *str7 = "abc";
char *str8 = "abc";
cout << ( str1 == str2 ) << endl;
cout << ( str3 == str4 ) << endl;
cout << ( str5 == str6 ) << endl;
cout << ( str7 == str8 ) << endl;
结果是：0 0 1 1
解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；
而str5,str6,str7,str8是指针，它们指向相同的常量区域。

12. 以下代码中的两个sizeof用法有问题吗？[C易]
void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母
{
    for( size_t i=0; i<sizeof(str)/sizeof(str[0]); ++i )
        if( 'a'<=str[i] && str[i]<='z' )
            str[i] -= ('a'-'A' );
}
char str[] = "aBcDe";
cout << "str字符长度为: " << sizeof(str)/sizeof(str[0]) << endl;
UpperCase( str );
cout << str << endl;
答：函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。
一个32位的机器,该机器的指针是多少位
指针是多少位只要看地址总线的位数就行了。80386以后的机子都是32的数据总线。所以指针的位数就是4个字节了。
main()
{
  int a[5]={1,2,3,4,5};
   int *ptr=(int *)(&a+1);
   printf("%d,%d",*(a+1),*(ptr-1));
}
输出：2,5
*(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5
&a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）
int *ptr=(int *)(&a+1); 
则ptr实际是&(a[5]),也就是a+5
原因如下：
&a是数组指针，其类型为 int (*)[5];
而指针加1要根据指针类型加上一定的值，
不同类型的指针+1之后增加的大小不同
a是长度为5的int数组指针，所以要加 5*sizeof(int)
所以ptr实际是a[5]
但是prt与(&a+1)类型是不一样的(这点很重要)
所以prt-1只会减去sizeof(int*)
a,&a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5].
1.请问以下代码有什么问题：
int  main()
{
char a;
char *str=&a;
strcpy(str,"hello");
printf(str);
return 0;
}
没有为str分配内存空间，将会发生异常
问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。
char* s="AAA";
printf("%s",s);
s[0]='B';
printf("%s",s);
有什么错？
"AAA"是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。
cosnt char* s="AAA";
然后又因为是常量，所以对是s[0]的赋值操作是不合法的。
1、写一个“标准”宏，这个宏输入两个参数并返回较小的一个。
.#define Min(X, Y) ((X)>(Y)?(Y):(X))//结尾没有;
2、嵌入式系统中经常要用到无限循环，你怎么用C编写死循环。
while(1){}或者for(;;)
3、关键字static的作用是什么？
定义静态变量
4、关键字const有什么含意？
表示常量不可以修改的变量。
5、关键字volatile有什么含意？并举出三个不同的例子？
提示编译器对象的值可能在编译器未监测到的情况下改变。
int (*s[10])(int) 表示的是什么啊
int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。
1.有以下表达式：
int a=248; b=4;int const c=21;const int *d=&a;
int *const e=&b;int const *f const =&a;
请问下列表达式哪些会被编译器禁止？为什么？
*c=32;d=&b;*d=43;e=34;e=&a;f=0x321f;
*c 这是个什么东东，禁止
*d 说了是const， 禁止
e = &a 说了是const 禁止
const *f const =&a; 禁止
2.交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3;
有两种解法, 一种用算术算法, 一种用^(异或)
a = a + b;
b = a - b;
a = a - b; 
or
a = a^b;// 只能对int,char..
b = a^b;
a = a^b;
or
a ^= b ^= a;
3.c和c++中的struct有什么不同？
c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private
4.#include <stdio.h>
  #include <stdlib.h>
  void getmemory(char *p)
  {
    p=(char *) malloc(100);
    strcpy(p,"hello world");
  }
  int main( )
  {
    char *str=NULL;
    getmemory(str);
    printf("%s/n",str);
    free(str);
    return 0;
   }
程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险
5.char szstr[10];
  strcpy(szstr,"0123456789");
  产生什么结果？为什么？
  长度不一样，会造成非法的OS
6.列举几种进程的同步机制，并比较其优缺点。
   原子操作 
信号量机制
   自旋锁
   管程，会合，分布式系统
7.进程之间通信的途径
共享存储系统
消息传递系统
管道：以文件系统为基础
11.进程死锁的原因
资源竞争及进程推进顺序非法
12.死锁的4个必要条件
互斥、请求保持、不可剥夺、环路
13.死锁的处理
鸵鸟策略、预防策略、避免策略、检测与解除死锁
15.   操作系统中进程调度策略有哪几种？
FCFS(先来先服务)，优先级，时间片轮转，多级反馈
8.类的静态成员和非静态成员有何区别？
类的静态成员每个类只有一个，非静态成员每个对象一个
9.纯虚函数如何定义？使用时应注意什么？
virtual void f()=0;
是接口，子类必须要实现
10.数组和链表的区别
数组：数据顺序存储，固定大小
连表：数据可以随机存储，大小可动态改变
12.ISO的七层模型是什么？tcp/udp是属于哪一层？tcp/udp有何优缺点？
应用层
表示层
会话层
运输层
网络层
物理链路层
物理层
tcp /udp属于运输层
TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。
与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。
tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好
udp: 不提供稳定的服务，包头小，开销小   
1：(void *)ptr 和 (*(void**))ptr的结果是否相同？其中ptr为同一个指针
.(void *)ptr 和 (*(void**))ptr值是相同的
2：int main()
   {
    int x=3;
    printf("%d",x);
    return 1;
   }
问函数既然不会被其它函数调用，为什么要返回1？
mian中，c标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息
1，要对绝对地址0x100000赋值，我们可以用
(unsigned int*)0x100000 = 1234;
那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？
*((void (*)( ))0x100000 ) ( );
首先要将0x100000强制转换成函数指针,即:
(void (*)())0x100000
然后再调用它:
*((void (*)())0x100000)();
用typedef可以看得更直观些:
typedef void(*)() voidFuncPtr;
*((voidFuncPtr)0x100000)();
2，已知一个数组table，用一个宏定义，求出数据的元素个数
#define NTBL
#define NTBL (sizeof(table)/sizeof(table[0]))
面试题: 线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?
进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。
每个线程有自己的堆栈。
DLL中有没有独立的堆栈，这个问题不好回答，或者说这个问题本身是否有问题。因为DLL中的代码是被某些线程所执行，只有线程拥有堆栈，如果DLL中的代码是EXE中的线程所调用，那么这个时候是不是说这个DLL没有自己独立的堆栈？如果DLL中的代码是由DLL自己创建的线程所执行，那么是不是说DLL有独立的堆栈？
以上讲的是堆栈，如果对于堆来说，每个DLL有自己的堆，所以如果是从DLL中动态分配的内存，最好是从DLL中删除，如果你从DLL中分配内存，然后在EXE中，或者另外一个DLL中删除，很有可能导致程序崩溃
unsigned short A = 10;
printf("~A = %u\n", ~A);
char c=128; 
printf("c=%d\n",c);
输出多少？并分析过程
第一题，～A ＝0xfffffff5,int值 为－11，但输出的是uint。所以输出4294967285
第二题，c＝0x10,输出的是int，最高位为1，是负数，所以它的值就是0x00的补码就是128，所以输出－128。
这两道题都是在考察二进制向int或uint转换时的最高位处理。
分析下面的程序：
void GetMemory(char **p,int num)
{
    *p=(char *)malloc(num);
    
}        
int main()
{
    char *str=NULL;
    GetMemory(&str,100);
    strcpy(str,"hello");
    free(str);
    if(str!=NULL)
    {
        strcpy(str,"world");
    }    
        
    printf("\n str is %s",str);
    getchar();
}    
问输出结果是什么？希望大家能说说原因，先谢谢了
输出str is world。
free 只是释放的str指向的内存空间,它本身的值还是存在的.
所以free之后，有一个好的习惯就是将str=NULL.
此时str指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储空间是可能被重新分配给其他变量的,
尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出world来。
这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。
当你malloc一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继续访问这块地址的，只不过。。。。。。。。楼上都说过了，最好别这么干。
char a[10],strlen(a)为什么等于15？运行的结果
#include "stdio.h"
#include "string.h"
void main()
{
char aa[10];
printf("%d",strlen(aa));
}
sizeof()和初不初始化，没有关系；
strlen()和初始化有关。
char (*str)[20];/*str是一个数组指针，即指向数组的指针．*/
char *str[20];/*str是一个指针数组，其元素为指针型数据．*/
long a=0x801010;
a+5=?
0x801010用二进制表示为：“1000 0000 0001 0000 0001 0000”，十进制的值为8392720，再加上5就是8392725罗
1)给定结构struct A 
{
       char t:4;
       char k:4;
       unsigned short i:8;
       unsigned long m;
};问sizeof(A) = ?
给定结构struct A 
{
       char t:4; 4位
       char k:4; 4位
       unsigned short i:8; 8位      
       unsigned long m; // 偏移2字节保证4字节对齐
}; // 共8字节
2)下面的函数实现在一个数上加一个数，有什么错误？请改正。
int add_n ( int n )
{
    static int i = 100;
    i += n;
    return i;
}
当你第二次调用时得不到正确的结果，难道你写个函数就是为了调用一次？问题就出在 static上？
// 帮忙分析一下
#include<iostream.h>
#include <string.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
typedef struct  AA
{
        int b1:5;
        int b2:2;
}AA;
void main()
{
        AA aa;
        char cc[100];
         strcpy(cc,"0123456789abcdefghijklmnopqrstuvwxyz");
       memcpy(&aa,cc,sizeof(AA));
        cout << aa.b1 <<endl;
        cout << aa.b2 <<endl;
}
答案是 -16和１
首先sizeof(AA)的大小为4,b1和b2分别占5bit和2bit.
经过strcpy和memcpy后,aa的4个字节所存放的值是:
0,1,2,3的ASC码，即00110000,00110001,00110010,00110011
所以，最后一步：显示的是这４个字节的前５位，和之后的２位
分别为：10000,和01
因为int是有正负之分　　所以：答案是-16和１
求函数返回值，输入x=9999; 
int func （ x ）
{ 
    int countx = 0; 
    while ( x ) 
    { 
        countx ++; 
        x = x&(x-1); 
    } 
    return countx; 
} 
结果呢？
知道了这是统计9999的二进制数值中有多少个1的函数，且有
9999＝9×1024＋512＋256＋15
9×1024中含有1的个数为2；
512中含有1的个数为1；
256中含有1的个数为1；
15中含有1的个数为4；
故共有1的个数为8，结果为8。
1000 - 1 = 0111，正好是原数取反。这就是原理。
用这种方法来求1的个数是很效率很高的。
不必去一个一个地移位。循环次数最少。
int a,b,c 请写函数实现C=a+b ,不可以改变数据类型,如将c改为long int,关键是如何处理溢出问题
bool add (int a, int b,int *c)
{
*c=a+b;
return (a>0 && b>0 &&(*c<a || *c<b) || (a<0 && b<0 &&(*c>a || *c>b)));
}
分析：
struct bit 
{   int a:3; 
    int  b:2; 
    int c:3; 
}; 
int main() 
{ 
  bit s; 
  char *c=(char*)&s; 
   cout<<sizeof(bit)<<endl;
  *c=0x99;
   cout << s.a <<endl <<s.b<<endl<<s.c<<endl; 
     int a=-1;
   printf("%x",a);
  return 0; 
} 
输出为什么是
4
1
-1
-4
ffffffff
因为0x99在内存中表示为 100 11 001 , a = 001, b = 11, c = 100
当c为有符合数时, c = 100, 最高1为表示c为负数，负数在计算机用补码表示，所以c = -4;同理 
b = -1;
当c为有符合数时, c = 100,即 c = 4,同理 b = 3
位域 ：   
有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：     
struct 位域结构名     
{ 位域列表 };    
其中位域列表的形式为： 类型说明符 位域名：位域长度     
例如：     
struct bs    
{    
int a:8;    
int b:2;    
int c:6;    
};    
位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。例如：     
struct bs    
{    
int a:8;    
int b:2;    
int c:6;    
}data;    
说明data为bs变量，共占两个字节。其中位域a占8位，位域b占2位，位域c占6位。对于位域的定义尚有以下几点说明：    
1. 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：     
struct bs    
{ unsigned a:4    
unsigned :0 /*空域*/    
unsigned b:4 /*从下一单元开始存放*/    
unsigned c:4    }    
在这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。    
2. 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。    
3. 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：     
struct k    
{    int a:1    
int :2 /*该2位不能使用*/    
int b:3    
int c:2    };    
从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。    
二、位域的使用位域的使用和结构成员的使用相同，其一般形式为： 位域变量名&#8226;位域名 位域允许用各种格式输出。    
main(){    
struct bs    
{unsigned a:1;    
unsigned b:3;    
unsigned c:4;    
} bit,*pbit;    
bit.a=1;    
bit.b=7;    
bit.c=15;    
pri
改错：
#include <stdio.h>
int main(void) {
    int **p;
    int arr[100];
    p = &arr;
    return 0;}
解答：
搞错了,是指针类型不同,
int **p; //二级指针
&arr; //得到的是指向第一维为100的数组的指针
#include <stdio.h>
int main(void) {
int **p, *q;
int arr[100];
q = arr;
p = &q;
return 0;}
下面这个程序执行后会有什么错误或者效果:
 #define MAX 255
 int main()
{unsigned char A[MAX],i;//i被定义为unsigned char
   for (i=0;i<=MAX;i++)
      A[i]=i;}
解答：死循环加数组越界访问（C/C++不进行数组越界检查）
MAX=255 
数组A的下标范围为:0..MAX-1,这是其一..
其二.当i循环到255时,循环内执行:
  A[255]=255;
这句本身没有问题..但是返回for (i=0;i<=MAX;i++)语句时,
由于unsigned char的取值范围在(0..255),i++以后i又为0了..无限循环下去.
struct name1{
   char  str;
   short x;
   int   num;}
struct name2{
   char str;
   int num;
   short x;}
sizeof(struct name1)=8,sizeof(struct name2)=12
在第二个结构中，为保证num按四个字节对齐，char后必须留出3字节的空间；同时为保证整个结构的自然对齐（这里是4字节对齐），在x后还要补齐2个字节，这样就是12字节。
intel：
A.c 和B.c两个c文件中使用了两个相同名字的static变量,编译的时候会不会有问题?这两个static变量会保存到哪里（栈还是堆或者其他的）?
static的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。
他们都放在数据区，但是编译器对他们的命名是不同的。
如果要使变量在其他模块也有意义的话，需要使用extern关键字。
struct s1
{int i: 8;
  int j: 4;
  int a: 3;
  double b;
};
struct s2
{int i: 8;
  int j: 4;
  double b;
  int a:3;
};
printf("sizeof(s1)= %d\n", sizeof(s1));
printf("sizeof(s2)= %d\n", sizeof(s2));
result: 16, 24
第一个struct s1
{int i: 8;
  int j: 4;
  int a: 3;
  double b;};
理论上是这样的，首先是i在相对0的位置，占8位一个字节，然后，j就在相对一个字节的位置，由于一个位置的字节数是4位的倍数，因此不用对齐，就放在那里了，然后是a，要在3位的倍数关系的位置上，因此要移一位，在15位的位置上放下，目前总共是18位，折算过来是2字节2位的样子，由于double是8字节的，因此要在相对0要是8个字节的位置上放下，因此从18位开始到8个字节之间的位置被忽略，直接放在8字节的位置了，因此，总共是16字节。
第二个最后会对照是不是结构体内

下面的题目必须全部答对才给分：
1、 如何在C中初始化一个字符数组。
2、 如何在C中为一个数组分配空间。
3、 如何初始化一个指针数组。
4、如何定义一个有10个元素的整数型指针数组。
5、 s[10]的另外一种表达方式是什么。
6、 GCC3.2.2版本中支持哪几种编程语言。
7、 要使用CHAR_BIT需要包含哪个头文件。
8、 对(-1.2345)取整是多少？
9、 如何让局部变量具有全局生命期。
10、C中的常量字符串应在何时定义？
11、如何在两个.c文件中引用对方的变量。
12、使用malloc之前需要做什么准备工作。
13、realloc函数在使用上要注意什么问题。
14、strtok函数在使用上要注意什么问题。
15、gets函数在使用上要注意什么问题。
16、C语言的词法分析在长度规则方面采用的是什么策略？
17、a+++++b所表示的是什么意思？有什么问题？
18、如何定义Bool变量的TRUE和FALSE的值。
19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。
这部分是ANSI C的一些问题，题目的前提是必须都答对，看似很变态，但是细想一下，这些都是最基础的，虽然我们在使用他们的时候会犯这样那样的错误，但是最终目的是不犯错误，不是么，那么好，从最基础的开始。
1、 如何在C中初始化一个字符数组。
这个问题看似很简单，但是我们要将最简单的问题用最严谨的态度来对待。关键的地方：初始化、字符型、数组。最简单的方法是char array[];。这个问题看似解决了，但是在初始化上好像还欠缺点什么，个人认为：char array[5]={'1','2','3','4','5'};或者char array[5]={"12345"};或者char array[2][10]={"China","Beijing"};也许更符合“初始化”的意思。
2、 如何在C中为一个数组分配空间。
最简单的方法是：char array[5]；意思是分配给数组array一个5个字节的空间。但是我们要知道在C中数组其实就是一个名字，其实质含义就是指针，比如char array[]；是到底分配的多少空间？所以我们要将其分成为两种不同的形式给出答案：
一种是栈的形式：char array[5]；
一种是堆的形式：char *array; array=(char *)malloc(5);//C++: array=new char[5];
堆和栈的含义其实我也没弄太透彻，改天明白了再发一篇。
我们要明白的是，第一种形式空间分配的大小可能会受操作系统的限制,比如windows会限制在2M；第二种形式成空间分配很灵活，想分配多少分配多少，只要RAM够大。
3、 如何初始化一个指针数组。
首先明确一个概念，就是指向数组的指针，和存放指针的数组。
指向数组的指针：char (*array)[5];含义是一个指向存放5个字符的数组的指针。
存放指针的数组：char *array[5];含义是一个数组中存放了5个指向字符型数据的指针。
按照题意，我理解为初始化一个存放指针的数组，char *array[2]={"China","Beijing"}；其含义是初始化了一个有两个指向字符型数据的指针的数组，这两个指针分别指向字符串"China"和"Beijing"。
4、如何定义一个有10个元素的整数型指针数组。
既然只是定义而不是初始化，那就很简单且没有争议了：int *array[10];。
5、 s[10]的另外一种表达方式是什么。
前面说过了，数组和指针其实是数据存在形态的两种表现形式，如果说对于数组s[]，我们知道*s=s[0]，那么s[10]的另一种表达方式就是：*(s+10)。
6、 GCC3.2.2版本中支持哪几种编程语言。
这个问题实在变态，就像问你#error的作用是什么一样。不可否认，gcc是linux下一个亮点，是一个备受无数程序员推崇的编译器，其优点省略1000字，有兴趣可以自己查，我翻了翻书，书上曰：支持C,C++,Java,Obj-C,Ada,Fortran,Pascal,Modula-3等语言，这个“等”比较要命，不过我认为已经很全了，如果认为还是不全，干脆把ASM也加上算了，不过那已经不算是编译了。
7、 要使用CHAR_BIT需要包含哪个头文件。
如果结合上面的问题，答题的人估计会认为自己撞鬼了，这个问题实在是……搜索了一下，应该是limits.h。
8、 对(-1.2345)取整是多少？
其实不同的取整函数可能有不同的结果，不过这个数没有太大的争议，答案是-1。
9、 如何让局部变量具有全局生命期。
具体的生命期的概念我觉得我还要好好深入的学习一下，但是这个题目还算比较简单，即用static修饰就可以了，但是只是生命期延长，范围并没有扩大，除非把这个变量定义在函数体外的静态区，不过那样就变成全局变量了，仿佛不符合题目要求。
10、C中的常量字符串应在何时定义？
这个问题说实话不是很理解题干的意思，据我理解，有两种情况，一种是预处理阶段，用#define定义；还有就是使用const修饰词，不过const修饰的是一个变量，其含义是“只读”，称之为常量并不准确，但是确实可以用操作变量的方法当常量用。所以还是第一种比较靠谱。
11、如何在两个.c文件中引用对方的变量。
这个问题也问的挺含糊的，怎么说呢，最简单最直接的方法是为变量添加extern修饰词，当然，这个变量必须是全局变量。还有一种就是利用函数调用来进行变量的间接引用，比如这个C文件中的一个函数引用另外一个C中的函数，将变量通过实参的形式传递过去。不过题目既然说是引用，那么还是用第一个答案好了。
12、使用malloc之前需要做什么准备工作。
其实准备工作很多啊，比如你需要一台计算机之类的。玩笑话，我们首先要知道malloc的用途，简单的说就是动态的分配一段空间，返回这段空间的头指针。实际的准备工作可以这么分：需要这段空间的指针是否存在，若不存在，则定义一个指针用来被赋值，还要清楚要返回一个什么类型的指针，分配的空间是否合理；如果指针已经存在，那么在重新将新的空间头地址赋值给这个指针之前，要先判断指针是否为NULL，如果不是要free一下，否则原来的空间就会被浪费，或者出错，free之后就按照前一种情形考虑就可以了。
13、realloc函数在使用上要注意什么问题。
这个函数我也才知道的，汗一个。据我的初步理解，这个函数的作用是重新分配空间大小，返回的头指针不变，只是改变空间大小。既然是改变，就有变大、变小和为什么改变的问题。变大，要注意不能大到内存溢出；变小，那变小的那部分空间会被征用，原有数据不再存在；为什么改变，如果是想重新挪作他用，还是先free了吧。
14、strtok函数在使用上要注意什么问题。
这个问题我不知道能不能回答全面，因为实在是用的很少。这个函数的作用是分割字符串，但是要分割的字符串不能是常量，这是要注意的。比如先定义一个字符串：char array[]="part1,part2";，strtok的原形是char *strtok(char *string, char *delim);，我们将","作为分隔符，先用pt=strtok(array,",");，得到的结果print出来就是"part1"，那后面的呢，要写成pt=strtok(NULL,",");，注意，要用NULL，如果被分割的字符串会被分成N段，那从第二次开始就一直要用NULL。总结起来，需要注意的是：被分割的字符串和分隔符都要使用变量；除第一次使用指向字符串的指针外，之后的都要使用NULL；注意使用这个函数的时候千万别把指针跟丢了，不然就全乱了。
15、gets函数在使用上要注意什么问题。
这是一个键盘输入函数，将输入字符串的头地址返回。说到要注意的问题，我还是先查了一下网上的一些情况，需要注意的就是gets以输入回车结束，这个地球人都知道，但是很多人不知道的是，当你输入完一个字符串后，这个字符串可能依然存在于这个标准输入流之中，当再次使用gets的时候，也许会把上次输入的东西读出来，所以应该在使用之后用fflush(stdin);处理一下，将输入流清空。最后也还是要注意溢出的问题。关于这个答案我比较含糊，不知道有没有高人高见？
16、C语言的词法分析在长度规则方面采用的是什么策略？
我无语……闻所未闻啊……还是搜索了一下，有一篇文章，地址是：http://202.117.80.9/jp2005/20/kcwz/wlkc/wlkc/03/3_5_2.htm，是关于词法分析器的。其中提到了两点策略： (1) 按最长匹配原则确定被选的词型；(2) 如果一个字符串能为若干个词型匹配，则排列在最前面的词型被选中。不知道是不是题干的要求，还是其他什么。我乃一介草民，望达人指点迷津！
17、a+++++b所表示的是什么意思？有什么问题？
这个东西（称之为东西一点都不过分）其实并没有语法错误，按照C对运算符等级的划分，++的优先级大于+，那么这句话会被编译器看做：(a++)+(++b)，这回明白了吧。有什么问题，语法上没有问题，有的是道德上的问题！作为一个优秀的程序员，我们要力求语句的合法性和可读性，如果写这句的人是在一个team里，那么他基本会被打的半死……最后讨论一下结果：假设a之前的值是3，b是4，那么运行完这个变态语句后，a的值是4，b是5，语句的结果是8。
18、如何定义Bool变量的TRUE和FALSE的值。
不知道这个题有什么陷阱，写到现在神经已经大了，一般来说先要把TURE和FALSE给定义了，使用#define就可以：
#define TURE 1
#define FALSE 0
如果有一个变量需要定义成bool型的，举个例子：bool a=TURE;就可以了。
19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
首先，这个题干抽了10题回答的一个大嘴巴。关于常量的概念看来我要好好看看书了……我说过了，const修饰词可以将一个变量修饰为“只读”，这个就能称为常量么？姑且认为可以。回到题目中，const是只读的意思，它限定一个变量不允许被改变，谁都不能改！既然是修饰变量，那么变量的类型就可以丰富多彩，int啊，char啊，只要C认识的都可以；但是#define就不可以了，在预处理阶段缺乏类型检测机制，有可能会出错。还有就是变量可以extern，但是#define就不可以。貌似const还可以节省RAM，这个我倒是没有考证过。至于const的用法和作用，有很多，我会总结后发上来。
20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。
终于最后一题了，容易么……如果这个测试是一个关于嵌入式的，那么这道题非常重要！！从词面上讲，volatile的意思是易变的，也就是说，在程序运行过程中，有一些变量可能会被莫名其妙的改变，而优化器为了节约时间，有时候不会重读这个变量的真实值，而是去读在寄存器的备份，这样的话，这个变量的真实值反而被优化器给“优化”掉了，用时髦的词说就是被“和谐”了。如果使用了这个修饰词，就是通知编译器别犯懒，老老实实去重新读一遍！可能我说的太“通俗”了，那么我引用一下“大师”的标准解释：
volatile的本意是“易变的” 。
由于访问寄存器的速度要快过RAM,所以编译器一般都会作减少存取外部RAM的优化，但有可能会读脏数据。当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2).一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。

在网上看到了一篇嵌入式的面试题，忽然觉得自己很渺小……在未来一段时间内我会陆续贴上我的答案，当然可能有些我做不出来，做出来的也不一定准确，在检验和提高自己的同时，希望有走过路过高人指点一二。

下面的题目必须全部答对才给分：
1、 如何在C中初始化一个字符数组。
2、 如何在C中为一个数组分配空间。
3、 如何初始化一个指针数组。
4、如何定义一个有10个元素的整数型指针数组。
5、 s[10]的另外一种表达方式是什么。
6、 GCC3.2.2版本中支持哪几种编程语言。
7、 要使用CHAR_BIT需要包含哪个头文件。
8、 对(-1.2345)取整是多少？
9、 如何让局部变量具有全局生命期。
10、C中的常量字符串应在何时定义？
11、如何在两个.c文件中引用对方的变量。
12、使用malloc之前需要做什么准备工作。
13、realloc函数在使用上要注意什么问题。
14、strtok函数在使用上要注意什么问题。
15、gets函数在使用上要注意什么问题。
16、C语言的词法分析在长度规则方面采用的是什么策略？
17、a+++++b所表示的是什么意思？有什么问题？
18、如何定义Bool变量的TRUE和FALSE的值。
19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。

这部分是ANSI C的一些问题，题目的前提是必须都答对，看似很变态，但是细想一下，这些都是最基础的，虽然我们在使用他们的时候会犯这样那样的错误，但是最终目的是不犯错误，不是么，那么好，从最基础的开始。



1、 如何在C中初始化一个字符数组。
这个问题看似很简单，但是我们要将最简单的问题用最严谨的态度来对待。关键的地方：初始化、字符型、数组。最简单的方法是char array[];。这个问题看似解决了，但是在初始化上好像还欠缺点什么，个人认为：char array[5]={'1','2','3','4','5'};或者char array[5]={"12345"};或者char array[2][10]={"China","Beijing"};也许更符合“初始化”的意思。



2、 如何在C中为一个数组分配空间。
最简单的方法是：char array[5]；意思是分配给数组array一个5个字节的空间。但是我们要知道在C中数组其实就是一个名字，其实质含义就是指针，比如char array[]；是到底分配的多少空间？所以我们要将其分成为两种不同的形式给出答案：
一种是栈的形式：char array[5]；
一种是堆的形式：char *array; array=(char *)malloc(5);//C++: array=new char[5];
堆和栈的含义其实我也没弄太透彻，改天明白了再发一篇。
我们要明白的是，第一种形式空间分配的大小可能会受操作系统的限制,比如windows会限制在2M；第二种形式成空间分配很灵活，想分配多少分配多少，只要RAM够大。



3、 如何初始化一个指针数组。
首先明确一个概念，就是指向数组的指针，和存放指针的数组。
指向数组的指针：char (*array)[5];含义是一个指向存放5个字符的数组的指针。
存放指针的数组：char *array[5];含义是一个数组中存放了5个指向字符型数据的指针。
按照题意，我理解为初始化一个存放指针的数组，char *array[2]={"China","Beijing"}；其含义是初始化了一个有两个指向字符型数据的指针的数组，这两个指针分别指向字符串"China"和"Beijing"。



4、如何定义一个有10个元素的整数型指针数组。
既然只是定义而不是初始化，那就很简单且没有争议了：int *array[10];。



5、 s[10]的另外一种表达方式是什么。
前面说过了，数组和指针其实是数据存在形态的两种表现形式，如果说对于数组s[]，我们知道*s=s[0]，那么s[10]的另一种表达方式就是：*(s+10)。



6、 GCC3.2.2版本中支持哪几种编程语言。
这个问题实在变态，就像问你#error的作用是什么一样。不可否认，gcc是linux下一个亮点，是一个备受无数程序员推崇的编译器，其优点省略1000字，有兴趣可以自己查，我翻了翻书，书上曰：支持C,C++,Java,Obj-C,Ada,Fortran,Pascal,Modula-3等语言，这个“等”比较要命，不过我认为已经很全了，如果认为还是不全，干脆把ASM也加上算了，不过那已经不算是编译了。



7、 要使用CHAR_BIT需要包含哪个头文件。
如果结合上面的问题，答题的人估计会认为自己撞鬼了，这个问题实在是……搜索了一下，应该是limits.h。



8、 对(-1.2345)取整是多少？
其实不同的取整函数可能有不同的结果，不过这个数没有太大的争议，答案是-1。



9、 如何让局部变量具有全局生命期。
具体的生命期的概念我觉得我还要好好深入的学习一下，但是这个题目还算比较简单，即用static修饰就可以了，但是只是生命期延长，范围并没有扩大，除非把这个变量定义在函数体外的静态区，不过那样就变成全局变量了，仿佛不符合题目要求。



10、C中的常量字符串应在何时定义？
这个问题说实话不是很理解题干的意思，据我理解，有两种情况，一种是预处理阶段，用#define定义；还有就是使用const修饰词，不过const修饰的是一个变量，其含义是“只读”，称之为常量并不准确，但是确实可以用操作变量的方法当常量用。所以还是第一种比较靠谱。



11、如何在两个.c文件中引用对方的变量。
这个问题也问的挺含糊的，怎么说呢，最简单最直接的方法是为变量添加extern修饰词，当然，这个变量必须是全局变量。还有一种就是利用函数调用来进行变量的间接引用，比如这个C文件中的一个函数引用另外一个C中的函数，将变量通过实参的形式传递过去。不过题目既然说是引用，那么还是用第一个答案好了。



12、使用malloc之前需要做什么准备工作。
其实准备工作很多啊，比如你需要一台计算机之类的。玩笑话，我们首先要知道malloc的用途，简单的说就是动态的分配一段空间，返回这段空间的头指针。实际的准备工作可以这么分：需要这段空间的指针是否存在，若不存在，则定义一个指针用来被赋值，还要清楚要返回一个什么类型的指针，分配的空间是否合理；如果指针已经存在，那么在重新将新的空间头地址赋值给这个指针之前，要先判断指针是否为NULL，如果不是要free一下，否则原来的空间就会被浪费，或者出错，free之后就按照前一种情形考虑就可以了。



13、realloc函数在使用上要注意什么问题。
这个函数我也才知道的，汗一个。据我的初步理解，这个函数的作用是重新分配空间大小，返回的头指针不变，只是改变空间大小。既然是改变，就有变大、变小和为什么改变的问题。变大，要注意不能大到内存溢出；变小，那变小的那部分空间会被征用，原有数据不再存在；为什么改变，如果是想重新挪作他用，还是先free了吧。



14、strtok函数在使用上要注意什么问题。
这个问题我不知道能不能回答全面，因为实在是用的很少。这个函数的作用是分割字符串，但是要分割的字符串不能是常量，这是要注意的。比如先定义一个字符串：char array[]="part1,part2";，strtok的原形是char *strtok(char *string, char *delim);，我们将","作为分隔符，先用pt=strtok(array,",");，得到的结果print出来就是"part1"，那后面的呢，要写成pt=strtok(NULL,",");，注意，要用NULL，如果被分割的字符串会被分成N段，那从第二次开始就一直要用NULL。总结起来，需要注意的是：被分割的字符串和分隔符都要使用变量；除第一次使用指向字符串的指针外，之后的都要使用NULL；注意使用这个函数的时候千万别把指针跟丢了，不然就全乱了。



15、gets函数在使用上要注意什么问题。
这是一个键盘输入函数，将输入字符串的头地址返回。说到要注意的问题，我还是先查了一下网上的一些情况，需要注意的就是gets以输入回车结束，这个地球人都知道，但是很多人不知道的是，当你输入完一个字符串后，这个字符串可能依然存在于这个标准输入流之中，当再次使用gets的时候，也许会把上次输入的东西读出来，所以应该在使用之后用fflush(stdin);处理一下，将输入流清空。最后也还是要注意溢出的问题。关于这个答案我比较含糊，不知道有没有高人高见？



16、C语言的词法分析在长度规则方面采用的是什么策略？
我无语……闻所未闻啊……还是搜索了一下，有一篇文章，地址是：http://202.117.80.9/jp2005/20/kcwz/wlkc/wlkc/03/3_5_2.htm，是关于词法分析器的。其中提到了两点策略： (1) 按最长匹配原则确定被选的词型；(2) 如果一个字符串能为若干个词型匹配，则排列在最前面的词型被选中。不知道是不是题干的要求，还是其他什么。我乃一介草民，望达人指点迷津！



17、a+++++b所表示的是什么意思？有什么问题？
这个东西（称之为东西一点都不过分）其实并没有语法错误，按照C对运算符等级的划分，++的优先级大于+，那么这句话会被编译器看做：(a++)+(++b)，这回明白了吧。有什么问题，语法上没有问题，有的是道德上的问题！作为一个优秀的程序员，我们要力求语句的合法性和可读性，如果写这句的人是在一个team里，那么他基本会被打的半死……最后讨论一下结果：假设a之前的值是3，b是4，那么运行完这个变态语句后，a的值是4，b是5，语句的结果是8。



18、如何定义Bool变量的TRUE和FALSE的值。
不知道这个题有什么陷阱，写到现在神经已经大了，一般来说先要把TURE和FALSE给定义了，使用#define就可以：
#define TURE 1
#define FALSE 0
如果有一个变量需要定义成bool型的，举个例子：bool a=TURE;就可以了。



19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
首先，这个题干抽了10题回答的一个大嘴巴。关于常量的概念看来我要好好看看书了……我说过了，const修饰词可以将一个变量修饰为“只读”，这个就能称为常量么？姑且认为可以。回到题目中，const是只读的意思，它限定一个变量不允许被改变，谁都不能改！既然是修饰变量，那么变量的类型就可以丰富多彩，int啊，char啊，只要C认识的都可以；但是#define就不可以了，在预处理阶段缺乏类型检测机制，有可能会出错。还有就是变量可以extern，但是#define就不可以。貌似const还可以节省RAM，这个我倒是没有考证过。至于const的用法和作用，有很多，我会总结后发上来。



20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。
终于最后一题了，容易么……如果这个测试是一个关于嵌入式的，那么这道题非常重要！！从词面上讲，volatile的意思是易变的，也就是说，在程序运行过程中，有一些变量可能会被莫名其妙的改变，而优化器为了节约时间，有时候不会重读这个变量的真实值，而是去读在寄存器的备份，这样的话，这个变量的真实值反而被优化器给“优化”掉了，用时髦的词说就是被“和谐”了。如果使用了这个修饰词，就是通知编译器别犯懒，老老实实去重新读一遍！可能我说的太“通俗”了，那么我引用一下“大师”的标准解释：
volatile的本意是“易变的” 。
由于访问寄存器的速度要快过RAM,所以编译器一般都会作减少存取外部RAM的优化，但有可能会读脏数据。当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。

好了，答完了，也不知道标准答案是什么。如果有达人看到皱眉头的话，千万停下来，浪费您宝贵的几分钟时间指点一二，不胜感激！

华为笔试题 
1.写出判断ABCD四个表达式的是否正确, 若正确, 写出经过表达式中 a的值(3分)
int a = 4;
(A)a += (a++); (B) a += (++a) ;(C) (a++) += a;(D) (++a) += (a++);
a = ?
答：C错误，左侧不是一个有效变量，不能赋值，可改为(++a) += a;
改后答案依次为9,10,10,11
2.某32位系统下, C++程序，请计算sizeof 的值(5分).
char str[] = “http://www.ibegroup.com/”
char *p = str ;
int n = 10;
请计算
sizeof (str ) = ？（1）
sizeof ( p ) = ？（2）
sizeof ( n ) = ？（3）
void Foo ( char str[100]){
请计算
sizeof( str ) = ？（4）
}
void *p = malloc( 100 );
请计算
sizeof ( p ) = ？（5）
答：（1）17 25 （2）4 （3） 4 （4）4 （5）4
3. 回答下面的问题. (4分)
(1).头文件中的 ifndef/define/endif 干什么用？预处理
答：防止头文件被重复引用
(2). ＃i nclude 和 ＃i nclude “filename.h” 有什么区别？
答：前者用来包含开发环境提供的库头文件，后者用来包含自己编写的头文件。
(3).在C++ 程序中调用被 C 编译器编译后的函数，为什么要加 extern “C”声明？
答：函数和变量被C++编译后在符号库中的名字与C语言的不同，被extern "C"修饰的变
量和函数是按照C语言方式编译和连接的。由于编译后的名字不同，C++程序不能直接调
用C 函数。C++提供了一个C 连接交换指定符号extern“C”来解决这个问题。
(4). switch()中不允许的数据类型是?
答：实型
4. 回答下面的问题(6分)
(1).Void GetMemory(char **p, int num){
*p = (char *)malloc(num);
}
void Test(void){
char *str = NULL;
GetMemory(&str, 100);
strcpy(str, "hello");
printf(str);
}
请问运行Test 函数会有什么样的结果？
答：输出“hello”
(2). void Test(void){
char *str = (char *) malloc(100);
strcpy(str, “hello”);
free(str);
if(str != NULL){
strcpy(str, “world”);
printf(str);
}
}
请问运行Test 函数会有什么样的结果？
答：输出“world”
(3). char *GetMemory(void){
char p[] = "hello world";
return p;
}
void Test(void){
char *str = NULL;
str = GetMemory();
printf(str);
}
请问运行Test 函数会有什么样的结果？
答：无效的指针，输出不确定
5. 编写strcat函数(6分)
已知strcat函数的原型是char *strcat (char *strDest, const char *strSrc);
其中strDest 是目的字符串，strSrc 是源字符串。
（1）不调用C++/C 的字符串库函数，请编写函数 strcat
答：
VC源码：
char * __cdecl strcat (char * dst, const char * src)
{
char * cp = dst;
while( *cp )
cp++; /* find end of dst */
while( *cp++ = *src++ ) ; /* Copy src to end of dst */
return( dst ); /* return dst */
}
（2）strcat能把strSrc 的内容连接到strDest，为什么还要char * 类型的返回值？
答：方便赋值给其他变量
6.MFC中CString是类型安全类么？
答：不是，其它数据类型转换到CString可以使用CString的成员函数Format来转换
7.C++中为什么用模板类。
答：(1)可用来创建动态增长和减小的数据结构
（2）它是类型无关的，因此具有很高的可复用性。
（3）它在编译时而不是运行时检查数据类型，保证了类型安全
（4）它是平台无关的，可移植性
（5）可用于基本数据类型
8.CSingleLock是干什么的。
答：同步多个线程对一个数据类的同时访问
9.NEWTEXTMETRIC 是什么。
答：物理字体结构，用来设置字体的高宽大小
10.程序什么时候应该使用线程，什么时候单线程效率高。
答：1．耗时的操作使用线程，提高应用程序响应
2．并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求。
3．多CPU系统中，使用线程提高CPU利用率
4．改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独
立的运行部分，这样的程序会利于理解和修改。
其他情况都使用单线程。
11.Windows是内核级线程么。
答：见下一题
12.Linux有内核级线程么?
答：线程通常被定义为一个进程中代码的不同执行路线。从实现方式上划分，线程有两
种类型：“用户级线程”和“内核级线程”。 用户线程指不需要内核支持而在用户程序
中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度
和管理线程的函数来控制用户线程。这种线程甚至在象 DOS 这样的操作系统中也可实现
，但线程的调度需要用户程序完成，这有些类似 Windows 3.x 的协作式多任务。另外一
种则需要内核的参与，由内核完成线程的调度。其依赖于操作系统核心，由内核的内部
需求进行创建和撤销，这两种模型各有其好处和缺点。用户线程不需要额外的内核开支
，并且用户态线程的实现方式可以被定制或修改以适应特殊应用的要求，但是当一个线
程因 I/O 而处于等待状态时，整个进程就会被调度程序切换为等待状态，其他线程得不
到运行的机会；而内核线程则没有各个限制，有利于发挥多处理器的并发优势，但却占
用了更多的系统开支。 
Windows NT和OS/2支持内核线程。Linux 支持内核级的多线程
13.C++中什么数据分配在栈或堆中，New分配数据是在近堆还是远堆中？
答：栈: 存放局部变量，函数调用参数,函数返回值，函数返回地址。由系统管理
堆: 程序运行时动态申请，new 和　malloc申请的内存就在堆上
14.使用线程是如何防止出现大的波峰。
答：意思是如何防止同时产生大量的线程，方法是使用线程池，线程池具有可以同时提
高调度效率和限制资源使用的好处，线程池中的线程达到最大数时，其他线程就会排队
等候。
15函数模板与类模板有什么区别？
答：函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化
必须由程序员在程序中显式地指定。
16一般数据库若出现日志满了，会出现什么情况，是否还能使用？
答：只能执行查询等读操作，不能执行更改，备份等写操作，原因是任何写操作都要记
录日志。也就是说基本上处于不能使用的状态。
17 SQL Server是否支持行级锁，有什么好处？
答：支持，设立封锁机制主要是为了对并发操作进行控制，对干扰进行封锁，保证数据
的一致性和准确性，行级封锁确保在用户取得被更新的行到该行进行更新这段时间内不
被其它用户所修改。因而行级锁即可保证数据的一致性又能提高数据操作的迸发性。
18如果数据库满了会出现什么情况，是否还能使用？
答：见16
19 关于内存对齐的问题以及sizof()的输出 
答：编译器自动对齐的原因：为了提高程序的性能，数据结构（尤其是栈）应该尽可能
地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问
；然而，对齐的内存访问仅需要一次访问。
20 int i=10, j=10, k=3; k*=i+j; k最后的值是？
答：60，此题考察优先级，实际写成： k*=(i+j);，赋值运算符优先级最低
21.对数据库的一张表进行操作,同时要对另一张表进行操作,如何实现?
答：将操作多个表的操作放入到事务中进行处理
22.TCP/IP 建立连接的过程?(3-way shake)
答：在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
　　第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状
态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个
SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
　　第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)
，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
23.ICMP是什么协议,处于哪一层?
答：Internet控制报文协议，处于网络层（IP层）
24.触发器怎么工作的?
答：触发器主要是通过事件进行触发而被执行的，当对某一表进行诸如UPDATE、 INSERT
、 DELETE 这些操作时，数据库就会自动执行触发器所定义的SQL 语句，从而确保对数
据的处理必须符合由这些SQL 语句所定义的规则。
25.winsock建立连接的主要实现步骤?
答：服务器端：socker()建立套接字，绑定（bind）并监听（listen），用accept（）
等待客户端连接。
客户端：socker()建立套接字，连接（connect）服务器，连接上后使用send()和recv（
），在套接字上写读数据，直至数据交换完毕，closesocket()关闭套接字。
服务器端：accept（）发现有客户端连接，建立一个新的套接字，自身重新开始等待连
接。该新产生的套接字使用send()和recv（）写读数据，直至数据交换完毕，closesock
et()关闭套接字。
26.动态连接库的两种方式?
答：调用一个DLL中的函数有两种方法：
1．载入时动态链接（load-time dynamic linking），模块非常明确调用某个导出函数
，使得他们就像本地函数一样。这需要链接时链接那些函数所在DLL的导入库，导入库向
系统提供了载入DLL时所需的信息及DLL函数定位。 
2．运行时动态链接（run-time dynamic linking），运行时可以通过LoadLibrary或Loa
dLibraryEx函数载入DLL。DLL载入后，模块可以通过调用GetProcAddress获取DLL函数的
出口地址，然后就可以通过返回的函数指针调用DLL函数了。如此即可避免导入库文件了
。
27.IP组播有那些好处?
答：Internet上产生的许多新的应用，特别是高带宽的多媒体应用，带来了带宽的急剧
消耗和网络拥挤问题。组播是一种允许一个或多个发送者（组播源）发送单一的数据包
到多个接收者（一次的，同时的）的网络技术。组播可以大大的节省网络带宽，因为无
论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包。所以说组播
技术的核心就是针对如何节约网络资源的前提下保证服务质量。
1.static有什么用途？（请至少说明两种）
    1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
    2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
    3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用
2.引用与指针有什么区别？
    1) 引用必须被初始化，指针不必。
    2) 引用初始化以后不能被改变，指针可以改变所指的对象。
    3) 不存在指向空值的引用，但是存在指向空值的指针。
3.描述实时系统的基本特性
       在特定时间内完成特定的任务，实时性与可靠性。
4.全局变量和局部变量在内存中是否有区别？如果有，是什么区别？
      全局变量储存在静态数据库，局部变量在堆栈。
5.什么是平衡二叉树？
      左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。
6.堆栈溢出一般是由什么原因导致的？
      没有回收垃圾资源。
7.什么函数不能声明为虚函数？
      constructor函数不能声明为虚函数。
8.冒泡排序算法的时间复杂度是什么？
      时间复杂度是O(n^2)。
9.写出float x 与“零值”比较的if语句。
      if(x>0.000001&&x<-0.000001)
10.Internet采用哪种网络协议？该协议的主要层次结构？
      Tcp/Ip协议
      主要层次结构为： 应用层/传输层/网络层/数据链路层/物理层。
11.Internet物理地址和IP地址转换采用什么协议？
      ARP (Address Resolution Protocol)（地址解析協議）
12.IP地址的编码分为哪俩部分？
     IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。
13.用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。
     循环链表，用取余操作做
14.不能做switch()的参数类型是：
     switch的参数不能为实型。
華為
1、局部变量能否和全局变量重名？
     答：能，局部会屏蔽全局。要用全局变量，需要使用"::"
局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。
2、如何引用一个已经定义过的全局变量？
     答：extern
     可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。
3、全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？
    答：可以，在不同的C文件中以static形式来声明同名全局变量。
    可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错。
4、语句for( ；1 ；)有什么问题？它是什么意思？
    答：无限循环，和while(1)相同。
5、do……while和while……do有什么区别？
    答：前一个循环一遍再判断，后一个判断以后再循环。
6、请写出下列代码的输出内容
＃i nclude<stdio.h>
main()
{
int a,b,c,d;
a=10;
b=a++;
c=++a;
d=10*a++;
printf("b，c，d：%d，%d，%d"，b，c，d）;
return 0;
} 
答：10，12，120
1、static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？
    答：全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。
    从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。
    static函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件
    static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;
    static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；
    static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝
2、程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。
3、设有以下说明和定义：
typedef union {long i; int k[5]; char c;} DATE;
struct data { int cat; DATE cow; double dog;} too;
DATE max;
则语句 printf("%d",sizeof(struct date)+sizeof(max));的执行结果是：___52____
    答：DATE是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20个字节. 所以它的大小是20
data是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32.
所以结果是 20 + 32 = 52.
当然...在某些16位编辑器下, int可能是2字节,那么结果是 int2 + DATE10 + double8 = 20
4、队列和栈有什么区别？
    队列先进先出，栈后进先出
5、写出下列代码的输出内容
＃i nclude<stdio.h>
int inc(int a)
{
return(++a);
}
int multi(int*a,int*b,int*c)
{
return(*c=*a**b);
}
typedef int(FUNC1)(int in);
typedef int(FUNC2) (int*,int*,int*);
void show(FUNC2 fun,int arg1, int*arg2)
{
INCp=&inc;
int temp =p(arg1);
fun(&temp,&arg1, arg2);
printf("%d\n",*arg2);
}
main()
{
int a;
show(multi,10,&a);
return 0;
}
答：110
7、请找出下面代码中的所以错误
说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba”
1、＃i nclude"string.h"
2、main()
3、{
4、 char*src="hello,world";
5、 char* dest=NULL;
6、 int len=strlen(src);
7、 dest=(char*)malloc(len);
8、 char* d=dest;
9、 char* s=src[len];
10、 while(len--!=0) 
11、 d++=s--;
12、 printf("%s",dest);
13、 return 0;
14、} 
答：
方法1：
int main(){
char* src = "hello,world";
int len = strlen(src);
char* dest = (char*)malloc(len+1);//要为\0分配一个空间
char* d = dest;
char* s = &src[len-1];//指向最后一个字符
while( len-- != 0 )
*d++=*s--;
*d = 0;//尾部要加\0
printf("%s\n",dest);
free(dest);// 使用完，应当释放空间，以免造成内存汇泄露
return 0;
}
方法2：
＃i nclude <stdio.h>
＃i nclude <string.h>
main()
{
char str[]="hello,world";
int len=strlen(str);
char t;
for(int i=0; i<len/2; i++)
{
t=str[i]; 
str[i]=str[len-i-1]; str[len-i-1]=t;
}
printf("%s",str);
return 0;
}
1.-1,2,7,28,,126请问28和126中间那个数是什么？为什么？
第一题的答案应该是4^3-1=63
规律是n^3-1(当n为偶数0，2，4)
      n^3+1(当n为奇数1，3，5)
答案：63
2.用两个栈实现一个队列的功能？要求给出算法和思路！
设2个栈为A,B, 一开始均为空.
入队:
将新元素push入栈A;
出队:
(1)判断栈B是否为空；
(2)如果不为空，则将栈A中所有元素依次pop出并push到栈B；
(3)将栈B的栈顶元素pop出；
这样实现的队列入队和出队的平摊复杂度都还是O(1), 比上面的几种方法要好。3.在c语言库函数中将一个字符转换成整型的函数是atool()吗，这个函数的原型是什么？
函数名: atol 
功 能: 把字符串转换成长整型数 
用 法: long atol(const char *nptr); 
程序例: 
＃i nclude <stdlib.h> 
＃i nclude <stdio.h> 
int main(void) 
{ 
long l; 
char *str = "98765432"; 
l = atol(lstr); 
printf("string = %s integer = %ld\n", str, l); 
return(0); 
}
2.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?
c用宏定义，c++用inline
  3.直接链接两个信令点的一组链路称作什么?
PPP点到点连接
  4.接入网用的是什么接口?
  5.voip都用了那些协议?
  6.软件测试都有那些种类?
黑盒：针对系统功能的测试    白合：测试函数功能，各函数接口
  7.确定模块的功能和模块的接口是在软件设计的那个队段完成的?
概要设计阶段
  8.enum string
    {
    x1,
    x2,
    x3=10,
    x4,
    x5,
    }x;
   问x= 0x801005，0x8010f4  ;
  9.unsigned char *p1;
    unsigned long *p2;
    p1=(unsigned char *)0x801000;
    p2=(unsigned long *)0x810000;
    请问p1+5=  ;
        p2+5=  ;
三.选择题:
  1.Ethternet链接到Internet用到以下那个协议?
  A.HDLC;B.ARP;C.UDP;D.TCP;E.ID
  2.属于网络层协议的是:
  A.TCP;B.IP;C.ICMP;D.X.25
  3.Windows消息调度机制是:
  A.指令队列;B.指令堆栈;C.消息队列;D.消息堆栈;
  4.unsigned short hash(unsigned short key)
    {
      return (key>>)%256
    }
   请问hash(16),hash(256)的值分别是:
  A.1.16;B.8.32;C.4.16;D.1.32
四.找错题:
  1.请问下面程序有什么错误?
   int a[60][250][1000],i,j,k;
   for(k=0;k<=1000;k++)
    for(j=0;j<250;j++)
     for(i=0;i<60;i++)
      a[i][j][k]=0;
把循环语句内外换一下
  2.#define Max_CB 500
    void LmiQueryCSmd(Struct MSgCB * pmsg)
     {
     unsigned char ucCmdNum;
     ......
    
     for(ucCmdNum=0;ucCmdNum<Max_CB;ucCmdNum++)
      {
      ......;
      }
死循环
   3.以下是求一个数的平方的程序,请找出错误:
    #define SQUARE(a)((a)*(a))
    int a=5;
    int b;
    b=SQUARE(a++);
   4.typedef unsigned char BYTE
     int examply_fun(BYTE gt_len; BYTE *gt_code)
      {  
      BYTE *gt_buf;
      gt_buf=(BYTE *)MALLOC(Max_GT_Length);
      ......
      if(gt_len>Max_GT_Length)
        {
        return GT_Length_ERROR;  
        }
        .......
      }
五.问答题:
   1.IP Phone的原理是什么?
IPV6
   2.TCP/IP通信建立的过程怎样，端口有什么作用？
三次握手，确定是哪个应用程序使用该协议
   3.1号信令和7号信令有什么区别，我国某前广泛使用的是那一种？
   4.列举5种以上的电话新业务？
微软亚洲技术中心的面试题！！！
1．进程和线程的差别。
线程是指进程内的一个执行单元,也是进程内的可调度实体.
与进程的区别:
(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源. 
(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。
2.测试方法 
人工测试：个人复查、抽查和会审
机器测试：黑盒测试和白盒测试
2．Heap与stack的差别。
Heap是堆，stack是栈。
Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。
Stack空间有限，Heap是很大的自由存储区
C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。
程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行
3．Windows下的内存是如何管理的？
4．介绍.Net和.Net的安全性。
5．客户端如何访问.Net组件实现Web Service？
6．C/C++编译器中虚表是如何完成的？
7．谈谈COM的线程模型。然后讨论进程内/外组件的差别。
8．谈谈IA32下的分页机制
小页(4K)两级分页模式，大页(4M)一级
9．给两个变量，如何找出一个带环单链表中是什么地方出现环的？
一个递增一，一个递增二，他们指向同一个接点时就是环出现的地方
10．在IA32中一共有多少种办法从用户态跳到内核态？
通过调用门，从ring3到ring0，中断从ring3到ring0，进入vm86等等
11．如果只想让程序有一个实例运行，不能运行两个。像winamp一样，只能开一个窗口，怎样实现？
用内存映射或全局原子（互斥变量）、查找窗口句柄.. 
FindWindow，互斥，写标志到文件或注册表,共享内存。.　  
12．如何截取键盘的响应，让所有的‘a’变成‘b’？
键盘钩子SetWindowsHookEx
　13．Apartment在COM中有什么用？为什么要引入？
　14．存储过程是什么？有什么用？有什么优点？
我的理解就是一堆sql的集合，可以建立非常复杂的查询，编译运行，所以运行一次后，以后再运行速度比单独执行SQL快很多
　15．Template有什么特点？什么时候用？
16．谈谈Windows DNA结构的特点和优点。

网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别？
1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。
2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
两者都可以提高程序的并发度，提高程序运行效率和响应时间。
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
思科
1. 用宏定义写出swap（x，y）
#define swap(x, y)\
x = x + y;\
y = x - y;\
x = x - y;
2.数组a[N]，存放了1至N-1个数，其中某个数重复一次。写一个函数，找出被重复的数字.时间复杂度必须为o（N）函数原型：
int do_dup(int a[],int N)
3 一语句实现x是否为2的若干次幂的判断
int i = 512;
cout << boolalpha << ((i & (i - 1)) ? false : true) << endl;
4.unsigned int intvert(unsigned int x,int p,int n)实现对x的进行转换,p为起始转化位,n为需要转换的长度,假设起始点在右边.如x=0b0001 0001,p=4,n=3转换后x=0b0110 0001
unsigned int intvert(unsigned int x,int p,int n){
unsigned int _t = 0;
unsigned int _a = 1;
for(int i = 0; i < n; ++i){
_t |= _a;
_a = _a << 1;
}
_t = _t << p;
x ^= _t;
return x;
}
慧通：
什么是预编译
何时需要预编译：
１、总是使用不经常改动的大型代码体。 
２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。
char * const p;
char const * p
const char *p
上述三个有什么区别？
char * const p; //常量指针，p的值不可以修改
char const * p；//指向常量的指针，指向的常量值不可以改
const char *p； //和char const *p
char str1[] = "abc";
char str2[] = "abc";
const char str3[] = "abc";
const char str4[] = "abc";
const char *str5 = "abc";
const char *str6 = "abc";
char *str7 = "abc";
char *str8 = "abc";

cout << ( str1 == str2 ) << endl;
cout << ( str3 == str4 ) << endl;
cout << ( str5 == str6 ) << endl;
cout << ( str7 == str8 ) << endl;
结果是：0 0 1 1
解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；
而str5,str6,str7,str8是指针，它们指向相同的常量区域。

12. 以下代码中的两个sizeof用法有问题吗？[C易]
void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母
{
    for( size_t i=0; i<sizeof(str)/sizeof(str[0]); ++i )
        if( 'a'<=str[i] && str[i]<='z' )
            str[i] -= ('a'-'A' );
}
char str[] = "aBcDe";
cout << "str字符长度为: " << sizeof(str)/sizeof(str[0]) << endl;
UpperCase( str );
cout << str << endl;
答：函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。
一个32位的机器,该机器的指针是多少位
指针是多少位只要看地址总线的位数就行了。80386以后的机子都是32的数据总线。所以指针的位数就是4个字节了。
main()
{
  int a[5]={1,2,3,4,5};
   int *ptr=(int *)(&a+1);
   printf("%d,%d",*(a+1),*(ptr-1));
}
输出：2,5
*(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5
&a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int）
int *ptr=(int *)(&a+1); 
则ptr实际是&(a[5]),也就是a+5
原因如下：
&a是数组指针，其类型为 int (*)[5];
而指针加1要根据指针类型加上一定的值，
不同类型的指针+1之后增加的大小不同
a是长度为5的int数组指针，所以要加 5*sizeof(int)
所以ptr实际是a[5]
但是prt与(&a+1)类型是不一样的(这点很重要)
所以prt-1只会减去sizeof(int*)
a,&a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5].

1.请问以下代码有什么问题：
int  main()
{
char a;
char *str=&a;
strcpy(str,"hello");
printf(str);
return 0;
}
没有为str分配内存空间，将会发生异常
问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。
char* s="AAA";
printf("%s",s);
s[0]='B';
printf("%s",s);
有什么错？
"AAA"是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。
cosnt char* s="AAA";
然后又因为是常量，所以对是s[0]的赋值操作是不合法的。
1、写一个“标准”宏，这个宏输入两个参数并返回较小的一个。
.#define Min(X, Y) ((X)>(Y)?(Y):(X))//结尾没有;
2、嵌入式系统中经常要用到无限循环，你怎么用C编写死循环。
while(1){}或者for(;;)
3、关键字static的作用是什么？
定义静态变量
4、关键字const有什么含意？
表示常量不可以修改的变量。
5、关键字volatile有什么含意？并举出三个不同的例子？
提示编译器对象的值可能在编译器未监测到的情况下改变。

int (*s[10])(int) 表示的是什么啊
int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。

1.有以下表达式：
int a=248; b=4;int const c=21;const int *d=&a;
int *const e=&b;int const *f const =&a;
请问下列表达式哪些会被编译器禁止？为什么？
*c=32;d=&b;*d=43;e=34;e=&a;f=0x321f;
*c 这是个什么东东，禁止
*d 说了是const， 禁止
e = &a 说了是const 禁止
const *f const =&a; 禁止
2.交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3;
有两种解法, 一种用算术算法, 一种用^(异或)
a = a + b;
b = a - b;
a = a - b; 
or
a = a^b;// 只能对int,char..
b = a^b;
a = a^b;
or
a ^= b ^= a;
3.c和c++中的struct有什么不同？
c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private
4.＃i nclude <stdio.h>
  ＃i nclude <stdlib.h>
  void getmemory(char *p)
  {
    p=(char *) malloc(100);
    strcpy(p,"hello world");
  }
  int main( )
  {
    char *str=NULL;
    getmemory(str);
    printf("%s/n",str);
    free(str);
    return 0;
   }
程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险
5.char szstr[10];
  strcpy(szstr,"0123456789");
  产生什么结果？为什么？
  长度不一样，会造成非法的OS
6.列举几种进程的同步机制，并比较其优缺点。
   原子操作 
信号量机制
   自旋锁
   管程，会合，分布式系统
7.进程之间通信的途径
共享存储系统
消息传递系统
管道：以文件系统为基础
11.进程死锁的原因
资源竞争及进程推进顺序非法
12.死锁的4个必要条件
互斥、请求保持、不可剥夺、环路
13.死锁的处理
鸵鸟策略、预防策略、避免策略、检测与解除死锁
15.   操作系统中进程调度策略有哪几种？
FCFS(先来先服务)，优先级，时间片轮转，多级反馈
8.类的静态成员和非静态成员有何区别？
类的静态成员每个类只有一个，非静态成员每个对象一个
9.纯虚函数如何定义？使用时应注意什么？
virtual void f()=0;
是接口，子类必须要实现
10.数组和链表的区别
数组：数据顺序存储，固定大小
连表：数据可以随机存储，大小可动态改变
12.ISO的七层模型是什么？tcp/udp是属于哪一层？tcp/udp有何优缺点？
应用层
表示层
会话层
运输层
网络层
物理链路层
物理层
tcp /udp属于运输层
TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。
与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。
tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好
udp: 不提供稳定的服务，包头小，开销小   

1：(void *)ptr 和 (*(void**))ptr的结果是否相同？其中ptr为同一个指针
.(void *)ptr 和 (*(void**))ptr值是相同的
2：int main()
   {
    int x=3;
    printf("%d",x);
    return 1;
   
   }
问函数既然不会被其它函数调用，为什么要返回1？
mian中，c标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息

1，要对绝对地址0x100000赋值，我们可以用
(unsigned int*)0x100000 = 1234;
那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？
*((void (*)( ))0x100000 ) ( );
首先要将0x100000强制转换成函数指针,即:
(void (*)())0x100000
然后再调用它:
*((void (*)())0x100000)();
用typedef可以看得更直观些:
typedef void(*)() voidFuncPtr;
*((voidFuncPtr)0x100000)();
2，已知一个数组table，用一个宏定义，求出数据的元素个数
#define NTBL
#define NTBL (sizeof(table)/sizeof(table[0]))
面试题: 线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈?
进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。
每个线程有自己的堆栈。
DLL中有没有独立的堆栈，这个问题不好回答，或者说这个问题本身是否有问题。因为DLL中的代码是被某些线程所执行，只有线程拥有堆栈，如果DLL中的代码是EXE中的线程所调用，那么这个时候是不是说这个DLL没有自己独立的堆栈？如果DLL中的代码是由DLL自己创建的线程所执行，那么是不是说DLL有独立的堆栈？
以上讲的是堆栈，如果对于堆来说，每个DLL有自己的堆，所以如果是从DLL中动态分配的内存，最好是从DLL中删除，如果你从DLL中分配内存，然后在EXE中，或者另外一个DLL中删除，很有可能导致程序崩溃

unsigned short A = 10;
printf("~A = %u\n", ~A);
char c=128; 
printf("c=%d\n",c);
输出多少？并分析过程
第一题，～A ＝0xfffffff5,int值 为－11，但输出的是uint。所以输出4294967285
第二题，c＝0x10,输出的是int，最高位为1，是负数，所以它的值就是0x00的补码就是128，所以输出－128。
这两道题都是在考察二进制向int或uint转换时的最高位处理。
分析下面的程序：
void GetMemory(char **p,int num)
{
    *p=(char *)malloc(num);
    
}        
int main()
{
    char *str=NULL;
    
    GetMemory(&str,100);
    
    strcpy(str,"hello");
    
    free(str);
    
    if(str!=NULL)
    {
        strcpy(str,"world");
    }    
        
    printf("\n str is %s",str);
    getchar();
}    
问输出结果是什么？希望大家能说说原因，先谢谢了
输出str is world。
free 只是释放的str指向的内存空间,它本身的值还是存在的.
所以free之后，有一个好的习惯就是将str=NULL.
此时str指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储空间是可能被重新分配给其他变量的,
尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出world来。
这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。
当你malloc一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继续访问这块地址的，只不过。。。。。。。。楼上都说过了，最好别这么干。
char a[10],strlen(a)为什么等于15？运行的结果
＃i nclude "stdio.h"
＃i nclude "string.h"
void main()
{
char aa[10];
printf("%d",strlen(aa));
}
sizeof()和初不初始化，没有关系；
strlen()和初始化有关。

char (*str)[20];/*str是一个数组指针，即指向数组的指针．*/
char *str[20];/*str是一个指针数组，其元素为指针型数据．*/
long a=0x801010;
a+5=?
0x801010用二进制表示为：“1000 0000 0001 0000 0001 0000”，十进制的值为8392720，再加上5就是8392725罗
1)给定结构struct A 
{
       char t:4;
       char k:4;
       unsigned short i:8;
       unsigned long m;
};问sizeof(A) = ?
给定结构struct A 
{
       char t:4; 4位
       char k:4; 4位
       unsigned short i:8; 8位      
       unsigned long m; // 偏移2字节保证4字节对齐
}; // 共8字节
2)下面的函数实现在一个数上加一个数，有什么错误？请改正。
int add_n ( int n )
{
    static int i = 100;
    i += n;
    return i;
}
当你第二次调用时得不到正确的结果，难道你写个函数就是为了调用一次？问题就出在 static上？

// 帮忙分析一下
＃i nclude<iostream.h>
＃i nclude <string.h>
＃i nclude <malloc.h>
＃i nclude <stdio.h>
＃i nclude <stdlib.h>
＃i nclude <memory.h>
typedef struct  AA
{
        int b1:5;
        int b2:2;
}AA;
void main()
{
        AA aa;
        char cc[100];
         strcpy(cc,"0123456789abcdefghijklmnopqrstuvwxyz");
       memcpy(&aa,cc,sizeof(AA));
        cout << aa.b1 <<endl;
        cout << aa.b2 <<endl;
}
答案是 -16和１
首先sizeof(AA)的大小为4,b1和b2分别占5bit和2bit.
经过strcpy和memcpy后,aa的4个字节所存放的值是:
0,1,2,3的ASC码，即00110000,00110001,00110010,00110011
所以，最后一步：显示的是这４个字节的前５位，和之后的２位
分别为：10000,和01
因为int是有正负之分　　所以：答案是-16和１
求函数返回值，输入x=9999; 
int func （ x ）
{ 
    int countx = 0; 
    while ( x ) 
    { 
        countx ++; 
        x = x&(x-1); 
    } 
    return countx; 
} 
结果呢？
知道了这是统计9999的二进制数值中有多少个1的函数，且有
9999＝9×1024＋512＋256＋15
9×1024中含有1的个数为2；
512中含有1的个数为1；
256中含有1的个数为1；
15中含有1的个数为4；
故共有1的个数为8，结果为8。
1000 - 1 = 0111，正好是原数取反。这就是原理。
用这种方法来求1的个数是很效率很高的。
不必去一个一个地移位。循环次数最少。
int a,b,c 请写函数实现C=a+b ,不可以改变数据类型,如将c改为long int,关键是如何处理溢出问题
bool add (int a, int b,int *c)
{
*c=a+b;
return (a>0 && b>0 &&(*c<a || *c<b) || (a<0 && b<0 &&(*c>a || *c>b)));
}

分析：
struct bit 
{   int a:3; 
    int  b:2; 
    int c:3; 
}; 
int main() 
{ 
  bit s; 
  char *c=(char*)&s; 
   cout<<sizeof(bit)<<endl;
  *c=0x99;
   cout << s.a <<endl <<s.b<<endl<<s.c<<endl; 
     int a=-1;
   printf("%x",a);
  return 0; 
} 
输出为什么是
4
1
-1
-4
ffffffff
因为0x99在内存中表示为 100 11 001 , a = 001, b = 11, c = 100
当c为有符合数时, c = 100, 最高1为表示c为负数，负数在计算机用补码表示，所以c = -4;同理 
b = -1;
当c为有符合数时, c = 100,即 c = 4,同理 b = 3

位域 ：   
有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：     
struct 位域结构名     
{ 位域列表 };    
其中位域列表的形式为： 类型说明符 位域名：位域长度     
例如：     
struct bs    
{    
int a:8;    
int b:2;    
int c:6;    
};    
位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。例如：     
struct bs    
{    
int a:8;    
int b:2;    
int c:6;    
}data;    
说明data为bs变量，共占两个字节。其中位域a占8位，位域b占2位，位域c占6位。对于位域的定义尚有以下几点说明：    
1. 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：     
struct bs    
{    
unsigned a:4    
unsigned :0 /*空域*/    
unsigned b:4 /*从下一单元开始存放*/    
unsigned c:4    
}    
在这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。    
2. 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。    
3. 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：     
struct k    
{    
int a:1    
int :2 /*该2位不能使用*/    
int b:3    
int c:2    
};    
从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。    
二、位域的使用位域的使用和结构成员的使用相同，其一般形式为： 位域变量名&#8226;位域名 位域允许用各种格式输出。    
main(){    
struct bs    
{    
unsigned a:1;    
unsigned b:3;    
unsigned c:4;    
} bit,*pbit;    
bit.a=1;    
bit.b=7;    
bit.c=15;    
pri
改错：
＃i nclude <stdio.h>
int main(void) {
    int **p;
    int arr[100];
    p = &arr;
    return 0;
}
解答：
搞错了,是指针类型不同,
int **p; //二级指针
&arr; //得到的是指向第一维为100的数组的指针
＃i nclude <stdio.h>
int main(void) {
int **p, *q;
int arr[100];
q = arr;
p = &q;
return 0;
}

下面这个程序执行后会有什么错误或者效果:
 #define MAX 255
 int main()
{
   unsigned char A[MAX],i;//i被定义为unsigned char
   for (i=0;i<=MAX;i++)
      A[i]=i;
}
解答：死循环加数组越界访问（C/C++不进行数组越界检查）
MAX=255 
数组A的下标范围为:0..MAX-1,这是其一..
其二.当i循环到255时,循环内执行:
  A[255]=255;
这句本身没有问题..但是返回for (i=0;i<=MAX;i++)语句时,
由于unsigned char的取值范围在(0..255),i++以后i又为0了..无限循环下去.
struct name1{
   char  str;
   short x;
   int   num;
}
struct name2{
   char str;
   int num;
   short x;
}
sizeof(struct name1)=8,sizeof(struct name2)=12
在第二个结构中，为保证num按四个字节对齐，char后必须留出3字节的空间；同时为保证整个结构的自然对齐（这里是4字节对齐），在x后还要补齐2个字节，这样就是12字节。
intel：
A.c 和B.c两个c文件中使用了两个相同名字的static变量,编译的时候会不会有问题?这两个static变量会保存到哪里（栈还是堆或者其他的）?
static的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。
他们都放在数据区，但是编译器对他们的命名是不同的。
如果要使变量在其他模块也有意义的话，需要使用extern关键字。
struct s1
{
  int i: 8;
  int j: 4;
  int a: 3;
  double b;
};
struct s2
{
  int i: 8;
  int j: 4;
  double b;
  int a:3;
};
printf("sizeof(s1)= %d\n", sizeof(s1));
printf("sizeof(s2)= %d\n", sizeof(s2));
result: 16, 24
第一个struct s1
{
  int i: 8;
  int j: 4;
  int a: 3;
  double b;
};
理论上是这样的，首先是i在相对0的位置，占8位一个字节，然后，j就在相对一个字节的位置，由于一个位置的字节数是4位的倍数，因此不用对齐，就放在那里了，然后是a，要在3位的倍数关系的位置上，因此要移一位，在15位的位置上放下，目前总共是18位，折算过来是2字节2位的样子，由于double是8字节的，因此要在相对0要是8个字节的位置上放下，因此从18位开始到8个字节之间的位置被忽略，直接放在8字节的位置了，因此，总共是16字节。
第二个最后会对照是不是结构体内最大数据的倍数，不是的话，会补成是最大数据的倍数
上面是基本问题，接下来是编程问题：

本人很弱，这几个题也搞不定，特来求救：
1）读文件file1.txt的内容（例如）：
12
34
56
输出到file2.txt：
56
34
12
（逆序）
2）输出和为一个给定整数的所有组合
例如n=5
5=1+4；5=2+3（相加的数不能重复）
则输出
1，4；2，3。
望高手赐教！！
第一题,注意可增长数组的应用.
＃i nclude <stdio.h>
＃i nclude <stdlib.h>
int main(void)
{
         int MAX = 10;
int *a = (int *)malloc(MAX * sizeof(int));
int *b;
    
FILE *fp1;
FILE *fp2;
fp1 = fopen("a.txt","r");
if(fp1 == NULL)
{printf("error1");
    exit(-1);
}
    fp2 = fopen("b.txt","w");
if(fp2 == NULL)
{printf("error2");
    exit(-1);
}
int i = 0;
    int j = 0;
while(fscanf(fp1,"%d",&a[i]) != EOF)
{
i++;
j++;
if(i >= MAX)
{
MAX = 2 * MAX;
b = (int*)realloc(a,MAX * sizeof(int));
if(b == NULL)
{
printf("error3");
exit(-1);
}
a = b;
}
}
for(;--j >= 0;)
   fprintf(fp2,"%d\n",a[j]);
fclose(fp1);
fclose(fp2);
return 0;
}
第二题.
＃i nclude <stdio.h>
int main(void)
{
unsigned long int i,j,k;
printf("please input the number\n");
scanf("%d",&i);
    if( i % 2 == 0)
        j = i / 2;
else
j = i / 2 + 1;
printf("The result is \n");
    for(k = 0; k < j; k++)
     printf("%d = %d + %d\n",i,k,i - k);
return 0;
}
＃i nclude <stdio.h>
void main()
{
unsigned long int a,i=1;
scanf("%d",&a);
if(a%2==0)
{
     for(i=1;i<a/2;i++)
     printf("%d",a,a-i);
}
else
for(i=1;i<=a/2;i++)
        printf(" %d, %d",i,a-i);
}
兄弟,这样的题目若是做不出来实在是有些不应该, 给你一个递规反向输出字符串的例子,可谓是反序的经典例程.
void inverse(char *p)
{
    if( *p = = '\0' ) 
return;
    inverse( p+1 );
    printf( "%c", *p );
}
int main(int argc, char *argv[])
{
    inverse("abc\0");
    return 0;
}
借签了楼上的“递规反向输出”
＃i nclude <stdio.h>
void test(FILE *fread, FILE *fwrite)
{
        char buf[1024] = {0};
        if (!fgets(buf, sizeof(buf), fread))
    &nb

1、  如何在C中初始化一个字符数组。
这个问题看似很简单，但是我们要将最简单的问题用最严谨的态度来对待。关键的地方：初始化、字符型、数组。最简单的方法是char 
array[];。这个问题看似解决了，但是在初始化上好像还欠缺点什么，个人认为：char 
array[5]={'1','2','3','4','5'};或者char 
array[5]={"12345"};或者char 
array[2][10]={"China","Beijing"};也许更符合“初始化”的意思。

2、 如何在C中为一个数组分配空间。
最简单的方法是：char 
array[5]；意思是分配给数组array一个5个字节的空间。但是我们要知道在C中数组其实就是一个名字，其实质含义就是指针，比如char 
array[]；是到底分配的多少空间？所以我们要将其分成为两种不同的形式给出答案：
一种是栈的形式：char array[5]；
一种是堆的形式：char *array; array=(char 
*)malloc(5);//C++: array=new char[5];
堆和栈的含义其实我也没弄太透彻，改天明白了再发一篇。
我们要明白的是，第一种形式空间分配的大小可能会受操作系统的限制,比如windows会限制在2M；第二种形式成空间分配很灵活，想分配多少分配多少，只要RAM够大。
3、 如何初始化一个指针数组。
首先明确一个概念，就是指向数组的指针，和存放指针的数组。
指向数组的指针：char (*array)[5];含义是一个指向存放5个字符的数组的指针。
存放指针的数组：char *array[5];含义是一个数组中存放了5个指向字符型数据的指针。
按照题意，我理解为初始化一个存放指针的数组，char 
*array[2]={"China","Beijing"}；其含义是初始化了一个有两个指向字符型数据的指针的数组，这两个指针分别指向字符串"China"和"Beijing"。
4、如何定义一个有10个元素的整数型指针数组。
既然只是定义而不是初始化，那就很简单且没有争议了：int *array[10];。
5、 s[10]的另外一种表达方式是什么。
前面说过了，数组和指针其实是数据存在形态的两种表现形式，如果说对于数组s[]，我们知道*s=s[0]，那么s[10]的另一种表达方式就是：*(s+10)。
6、 GCC3.2.2版本中支持哪几种编程语言。
这个问题实在变态，就像问你#error的作用是什么一样。不可否认，gcc是linux下一个亮点，是一个备受无数程序员推崇的编译器，其优点省略 
1000字，有兴趣可以自己查，我翻了翻书，书上曰：支持C,C++,Java,Obj-C,Ada,Fortran,Pascal,Modula-3等语言，这个“等”比较要命，不过我认为已经很全了，如果认为还是不全，干脆把ASM也加上算了，不过那已经不算是编译了。
7、 要使用CHAR_BIT需要包含哪个头文件。
如果结合上面的问题，答题的人估计会认为自己撞鬼了，这个问题实在是……搜索了一下，应该是limits.h。
8、 对(-1.2345)取整是多少？
其实不同的取整函数可能有不同的结果，不过这个数没有太大的争议，答案是-1。
9、 如何让局部变量具有全局生命期。
具体的生命期的概念我觉得我还要好好深入的学习一下，但是这个题目还算比较简单，即用static修饰就可以了，但是只是生命期延长，范围并没有扩大，除非把这个变量定义在函数体外的静态区，不过那样就变成全局变量了，仿佛不符合题目要求。
10、C中的常量字符串应在何时定义？
这个问题说实话不是很理解题干的意思，据我理解，有两种情况，一种是预处理阶段，用#define定义；还有就是使用const修饰词，不过const修饰的是一个变量，其含义是“只读”，称之为常量并不准确，但是确实可以用操作变量的方法当常量用。所以还是第一种比较靠谱。
11、如何在两个.c文件中引用对方的变量。
这个问题也问的挺含糊的，怎么说呢，最简单最直接的方法是为变量添加extern修饰词，当然，这个变量必须是全局变量。还有一种就是利用函数调用来进行变量的间接引用，比如这个C文件中的一个函数引用另外一个C中的函数，将变量通过实参的形式传递过去。不过题目既然说是引用，那么还是用第一个答案好了。
12、使用malloc之前需要做什么准备工作。
其实准备工作很多啊，比如你需要一台计算机之类的。玩笑话，我们首先要知道malloc的用途，简单的说就是动态的分配一段空间，返回这段空间的头指针。实际的准备工作可以这么分：需要这段空间的指针是否存在，若不存在，则定义一个指针用来被赋值，还要清楚要返回一个什么类型的指针，分配的空间是否合理；如果指针已经存在，那么在重新将新的空间头地址赋值给这个指针之前，要先判断指针是否为NULL，如果不是要free一下，否则原来的空间就会被浪费，或者出错，free之后就按照前一种情形考虑就可以了。
13、realloc函数在使用上要注意什么问题。
这个函数我也才知道的，汗一个。据我的初步理解，这个函数的作用是重新分配空间大小，返回的头指针不变，只是改变空间大小。既然是改变，就有变大、变小和为什么改变的问题。变大，要注意不能大到内存溢出；变小，那变小的那部分空间会被征用，原有数据不再存在；为什么改变，如果是想重新挪作他用，还是先free了吧。
14、strtok函数在使用上要注意什么问题。
这个问题我不知道能不能回答全面，因为实在是用的很少。这个函数的作用是分割字符串，但是要分割的字符串不能是常量，这是要注意的。比如先定义一个字符串：char 
array[]="part1,part2";，strtok的原形是char *strtok(char 
*string, char 
*delim);，我们将","作为分隔符，先用pt=strtok(array,",");，得到的结果print出来就是"part1"，那后面的呢，要写成pt=strtok(NULL,",");，注意，要用NULL，如果被分割的字符串会被分成N段，那从第二次开始就一直要用NULL。总结起来，需要注意的是：被分割的字符串和分隔符都要使用变量；除第一次使用指向字符串的指针外，之后的都要使用NULL；注意使用这个函数的时候千万别把指针跟丢了，不然就全乱了。
15、gets函数在使用上要注意什么问题。
这是一个键盘输入函数，将输入字符串的头地址返回。说到要注意的问题，我还是先查了一下网上的一些情况，需要注意的就是gets以输入回车结束，这个地球人都知道，但是很多人不知道的是，当你输入完一个字符串后，这个字符串可能依然存在于这个标准输入流之中，当再次使用gets的时候，也许会把上次输入的东西读出来，所以应该在使用之后用fflush(stdin);处理一下，将输入流清空。最后也还是要注意溢出的问题。关于这个答案我比较含糊，不知道有没有高人高见？
16、C语言的词法分析在长度规则方面采用的是什么策略？
关于词法分析器的。其中提到了两点策略： 
1) 按最长匹配原则确定被选的词型；(2) 如果一个字符串能为若干个词型匹配，则排列在最前面的词型被选中。
17、a+++++b所表示的是什么意思？有什么问题？
这个东西（称之为东西一点都不过分）其实并没有语法错误，按照C对运算符等级的划分，++的优先级大于+，那么这句话会被编译器看做：(a++)+(++b)，这回明白了吧。有什么问题，语法上没有问题，有的是道德上的问题！作为一个优秀的程序员，我们要力求语句的合法性和可读性，如果写这句的人是在一个 team里，那么他基本会被打的半死……最后讨论一下结果：假设a之前的值是3，b是4，那么运行完这个变态语句后，a的值是4，b是5，语句的结果是 8。
18、如何定义Bool变量的TRUE和FALSE的值。
不知道这个题有什么陷阱，写到现在神经已经大了，一般来说先要把TURE和FALSE给定义了，使用#define就可以：
#define TURE 1
#define FALSE 0
如果有一个变量需要定义成bool型的，举个例子：bool a=TURE;就可以了。
19、C语言的const的含义是什么。在定义常量时，为什么推荐使用const，而不是#define。
首先，这个题干抽了10题回答的一个大嘴巴。关于常量的概念看来我要好好看看书了……我说过了，const修饰词可以将一个变量修饰为“只读”，这个就能称为常量么？姑且认为可以。回到题目中，const是只读的意思，它限定一个变量不允许被改变，谁都不能改！既然是修饰变量，那么变量的类型就可以丰富多彩，int啊，char啊，只要C认识的都可以；但是#define就不可以了，在预处理阶段缺乏类型检测机制，有可能会出错。还有就是变量可以 extern，但是#define就不可以。貌似const还可以节省RAM，这个我倒是没有考证过。至于const的用法和作用，有很多，我会总结后发上来。
20、C语言的volatile的含义是什么。使用时会对编译器有什么暗示。
终于最后一题了，容易么……如果这个测试是一个关于嵌入式的，那么这道题非常重要！！从词面上讲，volatile的意思是易变的，也就是说，在程序运行过程中，有一些变量可能会被莫名其妙的改变，而优化器为了节约时间，有时候不会重读这个变量的真实值，而是去读在寄存器的备份，这样的话，这个变量的真实值反而被优化器给“优化”掉了，用时髦的词说就是被“和谐”了。如果使用了这个修饰词，就是通知编译器别犯懒，老老实实去重新读一遍！可能我说的太“通俗”了，那么我引用一下“大师”的标准解释：
volatile的本意是“易变的” 。
由于访问寄存器的速度要快过RAM,所以编译器一般都会作减少存取外部RAM的优化，但有可能会读脏数据。当要求使用volatile声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
下面是volatile变量的几个例子：
1). 并行设备的硬件寄存器（如：状态寄存器）
2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3). 多线程应用中被几个任务共享的变量
嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。
嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。
Volatile的完全扩展：
    1). 一个参数既可以是const还可以是volatile吗？解释为什么。
是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
    2). 一个指针可以是volatile 吗？解释为什么。
是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
    3). 下面的函数有什么错误：
         int square(volatile int *ptr)
         {
              return *ptr * *ptr;
         }
    这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
    int square(volatile int *ptr) 
    {
         int a,b;
         a = *ptr;
         b = *ptr;
         return a * b;
     }
    由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：
     long square(volatile int *ptr) 
     {
            int a;
            a = *ptr;
            return a * a;
     } 

1.是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态?
virtual修饰符会被隐形继承的。private 也被集成，只事派生类没有访问权限而已。virtual可加可不加。子类的空间里有父类的所有变量(static除外)。同一个函数只存在一个实体(inline除外)。子类覆盖它的函数不加virtual ,也能实现多态。在子类的空间里，有父类的私有变量。私有变量不能直接访问。

--------------------------------------------------------------------------
2.输入一个字符串，将其逆序后输出。（使用C++，不建议用伪码）
#include <iostream>
using namespace std;

void main()
{
  char a[50];memset(a,0,sizeof(a));
  int i=0,j;
  char t;
  cin.getline(a,50,&apos;\n&apos;);
  for(i=0,j=strlen(a)-1;i<strlen(a)/2;i++,j--)
  {
   t=a[i];
      a[i]=a[j];
   a[j]=t;
  }
  cout<<a<<endl;  
}
//第二种
string str;
cin>>str;
str.replace;
cout<<str;

--------------------------------------------------------------------------
3.请简单描述Windows内存管理的方法。
内存管理是操作系统中的重要部分，两三句话恐怕谁也说不清楚吧～～
我先说个大概，希望能够抛砖引玉吧
当程序运行时需要从内存中读出这段程序的代码。代码的位置必须在物理内存中才能被运行，由于现在的操作系统中有非常多的程序运行着，内存中不能够完全放下，所以引出了虚拟内存的概念。把哪些不常用的程序片断就放入虚拟内存，当需要用到它的时候在load入主存（物理内存）中。这个就是内存管理所要做的事。内存管理还有另外一件事需要做：计算程序片段在主存中的物理位置，以便CPU调度。
内存管理有块式管理，页式管理，段式和段页式管理。现在常用段页式管理
块式管理：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程 序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了50％的内存空间，但时易于管理。
页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。
段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。一个程序片断可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上（计算机最耗时间的大家都知道是I/O吧）。
段页式管理：结合了段式管理和页式管理的优点。把主存分为若干页，每一页又分为若干段。好处就很明显，不用我多说了吧。
各种内存管理都有它自己的方法来计算出程序片断在主存中的物理地址，其实都很相似。
这只是一个大概而已，不足以说明内存管理的皮毛。无论哪一本操作系统书上都有详细的讲解

--------------------------------------------------------------------------
4.
#include "stdafx.h"
#define SQR(X) X*X
int main(int argc, char* argv[])
{
 int a = 10;
 int k = 2;
 int m = 1;
 a /= SQR(k+m)/SQR(k+m); 
 printf("%d\n",a); 
 return 0;
}
这道题目的结果是什么啊?
define 只是定义而已，在编择时只是简单代换X*X而已，并不经过算术法则的
a /= (k+m)*(k+m)/(k+m)*(k+m);
=>a /= (k+m)*1*(k+m);
=>a = a/9;
=>a = 1;
--------------------------------------------------------------------------
5.
const 符号常量；
(1)const char *p
(2)char const *p
(3)char * const p
说明上面三种描述的区别；

如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。
const char *p; //和char const *p一样
char const * p;//指向常量的指针，指向的常量值不可以改
char * const p; //常量指针，p的值不可以修改
--------------------------------------------------------------------------
6.下面是C语言中两种if语句判断方式。请问哪种写法更好？为什么？
 int n;
 if (n == 10) // 第一种判断方式
 if (10 == n) // 第二种判断方式
如果少了个=号,编译时就会报错,减少了出错的可能行,可以检测出是否少了=
--------------------------------------------------------------------------
7.下面的代码有什么问题？
void DoSomeThing(...)
{
 char* p;
 ...
 p = malloc(1024);  // 分配1K的空间
 if (NULL == p)
  return;
 ...
 p = realloc(p, 2048); // 空间不够，重新分配到2K
 if (NULL == p)
  return;
 ...
}
A:
p = malloc(1024);     应该写成： p = (char *) malloc(1024); 
        没有释放p的空间，造成内存泄漏。

--------------------------------------------------------------------------
8.下面的代码有什么问题？并请给出正确的写法。
void DoSomeThing(char* p)
{
 char str[16];
 int n;
 assert(NULL != p);
 sscanf(p, "%s%d", str, n);
 if (0 == strcmp(str, "something"))
 {
  ...
 }
}
A:
sscanf(p, "%s%d", str, n);   这句该写成： sscanf(p, "%s%d", str, &n);
--------------------------------------------------------------------------
9.下面代码有什么错误?
Void test1() 
{ 
 char string[10]; 
 char *str1="0123456789";
 strcpy(string, str1); 
} 
数组越界
--------------------------------------------------------------------------
10.下面代码有什么问题?
Void test2() 
{ 
  char string[10], str1[10]; 
  for(i=0; i<10;i++) 
  { 
     str1[i] =&apos;a&apos;; 
  } 
  strcpy(string, str1); 
} 
数组越界
--------------------------------------------------------------------------
11.下面代码有什么问题?
Void test3(char* str1) 
{ 
  char string[10]; 
  if(strlen(str1)<=10) 
  { 
    strcpy(string, str1); 
  } 
} 
==数组越界
==strcpy拷贝的结束标志是查找字符串中的\0 因此如果字符串中没有遇到\0的话 会一直复制，直到遇到\0,上面的123都因此产生越界的情况
 
建议使用 strncpy 和 memcpy
--------------------------------------------------------------------------
12.下面代码有什么问题?
#define MAX_SRM 256 
DSN get_SRM_no() 
{ 
  static int SRM_no; //是不是这里没赋初值？
  int I; 
  for(I=0;I<MAX_SRM;I++,SRM_no++) 
  { 
    SRM_no %= MAX_SRM; 
    if(MY_SRM.state==IDLE) 
    { 
      break; 
    } 
  } 
  if(I>=MAX_SRM) 
    return (NULL_SRM); 
  else 
    return SRM_no; 
} 
系统会初始化static int变量为0,但该值会一直保存,所谓的不可重入...
--------------------------------------------------------------------------
13.写出运行结果:
{// test1
    char str[] = "world"; cout << sizeof(str) << ": ";
    char *p    = str;     cout << sizeof(p) << ": ";
    char i     = 10;      cout << sizeof(i) << ": ";
    void *pp   = malloc(10);  cout << sizeof(p) << endl;
}
6：4：1：4
--------------------------------------------------------------------------
14.写出运行结果:
{// test2
    union V {
 struct X {
  unsigned char s1:2;
  unsigned char s2:3;
  unsigned char s3:3;
 } x;
 unsigned char c;
    } v;
    v.c = 100;
    printf("%d", v.x.s3); 
}
3
--------------------------------------------------------------------------
15.用C++写个程序，如何判断一个操作系统是16位还是32位的？不能用sizeof()函数
A1:
16位的系统下，
int i = 65536;
cout << i; // 输出0；
int i = 65535;
cout << i; // 输出-1；
32位的系统下，
int i = 65536;
cout << i; // 输出65536；
int i = 65535;
cout << i; // 输出65535；
A2:
int a = ~0;
if( a>65536 ) 
{
    cout<<"32 bit"<<endl;
}
else
{
    cout<<"16 bit"<<endl;
}

--------------------------------------------------------------------------
16.C和C++有什么不同?
从机制上：c是面向过程的（但c也可以编写面向对象的程序）；c++是面向对象的，提供了类。但是，
c++编写面向对象的程序比c容易
从适用的方向：c适合要求代码体积小的，效率高的场合，如嵌入式；c++适合更上层的，复杂的；  llinux核心大部分是c写的，因为它是系统软件，效率要求极高。
从名称上也可以看出，c++比c多了+，说明c++是c的超集；那为什么不叫c+而叫c++呢，是因为c++比
c来说扩充的东西太多了，所以就在c后面放上两个+；于是就成了c++
C语言是结构化编程语言，C++是面向对象编程语言。
C++侧重于对象而不是过程，侧重于类的设计而不是逻辑的设计。
--------------------------------------------------------------------------
17.在不用第三方参数的情况下，交换两个参数的值
#include <stdio.h>
void main()
{
        int i=60;
        int j=50;
        i=i+j;
        j=i-j;
        i=i-j;
        printf("i=%d\n",i);
        printf("j=%d\n",j);
}
方法二：
i^=j;
j^=i;
i^=j;
方法三：
// 用加减实现，而且不会溢出
a = a+b-(b=a)
--------------------------------------------------------------------------
18.有关位域的面试题（为什么输出的是一个奇怪的字符）
a.t = &apos;b&apos;;效果相当于 a.t= &apos;b&apos; & 0xf;
&apos;b&apos; --> 01100010
&apos;b&apos; & 0xf -->>00000010
所以输出Ascii码为2的特殊字符

char t:4;就是4bit的字符变量，同样
unsigned short i:8;就是8bit的无符号短整形变量
--------------------------------------------------------------------------
19.int i=10, j=10, k=3; k*=i+j; k最后的值是?
60
--------------------------------------------------------------------------
20.进程间通信的方式有?
进程间通信的方式有 共享内存， 管道 ，Socket ，消息队列 , DDE等
--------------------------------------------------------------------------
21.
struct A 
{ 
char t:4; 
char k:4; 
unsigned short i:8; 
unsigned long m; 
} 
sizeof(A)=?（不考虑边界对齐）
7
struct CELL             // Declare CELL bit field
{
   unsigned character  : 8;  // 00000000 ????????
   unsigned foreground : 3;  // 00000??? 00000000
   unsigned intensity  : 1;  // 0000?000 00000000
   unsigned background : 3;  // 0???0000 00000000
   unsigned blink      : 1;  // ?0000000 00000000
} screen[25][80];       // Array of bit fields
二、位结构 
    位结构是一种特殊的结构, 在需按位访问一个字节或字的多个位时, 位结构 
比按位运算符更加方便。 
    位结构定义的一般形式为: 
     struct位结构名{ 
          数据类型 变量名: 整型常数; 
          数据类型 变量名: 整型常数; 
     } 位结构变量; 
    其中: 数据类型必须是int(unsigned或signed)。 整型常数必须是非负的整 
数, 范围是0~15, 表示二进制位的个数, 即表示有多少位。 
    变量名是选择项, 可以不命名, 这样规定是为了排列需要。 
    例如: 下面定义了一个位结构。 
     struct{ 
          unsigned incon: 8;  /*incon占用低字节的0~7共8位*/ 
          unsigned txcolor: 4;/*txcolor占用高字节的0~3位共4位*/ 
          unsigned bgcolor: 3;/*bgcolor占用高字节的4~6位共3位*/ 
          unsigned blink: 1;  /*blink占用高字节的第7位*/ 
     }ch; 
    位结构成员的访问与结构成员的访问相同。 
    例如: 访问上例位结构中的bgcolor成员可写成: 
      ch.bgcolor 
  
    注意: 
    1. 位结构中的成员可以定义为unsigned, 也可定义为signed,  但当成员长 
度为1时, 会被认为是unsigned类型。因为单个位不可能具有符号。 
    2. 位结构中的成员不能使用数组和指针, 但位结构变量可以是数组和指针, 
如果是指针, 其成员访问方式同结构指针。 
    3. 位结构总长度(位数), 是各个位成员定义的位数之和,  可以超过两个字 
节。 
    4. 位结构成员可以与其它结构成员一起使用。 
    例如: 
     struct info{ 
          char name[8]; 
          int age; 
          struct addr address; 
          float pay; 
          unsigned state: 1; 
          unsigned pay: 1; 
          }workers;
    上例的结构定义了关于一个工人的信息。其中有两个位结构成员, 每个位结 
构成员只有一位, 因此只占一个字节但保存了两个信息, 该字节中第一位表示工 
人的状态, 第二位表示工资是否已发放。由此可见使用位结构可以节省存贮空间。

--------------------------------------------------------------------------
22.下面的函数实现在一个固定的数上加上一个数，有什么错误，改正 
int add_n(int n) 
{ 
  static int i=100; 
  i+=n; 
  return i; 
} 
答:
因为static使得i的值会保留上次的值。
去掉static就可了
--------------------------------------------------------------------------
23.下面的代码有什么问题?
class A 
{ 
public: 
  A() { p=this; } 
  ~A() { if(p!=NULL) { delete p; p=NULL; } } 
  A* p; 
};
答:
会引起无限递归
--------------------------------------------------------------------------
24.
union a {
 int a_int1;
 double a_double;
 int a_int2;
};
typedef struct
{
 a a1;
 char y;
} b;
class c
{
 double c_double;
 b b1;
 a a2;
};
输出cout<<sizeof(c)<<endl;的结果?
答:
VC6环境下得出的结果是32
另:
我(sun)在VC6.0+win2k下做过试验:
short - 2
int-4
float-4
double-8
指针-4
sizeof(union)，以结构里面size最大的为union的size
 ----------------------------------------------------------------------------------
25.i最后等于多少?
int i = 1;
int j = i++;
if((i>j++) && (i++ == j)) i+=j;
答:
i = 5
--------------------------------------------------------------------------
26.
unsigned short array[]={1,2,3,4,5,6,7};
int i = 3;
*(array + i) = ?
答:
4
--------------------------------------------------------------------------
27.
class A
{
  virtual void func1()；
  void func2();
}
Class B: class A
{
  void func1(){cout << "fun1 in class B" << endl;}
  virtual void func2(){cout << "fun2 in class B" << endl;}
} 
A, A中的func1和B中的func2都是虚函数.
B, A中的func1和B中的func2都不是虚函数.
C, A中的func2是虚函数.，B中的func1不是虚函数.
D, A中的func2不是虚函数，B中的func1是虚函数.
答:
A
--------------------------------------------------------------------------
28.
数据库：抽出部门，平均工资，要求按部门的字符串顺序排序，不能含有"human resource"部门， 
employee结构如下：employee_id, employee_name, depart_id,depart_name,wage
答:
select depart_name, avg(wage)
from employee
where depart_name <> &apos;human resource&apos;
group by depart_name
order by depart_name
--------------------------------------------------------------------------
29.
给定如下SQL数据库：Test(num INT(4)) 请用一条SQL语句返回num的最小值，但不许使用统计功能，如MIN，MAX等
答:
select top 1 num
from Test
order by num desc
--------------------------------------------------------------------------
30.
输出下面程序结果。 
#include <iostream.h> 
class A 
{ 
public:
 virtual void print(void) 
 { 
    cout<<"A::print()"<<endl; 
 } 
};
class B:public A 
{ 
public:
 virtual void print(void) 
 { 
   cout<<"B::print()"<<endl;
 }; 
}; 
class C:public B
{
public:
 virtual void print(void)
 {
  cout<<"C::print()"<<endl;
 }
};
void print(A a) 
{ 
   a.print(); 
} 
void main(void) 
{ 
   A a, *pa,*pb,*pc; 
   B b; 
   C c; 
   
   pa=&a; 
   pb=&b; 
   pc=&c; 
   
   a.print(); 
   b.print(); 
   c.print(); 
   
   pa->print(); 
   pb->print(); 
   pc->print(); 
   
   print(a); 
   print(b); 
   print(c); 
}
A:
A::print()
B::print()
C::print()
A::print()
B::print()
C::print()
A::print()
A::print()
A::print()
--------------------------------------------------------------------------
31.
试编写函数判断计算机的字节存储顺序是开序(little endian)还是降序(bigendian)
答:
bool IsBigendian()
{
 unsigned short usData = 0x1122;
 unsigned char  *pucData = (unsigned char*)&usData;
 return (*pucData == 0x22);
}
--------------------------------------------------------------------------
32.简述Critical Section和Mutex的不同点
答:
对几种同步对象的总结
1.Critical Section
A.速度快
B.不能用于不同进程
C.不能进行资源统计(每次只可以有一个线程对共享资源进行存取)
2.Mutex
A.速度慢
B.可用于不同进程
C.不能进行资源统计
3.Semaphore
A.速度慢
B.可用于不同进程
C.可进行资源统计(可以让一个或超过一个线程对共享资源进行存取)
4.Event
A.速度慢
B.可用于不同进程
C.可进行资源统计
 
--------------------------------------------------------------------------
33.一个数据库中有两个表:
一张表为Customer，含字段ID,Name;
一张表为Order，含字段ID,CustomerID（连向Customer中ID的外键）,Revenue；
写出求每个Customer的Revenue总和的SQL语句。
建表
create table customer
(
ID int primary key,Name char(10)
)
go
create table [order]
(
ID int primary key,CustomerID  int foreign key references customer(id) , Revenue float
)
go
--查询
select Customer.ID, sum( isnull([Order].Revenue,0) )
from customer full join [order] 
on( [order].customerid=customer.id )
group by customer.id
--------------------------------------------------------------------------
34.请指出下列程序中的错误并且修改
void GetMemory(char *p){
  p=(char *)malloc(100);
}
void Test(void){
  char *str=NULL;
  GetMemory=(str);
  strcpy(str,"hello world");
  printf(str);
}
A:错误--参数的值改变后，不会传回
GetMemory并不能传递动态内存，Test函数中的 str一直都是 NULL。
strcpy(str, "hello world");将使程序崩溃。
修改如下:
char *GetMemory(){
  char *p=(char *)malloc(100);
  return p;
}
void Test(void){
  char *str=NULL;
  str=GetMemory(){
  strcpy(str,"hello world");
  printf(str);
}
方法二:void GetMemory2(char **p)变为二级指针.
void GetMemory2(char **p, int num)
{
 *p = (char *)malloc(sizeof(char) * num);
}
--------------------------------------------------------------------------
35.程序改错
class mml
{
  private:
    static unsigned int x;
  public:
    mml(){ x++; }
    mml(static unsigned int &) {x++;}
    ~mml{x--;}
  pulic:
    virtual mon() {} = 0;
    static unsigned int mmc(){return x;}
    ......                      
 
};
class nnl:public mml
{
  private:
    static unsigned int y;
  public:
    nnl(){ x++; }
    nnl(static unsigned int &) {x++;}
    ~nnl{x--;}
  public:
    virtual mon() {};
     static unsigned int nnc(){return y;}
    ......                   
};
代码片断:
mml* pp = new nnl;
..........
delete pp;

A:
基类的析构函数应该为虚函数
virtual ~mml{x--;}
--------------------------------------------------------------------------
36.101个硬币100真、1假，真假区别在于重量。请用无砝码天平称两次给出真币重还是假币重的结论。
答:
101个先取出2堆,
33,33
第一次称,如果不相等,说明有一堆重或轻
那么把重的那堆拿下来,再放另外35个中的33
如果相等,说明假的重,如果不相等,新放上去的还是重的话,说明假的轻(不可能新放上去的轻)
第一次称,如果相等的话，这66个肯定都是真的,从这66个中取出35个来,与剩下的没称过的35个比
下面就不用说了
方法二:
第3题也可以拿A(50),B(50)比一下，一样的话拿剩下的一个和真的比一下。
如果不一样，就拿其中的一堆。比如A(50)再分成两堆25比一下，一样的话就在
B(50)中，不一样就在A(50)中，结合第一次的结果就知道了。
--------------------------------------------------------------------------
37.static变量和static 函数各有什么特点？
答:
static变量：在程序运行期内一直有效，如果定义在函数外，则在编译单元内可见，如果在函数内，在在定义的block内可见；
static函数：在编译单元内可见；
--------------------------------------------------------------------------
38.用C 写一个输入的整数,倒着输出整数的函数,要求用递归方法 ;
答:
void fun( int a )
{
 printf( "%d", a%10 );
 a /= 10;
 if( a <=0 )return;
 fun( a );
}
--------------------------------------------------------------------------
39.写出程序结果:
void Func(char str[100])
{
  printf("%d\n", sizeof(str));
}
答:
4
分析:
指针长度
--------------------------------------------------------------------------
40.int id[sizeof(unsigned long)];
    这个对吗？为什么??
答:
对
这个 sizeof是编译时运算符，编译时就确定了
可以看成和机器有关的常量。


1. 以下三条输出语句分别输出什么？
char str1[] = "abc";
char str2[] = "abc";
5. 以下代码有什么问题？
cout << (true?1:"1") << endl;
答：三元表达式“？:”问号后面的两个操作数必须为同一类型。
6. 以下代码能够编译通过吗，为什么？
unsigned int const size1 = 2;
char str1[ size1 ];
unsigned int temp = 0;
cin >> temp;
unsigned int const size2 = temp;
char str2[ size2 ];
答：str2定义出错，size2非编译器期间常量，而数组定义要求长度必须为编译期常量。
During my test in linux environment. The above code could be compiled successfully. But if we initialize the defined arrary like this “char str2[ size2 ] = {0};”, there would be a compile error informing that “variable-sized object `str2' may not be initialized”.
7. 以下反向遍历array数组的方法有什么错误？
vector array;
array.push_back( 1 );
array.push_back( 2 );
array.push_back( 3 );
for( vector::size_type i=array.size()-1; i>=0; --i ) // 反向遍历array数组
{
cout << array << endl;
}
答：首先数组定义有误，应加上类型参数：vector<int> array。其次vector::size_type被定义为unsigned int，即无符号数，这样做为循环变量的i为0时再减1就会变成最大的整数，导致循环失去控制。
8. 以下代码中的输出语句输出0吗，为什么？
struct CLS
{
int m_i;
CLS( int i ) : m_i(i) {}
CLS()
{
CLS(0);
}
};
CLS obj;
cout << obj.m_i << endl;
答：不能。在默认构造函数内部再调用带参的构造函数属用户行为而非编译器行为，亦即仅执行函数调用，而不会执行其后的初始化表达式。只有在生成对象时，初始化表达式才会随相应的构造函数一起调用。
9. C++中的空类，默认产生哪些类成员函数？
答：
class Empty
{
public:
Empty(); // 缺省构造函数
Empty( const Empty& ); // 拷贝构造函数
~Empty(); // 析构函数
Empty& operator=( const Empty& ); // 赋值运算符
Empty* operator&(); // 取址运算符
const Empty* operator&() const; // 取址运算符 const
};

10. 以下两条输出语句分别输出什么？
float a = 1.0f;
cout << (int)a << endl;
cout << (int&)a << endl;
cout << boolalpha << ( (int)a == (int&)a ) << endl; // 输出什么？
float b = 0.0f;
cout << (int)b << endl;
cout << (int&)b << endl;
cout << boolalpha << ( (int)b == (int&)b ) << endl; // 输出什么？
答：分别输出false和true。注意转换的应用。(int)a实际上是以浮点数a为参数构造了一个整型数，该整数的值是1，(int&)a则是告诉编译器将a当作整数看（并没有做任何实质上的转换）。因为1以整数形式存放和以浮点形式存放其内存数据是不一样的，因此两者不等。对b的两种转换意义同上，但是0的整数形式和浮点形式其内存数据是一样的，因此在这种特殊情形下，两者相等（仅仅在数值意义上）。
注意，程序的输出会显示(int&)a=1065353216，这个值是怎么来的呢？前面已经说了，1以浮点数形式存放在内存中，按ieee754规定，其内容为0x0000803F（已考虑字节反序）。这也就是a这个变量所占据的内存单元的值。当(int&)a出现时，它相当于告诉它的上下文：“把这块地址当做整数看待！不要管它原来是什么。”这样，内容0x0000803F按整数解释，其值正好就是1065353216（十进制数）。
通过查看汇编代码可以证实“(int)a相当于重新构造了一个值等于a的整型数”之说，而(int&)的作用则仅仅是表达了一个类型信息，意义在于为cout<<及==选择正确的重载版本。

①链表反转
单向链表的反转是一个经常被问到的一个面试题，也是一个非常基础的问题。比如一个链表是这样的： 1->2->3->4->5 通过反转后成为5->4->3->2->1。
最容易想到的方法遍历一遍链表，利用一个辅助指针，存储遍历过程中当前指针指向的下一个元素，然后将当前节点元素的指针反转后，利用已经存储的指针往后面继续遍历。源代码如下：
1.          struct linka {
 2.          int data;
 3.          linka* next;
 4.          };
 5.          void reverse(linka*& head) {
 6.          if(head ==NULL)
 7.                            return;
 8.          linka *pre, *cur, *ne;
 9.          pre=head;
 10.      cur=head->next;
 11.      while(cur)
 12.      {
 13.        ne = cur->next;
 14.        cur->next = pre;
 15.        pre = cur;
 16.        cur = ne;
 17.      }
 18.      head->next = NULL;
 19.      head = pre;
 20.      }
 还有一种利用递归的方法。这种方法的基本思想是在反转当前节点之前先调用递归函数反转后续节点。源代码如下。不过这个方法有一个缺点，就是在反转后的最后一个结点会形成一个环，所以必须将函数的返回的节点的next域置为NULL。因为要改变head指针，所以我用了引用。算法的源代码如下：
1.          linka* reverse(linka* p,linka*& head)
 2.          {
 3.          if(p == NULL || p->next == NULL)
 4.          {
 5.            head=p;
 6.            return p;
 7.          }
 8.          else
 9.          {
 10.        linka* tmp = reverse(p->next,head);
 11.        tmp->next = p;
 12.        return p;
 13.      }
 14.      }
 ②已知String类定义如下：
class String
{
public:
String(const char *str = NULL); // 通用构造函数
String(const String &another); // 拷贝构造函数
~ String(); // 析构函数
String & operater =(const String &rhs); // 赋值函数
private:
char *m_data; // 用于保存字符串
};
尝试写出类的成员函数实现。
答案：
String::String(const char *str)
{
if ( str == NULL ) //strlen在参数为NULL时会抛异常才会有这步判断
{
m_data = new char[1] ;
m_data[0] = '\0' ;
}
else
{
m_data = new char[strlen(str) + 1];
strcpy(m_data,str);
}
}
 String::String(const String &another)
{
m_data = new char[strlen(another.m_data) + 1];
strcpy(m_data,other.m_data);
}

String& String::operator =(const String &rhs)
{
if ( this == &rhs)
return *this ;
delete []m_data; //删除原来的数据，新开一块内存
m_data = new char[strlen(rhs.m_data) + 1];
strcpy(m_data,rhs.m_data);
return *this ;
}

String::~String()
{
delete []m_data ;
}
③网上流传的c++笔试题汇总
1.    求下面函数的返回值（微软）
int func(x)
{
int countx = 0;
while(x)
{
countx ++;
x = x&(x-1);
}
return countx;
}
 假定x = 9999。 答案：8
思路：将x转化为2进制，看含有的1的个数。
2. 什么是“引用”？申明和使用“引用”要注意哪些问题？
答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。
3. 将“引用”作为函数参数有哪些特点？
（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。
4. 在什么时候需要使用“常引用”？　
如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &引用名=目标变量名；
例1
int a ;
const int &ra=a;
ra=1; //错误
a=1; //正确
例2
string foo( );
void bar(string & s);
那么下面的表达式将是非法的：
bar(foo( ));
bar("hello world");
原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。
引用型参数应该在能被定义为const的情况下，尽量定义为const 。
5. 将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?
格式：类型标识符 &函数名（形参列表及类型说明）{ //函数体 }
好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error!
注意事项：
（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。
（2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。
（4）流操作符重载返回值申明为“引用”的作用：
流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。
例3
＃i nclude <iostream.h>
int &put(int n);
int vals[10];
int error=-1;
void main()
{
put(0)=10; //以put(0)函数值作为左值，等价于vals[0]=10;
put(9)=20; //以put(9)函数值作为左值，等价于vals[9]=20;
cout<<vals[0];
cout<<vals[9];
}
int &put(int n)
{
if (n>=0 && n<=9 ) return vals[n];
else { cout<<"subscript error"; return error; }
}
（5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。
6. “引用”与多态的关系？
引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。
例4
Class A; Class B : Class A{...}; B b; A& ref = b;
7. “引用”与指针的区别是什么？
指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。此外，就是上面提到的对函数传ref和pointer的区别。
8. 什么时候需要“引用”？
流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。
以上 2-8 参考：http://blog.csdn.net/wfwd/archive/2006/05/30/763551.aspx
9. 结构与联合有和区别？
1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。
 2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。
10. 下面关于“联合”的题目的输出？
a)
＃i nclude <stdio.h>
union
{
int i;
char x[2];
}a;

void main()
{
a.x[0] = 10;
a.x[1] = 1;
printf("%d",a.i);
}
答案：266 (低位低地址，高位高地址，内存占用情况是Ox010A）
b)
main()
{
union{ /*定义一个联合*/
int i;
struct{ /*在联合中定义一个结构*/
char first;
char second;
}half;
}number;
number.i=0x4241; /*联合成员赋值*/
printf("%c%c\n", number.half.first, mumber.half.second);
number.half.first='a'; /*联合中结构成员赋值*/
number.half.second='b';
printf("%x\n", number.i);
getch();
}
答案： AB (0x41对应'A',是低位；Ox42对应'B',是高位）
6261 (number.i和number.half共用一块地址空间）
11. 已知strcpy的函数原型：char *strcpy(char *strDest, const char *strSrc)其中strDest 是目的字符串，strSrc 是源字符串。不调用C++/C 的字符串库函数，请编写函数 strcpy。

答案：
char *strcpy(char *strDest, const char *strSrc)
{
if ( strDest == NULL || strSrc == NULL)
return NULL ;
if ( strDest == strSrc)
return strDest ;
char *tempptr = strDest ;
while( (*strDest++ = *strSrc++) != ‘\0’)
return tempptr ;
}
15.在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？
首先，作为extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。
通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数
extern "C"是连接申明(linkage declaration),被extern "C"修饰的变量和函数是按照C语言方式编译和连接的,来看看C++中对类似C的函数是怎样编译的：
作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。
16. 关联、聚合(Aggregation)以及组合(Composition)的区别？
涉及到UML中的一些概念：关联是表示两个类的一般性联系，比如“学生”和“老师”就是一种关联关系；聚合表示has-a的关系，是一种相对松散的关系，聚合类不需要对被聚合类负责，如下图所示，用空的菱形表示聚合关系：
 ;
从实现的角度讲，聚合可以表示为:
class A {...} class B { A* a; .....}
而组合表示contains-a的关系，关联性强于聚合：组合类与被组合类有相同的生命周期，组合类要对被组合类负责，采用实心的菱形表示组合关系：
实现的形式是:
class A{...} class B{ A a; ...}
参考文章：http://blog.csdn.net/wfwd/archive/2006/05/30/763753.aspx
http://blog.csdn.net/wfwd/archive/2006/05/30/763760.aspx
17.面向对象的三个基本特征，并简单叙述之？
1. 封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private, protected,public)
2. 继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合=>接口继承以及纯虚函数）构成了功能复用的两种方式。
3. 多态：是将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。
面向对象的三个基本特征是：封装、继承、多态。

封装
封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。
封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
继承
面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
通过继承创建的新类称为“子类”或“派生类”。
被继承的类称为“基类”、“父类”或“超类”。
继承的过程，就是从一般到特殊的过程。
要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。
在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。

继承概念的实现方式有三类：实现继承、接口继承和可视继承。
Ø        实现继承是指使用基类的属性和方法而无需额外编码的能力；
Ø        接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
Ø        可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。
在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。
抽象类仅定义将由子类创建的一般属性和方法，创建抽象类时，请使用关键字 Interface 而不是 Class。
OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。

多态
多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。
实现多态，有二种方式，覆盖，重载。
覆盖，是指子类重新定义父类的虚函数的做法。
重载，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚邦定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚邦定，它就不是多态。”
那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。

概念讲解
泛化（Generalization）

图表 1 泛化
在上图中，空心的三角表示继承关系（类继承），在UML的术语中，这种关系被称为泛化（Generalization）。Person(人)是基类，Teacher(教师)、Student(学生)、Guest(来宾)是子类。
若在逻辑上B是A的“一种”，并且A的所有功能和属性对B而言都有意义，则允许B继承A的功能和属性。
例如，教师是人，Teacher 是Person的“一种”（a kind of ）。那么类Teacher可以从类Person派生（继承）。
如果A是基类，B是A的派生类，那么B将继承A的数据和函数。
如果类A和类B毫不相关，不可以为了使B的功能更多些而让B继承A的功能和属性。
若在逻辑上B是A的“一种”（a kind of ），则允许B继承A的功能和属性。

聚合（组合）

图表 2 组合
若在逻辑上A是B的“一部分”（a part of），则不允许B从A派生，而是要用A和其它东西组合出B。
例如，眼（Eye）、鼻（Nose）、口（Mouth）、耳（Ear）是头（Head）的一部分，所以类Head应该由类Eye、Nose、Mouth、Ear组合而成，不是派生（继承）而成。

聚合的类型分为无、共享(聚合)、复合(组合)三类。

聚合（aggregation）


图表 3 共享
上面图中，有一个菱形（空心）表示聚合（aggregation）（聚合类型为共享），聚合的意义表示has-a关系。聚合是一种相对松散的关系，聚合类B不需要对被聚合的类A负责。

组合（composition）

图表 4 复合
这幅图与上面的唯一区别是菱形为实心的，它代表了一种更为坚固的关系——组合（composition）（聚合类型为复合）。组合表示的关系也是has-a，不过在这里，A的生命期受B控制。即A会随着B的创建而创建，随B的消亡而消亡。

依赖(Dependency)

图表 5 依赖
这里B与A的关系只是一种依赖(Dependency)关系，这种关系表明，如果类A被修改，那么类B会受到影响。

18. 重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？
常考的题目。从定义上来说：
重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
重写：是指子类重新定义复类虚函数的方法。
从实现原理上来说：
重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！
重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。
19. 多态的作用？
主要是两个：1. 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；2. 接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。

21. New delete 与malloc free 的联系与区别?
答案：都是在堆(heap)上进行动态的内存操作。用malloc函数需要指定内存分配的字节数并且不能初始化对象，new 会自动调用对象的构造函数。delete 会调用对象的destructor，而free 不会调用对象的destructor.
22. #define DOUBLE(x) x+x ，i = 5*DOUBLE(5)； i 是多少？
答案：i 为30。
23. 有哪几种情况只能用intialization list 而不能用assignment?
答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。
24. C++是不是类型安全的？
答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。
25. main 函数执行以前，还会执行什么代码？
答案：全局对象的构造函数会在main 函数之前执行。
26. 描述内存分配方式以及它们的区别?
1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。
2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。
3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。
27.struct 和 class 的区别
答案：struct
 而类的成员默认是私有的。struct 和 class 在其他方面是功能相当的。
从感情上讲，大多数的开发者感到类和结构有很大的差别。感觉上结构仅仅象一堆缺乏封装和功能的开放的内存位，而类就象活的并且可靠的社会成员，它有智能服务，有牢固的封装屏障和一个良好定义的接口。既然大多数人都这么认为，那么只有在你的类有很少的方法并且有公有数据（这种事情在良好设计的系统中是存在的!）时，你也许应该使用 struct 关键字，否则，你应该使用 class 关键字。
 28.当一个类A 中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）
答案：肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了。
29. 在8086 汇编下，逻辑地址和物理地址是怎样转换的？（Intel）
答案：通用寄存器给出的地址，是段内偏移地址，相应段寄存器地址*10H+通用寄存器内地址，就得到了真正要访问的地址。
30. 比较C++中的4种类型转换方式？
请参考：http://blog.csdn.net/wfwd/archive/2006/05/30/763785.aspx，重点是static_cast, dynamic_cast和reinterpret_cast的区别和应用。
31.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。
答案：
BOOL : if ( !a ) or if(a)
int : if ( a == 0)
float : const EXPRESSION EXP = 0.000001
if ( a < EXP && a >-EXP)
pointer : if ( a != NULL) or if(a == NULL)

32.请说出const与#define 相比，有何优点？
答案：1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。
33.简述数组与指针的区别？
数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。
(1)修改内容上的差别
char a[] = “hello”;
a[0] = ‘X’;
char *p = “world”; // 注意p 指向常量字符串
p[0] = ‘X’; // 编译器不能发现该错误，运行时错误
(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。
char a[] = "hello world";
char *p = a;
cout<< sizeof(a) << endl; // 12 字节
cout<< sizeof(p) << endl; // 4 字节
计算数组和指针的内存容量
void Func(char a[100])
{
cout<< sizeof(a) << endl; // 4 字节而不是100 字节
}
34.类成员函数的重载、覆盖和隐藏区别？
答案：
a.成员函数被重载的特征：
（1）相同的范围（在同一个类中）；
（2）函数名字相同；
（3）参数不同；
（4）virtual 关键字可有可无。
b.覆盖是指派生类函数覆盖基类函数，特征是：
（1）不同的范围（分别位于派生类与基类）；
（2）函数名字相同；
（3）参数相同；
（4）基类函数必须有virtual 关键字。
c.“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）
35. There are two int variables: a and b, don’t use “if”, “? :”, “switch”or other judgement statements, find out the biggest one of the two numbers.
答案：( ( a + b ) + abs( a - b ) ) / 2
36. 如何打印出当前源文件的文件名以及源文件的当前行号？
答案：
cout << __FILE__ ;
cout<<__LINE__ ;
__FILE__和__LINE__是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。
37. main 主函数执行完毕后，是否可能会再执行一段代码，给出说明？
答案：可以，可以用_onexit 注册一个函数，它会在main 之后执行int fn1(void), fn2(void), fn3(void), fn4 (void);
void main( void )
{
String str("zhanglin");
_onexit( fn1 );
_onexit( fn2 );
_onexit( fn3 );
_onexit( fn4 );
printf( "This is executed first.\n" );
}
int fn1()
{
printf( "next.\n" );
return 0;
}
int fn2()
{
printf( "executed " );
return 0;
}
int fn3()
{
printf( "is " );
return 0;
}
int fn4()
{
printf( "This " );
return 0;
}
The _onexit function is passed the address of a function (func) to be called when the program terminates normally. Successive calls to _onexit create a register of functions that are executed in LIFO (last-in-first-out) order. The functions passed to _onexit cannot take parameters.
38. 如何判断一段程序是由C 编译程序还是由C++编译程序编译的？
答案：
#ifdef __cplusplus
cout<<"c++";
#else
cout<<"c";
#endif
39.文件中有一组整数，要求排序后输出到另一个文件中
答案：
＃i nclude<iostream>
＃i nclude<fstream>
using namespace std;

void Order(vector<int>& data) //bubble sort
{
int count = data.size() ;
int tag = false ; // 设置是否需要继续冒泡的标志位
for ( int i = 0 ; i < count ; i++)
{
for ( int j = 0 ; j < count - i - 1 ; j++)
{
if ( data[j] > data[j+1])
{
tag = true ;
int temp = data[j] ;
data[j] = data[j+1] ;
data[j+1] = temp ;
}
}
if ( !tag )
break ;
}
}

void main( void )
{
vector<int>data;
ifstream in("c:\\data.txt");
if ( !in)
{
cout<<"file error!";
exit(1);
}
int temp;
while (!in.eof())
{
in>>temp;
data.push_back(temp);
}
in.close(); //关闭输入文件流
Order(data);
ofstream out("c:\\result.txt");
if ( !out)
{
cout<<"file error!";
exit(1);
}
for ( i = 0 ; i < data.size() ; i++)
out<<data<<" ";
out.close(); //关闭输出文件流
}

40. 链表题：一个链表的结点结构
struct Node
{
int data ;
Node *next ;
};
typedef struct Node Node ;

(1)已知链表的头结点head,写一个函数把这个链表逆序 ( Intel)
Node * ReverseList(Node *head) //链表逆序
{
if ( head == NULL || head->next == NULL )
return head;
Node *p1 = head ;
Node *p2 = p1->next ;
Node *p3 = p2->next ;
p1->next = NULL ;
while ( p3 != NULL )
{
p2->next = p1 ;
p1 = p2 ;
p2 = p3 ;
p3 = p3->next ;
}
p2->next = p1 ;
head = p2 ;
return head ;
}
(2)已知两个链表head1 和head2 各自有序，请把它们合并成一个链表依然有序。(保留所有结点，即便大小相同）
Node * Merge(Node *head1 , Node *head2)
{
if ( head1 == NULL)
return head2 ;
if ( head2 == NULL)
return head1 ;
Node *head = NULL ;
Node *p1 = NULL;
Node *p2 = NULL;
if ( head1->data < head2->data )
{
head = head1 ;
p1 = head1->next;
p2 = head2 ;
}
else
{
head = head2 ;
p2 = head2->next ;
p1 = head1 ;
}
Node *pcurrent = head ;
while ( p1 != NULL && p2 != NULL)
{
if ( p1->data <= p2->data )
{
pcurrent->next = p1 ;
pcurrent = p1 ;
p1 = p1->next ;
}
else
{
pcurrent->next = p2 ;
pcurrent = p2 ;
p2 = p2->next ;
}
}
if ( p1 != NULL )
pcurrent->next = p1 ;
if ( p2 != NULL )
pcurrent->next = p2 ;
return head ;
}
(3)已知两个链表head1 和head2 各自有序，请把它们合并成一个链表依然有序，这次要求用递归方法进行。 (Autodesk)
答案：
Node * MergeRecursive(Node *head1 , Node *head2)
{
if ( head1 == NULL )
return head2 ;
if ( head2 == NULL)
return head1 ;
Node *head = NULL ;
if ( head1->data < head2->data )
{
head = head1 ;
head->next = MergeRecursive(head1->next,head2);
}
else
{
head = head2 ;
head->next = MergeRecursive(head1,head2->next);
}
return head ;
}
41. 分析一下这段程序的输出 (Autodesk)
class B
{
public:
B()
{
cout<<"default constructor"<<endl;
}
~B()
{
cout<<"destructed"<<endl;
}
B(int i):data(i) //B(int) works as a converter ( int -> instance of B)
{
cout<<"constructed by parameter " << data <<endl;
}
private:
int data;
};

B Play( B b)
{
return b ;
}
(1) results:
int main(int argc, char* argv[]) constructed by parameter 5
{ destructed B(5)形参析构
B t1 = Play(5); B t2 = Play(t1); 　 destructed t1形参析构
return 0;　　　　　　　　　　　　　　 destructed t2　注意顺序！
} destructed t1
(2) results:
int main(int argc, char* argv[]) constructed by parameter 5
{ destructed B(5)形参析构
B t1 = Play(5); B t2 = Play(10); 　 constructed by parameter 10
return 0;　　　　　　　　　　　　　　 destructed B(10)形参析构
} destructed t2　注意顺序！
destructed t1
42. 写一个函数找出一个整数数组中，第二大的数 （microsoft）
答案：
const int MINNUMBER = -32767 ;
int find_sec_max( int data[] , int count)
{
int maxnumber = data[0] ;
int sec_max = MINNUMBER ;
for ( int i = 1 ; i < count ; i++)
{
if ( data > maxnumber )
{
sec_max = maxnumber ;
maxnumber = data ;
}
else
{
if ( data > sec_max )
sec_max = data ;
}
}
return sec_max ;
}
43. 写一个在一个字符串(n)中寻找一个子串(m)第一个位置的函数。
KMP算法效率最好，时间复杂度是Ｏ(n+m)。
44. 多重继承的内存分配问题：
比如有class A : public class B, public class C {}
那么A的内存结构大致是怎么样的？
这个是compiler-dependent的, 不同的实现其细节可能不同。
如果不考虑有虚函数、虚继承的话就相当简单；否则的话，相当复杂。
可以参考《深入探索C++对象模型》，或者：
http://blog.csdn.net/wfwd/archive/2006/05/30/763797.aspx
45. 如何判断一个单链表是有环的？（注意不能用标志位，最多只能用两个额外指针）
struct node { char val; node* next;}
bool check(const node* head) {} //return false : 无环；true: 有环
一种O（n）的办法就是（搞两个指针，一个每次递增一步，一个每次递增两步，如果有环的话两者必然重合，反之亦然）：
bool check(const node* head)
{
if(head==NULL) return false;
node *low=head, *fast=head->next;
while(fast!=NULL && fast->next!=NULL)
{
low=low->next;
fast=fast->next->next;
if(low==fast) return true;
}
return false;
}


嵌入式linux android驱动工程师 面试题总汇
1. linux内核里面，内存申请有哪几个函数，各自的区别？

2. IRQ和FIQ有什么区别，在CPU里面是是怎么做的？

3. 

int *a;

char *b;

a 和 b本身是什么类型？

a、b里面本身存放的只是一个地址，难道是这两个地址有不同么？ 


4. 中断的上半部分和下半部分的问题：

讲下分成上半部分和下半部分的原因，为何要分？讲下如何实现？

5. 内核函数mmap的实现原理，机制？

6. 驱动里面为什么要有并发、互斥的控制？如何实现？讲个例子？

7. spinlock自旋锁是如何实现的？

8. 任务调度的机制？

【二、本人碰到】

1. 嵌入式linux和wince操作系统的特点和特性？

2. 嵌入式linux中tty设备驱动的体系结构？

3. 嵌入式设备，为加快启动速度，可以做哪些方面的优化？

4. USB设备的枚举过程？

5. PSRAM、SDRAM、DDR、DDR2的时序特性？

6. I2C触摸屏芯片与CPU的数据传输流程？画出相关图例？（这题目记得不是太清楚了，大概是考查I2C设备驱动的数据传输过程）


 


C++中的堆与栈

                                    整理者：陆晓明

1 基本概念
也不知道是什么原因，很多人总是把堆和栈混合一起，在写程序时，总是经常脱口而出地说堆栈。网上的一些资料说堆栈的叫法是有历史原因的，至于具体是什么历史原因，这不是本文所要讨论的问题。

堆：在数据结构中，堆是一种满足“堆性质”（至于什么是堆性质可以查阅任何一本数据结构的书）的数据结构。然而，通常我们所指的堆都是指二叉堆，即一种使用数组来模拟完全二叉树的结构。当然，也存在其它形式的堆，包括斐波拉契堆、二项堆、杨氏表等，想获得有关这些特殊堆的性质可以查阅算法导论。然而，在编译器中，堆是一个存储区，通常用于动态分配存储空间，一般堆具有不连续性（在下文中将讲到堆的不连续性）。

栈：在数据结构中，栈是一种按照数据项先进后出的顺序排列的数据结构，我们只能在栈顶来对栈中的数据项进行操作。然而在编译器中，栈通常是用来为函数中的临时变量分配存储空间，通常栈空间的分配具有连续性。

2 相关知识
通常一个由C++编译的程序占用的内存分为以下五个部分（这些知识对理解下文至关重要，这些是对一个基本的C++程序的存储方式的认识）：

1）栈区（stack）

是由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 

2）堆区（heap）

一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收（如果回收的不及时有可能会造成内存泄露）。堆空间的分配方式类似于数据结构中的链表。 

3）全局区（静态区）（static）

全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。在程序结束后由系统释放。

4）文字常量区

用于存放常量数据，程序结束后由系统释放。

5）程序代码区

存放函数体的二进制代码。

3 堆和栈的区别
在IT面试中，通常有人会问哪个变量是堆变量，哪个变量又是栈变量，操作系统中的栈是向上（从低地址向高地址的方向）申请空间还是向下申请空间等等问题。我想只要掌握了堆和栈的区别，以及它们的工作原理，这些问题都会迎刃而解。本节将分以下几个方面来讲述它们之间的差别。

3.1 存储对象的不同
这个问题其实在第2节已经初步提到，在本小节中再次详细说明一下，因为这对下文的理解至关重要。

3.1.1堆区的存储对象
主要存储动态申请的空间。在C++中，存储“new出来”的对象，如下程序段

int *a;

a = new int;

*a = 1;

那么，变量a存储的值为1，1的存储地址在堆区，即指针a所指向的那个对象的存储地址是在堆区，但是要注意的是指针a本身所存储的区域是在栈区（嘿嘿，晕乎了把，可以看以下例子）。

Exp01:

#include <iostream.h>

int main ()

{

       int *a;

       a = new int;

       *a = 1;

       cout << "指针a所指向对象的地址为：" << a << endl;

       cout << "存储指针a本身的地址为：" << &a << endl;

       return 0;

}

Exp01的输出结果如下：

指针a所指向对象的地址(堆区地址)为：0x00371100

存储指针a本身的地址(栈区地址)为：0x0012FF7C

3.1.2 栈区的存储对象
主要存储程序中的临时变量，这些临时变量包括函数的参数变量、函数内的临时变量、指针变量（指的是指针本身）、数组变量等。注意：全局变量和静态变量不在栈区，它们是放在全局区。

3.2 存储空间的分配方式
3.2.1 堆区的空间分配方式
堆区的空间分配是由程序管理，而不是由系统管理。堆空间通常是由程序动态申请的。通常操作系统中有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，根据某种内存管理算法，寻找一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。对于这种申请方式，需要在程序中使用delete语句释放空间，否则容易导致内存泄露。

堆空间的分配一般都是向高地址扩展，并且具有不连续性。这是由于系统是用链表来管理空闲内存地址的，当然也就不连续了，而系统中链表的遍历方向通常是由低地址向高地址遍历。我们可以通过以下例子可以看到，

Exp02:

#include <iostream.h>

int main ()

{

       int *a,*b,*c;

       a = new int;

       b = new int;

       c = new int;

       cout << a << "       " << b << "     " << c << endl;

       return 0;

}

Exp02的输出结果：

0x00371100      0x00371138      0x00371170

由前文我们可以知道*a,*b,*c均为堆变量（注意指针本身为栈变量），再由输出结果我们可以看到，a的地址小于b，b小于c，并且a,b,c之间的差不是4，而是差值较大，由此可以说明堆分配的特点是向高地址扩展的、不连续的。

3.2.2 栈区的空间分配方式
栈通常是由系统自动分配空间的。只要系统剩余的空间大于程序所申请的空间，那么空间申请操作一般都会成功，否则就会出现缓冲栈溢出的错误。Windows系统中C++编译器的栈区空间的分配有以下一些性质：

1）  在Windows系统中，栈空间的分配是从高地址向低地址扩展的，并且栈空间的分配一般

具有连续性，栈顶的地址和栈的最大容量是由系统预先规定。可以通过以下例子来查看这一性质。

Exp03:

#include <iostream.h>

int main ()

{

       //a,b,c均为临时变量，即为栈变量，由系统自动分配空间

       int a;

       int b;

       int c;

       cout << &a << "    " << &b << "  " << &c << endl;

       return 0;

}

Exp03的输出结果为：

0x0012FF7C      0x0012FF78      0x0012FF74

显然，a的地址大于b和c的地址，并且a,b,c的地址间隔均为4个字节，这可以说明2个问题：1 栈空间的分配是由高地址向低地址扩展的；2 栈空间的分配一般具有连续性（即相邻变量之间的地址是不间断的，我做了多次实验，均证实了这点，不过仍然不能代表正确，所以只能说一般具有连续性）。

2）C++中函数参数的空间分配

函数参数的地址分配是根据参数列表中，从左到右的方向来分配的。我们根据下面这个例子来分析：

Exp04:

#include <iostream.h>

int p(int a, int b, int *h)

{

       int c,d;

       a = 1;

       cout << &a << "    " << &b  << "       " << &h << "  " << &c << "  " << &d << endl;

       return a;

}

int main ()

{

       int a;

       cout << "变量a的地址：" << &a << endl;

       int *h;

       cout << "指针变量h的地址：" << &h << endl;

       a = p(2,3,h);

       h = new int;

       a = p(2,3,h);

       a = q(a);

       int *q;

       q = new int;

       cout << &p << "    " << &q << "  " << endl;

       cout << "堆变量地址：" << h << "     " << q << endl;

       return 0;

}

Exp04的输出结果为：

变量a的地址：0x0012FF7C

指针变量h的地址：0x0012FF78

0x0012FF14      0x0012FF18      0x0012FF1C      0x0012FF08      0x0012FF04

0x0012FF14      0x0012FF18      0x0012FF1C      0x0012FF08      0x0012FF04

0x00401028      0x0012FF74

堆变量地址：0x00371280  0x003712B8

由上面的输出结果我们可以得到以下结论：

1）进一步证实栈区的分配地址方式是由高地址向低地址扩展（根据主函数中变量a的地址大于指针变量h的地址）；

2）函数参数变量的地址分配是由右向左的方式进行的（根据函数p中参数变量a的地址小于参数变量b的地址，参数变量b的地址小于指针参数变量h的地址，此处还发现了一个现象就是：临时变量c的地址比参数变量a的地址小了12个字节，那么编译器需要这12个字节是做什么用的呢？莫非是用于保存断点等信息，这些东西我们不得而知）；

3）函数指针存储在另外一个区域（由函数指针p的地址为0x00401028，我们可以知道，它并不是存储在一般的栈区，因为根据输出结果，栈区的地址一般都是0x0012FFxx左右，也不是存储在一般的堆区，因为根据输出结果，堆区的地址一般为0x003712xx左右，那到底编译器是如何给函数指针分配空间的呢？是另外开一块区域吗？这些问题我们也不得而知，不过我个人认为函数指针仍然是存储在一个“特殊的栈区”，这一点下文会有一个说明）；

4）函数变量申请空间的顺序为：按照先参数变量，后函数内的临时变量的顺序来申请空间（由函数p中临时变量c的地址小于参数a的地址）；

5）一个函数在调用结束后，所有的临时变量都会由系统释放，并且再次调用该函数时，仍然是从第一次调用的地址开始分配空间，这也说明了栈空间是由系统管理的，而不必程序员手工释放（这一点可以由2次调用函数p的输出结果一样来说明）。

3.3 存储空间的回收方式
1）堆空间的回收方式

堆空间通常需要使用free, delete等函数来释放，系统本身不会对堆空间进行回收。

2）栈空间的回收方式

栈空间通常是在程序结束时由系统回收，或者在函数调用完毕后，由系统自动回收。

3.4 存储空间的分配效率
栈由系统自动分配，速度较快，但程序员是无法控制的。堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片。这也解释了在写ACM程序时，使用静态数组要比动态数组的速度要快。

4 关于函数指针变量的存储问题
在第3节中，我们不能确定函数指针的存储位置，下面我们通过下面一个实例来说明我的观点：

Exp05:

#include <iostream.h>

int p()

{     return 0;  }

int q()

{     return 0;  }

int o()

{     return 0;  }

void f()

{}

void g()

{}

void h()

{}

int main ()

{

       p();

       q();

       o();

       f();

       g();

       h();

       cout << &p << endl;

       p();

       cout << &p << endl;

       cout << &q << endl;

       cout << &o << endl;

       cout << &f << endl;

       cout << &g << endl;

       cout << &h << endl;

       return 0;

}

Exp05的输出结果为：

0x00401019

0x00401019

0x00401014

0x00401037

0x00401023

0x0040101E

0x00401032

由输出结果，我们可以知道，函数指针的存储不具有连续性，但也不像堆区域那样有很大的间隔（各个函数指针的地址都相差不大）。我的观点是：编译器会专门开一块连续的内存区域来函数指针，然后通过某种hash算法来找到相应的函数，其空间的释放和申请也是由系统来管理。函数指针不会像堆那样，动态申请内存空间，因为我们在写程序时，是不需要为函数指针申请空间，也不需要为函数指针释放空间，因此这一点跟栈类似，但也它也不像栈，满足向低地址扩展、地址连续等特性。虽然它不是栈，但跟栈有很多共同点，所以可以认为，函数指针是存储在一个“特殊的栈区”。

5 附录
1）内存泄露

在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

2）  缓冲栈溢出

指程序中栈所申请的空间大于系统剩余的空间时就会发生缓冲栈溢出的错误。


本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/mitedu/archive/2008/12/02/3430332.aspx
拟电路
1、基尔霍夫定理的内容是什么？（仕兰微电子）
2、平板电容公式(C=εS/4πkd)。（未知）
3、最基本的如三极管曲线特性。（未知）
4、描述反馈电路的概念，列举他们的应用。（仕兰微电子）
5、负反馈种类（电压并联反馈，电流串联反馈，电压串联反馈和电流并联反馈）；负反 馈的优点（降低放大器的增益灵敏度，改变输入电阻和输出电阻，改善放大器的线性和非 线性失真，有效地扩展放大器的通频带，自动调节作用）（未知）
6、放大电路的频率补偿的目的是什么，有哪些方法？（仕兰微电子）
7、频率响应，如：怎么才算是稳定的，如何改变频响曲线的几个方法。（未知）
8、给出一个查分运放，如何相位补偿，并画补偿后的波特图。（凹凸）
9、基本放大电路种类（电压放大器，电流放大器，互导放大器和互阻放大器），优缺 点，特别是广泛采用差分结构的原因。（未知）
10、给出一差分电路，告诉其输出电压Y+和Y-,求共模分量和差模分量。（未知）
11、画差放的两个输入管。（凹凸）
12、画出由运放构成加法、减法、微分、积分运算的电路原理图。并画出一个晶体管级的 运放电路。（仕兰微电子）
13、用运算放大器组成一个10倍的放大器。（未知）
14、给出一个简单电路，让你分析输出电压的特性（就是个积分电路），并求输出端某点 的 rise/fall时间。(Infineon笔试试题)
15、电阻R和电容C串联，输入电压为R和C之间的电压，输出电压分别为C上电压和R上电 压，要求制这两种电路输入电压的频谱，判断这两种电路何为高通滤波器，何为低通滤 波器。当RC<<T时，给出输入电压波形图，绘制两种电路的输出波形图。（未知）
16、有源滤波器和无源滤波器的原理及区别?（新太硬件）
17、有一时域信号S=V0sin(2pif0t)+V1cos(2pif1t)+2sin(2pif3t+90),当其通过低通、 带通、高通滤波器后的信号表示方式。（未知）
18、选择电阻时要考虑什么？（东信笔试题）
19、在CMOS电路中，要有一个单管作为开关管精确传递模拟低电平，这个单管你会用P管 还是N管，为什么？（仕兰微电子）
20、给出多个mos管组成的电路求5个点的电压。(Infineon笔试试题)
21、电压源、电流源是集成电路中经常用到的模块，请画出你知道的线路结构，简单描述 其优缺点。（仕兰微电子）
22、画电流偏置的产生电路，并解释。（凹凸）
23、史密斯特电路,求回差电压。（华为面试题）
24、晶体振荡器,好像是给出振荡频率让你求周期(应该是单片机的,12分之一周期....) （华为面试题）
25、LC正弦波振荡器有哪几种三点式振荡电路，分别画出其原理图。（仕兰微电子）
26、VCO是什么,什么参数(压控振荡器?) （华为面试题）
27、锁相环有哪几部分组成？（仕兰微电子）
28、锁相环电路组成，振荡器（比如用D触发器如何搭）。（未知）
29、求锁相环的输出频率，给了一个锁相环的结构图。（未知）
30、如果公司做高频电子的，可能还要RF知识，调频，鉴频鉴相之类，不一一列举。（未知）
31、一电源和一段传输线相连（长度为L,传输时间为T），画出终端处波形，考虑传输线 无损耗。给出电源电压波形图，要求绘制终端波形图。（未知）
32、微波电路的匹配电阻。（未知）
33、DAC和ADC的实现各有哪些方法？（仕兰微电子）
34、A/D电路组成、工作原理。（未知）
35、实际工作所需要的一些技术知识(面试容易问到)。如电路的低功耗，稳定，高速如何做到，调运放，布版图注意的地方等等,一般会针对简历上你所写做过的东西具体问，肯定会问得很细（所以别把什么都写上，精通之类的词也别用太多了），这个东西各个人就 不一样了，不好说什么了。（未知）
____________________________________________________________
数字电路
1、同步电路和异步电路的区别是什么？（仕兰微电子）
2、什么是同步逻辑和异步逻辑？（汉王笔试）
同步逻辑是时钟之间有固定的因果关系。异步逻辑是各时钟之间没有固定的因果关系。
3、什么是"线与"逻辑，要实现它，在硬件特性上有什么具体要求？（汉王笔试）
线与逻辑是两个输出信号相连可以实现与的功能。在硬件上，要用oc门来实现，由于不用 oc门可能使灌电流过大，而烧坏逻辑门。 同时在输出端口应加一个上拉电阻。
4、什么是Setup 和Holdup时间？（汉王笔试）
5、setup和holdup时间,区别.（南山之桥）
6、解释setup time和hold time的定义和在时钟信号延迟时的变化。（未知）
7、解释setup和hold time violation，画图说明，并说明解决办法。（威盛VIA2003.11.06 上海笔试试题）
Setup/hold time 是测试芯片对输入信号和时钟信号之间的时间要求。建立时间是指触发 器的时钟信号上升沿到来以前，数据稳定不变的时间。输入信号应提前时钟上升沿（如上升沿有效）T时间到达芯片，这个T就是建立时间-Setup time.如不满足setup time,这个数据就不能被这一时钟打入触发器，只有在下一个时钟上升沿，数据才能被打入触发器。 保持时间是指触发器的时钟信号上升沿到来以后，数据稳定不变的时间。如果hold time 不够，数据同样不能被打入触发器.建立时间(Setup Time)和保持时间（Hold time）。建立时间是指在时钟边沿前，数据信 号需要保持不变的时间。保持时间是指时钟跳变边沿后数据信号需要保持不变的时间。如果不满足建立和保持时间的话，那么DFF将不能正确地采样到数据，将会出现 metastability的情况。如果数据信号在时钟沿触发前后持续的时间均超过建立和保持时 间，那么超过量就分别被称为建立时间裕量和保持时间裕量。
8、说说对数字逻辑中的竞争和冒险的理解，并举例说明竞争和冒险怎样消除。（仕兰微 电子）
9、什么是竞争与冒险现象？怎样判断？如何消除？（汉王笔试）
在组合逻辑中，由于门的输入信号通路中经过了不同的延时，导致到达该门的时间不一致叫竞争。产生毛刺叫冒险。如果布尔式中有相反的信号则可能产生竞争和冒险现象。解决方法：一是添加布尔式的消去项，二是在芯片外部加电容。
10、你知道那些常用逻辑电平？TTL与COMS电平可以直接互连吗？（汉王笔试）
常用逻辑电平：12V，5V，3.3V；TTL和CMOS不可以直接互连，由于TTL是在0.3-3.6V之间，而CMOS则是有在12V的有在5V的。CMOS输出接到TTL是可以直接互连。TTL接到CMOS需要在输出端口加一上拉电阻接到5V或者12V。
11、如何解决亚稳态。（飞利浦－大唐笔试）
亚稳态是指触发器无法在某个规定时间段内达到一个可确认的状态。当一个触发器进入亚稳态时，既无法预测该单元的输出电平，也无法预测何时输出才能稳定在某个正确的电平上。在这个稳定期间，触发器输出一些中间级电平，或者可能处于振荡状态，并且这种无
用的输出电平可以沿信号通道上的各个触发器级联式传播下去。
12、IC设计中同步复位与 异步复位的区别。（南山之桥）
13、MOORE 与 MEELEY状态机的特征。（南山之桥）
14、多时域设计中,如何处理信号跨时域。（南山之桥）
15、给了reg的setup,hold时间，求中间组合逻辑的delay范围。（飞利浦－大唐笔试）
Delay < period - setup ? hold
16、时钟周期为T,触发器D1的建立时间最大为T1max，最小为T1min。组合逻辑电路最大延迟为T2max,最小为T2min。问，触发器D2的建立时间T3和保持时间应满足什么条件。（华为）
17、给出某个一般时序电路的图，有Tsetup,Tdelay,Tck->q,还有 clock的delay,写出决定最大时钟的因素，同时给出表达式。（威盛VIA 2003.11.06 上海笔试试题）
18、说说静态、动态时序模拟的优缺点。（威盛VIA 2003.11.06 上海笔试试题）
19、一个四级的Mux,其中第二级信号为关键信号 如何改善timing。（威盛VIA2003.11.06 上海笔试试题）
20、给出一个门级的图，又给了各个门的传输延时，问关键路径是什么，还问给出输入，使得输出依赖于关键路径。（未知）
21、逻辑方面数字电路的卡诺图化简，时序（同步异步差异），触发器有几种（区别，优点），全加器等等。（未知）
22、卡诺图写出逻辑表达使。（威盛VIA 2003.11.06 上海笔试试题）
23、化简F(A,B,C,D)= m(1,3,4,5,10,11,12,13,14,15)的和。（威盛）
24、please show the CMOS inverter schmatic,layout and its cross sectionwith P-well process.Plot its transfer curve (Vout-Vin) And also explain the operation region of PMOS and NMOS for each segment of the transfer curve? （威盛笔试题circuit design-beijing-03.11.09）
25、To design a CMOS invertor with balance rise and fall time,please define the ration of channel width of PMOS and NMOS and explain?
26、为什么一个标准的倒相器中P管的宽长比要比N管的宽长比大？（仕兰微电子）
27、用mos管搭出一个二输入与非门。（扬智电子笔试）
28、please draw the transistor level schematic of a cmos 2 input AND gate and explain which input has faster response for output rising edge.(less delay time)。（威盛笔试题circuit design-beijing-03.11.09）
29、画出NOT,NAND,NOR的符号，真值表，还有transistor level的电路。（Infineon笔试）
30、画出CMOS的图，画出tow-to-one mux gate。（威盛VIA 2003.11.06 上海笔试试题）
31、用一个二选一mux和一个inv实现异或。（飞利浦－大唐笔试）
32、画出Y=A*B+C的cmos电路图。（科广试题）
33、用逻辑们和cmos电路实现ab+cd。（飞利浦－大唐笔试）
34、画出CMOS电路的晶体管级电路图，实现Y=A*B+C(D+E)。（仕兰微电子）
35、利用4选1实现F(x,y,z)=xz+yz’。（未知）
36、给一个表达式f=xxxx+xxxx+xxxxx+xxxx用最少数量的与非门实现（实际上就是化简）。
37、给出一个简单的由多个NOT,NAND,NOR组成的原理图，根据输入波形画出各点波形。（Infineon笔试）
38、为了实现逻辑（A XOR B）OR （C AND D），请选用以下逻辑中的一种，并说明为什么？1）INV 2）AND 3）OR 4）NAND 5）NOR 6）XOR 答案：NAND（未知）
39、用与非门等设计全加法器。（华为）
40、给出两个门电路让你分析异同。（华为）
41、用简单电路实现，当A为输入时，输出B波形为…（仕兰微电子）
42、A,B,C,D,E进行投票，多数服从少数，输出是F（也就是如果A,B,C,D,E中1的个数比0
多，那么F输出为1，否则F为0），用与非门实现，输入数目没有限制。（未知）
43、用波形表示D触发器的功能。（扬智电子笔试）
44、用传输门和倒向器搭一个边沿触发器。（扬智电子笔试）
45、用逻辑们画出D触发器。（威盛VIA 2003.11.06 上海笔试试题）
46、画出DFF的结构图,用verilog实现之。（威盛）
47、画出一种CMOS的D锁存器的电路图和版图。（未知）
48、D触发器和D锁存器的区别。（新太硬件面试）
49、简述latch和filp-flop的异同。（未知）
50、LATCH和DFF的概念和区别。（未知）
51、latch与register的区别,为什么现在多用register.行为级描述中latch如何产生的。（南山之桥）
52、用D触发器做个二分颦的电路.又问什么是状态图。（华为）
53、请画出用D触发器实现2倍分频的逻辑电路？（汉王笔试）
54、怎样用D触发器、与或非门组成二分频电路？（东信笔试）
55、How many flip-flop circuits are needed to divide by 16? (Intel) 16分频？
56、用filp-flop和logic-gate设计一个1位加法器，输入carryin和current-stage，输出
carryout和next-stage. （未知）
57、用D触发器做个4进制的计数。（华为）
58、实现N位Johnson Counter,N=5。（南山之桥）
59、用你熟悉的设计方式设计一个可预置初值的7进制循环计数器，15进制的呢？（仕兰微电子）
60、数字电路设计当然必问Verilog/VHDL，如设计计数器。（未知）
61、BLOCKING NONBLOCKING 赋值的区别。（南山之桥）
62、写异步D触发器的verilog module。（扬智电子笔试）
module dff8(clk , reset, d, q);
input clk;
input reset;
input [7:0] d;
output [7:0] q;
reg [7:0] q;
always @ (posedge clk or posedge reset)
if(reset)
q <= 0;
else
q <= d;
endmodule
63、用D触发器实现2倍分频的Verilog描述？ （汉王笔试）
module divide2( clk , clk_o, reset);
input clk , reset;
output clk_o;
wire in;
reg out ;
always @ ( posedge clk or posedge reset)
if ( reset)
out <= 0;
else
out <= in;
assign in = ~out;
assign clk_o = out;
endmodule
64、可编程逻辑器件在现代电子设计中越来越重要，请问：a) 你所知道的可编程逻辑器件有哪些？ b) 试用VHDL或VERILOG、ABLE描述8位D触发器逻辑。（汉王笔试）
PAL，PLD，CPLD，FPGA。
module dff8(clk , reset, d, q);
input clk;
input reset;
input d;
output q;
reg q;
always @ (posedge clk or posedge reset)
if(reset)
q <= 0;
else
q <= d;
endmodule
65、请用HDL描述四位的全加法器、5分频电路。（仕兰微电子）
66、用VERILOG或VHDL写一段代码，实现10进制计数器。（未知）
67、用VERILOG或VHDL写一段代码，实现消除一个glitch。（未知）
68、一个状态机的题目用verilog实现（不过这个状态机画的实在比较差，很容易误解的）。（威盛VIA 2003.11.06 上海笔试试题）
69、描述一个交通信号灯的设计。（仕兰微电子）
70、画状态机，接受1，2，5分钱的卖报机，每份报纸5分钱。（扬智电子笔试）
71、设计一个自动售货机系统，卖soda水的，只能投进三种硬币，要正确的找回钱数。（1）画出fsm（有限状态机）；（2）用verilog编程，语法要符合fpga设计的要求。（未知）
72、设计一个自动饮料售卖机，饮料10分钱，硬币有5分和10分两种，并考虑找零：（1）画出fsm（有限状态机）；（2）用verilog编程，语法要符合fpga设计的要求；（3）设计
工程中可使用的工具及设计大致过程。（未知）
73、画出可以检测10010串的状态图,并verilog实现之。（威盛）
74、用FSM实现101101的序列检测模块。（南山之桥）
a为输入端，b为输出端，如果a连续输入为1101则b输出为1，否则为0。例如a： 0001100110110100100110
b： 0000000000100100000000
请画出state machine；请用RTL描述其state machine。（未知）
75、用verilog/vddl检测stream中的特定字符串（分状态用状态机写）。（飞利浦－大唐笔试）
76、用verilog/vhdl写一个fifo控制器(包括空，满，半满信号)。（飞利浦－大唐笔试）
77、现有一用户需要一种集成电路产品，要求该产品能够实现如下功能：y=lnx，其中，x为4位二进制整数输入信号。y为二进制小数输出，要求保留两位小数。电源电压为3~5v假设公司接到该项目后，交由你来负责该产品的设计，试讨论该产品的设计全程。（仕兰微
电子）
78、sram，falsh memory，及dram的区别？（新太硬件面试）
79、给出单管DRAM的原理图(西电版《数字电子技术基础》作者杨颂华、冯毛官205页图9 －14b)，问你有什么办法提高refresh time，总共有5个问题，记不起来了。（降低温度，增大电容存储容量）（Infineon笔试）
80、Please draw schematic of a common SRAM cell with 6 transistors,point out which nodes can store data and which node is word line control? （威盛笔试题circuit design-beijing-03.11.09）
81、名词:sram,ssram,sdram
名词IRQ,BIOS,USB,VHDL,SDR
IRQ: Interrupt ReQuest
BIOS: Basic Input Output System
USB: Universal Serial Bus
VHDL: VHIC Hardware Description Language
SDR: Single Data Rate
　　压控振荡器的英文缩写(VCO)。
　　动态随机存储器的英文缩写(DRAM)。
名词解释，无聊的外文缩写罢了，比如PCI、ECC、DDR、interrupt、pipeline IRQ,BIOS,USB,VHDL,VLSI VCO(压控振荡器) RAM (动态随机存储器)，FIR IIR DFT(离散傅立叶变换)或者是中文的，比如：a.量化误差 b.直方图 c.白平衡
____________________________________________________________
IC设计基础（流程、工艺、版图、器件）
1、我们公司的产品是集成电路，请描述一下你对集成电路的认识，列举一些与集成电路相关的内容（如讲清楚模拟、数字、双极型、CMOS、MCU、RISC、CISC、DSP、ASIC、FPGA等的概念）。（仕兰微面试题目）
2、FPGA和ASIC的概念，他们的区别。（未知）
答案：FPGA是可编程ASIC。
ASIC:专用集成电路，它是面向专门用途的电路，专门为一个用户设计和制造的。根据一个用户的特定要求，能以低研制成本，短、交货周期供货的全定制，半定制集成电路。与门阵列等其它ASIC(Application Specific IC)相比，它们又具有设计开发周期短、设计制造成本低、开发工具先进、标准产品无需测试、质量稳定以及可实时在线检验等优点
3、什么叫做OTP片、掩膜片，两者的区别何在？（仕兰微面试题目）
4、你知道的集成电路设计的表达方式有哪几种？（仕兰微面试题目）
5、描述你对集成电路设计流程的认识。（仕兰微面试题目）
6、简述FPGA等可编程逻辑器件设计流程。（仕兰微面试题目）
7、IC设计前端到后端的流程和eda工具。（未知）
8、从RTL synthesis到tape out之间的设计flow,并列出其中各步使用的tool.（未知）
9、Asic的design flow。（威盛VIA 2003.11.06 上海笔试试题）
10、写出asic前期设计的流程和相应的工具。（威盛）
11、集成电路前段设计流程，写出相关的工具。（扬智电子笔试）
先介绍下IC开发流程：
1.）代码输入（design input)
用vhdl或者是verilog语言来完成器件的功能描述，生成hdl代码
语言输入工具：SUMMIT VISUALHDL
MENTOR RENIOR
图形输入: composer(cadence);
viewlogic (viewdraw)
2.）电路仿真（circuit simulation)
将vhd代码进行先前逻辑仿真，验证功能描述是否正确
数字电路仿真工具：
Verolog： CADENCE Verolig-XL
SYNOPSYS VCS
MENTOR Modle-sim
VHDL : CADENCE NC-vhdl
SYNOPSYS VSS
MENTOR Modle-sim
模拟电路仿真工具：
***ANTI HSpice pspice，spectre micro microwave: eesoft : hp
3.）逻辑综合（synthesis tools)
逻辑综合工具可以将设计思想vhd代码转化成对应一定工艺手段的门级电路；将初级仿真 中所没有考虑的门沿（gates delay）反标到生成的门级网表中,返回电路仿真阶段进行再 仿真。最终仿真结果生成的网表称为物理网表。
12、请简述一下设计后端的整个流程？（仕兰微面试题目）
13、是否接触过自动布局布线？请说出一两种工具软件。自动布局布线需要哪些基本元 素？（仕兰微面试题目）
14、描述你对集成电路工艺的认识。（仕兰微面试题目）
15、列举几种集成电路典型工艺。工艺上常提到0.25,0.18指的是什么？（仕兰微面试题目）
16、请描述一下国内的工艺现状。（仕兰微面试题目）
17、半导体工艺中，掺杂有哪几种方式？（仕兰微面试题目）
18、描述CMOS电路中闩锁效应产生的过程及最后的结果？（仕兰微面试题目）
19、解释latch-up现象和Antenna effect和其预防措施.（未知）
20、什么叫Latchup?（科广试题）
21、什么叫窄沟效应? （科广试题）
22、什么是NMOS、PMOS、CMOS？什么是增强型、耗尽型？什么是PNP、NPN？他们有什么差
别？（仕兰微面试题目）
23、硅栅COMS工艺中N阱中做的是P管还是N管，N阱的阱电位的连接有什么要求？（仕兰微面试题目）
24、画出CMOS晶体管的CROSS-OVER图（应该是纵剖面图），给出所有可能的传输特性和转移特性。（Infineon笔试试题）
25、以interver为例,写出N阱CMOS的process流程,并画出剖面图。（科广试题）
26、Please explain how we describe the resistance in semiconductor. Compare the resistance of a metal,poly and diffusion in tranditional CMOS process.（威盛笔试题circuit design-beijing-03.11.09）
27、说明mos一半工作在什么区。（凹凸的题目和面试）
28、画p-bulk 的nmos截面图。（凹凸的题目和面试）
29、写schematic note（？）， 越多越好。（凹凸的题目和面试）
30、寄生效应在ic设计中怎样加以克服和利用。（未知）
31、太底层的MOS管物理特性感觉一般不大会作为笔试面试题，因为全是微电子物理，公式推导太罗索，除非面试出题的是个老学究。IC设计的话需要熟悉的软件: Cadence,Synopsys, Avant，UNIX当然也要大概会操作。
32、unix 命令cp -r, rm,uname。（扬智电子笔试）
____________________________________________________________
单片机、MCU、计算机原理
1、简单描述一个单片机系统的主要组成模块，并说明各模块之间的数据流流向和控制流流向。简述单片机应用系统的设计原则。（仕兰微面试题目）
2、画出8031与2716（2K*8ROM）的连线图，要求采用三-八译码器，8031的P2.5,P2.4和P2.3参加译码，基本地址范围为3000H-3FFFH。该2716有没有重叠地址？根据是什么？若有，则写出每片2716的重叠地址范围。（仕兰微面试题目）
3、用8051设计一个带一个8*16键盘加驱动八个数码管（共阳）的原理图。（仕兰微面试题目）
4、PCI总线的含义是什么？PCI总线的主要特点是什么？ （仕兰微面试题目）
5、中断的概念？简述中断的过程。（仕兰微面试题目）
6、如单片机中断几个/类型，编中断程序注意什么问题；（未知）
7、要用一个开环脉冲调速系统来控制直流电动机的转速，程序由8051完成。简单原理如下：由P3.4输出脉冲的占空比来控制转速，占空比越大，转速越快；而占空比由K7-K0八个开关来设置，直接与P1口相连（开关拨到下方时为"0"，拨到上方时为"1"，组成一个八
位二进制数N），要求占空比为N/256。 （仕兰微面试题目）
　　 下面程序用计数法来实现这一功能，请将空余部分添完整。
　　 MOV P1，#0FFH
　　 LOOP1 ：MOV R4，#0FFH
　　 --------
　　 MOV R3，#00H
　　 LOOP2 ：MOV A，P1
　　 --------
　　 SUBB A，R3
　　 JNZ SKP1
　　 --------
　　 SKP1：MOV C，70H
　　 MOV P3.4，C
　　 ACALL DELAY ：此延时子程序略
　　 --------
　　 --------
　　 AJMP LOOP1
8、单片机上电后没有运转，首先要检查什么？（东信笔试题）
9、What is PC Chipset? （扬智电子笔试）
芯片组（Chipset）是主板的核心组成部分，按照在主板上的排列位置的不同，通常分为北桥芯片和南桥芯片。北桥芯片提供对CPU的类型和主频、内存的类型和最大容量ISA/PCI/AGP插槽、ECC纠错等支持。南桥芯片则提供对KBC（键盘控制器）、RTC（实时时
钟控制器）、USB（通用串行总线）、Ultra DMA/33(66)EIDE数据传输方式和ACPI（高级能源管理）等的支持。其中北桥芯片起着主导性的作用，也称为主桥（Host Bridge）。
　　除了最通用的南北桥结构外，目前芯片组正向更高级的加速集线架构发展，Intel的8xx系列芯片组就是这类芯片组的代表，它将一些子系统如IDE接口、音效、MODEM和USB直接接入主芯片，能够提供比PCI总线宽一倍的带宽，达到了266MB/s。
10、如果简历上还说做过cpu之类，就会问到诸如cpu如何工作，流水线之类的问题。（未知）
11、计算机的基本组成部分及其各自的作用。（东信笔试题）
12、请画出微机接口电路中，典型的输入设备与微机接口逻辑示意图（数据接口、控制接口、所存器/缓冲器）。 （汉王笔试）
13、cache的主要部分什么的。（威盛VIA 2003.11.06 上海笔试试题）
14、同步异步传输的差异（未知）
15、串行通信与同步通信异同,特点,比较。（华为面试题）
16、RS232c高电平脉冲对应的TTL逻辑是?(负逻辑?) （华为面试题）
____________________________________________________________
信号与系统
1、的话音频率一般为300~3400HZ，若对其采样且使信号不失真，其最小的采样频率应为多大？若采用8KHZ的采样频率，并采用8bit的PCM编码，则存储一秒钟的信号数据量有多大？（仕兰微面试题目）
2、什么耐奎斯特定律,怎么由模拟信号转为数字信号。（华为面试题）
3、如果模拟信号的带宽为 5khz,要用8K的采样率，怎么办？lucent) 两路？
4、信号与系统:在时域与频域关系。（华为面试题）
5、给出时域信号，求其直流分量。（未知）
6、给出一时域信号，要求（1）写出频率分量，（2）写出其傅立叶变换级数；（3）当波形经过低通滤波器滤掉高次谐波而只保留一次谐波时，画出滤波后的输出波形。（未知）
7、sketch 连续正弦信号和连续矩形波(都有图)的傅立叶变换 。（Infineon笔试试题）
8、拉氏变换和傅立叶变换的表达式及联系。（新太硬件面题）
____________________________________________________________
DSP、嵌入式、软件等
1、请用方框图描述一个你熟悉的实用数字信号处理系统，并做简要的分析；如果没有，也可以自己设计一个简单的数字信号处理系统，并描述其功能及用途。（仕兰微面试题目）
2、数字滤波器的分类和结构特点。（仕兰微面试题目）
3、IIR，FIR滤波器的异同。（新太硬件面题）
4、拉氏变换与Z变换公式等类似东西，随便翻翻书把如.h(n)=-a*h(n-1)+b*δ(n) a.求h(n)的z变换；b.问该系统是否为稳定系统；c.写出FIR数字滤波器的差分方程；（未知）
5、DSP和通用处理器在结构上有什么不同，请简要画出你熟悉的一种DSP结构图。（信威dsp软件面试题）
6、说说定点DSP和浮点DSP的定义（或者说出他们的区别）（信威dsp软件面试题）
7、说说你对循环寻址和位反序寻址的理解.（信威dsp软件面试题）
8、请写出【－8，7】的二进制补码，和二进制偏置码。用Q15表示出0.5和－0.5.（信威dsp软件面试题）
9、DSP的结构（哈佛结构）；（未知）
10、嵌入式处理器类型(如ARM)，操作系统种类（Vxworks,ucos,winCE,linux），操作系统方面偏CS方向了，在CS篇里面讲了；（未知）
11、有一个LDO芯片将用于对手机供电，需要你对他进行评估，你将如何设计你的测试项目？
12、某程序在一个嵌入式系统（200M CPU，50M SDRAM）中已经最优化了，换到零一个系统（300M CPU，50M SDRAM）中是否还需要优化？ （Intel）
13、请简要描述HUFFMAN编码的基本原理及其基本的实现方法。（仕兰微面试题目）
14、说出OSI七层网络协议中的四层（任意四层）。（仕兰微面试题目）
15、A） （仕兰微面试题目）
　　＃i nclude
　　void testf(int*p)
　　{
　　*p+=1;
　　}
　　main()
　　{
　　int *n,m[2];
　　n=m;
　　m[0]=1;
　　m[1]=8;
　　testf(n);
　　printf("Data v　alue is %d ",*n);
　　}
　　------------------------------
　　B)
　　＃i nclude
　　void testf(int**p)
　　{
　　*p+=1;
　　}
　　main()
　　{int *n,m[2];
　　n=m;
　　m[0]=1;
　　m[1]=8;
　　testf(&n);
　　printf(Data v　alue is %d",*n);
　　}
　　下面的结果是程序A还是程序B的？
　　Data v　alue is 8
　　那么另一段程序的结果是什么？
16、那种排序方法最快? （华为面试题）
17、写出两个排序算法,问哪个好？（威盛）
18、编一个简单的求n!的程序 。（Infineon笔试试题）
19、用一种编程语言写n!的算法。（威盛VIA 2003.11.06 上海笔试试题）
20、用C语言写一个递归算法求N！；（华为面试题）
21、给一个C的函数，关于字符串和数组，找出错误；（华为面试题）
22、防火墙是怎么实现的？ （华为面试题）
23、你对哪方面编程熟悉？（华为面试题）
24、冒泡排序的原理。（新太硬件面题）
25、操作系统的功能。（新太硬件面题）
26、学过的计算机语言及开发的系统。（新太硬件面题）
27、一个农夫发现围成正方形的围栏比长方形的节省4个木桩但是面积一样.羊的数目和正 方形围栏的桩子的个数一样但是小于36，问有多少羊？（威盛）
28、C语言实现统计某个cell在某.v文件调用的次数(这个题目真bt) （威盛VIA2003.11.06 上海笔试试题）
29、用C语言写一段控制手机中马达振子的驱动程序。(威胜)
30、用perl或TCL/Tk实现一段字符串识别和比较的程序。（未知）
31、给出一个堆栈的结构，求中断后显示结果，主要是考堆栈压入返回地址存放在低端地 址还是高端。（未知）
32、一些DOS命令，如显示文件，拷贝，删除。（未知）
33、设计一个类，使得该类任何形式的派生类无论怎么定义和实现，都无法产生任何对象 实例。（IBM）
34、What is pre-emption? (Intel)
35、What is the state of a process if a resource is not available? (Intel)
36、三个 float a,b,c;问值（a+b）+c==(b+a)+c， (a+b)+c==(a+c)+b。(Intel)
37、把一个链表反向填空。 (lucent)
38、x^4+a*x^3+x^2+c*x+d 最少需要做几次乘法？ (Dephi)
____________________________________________________________
主观题
1、你认为你从事研发工作有哪些特点？（仕兰微面试题目）
2、说出你的最大弱点及改进方法。（威盛VIA 2003.11.06 上海笔试试题）
3、说出你的理想。说出你想达到的目标。 题目是英文出的，要用英文回答。（威盛VIA 2003.11.06 上海笔试试题）
4、我们将研发人员分为若干研究方向，对协议和算法理解（主要应用在网络通信、图象 语音压缩方面）、电子系统方案的研究、用MCU、DSP编程实现电路功能、用ASIC设计技术 设计电路（包括MCU、DSP本身）、电路功能模块设计（包括模拟电路和数字电路）、集成 电路后端设计（主要是指综合及自动布局布线技术）、集成电路设计与工艺接口的研究.你希望从事哪方面的研究？（可以选择多个方向。另外，已经从事过相关研发的人员可以详细描述你的研发经历）。（仕兰微面试题目）
5、请谈谈对一个系统设计的总体思路。针对这个思路，你觉得应该具备哪些方面的知 识？（仕兰微面试题目）
6、设想你将设计完成一个电子电路方案。请简述用EDA软件（如PROTEL）进行设计（包括 原理图和PCB图）到调试出样机的整个过程。在各环节应注意哪些问题？电源的稳定，电 容的选取，以及布局的大小。（汉王笔试）
共同的注意点
各大公司电子类招聘题目精选

1.一般情况下，面试官主要根据你的简历提问，所以一定要对自己负责，把简历上的东西搞明白；
2.个别招聘针对性特别强，就招目前他们确的方向的人，这种情况下，就要投其所好，尽量介绍其所关心的东西。
3.其实技术面试并不难，但是由于很多东西都忘掉了，才觉得有些难。所以最好在面试前把该看的书看看。
4.虽然说技术面试是实力的较量与体现，但是不可否认，由于不用面试官/公司所专领域 及爱好不同，也有面试也有很大的偶然性，需要冷静对待。不能因为被拒，就否认自己或责骂公司。
5.面试时要take it easy，对越是自己钟情的公司越要这样。
一、判断题（对的写T，错的写F并说明原因，每小题4分，共20分）
1、有数组定义int a[2][2]={{1},{2,3}};则a[0][1]的值为0。（     ）
2、int (*ptr) (),则ptr是一维数组的名字。（     ）
3、指针在任何情况下都可进行>,<,>=,<=,==运算。（     ）
4、switch(c) 语句中c可以是int ,long,char ,float ,unsigned int 类型。（   ）
5、#define print(x) printf(＂the no, ＂#x＂,is ＂)

二、填空题（共30分）
1、在windows下，写出运行结果，每空2分，共10分。
char str[ ]= ＂Hello＂;
char *p=str;
int n=10;
sizeof(str)=(      )
sizeof(p)=(       )
sizeof(n)=(       )
void func(char str[100])
{    }
sizeof(str)=(     )

2、void setmemory(char **p, int num)
{ *p=(char *) malloc(num);}
void test(void)
{ char *str=NULL;
   getmemory(&str,100);
   strcpy(str,＂hello＂);
   printf(str);
}
运行test函数有什么结果？（                                ）10分

3、设int arr[]={6,7,8,9,10};
     int *ptr=arr;
   *(ptr++)+=123;
printf(＂%d,%d＂,*ptr,*(++ptr));
(                                   ) 10分

二、编程题（第一小题20，第二小题30分）
1、 不使用库函数，编写函数int strcmp(char *source, char *dest)
相等返回0，不等返回-1；
2、 写一函数int fun(char *p)判断一字符串是否为回文，是返回1，不是返回0，出错返回-1
五、 阅读程序题(每个小题5分，共20分)
 1．阅读以下程序，概括地写出程序的功能。
 ＃i nclude
 double Exp(double x)
 { double sum=1.0;
 double term=x;
 double i=1 ;
 while (term>=1.0E-8)
 { sum+=term ;
 i++;
 term=term*x/i ;
 }
 return sum ;
 }
 void main()
 { double s;
 s=Exp(1.0)+Exp(2.0);
 cout.precision(8);
 cout<<"s="<<
}
2. 阅读程序，写出程序执行时输出结果。
 ＃i nclude
 const int SIZE=10;
 class stack
 { char stck[SIZE];
 int top;
 public:
 void init();
 void push(char ch);
 char pop();
 };
 void stack::init()
 { top=0; }
 void stack::push(char ch)
 { if(top==SIZE)
 　{ cout<<"Stack is full.\n";
 return ;
 　}
 stck[top++]=ch;
 }
 char stack::pop()
 { if(top==0)
 　　　{ cout<<"Stack is empty.\n";
 　　　return 0;
 }
 return stck[--top];
 }
 void main()
 { stack s1, s2;
 　s1.init();
 　s2.init();
 　s1.push('a');
 　s1.push('b');
 　s1.push('c');
 　s2.push('x');
 　s2.push('y');
 　s2.push('z');
 　for(int i=0; i<3; i++)
 cout<<"Pop s1:"<<
　for(i=0; i<3; i++)
 cout<<"Pop s2:"<<
}
 程序结果:
 3.阅读程序，写出程序运行时输出结果。
 ＃i nclude
 class Tdate
 { public:
 Tdate();
 Tdate(int d);
 Tdate(int m, int d);
 Tdate(int m, int d, int y);
 protected:
 int month;
 int day;
 int year;
 };
 Tdate::Tdate()
 { month=4;
 　　　day=15;
 　　　year=1995;
 cout<<<"/" <<<"/" <<
}
 Tdate::Tdate(int d)
 { month=4;
 　　　day=d;
 　　year=1996;
 cout<<<"/" <<<"/" <<
}
 Tdate::Tdate(int m, int d)
 { month=m;
 　　　day=d;
 　　　year=1997;
 cout<<<"/" <<<"/" <<
}
 Tdate::Tdate(int m, int d, int y)
 { month=m;
 　　　day=d;
 　　　year=y;
 cout<<<"/" <<<"/" <<
}
 void main()
 { Tdate aday;
 Tdate bday(10);
 Tdate cday(2,12);
 Tdate dday(1,2,1998);
 }
 运行结果:
 4．阅读程序，写出程序运行时输出结果。
 ＃i nclude
 ＃i nclude
 class shape
 { public:
 shape(double x, double y):xCoord(x), yCoord(y){}
 virtual double Area()const {return 0.0; }
 protected:
 double xCoord, yCoord;
 };
 class AA :public shape
 { public:
 AA(double x, double y, double r): shape(x,y), rad(r){}
 virtual double Area()const { return 3.0 * rad * rad; }
 protected:
 double rad;
 };
 class BB :public shape
 { public:
 BB(double x1, double y1, double x2, double y2)
 :shape(x1, y1), x2Coord(x2), y2Coord(y2){ }
 virtual double Area()const;
 protected:
 double x2Coord, y2Coord;
 };
 double BB:Area()const
 { return fabs((xCoord-x2Coord)* (yCoord - y2Coord));
 //库函数fabs(double t)求得t的绝对值
 }
 void fun(const shape& sp)
 { cout<<
}
 void main()
 { AA aa(2.0, 5.0, 4.0);
 fun(aa);
 BB bb(2.0, 8.0, 12.0, 17.0);
 fun(bb);
 }
 运行结果:
 六、 编写程序题（每小题10分，共20分）
 1.编写一个函数int Judge(int *pArray, int n)，判断一个n×n二维整数数组pArray 是否为“魔方阵”，若是返回1，否则返回0。所谓魔方阵就是将1到n2的各个数字组成的方阵，它的每一行、每一列以及两个对角线上数字之和均相等。例如，3×3的中，A是魔方阵，而B不是魔方阵。然后在主程序中调用Judge函数判断数组A是否为魔方阵。
 参考程序
 ＃i nclude
 int Judge(int *pArray, int n)
 { int s1, s2, s3,s4,sum=0;
 int *p=pArray;
 for(int i=1; i<= n*n; i++)
 { int Found=0; //为0，不在方阵中；
 for(int j=0; j
if(p[j]==i)
 { Found=1; //为1，在方阵中
 break;
 }
 if(Found==0) return 0; // 值为 i 的元素不在数组中，显然不是魔方阵
 }
 for( i=1; i<=n*n; i++)
 sum=sum+i;
 sum=sum / n; // 各行、各列、对角线元素应当得到的和
 s3=0;
 s4=0;
 for( i=0; i
{ s1=0, s2=0;
 p=pArray;
 for(int j=0; j
{ s1=s1+p[i*n+j]; //第i行的元素和
 　s2=s2+p[j*n+i]; //第i列的元素和
 }
 if ( s1!=sum)
 return 0;
 if ( s2!=sum)
 return 0;
 s3=s3+pArray[i*n+i]; 　　　　// 对角线一元素和
 s4=s4+pArray[i*n+(n-1-i)]; // 对角线二元素和
 }
 if(s3!=sum)
 return 0;
 if(s4 != sum)
 return 0;
 return 1;
 }
 void main()
 { int Array[3][3]={{ 8, 1, 6},{ 3, 5, 7},{ 4, 9, 2}};
 当 x 输入值为9999时，函数返回值为多少？
 int fun ( unsigned int x )
 { int count = 0;
 while(x)
 {
 x = x & (x-1);
 count++;
 }
 return count;
 }
 答案：此函数是在计算 x 中含有1的个数，所以返回值为8。
 if(Judge((int*)Array, 3))
 cout<<"Yes, it's a magic array"<
else
 cout<<"No, it isn't a magic array"<
}
 /*********************************
 * 两个超大数相乘算法
 *********************************/
 ＃i nclude
 void main()
 {
 int a[30],b[30],c[60];
 int i,j;
 /* 给乘数和被乘数赋值，并把结果赋零 */
 for (i=0;i<30;i++)
 {
 a[i]=i%10;
 b[i]=i%10;
 c[2*i]=0;
 c[2*i+1]=0;
 }
 /* 给每位结果赋值，这里应该考虑清楚为什么这么写
 还有这里的位的值的最大限度应该是-128 -- +127
 所以就算是10*10也可以满足存进去一个char类型里 */
 for(i=0;i<30;i++)
 for(j=0;j<30;j++)
 c[i+j]+=a[i]*b[j];
 /* 这里把每个位>10的数进位和把余数重新赋值给这一位 */
 for(i=0;i<59;i++)
 {
 c[i+1]+=c[i]/10;
 c[i]=c[i]%10;
 }
 /* 打印出来 */
 for(i=0;i<30;i++)
 printf("%d",a[30-i-1]);
 printf("\n");
 for(i=0;i<30;i++)
 printf("%d",b[30-i-1]);
 printf("\n");
 for(i=0;i<60;i++)
 printf("%d",c[60-i-1]);
 printf("\n");
 }
十三、写一个程序可以算出字节在计算机中的存储是由大到小还是有小到大。
十四、一段程序，写出输出结果     
大概是                                                                                                                                                         
class A                                                                                                                                                        
{                                                                                                                                                             
static void virtual print(){cout<<"A::print()"<；                                                                                                       
}                                                                                                                                                              
class B                                                                                                                                                        
{                                                                                                                                                              
static void virtual print(){cout<<"B::print()"<；                                                                                                       
}                                                                                                                                                              
class C   
{                                                                                                                                                         
static void print(){cout<<"C::print()"<；                                                                                                              
}                                                                                                                                                             
print (A a)                                                                                                                                                    
{                                                                                                                                                             
a.print();                                                                                                                                                    
}                                                                                                                                                              
main()                                                                                                                                                         
{                                                                                                                                                              
A a,*aa,*ab,*ac;                                                                                                                                               
B b;                                                                                                                                                           
C c;
aa=&a;                                                                                                                                                         
ab=&b;                                                                                                                                                         
ac=&c;                                                                                                                                                         
a.print();                                                                                                                                                     
b.print();                                                                                                                                                     
c.print();                                                                                                                                                     
aa.print();                                                                                                                                                    
ab.print();                                                                                                                                                    
ac.print();                                                                                                                                                    
print(a);                                                                                                                                                      
print(b);                                                                                                                                                    
print(c);                                                                                                                                                      
}     
十五、给两个变量,如何找出一个带环单链表中是什么地方出现环的。（答案参考expert C programming）。
十～十五为MS笔试题。
十六、写一个带参数宏get_struct_addr_from_member_addr(p, stru, m)，
能够根据任意结构实体的某一个成员的地址，算出该结构实体的地址，其中参数p是指向该
成员的指针，stru是该结构体，m是该成员。（SUN试题）
十七、给一个函数
int main(){
    int i, n=20;
    for(i=0;i
        printf("-");
    return 0;
}
要求替换、增加或者减少一个字符，使该程序可以打出20个“-”号，并要求写出三种解法
。（sun试题）
参考：1。i-- 换成 n--
2。i换成 -i
十八、解释 typedef char (*FUNC)(int, char*)的含义
十九、问#include 和#include "abc.h"的区别，#define MAX_NUM 10 和 const int
MAX_NUM=10区别
二十、问用什么方法可以避免一些潜在错误，比如if( myvar = 3)这一类
编程规范的问题，用 if( 3 = myvar)就可以在编译时报错
十六～二十为SUN笔试题。
嗯，最后一页了！

二十一、用状态机实现10010码的探测，如x=1001001000 z=0000100100（输出）
二十二、给一个数组src[10]排序，用两种方法，并比较
二十三、c / c++ 的不同
新的注释风格，变量作用域，函数重载，操作符重载，缺省参数，按引用传送，内
联函数、模版等。
二十四、run time environemnt 的应用领域，并给予解释
二十五、使用代码或者宏将十进制转化为十六进制格式
二十六、实时嵌入系统中，两个任务同时访问RS232c port，设计一个共有的子窜转发……
二十七、多任务实施系统中，一个任务有多少种状态？描述一个系统怎么工作
二十八、选择题：char *p,*q="i am",*g="Chanese!"
strcpy(p,q);
strcat(p,g);
printf("%s",p);
a.i am b.i amChanese! c.i am Chanese! d都不是
二十九、对优先级抢占调度法和时间片轮转调度法的理解
三十、哈息表查找的优缺点，并列出你所知道的哈希函数构造法
三十一、有两个无序链表A1和A2，写出程序把A1和A2合并成一个递增的链表。
三十二、a++, ++a中a的值是先加还是后加的
三十三、函数栈中分配空间与全局堆中分配空间的区别和联系
三十四、函数体内 static声明的变量的特殊意义
三十五、Struct xxx xx[20]    这个是预先申请了内存么？
参考答案：是的，struct xxx xx[20]确实已经申请了内存，而struct xxx *xx[20]则不
是事先申请内存，仅表示申明一下，后者需要malloc申请内存。
三十六、char * p;
p = “ss”;
for (; *p != 0 ; p++)
        *p = 0
问此时p的值是多少？
参考答案：char * 的分配是在静态区，当作常量对待，赋值后就不可以修改，这是字符
串的用法，如果指向数组就另当别论。
这个程序的错误,首先字符串结束要比较'\0'而不是0，另外p指向const string不能
赋值。
三十七、char *string;
string = “I am ok”
这个语句有问题么？ 没有？
三十八、关于实现swap的方法：
    int p=1, q=2;
    swap(&p , &q);
下面三个函数 ，哪个是正确的？（参考答案：1）
1、void swap (int *p, *q) {
    int temp;
    temp = *p;
    *p = *q;
    *q = temp
}
2、void swap(int *p, *q) {
    int *temp;
    *temp = *p;
    *p = *q;
    *q = *temp;
}
3、void swap(int*p, *q) {
    int *temp;
     temp = p;
    p = q;
    p = temp;
}
4、main() {
    swap(a, b);
}
swap (int p, int q) {
    int temp;
    temp = p;
    p = q;
    q = temp;
}
三十九、全局变量被static变量重载，进行分析。
有如下C程序：
#include
#include
int i = 0;
int func();
void main(){
    int rst = 0;
    rst = func() + i ;
    rst += func() + i ;
    printf("%d", rst);
}
int func() {
    static i ;
    i++;
    return i;
}
参考：其实并不是全局变量被static重载，在函数内如果定义了i，那么，全局变量i
就不起作用了，什么意思，就是说如果i在函数内部定义了，那么函数内部使用的i
是函数自己定义的，而不是全局变量的i。
这里static是一个迷惑，其实不用static，含意也是一样的，只是每次函数里的i的值不能保存了。
全局变量不初始化，那么int的值为0，局部变量不初始化，那么其值不知。
四十、关于typedef和*相组合定义东西
四十一、关于union的使用，比如：
#include
#include
void main() {
    union xxx {
        struct xx {
            long int x;
            int y;
        } p;
        int z;
    } a;
    a.p.x = 5;
    a.p.y = 6;
    a.z = 7;
    printf("%d", a.p.x + a.p.y);
}
打印出来的结果是什么？
参考：结果为13，解释为：
由于union是联合，那么只能存在一个值，所以z的值始终和p.x的值相等
union的存储空间有最大那个单元决定，所以当对p.z赋值时，p.y的值并没有丢失。
四十二、long int i = -2;
那么(int)i的值是多少？
参考：仍然时－2，因为i用补码表示为 fffe 去掉高位，符号位不变，那么应该是fe所以
依然是-2。
三十～四十二为华为/华3的笔试题。―_________―!
四十三、类定义的构造函数提供缺省值与不提供缺省值，有何区别？
四十四、C++主要特性包含哪些？什么是虚函数，主要用处是什么？
四十五、5分钟之内写一个排序算法。
四十六、new/delete对象时，使用堆还是堆栈？
四十三～四十六为朗讯笔试题。
四十七、程序执行的时候怎么分配内存空间，每个部分的作用？
四十八、实时操作系统，在RS-232上面，如何设计才可以保证两个任务送出的命令字符串严格同步？
四十九、实时操作系统中运行多个任务，写出任务可能存在的状态，状态之间的转化，以及转化条件？
四十七～四十九为威盛考题。
五十、最为完整的MS－ATC笔试题
一多项选择18题（60分钟）
1.为什么有些文件里使用了不可打印的字符
a.这些文件不需要输出
b.这些文件里的数字在不同机器上的意义不同，所以另外用一个二进制数来表示
C.word里用来产生格式的
D.多一点也没坏处
2.类的不同instance有什么不同的
a.method不同
B.
C.attribute value
D.以上都不对
3.使用function的好处
若干道看程序输出结果题
14.数字规律题
10 1 9 3 8 5 7 7 6 问后面两个是什么
15.ABCDEF是1－9的不重复数字，ABCDEF*2=CDEFAB*2=EFABCD问ABCDEF=?
16.S给M和N看了一张扑克牌，牌只在下面的集合中
黑桃 A 4 3
红桃 Q 3 1 4
梅花 Q k j 4 5 2
方片 A 5
M看完说 我不知道是哪个
N看完说 我知道你不知道是哪个
M于是又说 我知道了
N于是又说 我也知道了
问到底是哪个？
17. 三个盒子里，只有一个有钻石，你已经选了一个盒子，然后打开剩下两个中的一个发现
没钻石，你还会改变你的选择么？
18. test plan应该包括那些内容
二编程（50分钟）
1. 编一个循环队列，实现三个函数，initialize（void*，int） PushAtEnd(CItem) Pop
FromHead(CItem*)
2. 两个单链表，一个升序一个降序，把它们合成一个升序的单链表。
三设计
1. 设计一个对话框，让用户输入密码，描述你认为特性的优先级别，设计测试用例。
四测试
1. 一个website声称自己能搜索internet。怎么测试它。
2. 设计用例测试atoi函数
--
To my understanding, it depends...
一：
已知类String的原型为：
class String
{
public：
     String(const char *str = NULL);            //普通构造函数
     String(const String ?);                //拷贝构造函数
     ~String(void);                             //析构函数
     String & operator = (const String ?); //赋值构造函数
private:
     char * m_data;                             //用于保存字符串
};
请编写String的上述4个函数。
答案：
版本1
// String 的析构函数
String::~String(void) // 3 分
{
delete [] m_data;
// 由于m_data 是内部数据类型，也可以写成delete m_data;
}
String::String(const char *str)
{
if(str==NULL)
{
m_data = new char[1]; // 若能加NULL 判断则更好
*m_data = ‘{post.content}’;
}
else
{
int length = strlen(str);
m_data = new char[length+1]; // 若能加NULL 判断则更好
strcpy(m_data, str);
}
}
// 拷贝构造函数
String::String(const String &other)
{
int length = strlen(other.m_data);
m_data = new char[length+1]; // 若能加NULL 判断则更好
strcpy(m_data, other.m_data);
}
// 赋值函数
String & String:operate =(const String &other)
{
// (1) 检查自赋值
if(this == &other)
return *this;
// (2) 释放原有的内存资源
delete [] m_data;
// （3）分配新的内存资源，并复制内容
int length = strlen(other.m_data);
m_data = new char[length+1]; // 若能加NULL 判断则更好
strcpy(m_data, other.m_data);
// （4）返回本对象的引用
return *this;
}
版本2
String::String (const char *str)
{
     if(str){
      memset(m_data,0,strlen(m_data));
      strcpy(m_data,str);
     }
     else *m_data=0;
}
String::String (const String ?)
{
     strcpy(m_data,copy.m_data);
}
String& String:operator =(const String ?)
{
    if(this==?) retrun *this;
     strcpy(m_data,copy.m_data);
      return *this;
}
版本3
String::String (const char *str)
{
     if ( m_data )
         delete[] m_data;
     if(str){
      m_data = new char[strlen(str)];
      memset(m_data,0,strlen(m_data));
      strcpy(m_data,str);
     }
     else *m_data=0;
}
String::String (const String ?)
{
     if ( m_data )
     delete[] m_data;
     m_data = new char[strlen(copy.m_data+1)]
     strcpy(m_data,copy.m_data);
}
String& String:operator =(const String ?)
{
    if(this==?) retrun *this;
     if ( m_data )
         delete[] m_data;
     m_data = new char[strlen(copy.m_data+1)]
     strcpy(m_data,copy.m_data);
      return *this;
}
~String::String(void)
{
if ( m_data )
      delete[] m_data;
}
二：改错题，只能在原来的基础上增加代码，不能删除代码
#include
#include
void foo(int age,char *b)
{
   b = (char *)malloc(64);
   sprintf(b,"Your Age is %d",age);
}
int main()
{
char *f;
foo(23,f);
printf("%s\n",f);
}
答案
版本1
#include
#include
void foo(int age,char **b)
{
   *b = (char *)malloc(64);
   sprintf(*b,"Your Age is %d",age);
}
int main()
{
char **f;
foo(23,f);
printf("%s\n",**f);
return 0;
}
版本2
#include
#include
void foo(int age,char *&b)
{
   b = (char *)malloc(64);
   sprintf(b,"Your Age is %d",age);
}
int main()
{
char *f;
foo(23,f);
printf("%s\n",f);
free(f);//不要忘了free;
}
三：有程序片断如下
int main()
{
   int I = 20;
   pid_t pid = 5;
   if((pid = fork()) > 0)
   {
      I = 50;
      printf("%d\n",I);   (1)
   }
   else if(pid == 0)
   {
      printf("%d\n",I);   (2)
   }
}
请问该程序用的是进程方式还是线程方式，并说明进程与线程的区别：
请问该程序输出什么结果？
无参考答案L
四、constant pointer points for String
   pointer points for constant string
五、下面等价的是：
A int i=0
    if(i)
   {
    printf("hello,world");
   }
   B int i=1;
      int j=2;
      if(i==1 || j==2)
      {
       printf("hello,world");
       }
   C Boolean b1=true;
      Boolean b2=true;
      if(b1==b2)
      {
       printf("hello,world");
     }
    D int i=1;
      int j=2;
      if(i==1 &| j==2)
      {
       printf("hello,world");
     }
六、排序二叉树插入一个节点或双向链表的实现
四～六为IBM面试题。
七、指针++的含义和用法
八、stack 和heap的分配，rt－os的特点、同步的方式
九、怎样避免内存泄漏的问题
十、编程实现十进制数转化为十六进制输出，不准用任何已经定义的库函数，比方说String                                                                        
，Math。int toHex(int )
嗯，一页写不下，再来一页。
十一、编程实现大于100的两个数值相乘的结果输出，同样不准使用任何已定义函数，Math,st                                                                                 
ring,convert等。比方说12345*32534677                                                                                                                          
输入为两个string      int toPlus('12345','32434677')                                                                                                           
输出为一个长型的
十二、int delete(node * head)                                                                                         
{                                                                                                                                                                                                                                   
free(head);                                                                                                                                                  
head=head->link;                                                                                                                                              
return(0);                                                                                                                                                     
}                                                                                                                                                             
指出程序的错误，并且写出正确的程序
--
For I dipped into the future,
far as human eye could see,
saw the vision of the world and
all the wonder that could be.
 1.改错(5分)

void test()
{
char str[10];
char* str1 = "0123456789";
strcpy(str, str1);
}

2.改错(5分)

void test()
{
char str[10], str1[10];
for( int = 0; i < 10; i++)
{
str = 'a';
}
strcpy(str, str1);
}

3.读程序,写出结果(5分)
int sum(int a)
{
int c = 0;
static int b = 3;
c += 1;
b += 2;
return (a + b + c);
}

int main()
{
int a = 2;
for(int i = 0; i < 5; i++)
{
printf("%d,", sum(a));
}
return 0;
}

4.读程序,写出结果(5分)
int main()
{
int a[3];
a[0] = 0;
a[1] = 1;
a[2] = 2;

int *p, *q;
p = a;
q = &a[2];

int c = a[q - p];

printf("value c = %d\n", c++);
printf("value c = %d\n", c);

return 0;
}

5.读程序,写出结果(10分,选做)
#define STRCPY(a, b) strcpy(a ## _p, #b)
int main()
{
char var1_p[20];
char var2_p[30];

strcpy(var1_p, "aaaa";
strcpy(var2_p, "bbbb";

STRCPY(var1, var2);
STRCPY(var2, var1);

printf("var1 = %s\n", var1_p);
printf("var2 = %s\n", var2_p);

return 0;
}

6.(10分)不用除法(即不能使用"/"号)和库函数,计算285 / 16的商和余数, 要求效率尽量高.

7.(15分)编写字符串反转函数:strrev.要求时间和空间效率都尽量高.
(测试用例:输入"abcd",输出应为"dcba"

函数原型为:
char* strrev(char* dest, char* src);

提示:dest和src可能是同一个字符串.

8.(15分)编写将字符串转换成整数的函数atoi,只处理输入字符串仅由0-9,'-','+',和空格的情况.
函数原型为:
int atoi(char* str);

提示:如果字符串不能构成一整数,可以直接返回0.但是对于以空格开始的字符串应特殊处理.

9.(30分)编写一组单链表操作函数.链表的结构如下:
struct ListNode
{
long id;
struct ListNode* next;
};
链表节点以id的从小到大排列,当id相等时,节点顺序没有约定,谁在前都可以.

要求编写的函数有:

遍历函数:返回cur下一个节点, 如果没有更多的节点, 返回0;
struct ListNode* ListNext(struct ListNode* cur);

插入函数:将newNode插入到head链表中,然后返回newNode的前一节点,
如果newNode已经在链表中,返回0.
struct ListNode* ListInsert(struct ListNode* head, struct ListNode* newNode);

删除函数:从head中删除theNode节点.返回theNode的前一节点.
如果theNode不在链表中,返回0;

struct ListNode* ListRemove(struct ListNode* head, struct ListNode* theNode);

1.概述

　　许多初学者对C/C++语言中的void及void指针类型不甚理解，因此在使用上出现了一些错误。本文将对void关键字的深刻含义进行解说，并详述void及void指针类型的使用方法与技巧。

　　2.void的含义

　　void的字面意思是“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据。

　　void几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个void变量，让我们试着来定义：

void a;

　　这行语句编译时会出错，提示“illegal use of type 'void'”。不过，即使void a的编译不会出错，它也没有任何实际意义。

　　void真正发挥的作用在于：

　　（1）对函数返回的限定；

　　（2）对函数参数的限定。

　　我们将在第三节对以上二点进行具体说明。

　　众所周知，如果指针p1和p2的类型相同，那么我们可以直接在p1和p2间互相赋值；如果p1和p2指向不同的数据类型，则必须使用强制类型转换运算符把赋值运算符右边的指针类型转换为左边指针的类型。

　　例如：

float *p1;
int *p2;
p1 = p2;

　　其中p1 = p2语句会编译出错，提示“'=' : cannot convert from 'int *' to 'float *'”，必须改为：

p1 = (float *)p2;

　　而void *则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换：

void *p1;
int *p2;
p1 = p2;

　　但这并不意味着，void *也可以无需强制类型转换地赋给其它类型的指针。因为“无类型”可以包容“有类型”，而“有类型”则不能包容“无类型”。道理很简单，我们可以说“男人和女人都是人”，但不能说“人是男人”或者“人是女人”。下面的语句编译出错：

void *p1;
int *p2;
p2 = p1;

　　提示“'=' : cannot convert from 'void *' to 'int *'”。
3.void的使用

　　下面给出void关键字的使用规则：

　　规则一如果函数没有返回值，那么应声明为void类型

　　在C语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理。但是许多程序员却误以为其为void类型。例如：

add ( int a, int b )
{
return a + b;
}
int main(int argc, char* argv[])
{
printf ( "2 + 3 = %d", add ( 2, 3) );
}

　　程序运行的结果为输出：

　　2 + 3 = 5

　　这说明不加返回值说明的函数的确为int函数。

　　林锐博士《高质量C/C++编程》中提到：“C++语言有很严格的类型安全检查，不允许上述情况（指函数不加类型声明）发生”。可是编译器并不一定这么认定，譬如在Visual C++6.0中上述add函数的编译无错也无警告且运行正确，所以不能寄希望于编译器会做严格的类型检查。

　　因此，为了避免混乱，我们在编写C/C++程序时，对于任何函数都必须一个不漏地指定其类型。如果函数没有返回值，一定要声明为void类型。这既是程序良好可读性的需要，也是编程规范性的要求。另外，加上void类型声明后，也可以发挥代码的“自注释”作用。代码的“自注释”即代码能自己注释自己。

　　规则二如果函数无参数，那么应声明其参数为void

　　在C++语言中声明一个这样的函数：

int function(void)
{
return 1;
}

　　则进行下面的调用是不合法的：

function(2);

　　因为在C++中，函数参数为void的意思是这个函数不接受任何参数。

　　我们在Turbo C 2.0中编译：

#include "stdio.h"
fun()
{
return 1;
}
main()
{
printf("%d",fun(2));
getchar();
}

　　编译正确且输出1，这说明，在C语言中，可以给无参数的函数传送任意类型的参数，但是在C++编译器中编译同样的代码则会出错。在C++中，不能向无参数的函数传送任何参数，出错提示“'fun' : function does not take 1 parameters”。

　　所以，无论在C还是C++中，若函数不接受任何参数，一定要指明参数为void。

　　规则三小心使用void指针类型

　　按照ANSI(American National Standards Institute)标准，不能对void指针进行算法操作，即下列操作都是不合法的：

void * pvoid;
pvoid++; //ANSI：错误
pvoid += 1; //ANSI：错误
//ANSI标准之所以这样认定，是因为它坚持：进行算法操作的指针必须是确定知道其指向数据类型大小的。
//例如：
int *pint;
pint++; //ANSI：正确

　　pint++的结果是使其增大sizeof(int)。

　　但是大名鼎鼎的GNU(GNU's Not Unix的缩写)则不这么认定，它指定void *的算法操作与char *一致。

　　因此下列语句在GNU编译器中皆正确：

pvoid++; //GNU：正确
pvoid += 1; //GNU：正确

　　pvoid++的执行结果是其增大了1。

　　在实际的程序设计中，为迎合ANSI标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：

void * pvoid;
(char *)pvoid++; //ANSI：正确；GNU：正确
(char *)pvoid += 1; //ANSI：错误；GNU：正确

　　GNU和ANSI还有一些区别，总体而言，GNU较ANSI更“开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合ANSI标准。

　　规则四如果函数的参数可以是任意类型指针，那么应声明其参数为void *

　　典型的如内存操作函数memcpy和memset的函数原型分别为：

void * memcpy(void *dest, const void *src, size_t len);
void * memset ( void * buffer, int c, size_t num );

　　这样，任何类型的指针都可以传入memcpy和memset中，这也真实地体现了内存操作函数的意义，因为它操作的对象仅仅是一片内存，而不论这片内存是什么类型。如果memcpy和memset的参数类型不是void *，而是char *，那才叫真的奇怪了！这样的memcpy和memset明显不是一个“纯粹的，脱离低级趣味的”函数！

　　下面的代码执行正确：

//示例：memset接受任意类型指针
int intarray[100];
memset ( intarray, 0, 100*sizeof(int) ); //将intarray清0
//示例：memcpy接受任意类型指针
int intarray1[100], intarray2[100];
memcpy ( intarray1, intarray2, 100*sizeof(int) ); //将intarray2拷贝给intarray1

　　有趣的是，memcpy和memset函数返回的也是void *类型，标准库函数的编写者是多么地富有学问啊！

　　规则五 void不能代表一个真实的变量

　　下面代码都企图让void代表一个真实的变量，因此都是错误的代码：

void a; //错误
function(void a); //错误

　　void体现了一种抽象，这个世界上的变量都是“有类型”的，譬如一个人不是男人就是女人（还有人妖？）。

　　void的出现只是为了一种抽象的需要，如果你正确地理解了面向对象中“抽象基类”的概念，也很容易理解void数据类型。正如不能给抽象基类定义一个实例，我们也不能定义一个void（让我们类比的称void为“抽象数据类型”）变量。

　　4.总结

　　小小的void蕴藏着很丰富的设计哲学，作为一名程序设计人员，对问题进行深一个层次的思考必然使我们受益匪浅


发表于 @ 2006年10月04日 01:40:00 | 评论 (0)


C++启蒙之编写简单的C++程序


每个C++程序都包含一个或多个函数（function），其中的一个函数的名称必须是main。一个函数由一系列执行函数功能的语句（statement）组成。操作系统通过调用main函数来执行程序。这个函数执行它的组成语句并给操作系统返回一个值。

　　下面是一个简单的main函数，它没有返回值：

int main()
{
return 0;
}

　　操作系统利用main函数返回的值判断程序执行成功还是失败。返回0表明成功了。

　　Main函数很特殊，其中最重要的是这个函数必须存在于每个C++程序中，而且它是操作系统明确调用的唯一一个函数。

　　我们定义main函数的方式与定义其它函数是一样的。函数定义说明了四个部分：返回类型、函数名称、括号中带有的参数列表（可能为空）和函数主体。Main函数可能包含一组参数。在上面的定义中，参数列表是空的。

　　上面的main函数需要一个int类型的返回类型，它表示整型。整型是内建的（built-in）类型，这意味着这种类型是语言所定义的。

　　函数定义的最后一部分（函数主体），是一组以波浪括号（curly brace）开始，以波浪反括号结束的语句块：

{
return 0;
}

　　我们的程序中的唯一一条语句是return，它是用于终止函数的语句。

　　注意

　　请注意return语句后面的分号。在C++中分号标志着大多数语句的结束。它们容易被忽略，如果忘记了可能导致难以理解的编译器错误信息。

　　当return包含一个值（例如0）的时候，这个值就是函数的返回值。返回值的类型必须与函数的返回类型相同或者必须能够转换成那种类型。在例子中main的返回类型是整型，而值0也是整型的。

　　在大多数系统中，main的返回值是状态标识。返回值为0表明main成功执行了。其它的返回值的意义由操作系统来定义。通常非0的返回值表明发生了错误。每个操作系统都由自身的、用于告诉用户main函数返回值的途径。

　　1、编译和执行程序

　　我们在编写程序之后需要编译它。编译程序的方法依赖于操作系统和编译器。如果你想了解编译器工作的细节信息，那么需要查看参考或者求助同事。

　　很多基于PC的编译器都在集成开发环境（IDE）中运行，同时它还绑定了相关的建立和分析工具。这些环境对于开发复杂的程序有很大的帮助，但是需要我们花大量的时间来学习如何高效率地使用它们。很多环境都包含了鼠标指向和点击（point-and-click）界面，它允许程序员编写程序并使用多种菜单来编译和运行程序。本文没有介绍这一方面的内容。

　　很多编译器（包括随着IDE发布的），提供了命令行接口。除非你对编译器IDE的使用非常熟悉，否则使用命令行接口更加容易使用编译器。使用命令行接口可以避免在学习某种语言之前需要先学习IDE的开销。

　　程序源文件命名习惯

　　无论使用命令行接口还是IDE，大多数编译器都希望被编译的程序存储在文件中。程序文件一般称为源文件。在大多数系统中，源文件的名称包含两个部分--文件名（例如prog1）和扩展名。按照习惯，扩展名表明该文件是一个程序。扩展名通常表明了程序是用哪种语言编写的，应该选择哪种编译器来运行。我们用来编译本文中的示例文件的系统把扩展名.CC作为C++程序，因此我们把程序保存为：prog1.cc

　　C++程序文件的扩展名依赖于你所使用的编译器。其它一些命名习惯还包括：

prog1.cxx
prog1.cpp
prog1.cp
prog1.C

　　调用GNU或微软编译器

　　在不同的编译器和操作系统上，用来调用C++编译器的命令是不同的。大多数普通的编译器都是GNU编译器和微软Visual Studio编译器。在默认情况下，调用GNU编译器的命令是g++：

$ g++ prog1.cc -o prog1

　　其中$是系统提示符。这个命令产生一个叫做prog1或者prog1.exe的可执行文件（依赖于操作系统）。在UNIX上，可执行文件没有后缀；在Windows上，后缀名是.exe。-o prog1是一个编译器参数，它指定了放置可执行文件的文件名称。如果忽略了这个参数，在Unix系统上，编译器生成一个叫做a.out的可执行文件，在Windows上生成a.exe。

　　我们使用cl命令调用微软编译器：

C:\directory> cl -GX prog1.cpp

　　其中是C:directory>系统提示符，directory是当前目录的名称。调用编译器的命令是cl，-GX是一个选项，使用命令行接口编译程序的时候需要这个选项。微软编译器自动地生成一个与源文件名对应的可执行文件。这个可执行文件的扩展名是.exe，名称与源文件的名称相同。在这种情况下可执行文件是prog1.exe。你可以查看编译器的用户手册找到更多信息。

　　在命令行运行编译器

　　如果我们使用命令行接口，那么典型情况下我们会在控制台窗口（例如UNIX系统中的shell窗口或Windows中的命令提示符窗口）中编译程序。假设我们的主程序的程序名称是prog1.cc，我们可以使用下面的命令来编译它：

$ CC prog1.cc

　　其中CC调用编译器，$是系统提示符。它的输出是一个可执行文件，我们通过名字调用它。在我们的系统中，编译器生成的可执行文件的名称是a.exe。UNIX可能把它们的可执行文件叫做a.out。如果要运行一个可执行文件，只需要在命令行输入它的名称：

$ a.exe

　　执行我们编译过的程序。在UNIX系统中，有时候即使某个文件在当前目录中，你也必须提供该文件所在的目录。在这种情况下，我们应该这样输入：

$ ./a.exe

　　后面跟着斜线（/）的"."表明文件位于当前目录中。

　　我们需要使用依赖系统的方式来访问Main的返回值。在UNIX和Windows系统中，在执行某个程序之后，你都必须提交适当的echo命令。在UNIX系统中，我们通过下面的命令来获取状态：

$ echo $?

　　查看Windows系统中的状态，需要使用：

C:\directory> echo %ERRORLEVEL%

　　练习1：

　　查看你的编译器的文档，看看它所使用的命名习惯。编译和运行main程序。

　　练习2：

　　修改程序，使它返回-1。返回-1值通常表明程序执行失败了。但是，不同的系统报告main失败的情况有所不同。重新编译和运行该程序，看看系统如何处理main的失败标志。
 1.多态类中的虚函数表是Compile-Time，还是Run-Time时建立的?
2.将一个 1M -10M 的文件，逆序存储到另一个文件，就是前一个文件的最后一个
字符存到新文件的第一个字符，以此类推。
3.main主函数执行完毕后，是否可能会再执行一段代码?
4.一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态?
在子类的空间里，有没有父类的这个函数，或者父类的私有变量?
5.给一个字符串、例如 “ababc”要求返回“ab”. 因为“ab”连续重复出现且最长。
用C/C＋＋语言写一函数完成该算法，给出复杂度
6.对序列1、1、2、3、5、8、13。。。。 是Fab..数列
2、3、5、13...是Fab..质数数列，因为他们与自己前面的Fab...数列都互质
给出k，返回第k小的Fab..质数
7.101个硬币100真、1假，真假区别在于重量。请用无砝码天平称两次给出真币重还是假币重的结论。
8.完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别，你喜欢使用哪个，为什么？
9.变量的声明和定义有什么区别？
10.请写出下面代码在 32 位平台上的运行结果，并说明 sizeof 的性质：
#include
#include

int main(void)
{
char a[30];
char *b = (char *)malloc(20 * sizeof(char));
printf("%d\n", sizeof(a));
printf("%d\n", sizeof(b));
printf("%d\n", sizeof(a[3]));
printf("%d\n", sizeof(b+3));
printf("%d\n", sizeof(*(b+4)));
return 0 ;
}
12.请完成以下题目。注意，请勿直接调用 ANSI C 函数库中的函数实现。

a)请编写一个 C 函数，该函数给出一个字节中被置 1 的位的个数，并请
给出该题的至少一个不同解法。
b)请编写一个 C 函数，该函数将给定的一个字符串转换成整数。
c)请编写一个 C 函数，该函数将给定的一个整数转换成字符串。
d)请编写一个 C 函数，该函数将一个字符串逆序。
e)请编写一个 C 函数，该函数在给定的内存区域搜索给定的字符，并返回
该字符所在位置索引值。
f)请编写一个 C 函数，该函数在一个字符串中找到可能的最长的子字符串，
该字符串是由同一字符组成的。

给出演示上述函数功能的一个简单程序，并请编写对应的 Makefile 文件

13.我们需要编写一个图形相关的应用程序，需要处理大量图形(Shape)信息，
图形有矩形(Rectangle)，正方形(Square)，圆形 (Circle)等种类，应用
需要计算这些图形的面积，并且可能需要在某个设备上进行显示(使用在标准
输出上打印信息的方式做为示意)。

a)请用面向对象的方法对以上应用进行设计，编写可能需要的类
b)请给出实现以上应用功能的示例性代码，从某处获取图形信息，
并且进行计算和绘制
c)如果你的Square继承自Rectangle，请给出理由，如果不是，
请给出理由，并且请比较两种方式的优劣
d)请问你所编写的类，在如下代码中会有何表现，请解释
void test_rectangle_area(Rectangle& r)
{
r.set_width(10);
r.set_height(15);
assert(r.area() == 150);
}
14.假设现有一个单向的链表，但是只知道只有一个指向该节点的指针p，并且假设这个节点不是尾节点，试编程实现删除此节点
15.写一个程序，把一个100以内的自然数分解因数。（自然数分解因数就是将一个自然数分解为几个素数的乘积，提示,由于该数不是很大,所以可以将质数保存在数组中,以加快计算速度)
16.编写一个Identify的分配、释放的函数，为1－10000之间的自然数。
17.分别实现itoa和atoi.
18.Consider the following code:

#include
#include
int main(int argc, char *argv[]) {
int i = 1;
char buf[4];
strcpy(buf, "AAAA");
printf("%d\n", i);
return 0;
}

a) When compiled and executed on x86, why does this program usually not
output what the programmer intended?

b) Name several ways in which the security problem that causes this
program not to output what the programmer intended can be prevented
WITHOUT changing the code.

19.int w=1,x=2,y=3,z=4;
m=(wm=(mm=(m<2)?m:z;
printf("m=%d",m); 说出结果
20.说出结果
#include
main()
{
FILE *fp;
int i,a[4]={1,2,3,4},b;
fp=fopen("data.dat","wb");//这里帮忙解释一下
for(i=0;i<4;i++)
fwrite(&a[i],sizeof(int),1,fp);//这里也帮忙看一下
fclose(fp);
fp=fopen("data.dat","rb");
fseek(fp,-2L*sizeof(int),SEEK_END);//还有这里
fread(&b,sizeof(int),1,fp);//这里还有也看一下
fclose(fp);
printf("b=%d\n",b);
}
21.有双向循环链表结点：
typedef struct node
{
int date;
struct node *front,*next;
}_Node;
有两个双向循环链表A，B，知道其头指针为：pHeadA,pHeadB，请写一函数将两上链表中date值相同的结点删除

22.
char * GetStr()
{
char *tmp;
tmp = "123"
return tmp;
}

void main()
{
printf("%s", GetStr());
}

会输出123吗？123创建在堆上还是栈上呢？123的空间是什么时候释放的？

23.
字符指针、浮点数指针、以及函数指针这三种类型的变量哪个占用的内存最大？为什么？
类ClassB从ClassA派生，那么ClassA *a = new ClassB(…); 试问该表达是否合法？为什么？
如果ClassA中定义并实现虚函数int func(void)，ClassB中也实现该函数，那么上述变量a->func()将调用哪个类里面的函数？如果int func(void)不是虚函数，情况又如何？为什么？
char **p, a[16][8]; 问：p=a是否会导致程序在以后出现问题？为什么？
如下所述的if else和switch语句哪个的效率高？为什么？
在同一个进程中，一个模块是否可以通过指针操作破坏其它模块的内存，为什么？
应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？
24.Assignment 2: Picture Processing

Use C++, Java, or similar languages or/and any middleware such as EJB and J2EE to process a picture with a high resolution (3 Mega Pixels for example). Use some methodologies to degrade the resolution of the picture to make it quicker for browsing. Then divide the degraded picture into 9 sectors equally. Click any of the 9 sectors will result a detailed picture for this sector with the same resolution as that of the original picture. This assignment is designed for you to demonstrate your ability to handle pictures.
25.用<<,>>,|,&实现一个WORD(2个字节)的高低位交换!!
26.要开辟P1,P2,P3,P4内存来做缓冲,大小自定,但这四个缓冲的大小要一样,并且是连续的!
27.有一浮点型数组A,用C语言写一函数实现对浮点数组A进行降序排序,并输出结果,要求要以数组A作为函数的入口.(建议用冒泡排序法)
28.找错：
#include
#include
class Base
{
private:
char * name;
public:
Base(char * className)
{
name = new char[strlen(className)];
strcpy(name, className);
}
~Base()
{
delete name;
}
char * copyName()
{
char newname [256];
strcpy(newname, name);
return newname;
}
char * getName()
{
return name;
}
static void print(Base base)
{
printf("name: %s\n" , base.name);
}
};
class Subclass : public Base
{
public:
Subclass(char * className) : Base(className)
{
}
};
int main()
{
Base * pBase = new Subclass("test");
Base::print(*pBase);
printf("name: %s\n", pBase->getName());
printf("new name: %s\n", pBase->copyName());
return 0;
}
29.编写一个函数，函数接收一个字符串,是由十六进制数组成的一组字符串,函数的功能是把接到的这组字符串转换成十进制数字.并将十进制数字返回.
30.编写一个函数将一条字符串分成两部分，将前半部分按ASCII码升序排序，后半部分不变，（如果字符串是奇数则中间的字符不变，）最后再将前后两部分交换，然后将该字符串输出，
测试字符串“ADZDDJKJFIEJHGI”
31.找错
Void test1()
{
char string[10];
char* str1="0123456789";
strcpy(string, str1);
}


Void test2()
{
char string[10], str1[10];
for(I=0; I<10;I++)
{
str1[i] ='a';
}
strcpy(string, str1);
}

Void test3(char* str1)
{
char string[10];
if(strlen(str1)<=10)
{
strcpy(string, str1);
}
}


32. 找错
#define MAX_SRM 256

DSN get_SRM_no()
{
static int SRM_no;
int I;
for(I=0;I{
SRM_no %= MAX_SRM;
if(MY_SRM.state==IDLE)
{
break;
}
}
if(I>=MAX_SRM)
return (NULL_SRM);
else
return SRM_no;
}


33. 写出程序运行结果

int sum(int a)
{
auto int c=0;
static int b=3;
c+=1;
b+=2;
return(a+b+C);
}

void main()
{
int I;
int a=2;
for(I=0;I<5;I++)
{
printf("%d,", sum(a));
}
}

34.

int func(int a)
{
int b;
switch(a)
{
case 1: 30;
case 2: 20;
case 3: 16;
default: 0
}
return b;
}
则func(1)=?

35:
int a[3];
a[0]=0; a[1]=1; a[2]=2;
int *p, *q;
p=a;
q=&a[2];
则a[q-p]=?

36.
定义 int **a[3][4], 则变量占有的内存空间为：_____
37.
编写一个函数，要求输入年月日时分秒，输出该年月日时分秒的下一秒。如输入2004年12月31日23时59分59秒，则输出2005年1月1日0时0分0秒。
38.写一个函数，判断一个int型的整数是否是2的幂，即是否可以表示成2^X的形式（不可以用循环）
我只知道是用递推，大概写了一下，如下：
int IsTwoPow(int s)
{
if(s==1)return FALSE;
s=s>>1;
if(s>1)IsTwoPow(s);
return (s==1)?TRUE:FALSE;//大概是这个意思，但是这一句似乎不该这么返回！
}

39 A，B从一堆玻璃球（共100个）里向外拿球，规则如下：
(1)A先拿，然后一人一次交替着拿；
（2）每次只能拿1个或2个或4个；
（3）谁拿最后一个球，谁就是最后的失败者；
问A，B谁将是失败者？写出你的判断步骤。
40.已知：无序数组，折半查找，各元素值唯一。
函数原型是：Binary_Seach(int array[], int iValue, int iCount)
array是数组，在里面用折半查找的方法找等于iValue的值，找到返回1否则0，iCount是元素个数
41.统计一个字符串中字符出现的次数
42.100位以上的超大整数的加法（主要考虑数据结构和加法的实现）。
43.对如下电文："CASTCASTSATATATASA"给出Huffman编码。
44.int (* (*f)(int, int))(int)表示什么含义？
45.x=x+1，x+=1，x++，为这三个语句的效率排序。并说明为什么。
46.中缀表达式 A-(B+C/D)*E的后缀形式是什么？
47.struct S1
{
char c;
int i;
};
sizeof(S1) = ?

class X{
public:
X();
virtual ~X();
void myMemberFunc();
static void myStaticFunc();
virtual void myVirtualFunc();
private:
int i;
char * pstr;
char a;
}
sizeof(X) = ?
48.找出两个字符串中最大子字符串,如"abractyeyt","dgdsaeactyey"的最大子串为"actyet"
49.有一百个整数,其中有负数,找出连续三个数之和最大的部分.
50.写一程序实现快速排序. 假设数据输入为一文件
快速算法描述如下
Algorithm Partition
Input: sequence a0, ..., an-1 with n elements
Output: permutation of the sequence such that all elements a0, ..., aj are less than or equal to all
elements ai, ..., an-1 (i > j)
Method:

choose the element in the middle of the sequence as comparison element x
let i = 0 and j = n-1
while ij

search the first element ai which is greater than or equal to x
search the last element aj which is less than or equal to x
if ij

exchange ai and aj
let i = i+1 and j = j-1
After partitioning the sequence, Quicksort treats the two parts recursively by the same procedure.
The recursion ends whenever a part consists of one element only.
51.写一算法检测单向链表中是否存在环(whether there is a loop in a link list),
要求算法复杂度(Algorithm's complexity是O(n)) 并只使用常数空间(space is O(c)).
注意，你只知道一个指向单向链表头的指针。链表的长度是不定的，而且环出现的地方也是不定的，环有可能在头，有可能在中间。而且要求是检测, 不能破坏环的结构.
52.设下列函数已经通过了调试
bool Sort_Array(ArrayType * Pinputarray, ArrayType * Poutarray);
该函数在内存中排序，能把字节数最大为100M字节的ArrayType类型的数组排序。其中ArrayType是一个
预定义的数组类型（细节无关紧要），Pinputarray，Poutarray分别为排序前的指针和排序后的指针。
请用c语言的伪码风格设计一个算法，他调用上面给出的函数完成下列从输入到输出的任务：
输入：排序前的大文件，名称为char * pinoutfilename ，其内容为用分号分隔的ArrayType类型的数组元素，可装满4个100M字节的数组。
输出：排序后的大文件char * poutoutfilename。
53.用最有效率的方法算出2乘以8等於几？
54.
1.错误的转义字符是 (ｃ )
A.'\091' B.'\\'
C.'\0' D.'\''

2.若数组名作实参而指针变量作形参，函数调用实参传给形参的是 (ｄ )
A.数组的长度 B.数组第一个元素的值
C.数组所有元素的值 D.数组第一个元素的地址

3.变量的指针含意是指变量的 (ｂ )
A.值 B.地址
C.存储 D.名字

5.某文件中定义的静态全局变量(或称静态外部变量)其作用域是 (ｄ )
A.只限某个函数 B.本文件
C.跨文件 D.不限制作用域
55.
1. 解二次方程:a*x*x+b*x+c
int Quadratic( double a,double b,double c,double& x1,double& x2);
返回值：解的个数

2. 最大公约数
DWORD Divisor( DWORD dwFirst, DWORD dwSecond );
返回值：最大公约数

3. 根据蒙特卡洛算法计算圆周率
double PI( DOWRD dwCount/*测试次数*/ )；
返回值：PI

4. 无符号整数乘法，乘数为32bit，结果为64bit
提示：32bit整数分解为16bit相乘
void Multiply( DWORD dwFirst, DWORD dwSecond, DWORD& dwHigh, DWORD& dwLower );

5. 链表排序(从小到大)
节点定义为：
struct Node{
int nValue;
struct Node* pNext;
};
最后一个节点的pNext = NULL.
Node* SortChain( Node* pHead );
返回值：链表头
1.求下面函数的返回值（微软）
int func(x)
{
int countx = 0;
while(x)
{
countx ++;
x = x&(x-1);
}
return countx;
}
假定x = 9999。 答案：8
思路：将x转化为2进制，看含有的1的个数。
2. 什么是“引用”？申明和使用“引用”要注意哪些问题？
答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。
3. 将“引用”作为函数参数有哪些特点？
（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。
（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。
4. 在什么时候需要使用“常引用”？　
如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &引用名=目标变量名；
例1
int a ;
const int &ra=a;
ra=1; //错误
a=1; //正确
例2
string foo( );
void bar(string & s);
那么下面的表达式将是非法的：
bar(foo( ));
bar("hello world");
原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。
引用型参数应该在能被定义为const的情况下，尽量定义为const 。
5. 将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?
格式：类型标识符 &函数名（形参列表及类型说明）{ //函数体 }
好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error!
注意事项：
（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。
（2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。
（4）流操作符重载返回值申明为“引用”的作用：
流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的！这无法让人接受。对于返回一个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。
例3
＃i nclude
int &put(int n);
int vals[10];
int error=-1;
void main()
{
put(0)=10; //以put(0)函数值作为左值，等价于vals[0]=10;
put(9)=20; //以put(9)函数值作为左值，等价于vals[9]=20;
cout<cout<}
int &put(int n)
{
if (n>=0 && n<=9 ) return vals[n];
else { cout<<"subscript error"; return error; }
}
（5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。
6. “引用”与多态的关系？
引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。
例4
Class A; Class B : Class A{...}; B b; A& ref = b;
7. “引用”与指针的区别是什么？
指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。此外，就是上面提到的对函数传ref和pointer的区别。
8. 什么时候需要“引用”？
流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。
以上 2-8 参考：http://blog.csdn.net/wfwd/archive/2006/05/30/763551.aspx
9. 结构与联合有和区别？
1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。
2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。
10. 下面关于“联合”的题目的输出？
a)
＃i nclude
union
{
int i;
char x[2];
}a;

void main()
{
a.x[0] = 10;
a.x[1] = 1;
printf("%d",a.i);
}
答案：266 (低位低地址，高位高地址，内存占用情况是Ox010A）
b)
main()
{
union{ /*定义一个联合*/
int i;
struct{ /*在联合中定义一个结构*/
char first;
char second;
}half;
}number;
number.i=0x4241; /*联合成员赋值*/
printf("%c%c\n", number.half.first, mumber.half.second);
number.half.first='a'; /*联合中结构成员赋值*/
number.half.second='b';
printf("%x\n", number.i);
getch();
}
答案： AB (0x41对应'A',是低位；Ox42对应'B',是高位）
6261 (number.i和number.half共用一块地址空间）
11. 已知strcpy的函数原型：char *strcpy(char *strDest, const char *strSrc)其中strDest 是目的字符串，strSrc 是源字符串。不调用C++/C 的字符串库函数，请编写函数 strcpy。

答案：
char *strcpy(char *strDest, const char *strSrc)
{
if ( strDest == NULL || strSrc == NULL)
return NULL ;
if ( strDest == strSrc)
return strDest ;
char *tempptr = strDest ;
while( (*strDest++ = *strSrc++) != ‘\0’)
;
return tempptr ;
}
12. 已知String类定义如下：
class String
{
public:
String(const char *str = NULL); // 通用构造函数
String(const String &another); // 拷贝构造函数
~ String(); // 析构函数
String & operater =(const String &rhs); // 赋值函数
private:
char *m_data; // 用于保存字符串
};
尝试写出类的成员函数实现。
答案：
String::String(const char *str)
{
if ( str == NULL ) //strlen在参数为NULL时会抛异常才会有这步判断
{
m_data = new char[1] ;
m_data[0] = '\0' ;
}
else
{
m_data = new char[strlen(str) + 1];
strcpy(m_data,str);
}
}
String::String(const String &another)
{
m_data = new char[strlen(another.m_data) + 1];
strcpy(m_data,other.m_data);
}

String& String::operator =(const String &rhs)
{
if ( this == &rhs)
return *this ;
delete []m_data; //删除原来的数据，新开一块内存
m_data = new char[strlen(rhs.m_data) + 1];
strcpy(m_data,rhs.m_data);
return *this ;
}

String::~String()
{
delete []m_data ;
}
13. .h头文件中的ifndef/define/endif 的作用？
答：防止该头文件被重复引用。
14. ＃i nclude 与 ＃i nclude "file.h"的区别？
答：前者是从Standard Library的路径寻找和引用file.h，而后者是从当前工作路径搜寻并引用file.h。
15.在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？
首先，作为extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。
通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数
extern "C"是连接申明(linkage declaration),被extern "C"修饰的变量和函数是按照C语言方式编译和连接的,来看看C++中对类似C的函数是怎样编译的：

作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：
void foo( int x, int y );
　　
该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。

_foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。
同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以"."来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。

未加extern "C"声明时的连接方式
假设在C++中，模块A的头文件如下：
// 模块A头文件　moduleA.h
#ifndef MODULE_A_H
#define MODULE_A_H
int foo( int x, int y );
#endif　　
在模块B中引用该函数：
// 模块B实现文件　moduleB.cpp
＃i nclude "moduleA.h"
foo(2,3);
　　
实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.obj中寻找_foo_int_int这样的符号！

加extern "C"声明后的编译和连接方式

加extern "C"声明后，模块A的头文件变为：
// 模块A头文件　moduleA.h
#ifndef MODULE_A_H
#define MODULE_A_H
extern "C" int foo( int x, int y );
#endif　　
在模块B的实现文件中仍然调用foo( 2,3 )，其结果是：
（1）模块A编译生成foo的目标代码时，没有对其名字进行特殊处理，采用了C语言的方式；
（2）连接器在为模块B的目标代码寻找foo(2,3)调用时，寻找的是未经修改的符号名_foo。

如果在模块A中函数声明了foo为extern "C"类型，而模块B中包含的是extern int foo( int x, int y ) ，则模块B找不到模块A中的函数；反之亦然。

所以，可以用一句话概括extern “C”这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）：实现C++与C及其它语言的混合编程。　　
明白了C++中extern "C"的设立动机，我们下面来具体分析extern "C"通常的使用技巧：
extern "C"的惯用法

（1）在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h）时，需进行下列处理：
extern "C"
{
＃i nclude "cExample.h"
}
而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern "C"声明，在.c文件中包含了extern "C"时会出现编译语法错误。

C++引用C函数例子工程中包含的三个文件的源代码如下：
/* c语言头文件：cExample.h */
#ifndef C_EXAMPLE_H
#define C_EXAMPLE_H
extern int add(int x,int y);
#endif

/* c语言实现文件：cExample.c */
＃i nclude "cExample.h"
int add( int x, int y )
{
return x + y;
}

// c++实现文件，调用add：cppFile.cpp
extern "C"
{
＃i nclude "cExample.h"
}
int main(int argc, char* argv[])
{
add(2,3);
return 0;
}
如果C++调用一个C语言编写的.DLL时，当包括.DLL的头文件或声明接口函数时，应加extern "C" {　}。

（2）在C中引用C++语言中的函数和变量时，C++的头文件需添加extern "C"，但是在C语言中不能直接引用声明了extern "C"的该头文件，应该仅将C文件中将C++中定义的extern "C"函数声明为extern类型。
C引用C++函数例子工程中包含的三个文件的源代码如下：
//C++头文件 cppExample.h
#ifndef CPP_EXAMPLE_H
#define CPP_EXAMPLE_H
extern "C" int add( int x, int y );
#endif

//C++实现文件 cppExample.cpp
＃i nclude "cppExample.h"
int add( int x, int y )
{
return x + y;
}

/* C实现文件 cFile.c
/* 这样会编译出错：＃i nclude "cExample.h" */
extern int add( int x, int y );
int main( int argc, char* argv[] )
{
add( 2, 3 );
return 0;
}
15题目的解答请参考《C++中extern “C”含义深层探索》注解：
16. 关联、聚合(Aggregation)以及组合(Composition)的区别？
涉及到UML中的一些概念：关联是表示两个类的一般性联系，比如“学生”和“老师”就是一种关联关系；聚合表示has-a的关系，是一种相对松散的关系，聚合类不需要对被聚合类负责，如下图所示，用空的菱形表示聚合关系：

从实现的角度讲，聚合可以表示为:
class A {...} class B { A* a; .....}
而组合表示contains-a的关系，关联性强于聚合：组合类与被组合类有相同的生命周期，组合类要对被组合类负责，采用实心的菱形表示组合关系：

实现的形式是:
class A{...} class B{ A a; ...}
参考文章：http://blog.csdn.net/wfwd/archive/2006/05/30/763753.aspx
http://blog.csdn.net/wfwd/archive/2006/05/30/763760.aspx
17.面向对象的三个基本特征，并简单叙述之？
1. 封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private, protected,public)
2. 继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合=>接口继承以及纯虚函数）构成了功能复用的两种方式。
3. 多态：是将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。
18. 重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？
常考的题目。从定义上来说：
重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
重写：是指子类重新定义复类虚函数的方法。
从实现原理上来说：
重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！
重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。
19. 多态的作用？
主要是两个：1. 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；2. 接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。
20. Ado与Ado.net的相同与不同？
除了“能够让应用程序处理存储于DBMS 中的数据“这一基本相似点外，两者没有太多共同之处。但是Ado使用OLE DB 接口并基于微软的COM 技术，而ADO.NET 拥有自己的ADO.NET 接口并且基于微软的.NET 体系架构。众所周知.NET 体系不同于COM 体系，ADO.NET 接口也就完全不同于ADO和OLE DB 接口，这也就是说ADO.NET 和ADO是两种数据访问方式。ADO.net 提供对XML 的支持。
21. New delete 与malloc free 的联系与区别?
答案：都是在堆(heap)上进行动态的内存操作。用malloc函数需要指定内存分配的字节数并且不能初始化对象，new 会自动调用对象的构造函数。delete 会调用对象的destructor，而free 不会调用对象的destructor.
22. #define DOUBLE(x) x+x ，i = 5*DOUBLE(5)； i 是多少？
答案：i 为30。
23. 有哪几种情况只能用intialization list 而不能用assignment?
答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。
24. C++是不是类型安全的？
答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。
25. main 函数执行以前，还会执行什么代码？
答案：全局对象的构造函数会在main 函数之前执行。
26. 描述内存分配方式以及它们的区别?
1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。
2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。
3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。
27.struct 和 class 的区别
答案：struct 的成员默认是公有的，而类的成员默认是私有的。struct 和 class 在其他方面是功能相当的。
从感情上讲，大多数的开发者感到类和结构有很大的差别。感觉上结构仅仅象一堆缺乏封装和功能的开放的内存位，而类就象活的并且可靠的社会成员，它有智能服务，有牢固的封装屏障和一个良好定义的接口。既然大多数人都这么认为，那么只有在你的类有很少的方法并且有公有数据（这种事情在良好设计的系统中是存在的!）时，你也许应该使用 struct 关键字，否则，你应该使用 class 关键字。
28.当一个类A 中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）
答案：肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了。
29. 在8086 汇编下，逻辑地址和物理地址是怎样转换的？（Intel）
答案：通用寄存器给出的地址，是段内偏移地址，相应段寄存器地址*10H+通用寄存器内地址，就得到了真正要访问的地址。
30. 比较C++中的4种类型转换方式？
请参考：http://blog.csdn.net/wfwd/archive/2006/05/30/763785.aspx，重点是static_cast, dynamic_cast和reinterpret_cast的区别和应用。
31.分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。
答案：
BOOL : if ( !a ) or if(a)
int : if ( a == 0)
float : const EXPRESSION EXP = 0.000001
if ( a < EXP && a >-EXP)
pointer : if ( a != NULL) or if(a == NULL)

32.请说出const与#define 相比，有何优点？
答案：1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。
33.简述数组与指针的区别？
数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。
(1)修改内容上的差别
char a[] = “hello”;
a[0] = ‘X’;
char *p = “world”; // 注意p 指向常量字符串
p[0] = ‘X’; // 编译器不能发现该错误，运行时错误
(2) 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。
char a[] = "hello world";
char *p = a;
cout<< sizeof(a) << endl; // 12 字节
cout<< sizeof(p) << endl; // 4 字节
计算数组和指针的内存容量
void Func(char a[100])
{
cout<< sizeof(a) << endl; // 4 字节而不是100 字节
}
34.类成员函数的重载、覆盖和隐藏区别？
答案：
a.成员函数被重载的特征：
（1）相同的范围（在同一个类中）；
（2）函数名字相同；
（3）参数不同；
（4）virtual 关键字可有可无。
b.覆盖是指派生类函数覆盖基类函数，特征是：
（1）不同的范围（分别位于派生类与基类）；
（2）函数名字相同；
（3）参数相同；
（4）基类函数必须有virtual 关键字。
c.“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）
35. There are two int variables: a and b, don’t use “if”, “? :”, “switch”or other judgement statements, find out the biggest one of the two numbers.
答案：( ( a + b ) + abs( a - b ) ) / 2
36. 如何打印出当前源文件的文件名以及源文件的当前行号？
答案：
cout << __FILE__ ;
cout<<__LINE__ ;
__FILE__和__LINE__是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。
37. main 主函数执行完毕后，是否可能会再执行一段代码，给出说明？
答案：可以，可以用_onexit 注册一个函数，它会在main 之后执行int fn1(void), fn2(void), fn3(void), fn4 (void);
void main( void )
{
String str("zhanglin");
_onexit( fn1 );
_onexit( fn2 );
_onexit( fn3 );
_onexit( fn4 );
printf( "This is executed first.\n" );
}
int fn1()
{
printf( "next.\n" );
return 0;
}
int fn2()
{
printf( "executed " );
return 0;
}
int fn3()
{
printf( "is " );
return 0;
}
int fn4()
{
printf( "This " );
return 0;
}
The _onexit function is passed the address of a function (func) to be called when the program terminates normally. Successive calls to _onexit create a register of functions that are executed in LIFO (last-in-first-out) order. The functions passed to _onexit cannot take parameters.

38. 如何判断一段程序是由C 编译程序还是由C++编译程序编译的？
答案：
#ifdef __cplusplus
cout<<"c++";
#else
cout<<"c";
#endif
39.文件中有一组整数，要求排序后输出到另一个文件中
答案：
＃i nclude
＃i nclude
using namespace std;

void Order(vector& data) //bubble sort
{
int count = data.size() ;
int tag = false ; // 设置是否需要继续冒泡的标志位
for ( int i = 0 ; i < count ; i++)
{
for ( int j = 0 ; j < count - i - 1 ; j++)
{
if ( data[j] > data[j+1])
{
tag = true ;
int temp = data[j] ;
data[j] = data[j+1] ;
data[j+1] = temp ;
}
}
if ( !tag )
break ;
}
}

void main( void )
{
vectordata;
ifstream in("c:\\data.txt");
if ( !in)
{
cout<<"file error!";
exit(1);
}
int temp;
while (!in.eof())
{
in>>temp;
data.push_back(temp);
}
in.close(); //关闭输入文件流
Order(data);
ofstream out("c:\\result.txt");
if ( !out)
{
cout<<"file error!";
exit(1);
}
for ( i = 0 ; i < data.size() ; i++)
out<<<" ?;}
~B()
{
cout<<"destructed"<}
B(int i):data(i) //B(int) works as a converter ( int -> instance of B)
{
cout<<"constructed by parameter " << data <}
private:
int data;
};

B Play( B b)
{
return b ;
}
(1) results:
int main(int argc, char* argv[]) constructed by parameter 5
{ destructed B(5)形参析构
B t1 = Play(5); B t2 = Play(t1); 　 destructed t1形参析构
return 0;　　　　　　　　　　　　　　 destructed t2　注意顺序！
} destructed t1
(2) results:
int main(int argc, char* argv[]) constructed by parameter 5
{ destructed B(5)形参析构
B t1 = Play(5); B t2 = Play(10); 　 constructed by parameter 10
return 0;　　　　　　　　　　　　　　 destructed B(10)形参析构
} destructed t2　注意顺序！
destructed t1
42. 写一个函数找出一个整数数组中，第二大的数 （microsoft）
答案：
const int MINNUMBER = -32767 ;
int find_sec_max( int data[] , int count)
{
int maxnumber = data[0] ;
int sec_max = MINNUMBER ;
for ( int i = 1 ; i < count ; i++)
{
if ( data[i] > maxnumber )
{
sec_max = maxnumber ;
maxnumber = data[i] ;
}
else
{
if ( data[i] > sec_max )
sec_max = data[i] ;
}
}
return sec_max ;
}
43. 写一个在一个字符串(n)中寻找一个子串(m)第一个位置的函数。
KMP算法效率最好，时间复杂度是Ｏ(n+m)。
44. 多重继承的内存分配问题：
比如有class A : public class B, public class C {}
那么A的内存结构大致是怎么样的？

这个是compiler-dependent的, 不同的实现其细节可能不同。
如果不考虑有虚函数、虚继承的话就相当简单；否则的话，相当复杂。
可以参考《深入探索C++对象模型》，或者：
http://blog.csdn.net/wfwd/archive/2006/05/30/763797.aspx
45. 如何判断一个单链表是有环的？（注意不能用标志位，最多只能用两个额外指针）

struct node { char val; node* next;}

bool check(const node* head) {} //return false : 无环；true: 有环
一种O（n）的办法就是（搞两个指针，一个每次递增一步，一个每次递增两步，如果有环的话两者必然重合，反之亦然）：
bool check(const node* head)
{
if(head==NULL) return false;
node *low=head, *fast=head->next;
while(fast!=NULL && fast->next!=NULL)
{
low=low->next;
fast=fast->next->next;
if(low==fast) return true;
}
return false;
}

数据结构（C语言）部分常考的知识点：
1、局部变量能、全局变量和静态变量
2、堆和栈   
3、Const、volatile、define、typedef的用途
4、链表（比如链表的插入、删除和排序）
5、排序（考查冒泡法的较多）
6、可重入函数 、malloc函数
7、指针（常考函数指针，函数指针，数组指针，指针数组和其他的应用），结构体和共用体
8、＃include<filename.h>和＃include“filename.h”的区别。
操作系统部分常考的知识点：
1、中断和异常
2、进程和线程
3、进程的同步机制，进程通信和进程的死锁
4、优先级反转和优先级继承问题
5、makefile文件
一些嵌入式开发的网址：
国外站点
Linux设备网站，由Rick Lehrbaum创建和维护，是一个嵌入式Linux入门网站，其中包含
嵌入式Linux行业的每日新闻、完整系列的快速参考指南、由重要开发者撰写的大量文章
，还包括一个交互论坛。
http://www.linuxdevices.com/
下载嵌入式Linux交叉编译工具链的好地方
SnapGear Embedded Linux Distribution Home Page
http://www.snapgear.org/snapgear/index.html
http://www.uclinux.org/pub/uClinux/...lf-tools/gcc-3/
嵌入式Linux联盟(ELC)，一个非盈利性的厂商中立的同业工会，其目标是在整个嵌入式
、应用和设备市场中发展和推广Linux。
www.embedded-linux.org
Beyond Logic公司主页，提供了许多嵌入式Linux系统开发的资料。
http://www.beyondlogic.org
嵌入式Linux期刊(ELJ，Embedded Linux Journal)，主要关注Linux和其他开源软件在嵌
入式系统中的应用。 其中有很多业界领导者为ELJ撰写文章。
embedded.linuxjournal.com
有几本写嵌入式Linux系统的书
http://www.embeddedlogic.com/ELSweb/booklinks.html
有关PowerPC体系的嵌入式
www.mvista.com
www.denx.de/e/index1.php
IXP4XX Open Source Developers Guide
http://ixp4xx-osdg.sourceforge.net/
uClinux/ARM项目
http://adam.kaist.ac.kr/~hschoe/notice.html
个人主页
一个业余爱好者代礼周的个人主页，都是实践出来的
http://www.lomx.net/index.htm
D_J嵌入式个人主页，有很多资料！
http://staff.ustc.edu.cn/~wangzhuo/index.html
renbagshoes的个人主页，有些资料可能你会用的到！
http://timity.nease.net
嵌入式Linux操作系统
小型化的嵌入式Linux版本
uClinux — 在没有 MMU 的系统上运行的 Linux。目前支持 Motorola 68K、MCF5206 和
　　MCF5207 ColdFire 微处理器。
http://www.uclinux.org/index.html
Etlinux — 设计用于在小型工业计算机，尤其是 PC/104 模块上运行的 Linux 的完全
分发版
http://www.prosa.it/etlinux/index.html
Tiny Linux ── 可以运行在 386 上的 Linux 分发版。
http://tiny.seul.org/en/
ThinLinux ── 面向专用的照相机服务器、X-10 控制器、MP3 播放器和其它类似的嵌
入式应用的最小化的 Linux 分发版。
www.thinlinux.org
LRP(Linux Route Project)
http://www.linuxrouter.org
Peeweelinux一个小的嵌入式Linux发行版
http://freshmeat.net/projects/peeweelinux
具有实时扩展功能的嵌入式Linux版本
RT-Linux主页
http://www.fsmlabs.com
http://www.rtlinux.com
RTAI
http://www.rtai.org
EL/IX
SRT-Linux
嵌入式GUI
Microwindows由Century Software的CEO Greg Haerr主持开发的一个公开源码(LGPL)的
项目。Microwindows致力于为一些小型设备和平台提供现代图形窗口环境。Microwindow
s支持许多硬件平台，移植性很强。Microwindows的主要目的之一便是运行在嵌入式Linu
x上，并且提供了基于Win32/X的两套API接口。
http://www.microwindows.org
http://microwindows.org
MiniGUI由原清华大学教师魏永明先生开发，是中国人做的得较好的自由软件之一。Mini
GUI 是一种面向嵌入式系统或者实时系统的公开源码(LGPL)的图形用户界面支持系统。
它主要运行于Linux控制台，实际可以运行在任何一种具有POSIX线程支持的POSIX兼容系
统上。
http://www.minigui.org
飞漫软件的MiniGUI项目
http://www.minigui.com/company/cindex.shtml
Qt/Embedded是著名的QT库开发商Trolltech正在进行的面向嵌入式系统的QT版本。Qt/Em
bedded对于各种硬件接口到GUI工具包提供了完整的图形栈。Qt/Embedded的API同Qt/X11
和Qt/Windows的相同，但它并不是基于X11库的。Qt/Embedded是公开源码(LGPL)项目。
http://www.trolltech.com
OpenGUI基于一个用汇编实现的x86图形内核，提供了一个快速的、32位的、高层的C/C++
图形接口。OpenGUI也是一个公开源码(LGPL)项目。OpenGUI提供了二维绘图原语，消息
驱动的API和BMP文件格式支持。
http://www.tutok.sk/fastgl
PicoGUI是一个可以工作在包括手持式设备等各种硬件上的小型的、可移植的、基于客户
/服务器结构的GUI。同X Window系统一样，它具有客户—服务器结构的灵活性，但又不
同于X Window系统，它将字体、BMP文件、控件以及一些应用程序所需要的其它的一些资
源直接集成在服务器。虽然减少了系统的灵活性，但在速度上有了很大的提高，并且减
小了程序大小。
http://picogui.org
Tiny-X是一个为嵌入式系统而开发的紧缩型的X Window服务器。它由SuSE赞助，由XFree
86的核心成员Keith Packard开发。Tiny-X的目标是可以在小内存或几乎无内存的情况下
良好运行。
http://www.pps.jussieu.fr/~jch/software/kdrive.html
凹凸笔试题目（嵌入式软件开发）
2007－02－07
Embedded Software Design Engineer
1 读程序段，回答问题
int main(int argc,char *argv[])
{
int c=9,d=0;
c=c++%5;
d=c;
printf("d=%d\n",d);
return 0;
}
a) 写出程序输出
b) 在一个可移植的系统中这种表达式是否存在风险？why?
#include "stdio.h"
int a=0;
int b;
static char c;
int main(int argc,char *argv[])
{
char d=4;
static short e;
a++;
b=100;
c=(char)++a;
e=(++d)++;
printf("a=%d, b=%d, c=%d, d= %d, e=%d",a,b,c,d,e);
return 0;
}
a) 写出程序输出
b) 编译器如果安排各个变量(a,b,c,d)在内存中的布局(eg. stack,heap,data section,bss section),最好用图形方式描述。
2 中断是嵌入式系统中重要的组成部分，这导致了许多编译开发商提供一种扩展：让标准C支持中断，产生了一个新的关键字__interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR),请评论以下这段代码。
__interrupt double compute_area(double radius)
{
double area = PI * radius *radius;
printf("nArea = %f", area);
return area;
}
3 C/C++基础知识问题
a) 关键字volatile在编译时有什么含义?并给出三个不同使用场景的例子(可以伪代码或者文字描述)。
b) C语言中static关键字的具体作用有哪些 ?
c) 请问下面三种变量声明有何区别?请给出具体含义
int const *p;p是一个指向常整型变量的指针。
int* const p;p是一个指向整型变量的常数执政。
int const* const p;
4 嵌入式系统相关问题
a) 对于整形变量A=0x12345678,请画出在little endian及big endian的方式下在内存中是如何存储的。
b) 在ARM系统中，函数调用的时候，参数是通过哪种方式传递的?
c) 中断(interrupt,如键盘中断)与异常(exception,如除零异常)有何区别?
5 设周期性任务P1,P2,P3的周期为T1,T2,T3分别为100，150，400；执行时间分别为20，40，100。请设计一种调度算法进行任务调度，满足任务执行周期及任务周期。
6 优先级反转问题在嵌入式系统中是一中严重的问题，必须给与足够重视。
a) 首先请解释优先级反转问题
b) 很多RTOS提供优先级继承策略(Priority inheritance)和优先级天花板策略(Priority ceilings)用来解决优先级反转问题，请讨论这两种策略。
参考答案:
1 5
存在风险，因为c=c++%5;这个表达式对c有两次修改，行为未定义，c的值不确定
int a=0; // data section
int b;   // data section
static char c; // BSS
int main(int argc,char *argv[])
{
    char d=4;         // stack
    static short e;   // BSS
    a++;
    b=100;
    c=(char)++a;
    e=(++d)++;
    printf("a=%d, b=%d, c=%d, d= %d, e=%d",a,b,c,d,e);
    return 0;
}
a=2,b=100,c=2,d=6,e=5
2 a)ISR不能返回一个值；
b)ISR不能传递参数；
c)浮点一般都是不可重入的；
d)printf函数有重入和性能上的问题。
3 a) 用volatile关键字定义变量，相当于告诉编译器，这个变量的值会随时发生变化，每次使用时都需要去内存里
重新读取它的值，并不要随意针对它作优化。
建议使用volatile变量的场所：
(1) 并行设备的硬件寄存器
(2) 一个中断服务子程序中会访问到的非自动变量（全局变量）
(3) 多线程应用中被几个任务共享的变量
b) 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
     在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数
访问。它是一个本地的全局变量。
     在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的
模块的本地范围内使用。
     static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;
     static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；
     static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝
c) 一个指向常整型数的指针
     一个指向整型数的常指针
     一个指向常整型数的常指针
4
a) 0x12345678
little endian        big endian 刚好反过来
高地址--〉 0x12      低地址--〉 0x12
             0x34                 0x34
             0x56                 0x56
低地址--〉 0x78      高地址--〉 0x78
b)参数<=4时候，通过R0~R3传递，>4的通过压栈方式传递
c)   异常：在产生时必须考虑与处理器的时钟同步，实践上，异常也称为同步中断。在处理器执行到由于编程失误而导致的错误指令时，或者在执行期间出现特殊情况(如缺页)，必须靠内核处理的时候，处理器就会产生一个异常。
所谓中断应该是指外部硬件产生的一个电信号，从cpu的中断引脚进入，打断cpu当前的运行；
所谓异常，是指软件运行中发生了一些必须作出处理的事件，cpu自动产生一个陷入来打断当前运行，转入异常处理流程。
异步与同步的区别`
5
6 高优先级任务需要等待低优先级任务释放资源，而低优先级任务又正在等待中等优先级任务的现象叫做优先级反转
优先级继承策略(Priority inheritance):继承现有被阻塞任务的最高优先级作为其优先级，任务退出临界区，恢
复初始优先级。
优先级天花板策略(Priority ceilings):控制访问临界资源的信号量的优先级天花板。
优先级继承策略对任务执行流程的影响相对教小，因为只有当高优先级任务申请已被低优先级任务占有的临界资源
这一事实发生时，才抬升低优先级任务的优先级。




